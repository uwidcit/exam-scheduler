{"ast":null,"code":"/**\n * Save class provide method to save file\n * ```typescript\n * let blob : Blob = new Blob([''], { type: 'text/plain' });\n * Save.save('fileName.txt',blob);\n */\nclass Save {\n  /**\n   * Initialize new instance of {save}\n   */\n  constructor() {\n    // tslint:disable\n  }\n  /**\n   * Saves the file with specified name and sends the file to client browser\n   * @param  {string} fileName- file name to save.\n   * @param  {Blob} buffer- the content to write in file\n   * @param  {boolean} isMicrosoftBrowser- specify whether microsoft browser or not\n   * @returns {void}\n   */\n  static save(fileName, buffer) {\n    if (fileName === null || fileName === undefined || fileName === '') {\n      throw new Error('ArgumentException: fileName cannot be undefined, null or empty');\n    }\n    let extension = fileName.substring(fileName.lastIndexOf('.') + 1, fileName.length);\n    let mimeType = this.getMimeType(extension);\n    if (mimeType !== '') {\n      buffer = new Blob([buffer], {\n        type: mimeType\n      });\n    }\n    if (this.isMicrosoftBrowser) {\n      navigator.msSaveBlob(buffer, fileName);\n    } else {\n      let downloadLink = document.createElementNS('http://www.w3.org/1999/xhtml', 'a');\n      this.saveInternal(fileName, extension, buffer, downloadLink, 'download' in downloadLink);\n    }\n  }\n  static saveInternal(fileName, extension, buffer, downloadLink, hasDownloadAttribute) {\n    if (hasDownloadAttribute) {\n      downloadLink.download = fileName;\n      let dataUrl = window.URL.createObjectURL(buffer);\n      downloadLink.href = dataUrl;\n      let event = document.createEvent('MouseEvent');\n      event.initEvent('click', true, true);\n      downloadLink.dispatchEvent(event);\n      setTimeout(() => {\n        window.URL.revokeObjectURL(dataUrl);\n        dataUrl = undefined;\n      });\n    } else {\n      if (extension !== 'docx' && extension !== 'xlsx') {\n        let url = window.URL.createObjectURL(buffer);\n        let isPopupBlocked = window.open(url, '_blank');\n        if (!isPopupBlocked) {\n          window.location.href = url;\n        }\n      } else {\n        let reader = new FileReader();\n        reader.onloadend = () => {\n          let isPopupBlocked = window.open(reader.result, '_blank');\n          if (!isPopupBlocked) {\n            window.location.href = reader.result;\n          }\n        };\n        reader.readAsDataURL(buffer);\n      }\n    }\n  }\n  /**\n   *\n   * @param {string} extension - get mime type of the specified extension\n   * @private\n   */\n  static getMimeType(extension) {\n    let mimeType = '';\n    switch (extension) {\n      case 'html':\n        mimeType = 'text/html';\n        break;\n      case 'pdf':\n        mimeType = 'application/pdf';\n        break;\n      case 'docx':\n        mimeType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';\n        break;\n      case 'xlsx':\n        mimeType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';\n        break;\n      case 'txt':\n        mimeType = 'text/plain';\n        break;\n    }\n    return mimeType;\n  }\n}\n\n/**\n * XmlWriter class provide method to create XML data\n */\nclass XmlWriter {\n  /**\n   * Initialize new instance of {XmlWriter}\n   */\n  constructor() {\n    this.contentPos = 0;\n    this.bufferText = '';\n    this.bufferBlob = new Blob([''], {\n      type: 'text/plain'\n    });\n    this.currentState = 'Initial';\n    this.namespaceStack = [];\n    this.namespaceStack.push(new Namespace());\n    this.namespaceStack[0].set('xmlns', 'http://www.w3.org/2000/xmlns/', 'Special');\n    this.namespaceStack.push(new Namespace());\n    this.namespaceStack[1].set('xml', 'http://www.w3.org/XML/1998/namespace', 'Special');\n    this.namespaceStack.push(new Namespace());\n    this.namespaceStack[2].set('', '', 'Implied');\n    this.elementStack = [];\n    this.elementStack.push(new XmlElement());\n    this.elementStack[0].set('', '', '', this.namespaceStack.length - 1);\n    this.attributeStack = [];\n    Save.isMicrosoftBrowser = !!navigator.msSaveBlob;\n  }\n  /**\n   * Gets the content written to the {XmlWriter} as Blob.\n   * @returns {Blob}\n   */\n  get buffer() {\n    this.flush();\n    return this.bufferBlob;\n  }\n  /**\n   * Writes processing instruction with a space between the name and text\n   * @param {string} name - name of the processing instruction\n   * @param {string} text - text to write in the processing instruction\n   * @throws ArgumentException\n   * @throws InvalidArgumentException\n   * @throws InvalidOperationException\n   */\n  writeProcessingInstruction(name, text) {\n    if (name === undefined || name === null || name.length === 0) {\n      throw new Error('ArgumentException: name should not be undefined, null or empty');\n    }\n    this.checkName(name);\n    if (text === undefined || text === null) {\n      text = '';\n    }\n    if (name.length === 3 && name === 'xml') {\n      if (this.currentState !== 'Initial') {\n        // tslint:disable-next-line:max-line-length\n        throw new Error('InvalidArgumentException: Cannot write XML declaration.WriteStartDocument method has already written it');\n      }\n    }\n    if (this.currentState !== 'Initial' || this.bufferBlob === undefined) {\n      throw new Error('InvalidOperationException: Wrong Token');\n    } else {\n      this.writeStartDocument();\n      this.writeProcessingInstructionInternal(name, text);\n    }\n  }\n  /**\n   * Writes Xml declaration with version and standalone attribute\n   * @param {boolean} standalone - if true it write standalone=yes else standalone=no\n   * @throws InvalidOperation\n   */\n  writeStartDocument(standalone) {\n    if (this.currentState !== 'Initial' || this.bufferBlob === undefined) {\n      throw new Error('InvalidOperationException: Wrong Token');\n    }\n    this.currentState = 'StartDocument';\n    this.rawText('<?xml version=\"1.0\" encoding=\"utf-8');\n    if (standalone !== null && standalone !== undefined) {\n      this.rawText('\" standalone=\"');\n      this.rawText(standalone ? 'yes' : 'no');\n    }\n    this.rawText('\"?>');\n  }\n  /**\n   * Closes any open tag or attribute and write the state back to start\n   */\n  writeEndDocument() {\n    while (this.elementStack.length - 1 > 0) {\n      this.writeEndElement();\n    }\n    this.currentState = 'EndDocument';\n    this.flush();\n  }\n  /**\n   * Writes the specified start tag and associates it with the given namespace and prefix.\n   * @param {string} prefix - namespace prefix of element\n   * @param {string} localName -localName of element\n   * @param {string} namespace - namespace URI associate with element\n   * @throws ArgumentException\n   * @throws InvalidOperationException\n   */\n  writeStartElement(prefix, localName, namespace) {\n    if (this.bufferBlob === undefined) {\n      throw new Error('InvalidOperationException: Wrong Token');\n    }\n    if (localName === undefined || localName === null || localName.length === 0) {\n      throw new Error('ArgumentException: localName cannot be undefined, null or empty');\n    }\n    this.checkName(localName);\n    if (this.currentState === 'Initial') {\n      this.writeStartDocument();\n    }\n    if (this.currentState === 'StartElement') {\n      this.startElementContent();\n    }\n    this.currentState = 'StartElement';\n    if (prefix === undefined || prefix === null) {\n      if (namespace !== undefined && namespace !== null) {\n        prefix = this.lookupPrefix(namespace);\n      }\n      if (prefix === undefined || prefix === null) {\n        prefix = '';\n      }\n    } else if (prefix.length > 0) {\n      if (namespace === undefined || namespace === null) {\n        namespace = this.lookupNamespace(prefix);\n      }\n      if (namespace === undefined || namespace === null || namespace !== undefined && namespace.length === 0) {\n        throw new Error('ArgumentException: Cannot use a prefix with an empty namespace');\n      }\n    }\n    if (namespace === undefined || namespace === null) {\n      namespace = this.lookupNamespace(prefix);\n    }\n    this.writeStartElementInternal(prefix, localName, namespace);\n  }\n  /**\n   * Closes one element and pop corresponding namespace scope\n   */\n  writeEndElement() {\n    if (this.currentState === 'StartElement') {\n      this.startElementContent();\n      this.currentState = 'ElementContent';\n    } else if (this.currentState === 'ElementContent') {\n      this.currentState = 'ElementContent';\n    }\n    this.currentState = 'EndElement';\n    let top = this.elementStack.length - 1;\n    this.writeEndElementInternal(this.elementStack[top].prefix, this.elementStack[top].localName);\n    this.namespaceStack.splice(this.elementStack[top].previousTop + 1);\n    this.elementStack.splice(top);\n    if (this.bufferText.length > 10240) {\n      this.flush();\n    }\n  }\n  /**\n   * Writes an element with the specified prefix, local name, namespace URI, and value.\n   * @param {string} prefix - namespace prefix of element\n   * @param {string} localName - localName of element\n   * @param {string} namespace - namespace URI associate with element\n   * @param {string} value - value of element\n   */\n  writeElementString(prefix, localName, namespace, value) {\n    this.writeStartElement(prefix, localName, namespace);\n    if (value !== undefined && value !== null && value.length !== 0) {\n      this.writeString(value);\n    }\n    this.writeEndElement();\n  }\n  /**\n   * Writes out the attribute with the specified prefix, local name, namespace URI, and value\n   * @param {string} prefix - namespace prefix of element\n   * @param {string} localName - localName of element\n   * @param {string} namespace - namespace URI associate with element\n   * @param {string} value - value of element\n   */\n  writeAttributeString(prefix, localName, namespace, value) {\n    this.writeStartAttribute(prefix, localName, namespace, value);\n    this.writeStringInternal(value, true);\n    this.writeEndAttribute();\n  }\n  /**\n   * Writes the given text content\n   * @param {string} text - text to write\n   * @throws InvalidOperationException\n   */\n  writeString(text) {\n    this.writeInternal(text, false);\n  }\n  /**\n   * Write given text as raw data\n   * @param {string} text - text to write\n   * @throws InvalidOperationException\n   */\n  writeRaw(text) {\n    this.writeInternal(text, true);\n  }\n  writeInternal(text, isRawString) {\n    if (text === undefined || text === null) {\n      return;\n    } else {\n      if (this.currentState !== 'StartElement' && this.currentState !== 'ElementContent') {\n        throw new Error('InvalidOperationException: Wrong Token');\n      }\n      if (this.currentState === 'StartElement') {\n        this.startElementContent();\n      }\n      this.currentState = 'ElementContent';\n      if (isRawString) {\n        this.rawText(text);\n      } else {\n        this.writeStringInternal(text, false);\n      }\n    }\n  }\n  /**\n   * Saves the file with specified name and sends the file to client browser\n   * @param {string} fileName - file name\n   */\n  save(fileName) {\n    while (this.elementStack.length - 1 > 0) {\n      this.writeEndElement();\n    }\n    if (this.bufferText !== '') {\n      this.flush();\n    }\n    Save.save(fileName, this.buffer);\n  }\n  /**\n   * Releases the resources used by XmlWriter.\n   */\n  destroy() {\n    this.bufferBlob = undefined;\n    for (let i = 0; i < this.namespaceStack.length; i++) {\n      this.namespaceStack[i].destroy();\n    }\n    this.namespaceStack = [];\n    for (let i = 0; i < this.elementStack.length; i++) {\n      this.elementStack[i].destroy();\n    }\n    this.elementStack = [];\n    this.bufferText = '';\n    this.contentPos = 0;\n  }\n  flush() {\n    if (this.bufferBlob === undefined) {\n      return;\n    }\n    this.bufferBlob = new Blob([this.bufferBlob, this.bufferText], {\n      type: 'text/plain'\n    });\n    this.bufferText = '';\n  }\n  writeProcessingInstructionInternal(name, text) {\n    this.bufferText += '<?';\n    this.rawText(name);\n    if (text.length > 0) {\n      this.bufferText += ' ';\n      text = text.replace(/\\?\\>/g, '? >');\n      this.bufferText += text;\n    }\n    this.bufferText += '?';\n    this.bufferText += '>';\n  }\n  writeStartAttribute(prefix, localName, namespace, value) {\n    if (localName === undefined || localName === null || localName.length === 0) {\n      if (prefix === 'xmlns') {\n        localName = 'xmlns';\n        prefix = '';\n      } else {\n        throw new Error('ArgumentException: localName cannot be undefined, null or empty');\n      }\n    }\n    if (this.currentState !== 'StartElement') {\n      throw new Error('InvalidOperationException: Wrong Token');\n    }\n    this.checkName(localName);\n    this.writeStartAttributePrefixAndNameSpace(prefix, localName, namespace, value);\n  }\n  writeStartAttributePrefixAndNameSpace(prefix, localName, namespace, value) {\n    if (prefix === undefined || prefix === null) {\n      if (namespace !== undefined && namespace !== null) {\n        if (!(localName === 'xmlns' && namespace === 'http://www.w3.org/2000/xmlns/')) {\n          prefix = this.lookupPrefix(namespace);\n        }\n      }\n      if (prefix === undefined || prefix === null) {\n        prefix = '';\n      }\n    }\n    if (namespace === undefined || namespace === null) {\n      if (prefix !== undefined && prefix !== null && prefix.length > 0) {\n        namespace = this.lookupNamespace(prefix);\n      }\n      if (namespace === undefined || namespace === null) {\n        namespace = '';\n      }\n    }\n    this.writeStartAttributeSpecialAttribute(prefix, localName, namespace, value);\n  }\n  writeStartAttributeSpecialAttribute(prefix, localName, namespace, value) {\n    if (prefix.length === 0) {\n      if (localName[0] === 'x' && localName === 'xmlns') {\n        this.skipPushAndWrite(prefix, localName, namespace);\n        this.pushNamespaceExplicit('', value);\n        return;\n      } else if (namespace.length > 0) {\n        prefix = this.lookupPrefix(namespace);\n      }\n    } else {\n      if (prefix[0] === 'x') {\n        if (prefix === 'xmlns') {\n          this.skipPushAndWrite(prefix, localName, namespace);\n          this.pushNamespaceExplicit(localName, value);\n          return;\n        } else if (prefix === 'xml') {\n          if (localName === 'space' || localName === 'lang') {\n            this.skipPushAndWrite(prefix, localName, namespace);\n            return;\n          }\n        }\n      }\n      if (namespace.length === 0) {\n        prefix = '';\n      }\n    }\n    if (prefix !== undefined && prefix !== null && prefix.length !== 0) {\n      this.pushNamespaceImplicit(prefix, namespace);\n    }\n    this.skipPushAndWrite(prefix, localName, namespace);\n  }\n  writeEndAttribute() {\n    this.currentState = 'StartElement';\n    this.bufferText += '\"';\n  }\n  writeStartElementInternal(prefix, localName, namespace) {\n    this.bufferText += '<';\n    if (prefix.length > 0) {\n      this.rawText(prefix);\n      this.bufferText += ':';\n    }\n    this.rawText(localName);\n    let top = this.elementStack.length;\n    this.elementStack.push(new XmlElement());\n    this.elementStack[top].set(prefix, localName, namespace, this.namespaceStack.length - 1);\n    this.pushNamespaceImplicit(prefix, namespace);\n    for (let i = 0; i < this.attributeStack.length; i++) {\n      this.attributeStack[i].destroy();\n    }\n    this.attributeStack = [];\n  }\n  writeEndElementInternal(prefix, localName) {\n    if (this.contentPos !== this.bufferText.length + 1) {\n      this.bufferText += '</';\n      if (prefix !== undefined && prefix !== null && prefix.length !== 0) {\n        this.rawText(prefix);\n        this.bufferText += ':';\n      }\n      this.rawText(localName);\n      this.bufferText += '>';\n    } else {\n      this.bufferText = this.bufferText.substring(0, this.bufferText.length - 1);\n      this.bufferText += ' />';\n    }\n  }\n  writeStartAttributeInternal(prefix, localName, namespaceName) {\n    this.bufferText += ' ';\n    if (prefix !== undefined && prefix !== null && prefix.length > 0) {\n      this.rawText(prefix);\n      this.bufferText += ':';\n    }\n    this.rawText(localName);\n    this.bufferText += '=';\n    this.bufferText += '\"';\n  }\n  writeNamespaceDeclaration(prefix, namespaceUri) {\n    this.writeStartNamespaceDeclaration(prefix);\n    this.writeStringInternal(namespaceUri, true);\n    this.bufferText += '\"';\n  }\n  writeStartNamespaceDeclaration(prefix) {\n    if (prefix === undefined || prefix === null || prefix.length === 0) {\n      this.rawText(' xmlns=\\\"');\n    } else {\n      this.rawText(' xmlns:');\n      this.rawText(prefix);\n      this.bufferText += '=';\n      this.bufferText += '\"';\n    }\n  }\n  writeStringInternal(text, inAttributeValue) {\n    if (text === null || text === undefined) {\n      text = '';\n    }\n    text = text.replace(/\\&/g, '&amp;');\n    text = text.replace(/\\</g, '&lt;');\n    text = text.replace(/\\>/g, '&gt;');\n    if (inAttributeValue) {\n      text = text.replace(/\\\"/g, '&quot;');\n    }\n    this.bufferText += text;\n    if (!inAttributeValue) {\n      this.contentPos = 0;\n    }\n  }\n  startElementContent() {\n    let start = this.elementStack[this.elementStack.length - 1].previousTop;\n    for (let i = this.namespaceStack.length - 1; i > start; i--) {\n      if (this.namespaceStack[i].kind === 'NeedToWrite') {\n        this.writeNamespaceDeclaration(this.namespaceStack[i].prefix, this.namespaceStack[i].namespaceUri);\n      }\n    }\n    this.bufferText += '>';\n    this.contentPos = this.bufferText.length + 1;\n  }\n  rawText(text) {\n    this.bufferText += text;\n  }\n  addNamespace(prefix, ns, kind) {\n    let top = this.namespaceStack.length;\n    this.namespaceStack.push(new Namespace());\n    this.namespaceStack[top].set(prefix, ns, kind);\n  }\n  lookupPrefix(namespace) {\n    for (let i = this.namespaceStack.length - 1; i >= 0; i--) {\n      if (this.namespaceStack[i].namespaceUri === namespace) {\n        return this.namespaceStack[i].prefix;\n      }\n    }\n    return undefined;\n  }\n  lookupNamespace(prefix) {\n    for (let i = this.namespaceStack.length - 1; i >= 0; i--) {\n      if (this.namespaceStack[i].prefix === prefix) {\n        return this.namespaceStack[i].namespaceUri;\n      }\n    }\n    return undefined;\n  }\n  lookupNamespaceIndex(prefix) {\n    for (let i = this.namespaceStack.length - 1; i >= 0; i--) {\n      if (this.namespaceStack[i].prefix === prefix) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  pushNamespaceImplicit(prefix, ns) {\n    let kind;\n    let existingNsIndex = this.lookupNamespaceIndex(prefix);\n    if (existingNsIndex !== -1) {\n      if (existingNsIndex > this.elementStack[this.elementStack.length - 1].previousTop) {\n        if (this.namespaceStack[existingNsIndex].namespaceUri !== ns) {\n          throw new Error('XmlException namespace Uri needs to be the same as the one that is already declared');\n        }\n        return;\n      } else {\n        if (this.namespaceStack[existingNsIndex].kind === 'Special') {\n          if (prefix === 'xml') {\n            if (ns !== this.namespaceStack[existingNsIndex].namespaceUri) {\n              throw new Error('InvalidArgumentException: Xml String');\n            } else {\n              kind = 'Implied';\n            }\n          } else {\n            throw new Error('InvalidArgumentException: Prefix \"xmlns\" is reserved for use by XML.');\n          }\n        } else {\n          kind = this.namespaceStack[existingNsIndex].namespaceUri === ns ? 'Implied' : 'NeedToWrite';\n        }\n      }\n    } else {\n      if (ns === 'http://www.w3.org/XML/1998/namespace' && prefix !== 'xml' || ns === 'http://www.w3.org/2000/xmlns/' && prefix !== 'xmlns') {\n        throw new Error('InvalidArgumentException');\n      }\n      kind = 'NeedToWrite';\n    }\n    this.addNamespace(prefix, ns, kind);\n  }\n  pushNamespaceExplicit(prefix, ns) {\n    let existingNsIndex = this.lookupNamespaceIndex(prefix);\n    if (existingNsIndex !== -1) {\n      if (existingNsIndex > this.elementStack[this.elementStack.length - 1].previousTop) {\n        this.namespaceStack[existingNsIndex].kind = 'Written';\n        return;\n      }\n    }\n    this.addNamespace(prefix, ns, 'Written');\n    return;\n  }\n  addAttribute(prefix, localName, namespaceName) {\n    let top = this.attributeStack.length;\n    this.attributeStack.push(new XmlAttribute());\n    this.attributeStack[top].set(prefix, localName, namespaceName);\n    for (let i = 0; i < top; i++) {\n      if (this.attributeStack[i].isDuplicate(prefix, localName, namespaceName)) {\n        throw new Error('XmlException: duplicate attribute name');\n      }\n    }\n  }\n  skipPushAndWrite(prefix, localName, namespace) {\n    this.addAttribute(prefix, localName, namespace);\n    this.writeStartAttributeInternal(prefix, localName, namespace);\n  }\n  checkName(text) {\n    let format = /[ !@#$%^&*()+\\=\\[\\]{};':\"\\\\|,<>\\/?]/;\n    if (format.test(text)) {\n      throw new Error('InvalidArgumentException: invalid name character');\n    }\n  }\n}\n/**\n * class for managing namespace collection\n */\nclass Namespace {\n  /**\n   * set value for current namespace instance\n   * @param {string} prefix namespace's prefix\n   * @param {string} namespaceUri namespace URI\n   * @param {string} kind namespace kind\n   */\n  set(prefix, namespaceUri, kind) {\n    this.prefix = prefix;\n    this.namespaceUri = namespaceUri;\n    this.kind = kind;\n  }\n  /**\n   * Releases the resources used by Namespace\n   */\n  destroy() {\n    this.prefix = undefined;\n    this.namespaceUri = undefined;\n    this.kind = undefined;\n  }\n}\n/**\n * class for managing element collection\n */\nclass XmlElement {\n  /**\n   * set value of current element\n   * @param {string} prefix - element prefix\n   * @param {string} localName - element local name\n   * @param {string} namespaceUri -namespace URI\n   * @param {string} previousTop - previous namespace top\n   */\n  set(prefix, localName, namespaceUri, previousTop) {\n    this.previousTop = previousTop;\n    this.prefix = prefix;\n    this.namespaceUri = namespaceUri;\n    this.localName = localName;\n  }\n  /**\n   * Releases the resources used by XmlElement\n   */\n  destroy() {\n    this.previousTop = undefined;\n    this.prefix = undefined;\n    this.localName = undefined;\n    this.namespaceUri = undefined;\n  }\n}\n/**\n * class for managing attribute collection\n */\nclass XmlAttribute {\n  /**\n   * set value of current attribute\n   * @param {string} prefix - namespace's prefix\n   * @param {string} namespaceUri - namespace URI\n   * @param {string} localName - attribute localName\n   */\n  set(prefix, localName, namespaceUri) {\n    this.prefix = prefix;\n    this.namespaceUri = namespaceUri;\n    this.localName = localName;\n  }\n  /**\n   * get whether the attribute is duplicate or not\n   * @param {string} prefix - namespace's prefix\n   * @param {string} namespaceUri - namespace URI\n   * @param {string} localName - attribute localName\n   */\n  isDuplicate(prefix, localName, namespaceUri) {\n    return this.localName === localName && (this.prefix === prefix || this.namespaceUri === namespaceUri);\n  }\n  /**\n   * Releases the resources used by XmlAttribute\n   */\n  destroy() {\n    this.prefix = undefined;\n    this.namespaceUri = undefined;\n    this.localName = undefined;\n  }\n}\n\n/**\n * Encoding class: Contains the details about encoding type, whether to write a Unicode byte order mark (BOM).\n * ```typescript\n * let encoding : Encoding = new Encoding();\n * encoding.type = 'Utf8';\n * encoding.getBytes('Encoding', 0, 5);\n * ```\n */\nclass Encoding {\n  /**\n   * Initializes a new instance of the Encoding class. A parameter specifies whether to write a Unicode byte order mark\n   * @param  {boolean} includeBom?-true to specify that a Unicode byte order mark is written; otherwise, false.\n   */\n  constructor(includeBom) {\n    this.emitBOM = true;\n    this.encodingType = 'Ansi';\n    this.initBOM(includeBom);\n  }\n  /**\n   * Gets a value indicating whether to write a Unicode byte order mark\n   * @returns boolean- true to specify that a Unicode byte order mark is written; otherwise, false\n   */\n  get includeBom() {\n    return this.emitBOM;\n  }\n  /**\n   * Gets the encoding type.\n   * @returns EncodingType\n   */\n  get type() {\n    return this.encodingType;\n  }\n  /**\n   * Sets the encoding type.\n   * @param  {EncodingType} value\n   */\n  set type(value) {\n    this.encodingType = value;\n  }\n  /**\n   * Initialize the includeBom to emit BOM or Not\n   * @param  {boolean} includeBom\n   */\n  initBOM(includeBom) {\n    if (includeBom === undefined || includeBom === null) {\n      this.emitBOM = true;\n    } else {\n      this.emitBOM = includeBom;\n    }\n  }\n  /**\n   * Calculates the number of bytes produced by encoding the characters in the specified string\n   * @param  {string} chars - The string containing the set of characters to encode\n   * @returns {number} - The number of bytes produced by encoding the specified characters\n   */\n  getByteCount(chars) {\n    validateNullOrUndefined(chars, 'string');\n    if (chars === '') {\n      let byte = this.utf8Len(chars.charCodeAt(0));\n      return byte;\n    }\n    if (this.type === null || this.type === undefined) {\n      this.type = 'Ansi';\n    }\n    return this.getByteCountInternal(chars, 0, chars.length);\n  }\n  /**\n   * Return the Byte of character\n   * @param  {number} codePoint\n   * @returns {number}\n   */\n  utf8Len(codePoint) {\n    let bytes = codePoint <= 0x7F ? 1 : codePoint <= 0x7FF ? 2 : codePoint <= 0xFFFF ? 3 : codePoint <= 0x1FFFFF ? 4 : 0;\n    return bytes;\n  }\n  /**\n   * for 4 byte character return surrogate pair true, otherwise false\n   * @param  {number} codeUnit\n   * @returns {boolean}\n   */\n  isHighSurrogate(codeUnit) {\n    return codeUnit >= 0xD800 && codeUnit <= 0xDBFF;\n  }\n  /**\n   * for 4byte character generate the surrogate pair\n   * @param  {number} highCodeUnit\n   * @param  {number} lowCodeUnit\n   */\n  toCodepoint(highCodeUnit, lowCodeUnit) {\n    highCodeUnit = (0x3FF & highCodeUnit) << 10;\n    let u = highCodeUnit | 0x3FF & lowCodeUnit;\n    return u + 0x10000;\n  }\n  /**\n   * private method to get the byte count for specific charindex and count\n   * @param  {string} chars\n   * @param  {number} charIndex\n   * @param  {number} charCount\n   */\n  getByteCountInternal(chars, charIndex, charCount) {\n    let byteCount = 0;\n    if (this.encodingType === 'Utf8' || this.encodingType === 'Unicode') {\n      let isUtf8 = this.encodingType === 'Utf8';\n      for (let i = 0; i < charCount; i++) {\n        let charCode = chars.charCodeAt(isUtf8 ? charIndex : charIndex++);\n        if (this.isHighSurrogate(charCode)) {\n          if (isUtf8) {\n            let high = charCode;\n            let low = chars.charCodeAt(++charIndex);\n            byteCount += this.utf8Len(this.toCodepoint(high, low));\n          } else {\n            byteCount += 4;\n            ++i;\n          }\n        } else {\n          if (isUtf8) {\n            byteCount += this.utf8Len(charCode);\n          } else {\n            byteCount += 2;\n          }\n        }\n        if (isUtf8) {\n          charIndex++;\n        }\n      }\n      return byteCount;\n    } else {\n      byteCount = charCount;\n      return byteCount;\n    }\n  }\n  /**\n   * Encodes a set of characters from the specified string into the ArrayBuffer.\n   * @param  {string} s- The string containing the set of characters to encode\n   * @param  {number} charIndex-The index of the first character to encode.\n   * @param  {number} charCount- The number of characters to encode.\n   * @returns {ArrayBuffer} - The ArrayBuffer that contains the resulting sequence of bytes.\n   */\n  getBytes(s, charIndex, charCount) {\n    validateNullOrUndefined(s, 'string');\n    validateNullOrUndefined(charIndex, 'charIndex');\n    validateNullOrUndefined(charCount, 'charCount');\n    if (charIndex < 0 || charCount < 0) {\n      throw new RangeError('Argument Out Of Range Exception: charIndex or charCount is less than zero');\n    }\n    if (s.length - charIndex < charCount) {\n      throw new RangeError('Argument Out Of Range Exception: charIndex and charCount do not denote a valid range in string');\n    }\n    let bytes;\n    if (s === '') {\n      bytes = new ArrayBuffer(0);\n      return bytes;\n    }\n    if (this.type === null || this.type === undefined) {\n      this.type = 'Ansi';\n    }\n    let byteCount = this.getByteCountInternal(s, charIndex, charCount);\n    switch (this.type) {\n      case 'Utf8':\n        bytes = this.getBytesOfUtf8Encoding(byteCount, s, charIndex, charCount);\n        return bytes;\n      case 'Unicode':\n        bytes = this.getBytesOfUnicodeEncoding(byteCount, s, charIndex, charCount);\n        return bytes;\n      default:\n        bytes = this.getBytesOfAnsiEncoding(byteCount, s, charIndex, charCount);\n        return bytes;\n    }\n  }\n  /**\n   * Decodes a sequence of bytes from the specified ArrayBuffer into the string.\n   * @param  {ArrayBuffer} bytes- The ArrayBuffer containing the sequence of bytes to decode.\n   * @param  {number} index- The index of the first byte to decode.\n   * @param  {number} count- The number of bytes to decode.\n   * @returns {string} - The string that contains the resulting set of characters.\n   */\n  getString(bytes, index, count) {\n    validateNullOrUndefined(bytes, 'bytes');\n    validateNullOrUndefined(index, 'index');\n    validateNullOrUndefined(count, 'count');\n    if (index < 0 || count < 0) {\n      throw new RangeError('Argument Out Of Range Exception: index or count is less than zero');\n    }\n    if (bytes.byteLength - index < count) {\n      throw new RangeError('Argument Out Of Range Exception: index and count do not denote a valid range in bytes');\n    }\n    if (bytes.byteLength === 0 || count === 0) {\n      return '';\n    }\n    if (this.type === null || this.type === undefined) {\n      this.type = 'Ansi';\n    }\n    let out = '';\n    let byteCal = new Uint8Array(bytes);\n    switch (this.type) {\n      case 'Utf8':\n        let s = this.getStringOfUtf8Encoding(byteCal, index, count);\n        return s;\n      case 'Unicode':\n        let byteUnicode = new Uint16Array(bytes);\n        out = this.getStringofUnicodeEncoding(byteUnicode, index, count);\n        return out;\n      default:\n        let j = index;\n        for (let i = 0; i < count; i++) {\n          let c = byteCal[j];\n          out += String.fromCharCode(c); // 1 byte(ASCII) character                  \n          j++;\n        }\n        return out;\n    }\n  }\n  getBytesOfAnsiEncoding(byteCount, s, charIndex, charCount) {\n    let bytes = new ArrayBuffer(byteCount);\n    let bufview = new Uint8Array(bytes);\n    let k = 0;\n    for (let i = 0; i < charCount; i++) {\n      let charcode = s.charCodeAt(charIndex++);\n      if (charcode < 0x800) {\n        bufview[k] = charcode;\n      } else {\n        bufview[k] = 63; //replacement character '?'\n      }\n\n      k++;\n    }\n    return bytes;\n  }\n  getBytesOfUtf8Encoding(byteCount, s, charIndex, charCount) {\n    let bytes = new ArrayBuffer(byteCount);\n    let uint = new Uint8Array(bytes);\n    let index = charIndex;\n    let j = 0;\n    for (let i = 0; i < charCount; i++) {\n      let charcode = s.charCodeAt(index);\n      if (charcode <= 0x7F) {\n        // 1 byte character 2^7\n        uint[j] = charcode;\n      } else if (charcode < 0x800) {\n        // 2 byte character 2^11\n        uint[j] = 0xc0 | charcode >> 6;\n        uint[++j] = 0x80 | charcode & 0x3f;\n      } else if (charcode < 0xd800 || charcode >= 0xe000) {\n        // 3 byte character 2^16        \n        uint[j] = 0xe0 | charcode >> 12;\n        uint[++j] = 0x80 | charcode >> 6 & 0x3f;\n        uint[++j] = 0x80 | charcode & 0x3f;\n      } else {\n        uint[j] = 0xef;\n        uint[++j] = 0xbf;\n        uint[++j] = 0xbd; // U+FFFE \"replacement character\"\n      }\n\n      ++j;\n      ++index;\n    }\n    return bytes;\n  }\n  getBytesOfUnicodeEncoding(byteCount, s, charIndex, charCount) {\n    let bytes = new ArrayBuffer(byteCount);\n    let uint16 = new Uint16Array(bytes);\n    for (let i = 0; i < charCount; i++) {\n      let charcode = s.charCodeAt(i);\n      uint16[i] = charcode;\n    }\n    return bytes;\n  }\n  getStringOfUtf8Encoding(byteCal, index, count) {\n    let j = 0;\n    let i = index;\n    let s = '';\n    for (j; j < count; j++) {\n      let c = byteCal[i++];\n      while (i > byteCal.length) {\n        return s;\n      }\n      if (c > 127) {\n        if (c > 191 && c < 224 && i < count) {\n          c = (c & 31) << 6 | byteCal[i] & 63;\n        } else if (c > 223 && c < 240 && i < byteCal.byteLength) {\n          c = (c & 15) << 12 | (byteCal[i] & 63) << 6 | byteCal[++i] & 63;\n        } else if (c > 239 && c < 248 && i < byteCal.byteLength) {\n          c = (c & 7) << 18 | (byteCal[i] & 63) << 12 | (byteCal[++i] & 63) << 6 | byteCal[++i] & 63;\n        }\n        ++i;\n      }\n      s += String.fromCharCode(c); // 1 byte(ASCII) character                          \n    }\n\n    return s;\n  }\n  getStringofUnicodeEncoding(byteUni, index, count) {\n    if (count > byteUni.length) {\n      throw new RangeError('ArgumentOutOfRange_Count');\n    }\n    let byte16 = new Uint16Array(count);\n    let out = '';\n    for (let i = 0; i < count && i < byteUni.length; i++) {\n      byte16[i] = byteUni[index++];\n    }\n    out = String.fromCharCode.apply(null, byte16);\n    return out;\n  }\n  /**\n   * To clear the encoding instance\n   * @return {void}\n   */\n  destroy() {\n    this.emitBOM = undefined;\n    this.encodingType = undefined;\n  }\n}\n/**\n * To check the object is null or undefined and throw error if it is null or undefined\n * @param {Object} value - object to check is null or undefined\n * @return {boolean}\n * @throws {ArgumentException} - if the value is null or undefined\n * @private\n */\nfunction validateNullOrUndefined(value, message) {\n  if (value === null || value === undefined) {\n    throw new Error('ArgumentException: ' + message + ' cannot be null or undefined');\n  }\n}\n\n/**\n * StreamWriter class contains the implementation for writing characters to a file in a particular encoding\n * ```typescript\n * let writer = new StreamWriter();\n * writer.write('Hello World');\n * writer.save('Sample.txt');\n * writer.dispose();\n * ```\n */\nclass StreamWriter {\n  /**\n   * Gets the content written to the StreamWriter as Blob.\n   * @returns Blob\n   */\n  get buffer() {\n    this.flush();\n    return this.bufferBlob;\n  }\n  /**\n   * Gets the encoding.\n   * @returns Encoding\n   */\n  get encoding() {\n    return this.enc;\n  }\n  /**\n   * Initializes a new instance of the StreamWriter class by using the specified encoding.\n   * @param  {Encoding} encoding?- The character encoding to use.\n   */\n  constructor(encoding) {\n    this.bufferBlob = new Blob(['']);\n    this.bufferText = '';\n    this.init(encoding);\n    Save.isMicrosoftBrowser = !!navigator.msSaveBlob;\n  }\n  init(encoding) {\n    if (encoding === null || encoding === undefined) {\n      this.enc = new Encoding(false);\n      this.enc.type = 'Utf8';\n    } else {\n      this.enc = encoding;\n      this.setBomByte();\n    }\n  }\n  /**\n   * Private method to set Byte Order Mark(BOM) value based on EncodingType\n   */\n  setBomByte() {\n    if (this.encoding.includeBom) {\n      switch (this.encoding.type) {\n        case 'Unicode':\n          let arrayUnicode = new ArrayBuffer(2);\n          let uint8 = new Uint8Array(arrayUnicode);\n          uint8[0] = 255;\n          uint8[1] = 254;\n          this.bufferBlob = new Blob([arrayUnicode]);\n          break;\n        case 'Utf8':\n          let arrayUtf8 = new ArrayBuffer(3);\n          let utf8 = new Uint8Array(arrayUtf8);\n          utf8[0] = 239;\n          utf8[1] = 187;\n          utf8[2] = 191;\n          this.bufferBlob = new Blob([arrayUtf8]);\n          break;\n        default:\n          this.bufferBlob = new Blob(['']);\n          break;\n      }\n    }\n  }\n  /**\n   * Saves the file with specified name and sends the file to client browser\n   * @param  {string} fileName - The file name to save\n   * @returns {void}\n   */\n  save(fileName) {\n    if (this.bufferText !== '') {\n      this.flush();\n    }\n    Save.save(fileName, this.buffer);\n  }\n  /**\n   * Writes the specified string.\n   * @param  {string} value - The string to write. If value is null or undefined, nothing is written.\n   * @returns {void}\n   */\n  write(value) {\n    if (this.encoding === undefined) {\n      throw new Error('Object Disposed Exception: current writer is disposed');\n    }\n    validateNullOrUndefined(value, 'string');\n    this.bufferText += value;\n    if (this.bufferText.length >= 10240) {\n      this.flush();\n    }\n  }\n  flush() {\n    if (this.bufferText === undefined || this.bufferText === null || this.bufferText.length === 0) {\n      return;\n    }\n    let bufferArray = this.encoding.getBytes(this.bufferText, 0, this.bufferText.length);\n    this.bufferText = '';\n    this.bufferBlob = new Blob([this.bufferBlob, bufferArray]);\n  }\n  /**\n   * Writes the specified string followed by a line terminator\n   * @param  {string} value - The string to write. If value is null or undefined, nothing is written\n   * @returns {void}\n   */\n  writeLine(value) {\n    if (this.encoding === undefined) {\n      throw new Error('Object Disposed Exception: current writer is disposed');\n    }\n    validateNullOrUndefined(value, 'string');\n    this.bufferText = this.bufferText + value + '\\r\\n';\n    if (this.bufferText.length >= 10240) {\n      this.flush();\n    }\n  }\n  /**\n   * Releases the resources used by the StreamWriter\n   * @returns {void}\n   */\n  destroy() {\n    this.bufferBlob = undefined;\n    this.bufferText = undefined;\n    if (this.enc instanceof Encoding) {\n      this.enc.destroy();\n    }\n    this.enc = undefined;\n  }\n}\n\n// export all modules from current location\n// example: export * from './module'\n/**\n * file utils modules\n */\n\nexport { XmlWriter, Namespace, XmlElement, XmlAttribute, StreamWriter, Encoding, validateNullOrUndefined, Save };\n//# sourceMappingURL=ej2-file-utils.es2015.js.map","map":null,"metadata":{},"sourceType":"module"}