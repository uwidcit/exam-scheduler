{"ast":null,"code":"import { Animation, Browser, ChildProperty, Collection, Component, Event, EventHandler, HijriParser, Internationalization, KeyboardEvents, L10n, NotifyPropertyChanges, Property, addClass, append, attributes, cldrData, closest, createElement, detach, extend, formatUnit, getDefaultDateObject, getUniqueID, getValue, isNullOrUndefined, isUndefined, merge, prepend, remove, removeClass, rippleEffect, select, setStyleAttribute, setValue, throwError } from '@syncfusion/ej2-base';\nimport { Popup } from '@syncfusion/ej2-popups';\nimport { Input } from '@syncfusion/ej2-inputs';\nimport { Button } from '@syncfusion/ej2-buttons';\nimport { ListBase } from '@syncfusion/ej2-lists';\nvar __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n//class constant defination.\nconst OTHERMONTH = 'e-other-month';\nconst OTHERDECADE = 'e-other-year';\nconst ROOT = 'e-calendar';\nconst DEVICE = 'e-device';\nconst HEADER = 'e-header';\nconst RTL = 'e-rtl';\nconst CONTENT = 'e-content';\nconst YEAR = 'e-year';\nconst MONTH = 'e-month';\nconst DECADE = 'e-decade';\nconst ICON = 'e-icons';\nconst PREVICON = 'e-prev';\nconst NEXTICON = 'e-next';\nconst PREVSPAN = 'e-date-icon-prev';\nconst NEXTSPAN = 'e-date-icon-next ';\nconst ICONCONTAINER = 'e-icon-container';\nconst DISABLED = 'e-disabled';\nconst OVERLAY = 'e-overlay';\nconst WEEKEND = 'e-weekend';\nconst WEEKNUMBER = 'e-week-number';\nconst SELECTED = 'e-selected';\nconst FOCUSEDDATE = 'e-focused-date';\nconst OTHERMONTHROW = 'e-month-hide';\nconst TODAY = 'e-today';\nconst TITLE = 'e-title';\nconst LINK = 'e-day';\nconst CELL = 'e-cell';\nconst WEEKHEADER = 'e-week-header';\nconst ZOOMIN = 'e-zoomin';\nconst FOOTER = 'e-footer-container';\nconst BTN = 'e-btn';\nconst FLAT = 'e-flat';\nconst CSS = 'e-css';\nconst PRIMARY = 'e-primary';\nconst DAYHEADERLONG = 'e-calendar-day-header-lg';\nconst dayMilliSeconds = 86400000;\nconst minutesMilliSeconds = 60000;\n/**\n *\n * @private\n */\nlet CalendarBase = /*#__PURE__*/(() => {\n  let CalendarBase = class CalendarBase extends Component {\n    /**\n     * Initialized new instance of Calendar Class.\n     * Constructor for creating the widget\n     *\n     * @param {CalendarBaseModel} options - Specifies the CalendarBase model.\n     * @param {string | HTMLElement} element - Specifies the element to render as component.\n     * @private\n     */\n    constructor(options, element) {\n      super(options, element);\n      this.effect = '';\n      this.isPopupClicked = false;\n      this.isDateSelected = true;\n      this.isTodayClicked = false;\n      this.preventChange = false;\n      this.isAngular = false;\n    }\n    /**\n     * To Initialize the control rendering.\n     *\n     * @returns {void}\n     * @private\n     */\n    render() {\n      this.rangeValidation(this.min, this.max);\n      this.calendarEleCopy = this.element.cloneNode(true);\n      if (this.calendarMode === 'Islamic') {\n        if (+this.min.setSeconds(0) === +new Date(1900, 0, 1, 0, 0, 0)) {\n          this.min = new Date(1944, 2, 18);\n        }\n        if (+this.max === +new Date(2099, 11, 31)) {\n          this.max = new Date(2069, 10, 16);\n        }\n      }\n      this.globalize = new Internationalization(this.locale);\n      if (isNullOrUndefined(this.firstDayOfWeek) || this.firstDayOfWeek > 6 || this.firstDayOfWeek < 0) {\n        this.setProperties({\n          firstDayOfWeek: this.globalize.getFirstDayOfWeek()\n        }, true);\n      }\n      this.todayDisabled = false;\n      this.todayDate = new Date(new Date().setHours(0, 0, 0, 0));\n      if (this.getModuleName() === 'calendar') {\n        this.element.classList.add(ROOT);\n        if (this.enableRtl) {\n          this.element.classList.add(RTL);\n        }\n        if (Browser.isDevice) {\n          this.element.classList.add(DEVICE);\n        }\n        attributes(this.element, {\n          'data-role': 'calendar'\n        });\n        this.tabIndex = this.element.hasAttribute('tabindex') ? this.element.getAttribute('tabindex') : '0';\n        this.element.setAttribute('tabindex', this.tabIndex);\n      } else {\n        this.calendarElement = this.createElement('div');\n        this.calendarElement.classList.add(ROOT);\n        if (this.enableRtl) {\n          this.calendarElement.classList.add(RTL);\n        }\n        if (Browser.isDevice) {\n          this.calendarElement.classList.add(DEVICE);\n        }\n        attributes(this.calendarElement, {\n          'role': 'calendar'\n        });\n      }\n      this.createHeader();\n      this.createContent();\n      this.wireEvents();\n    }\n    rangeValidation(min, max) {\n      if (isNullOrUndefined(min)) {\n        this.setProperties({\n          min: new Date(1900, 0, 1)\n        }, true);\n      }\n      if (isNullOrUndefined(max)) {\n        this.setProperties({\n          max: new Date(2099, 11, 31)\n        }, true);\n      }\n    }\n    getDefaultKeyConfig() {\n      this.defaultKeyConfigs = {\n        controlUp: 'ctrl+38',\n        controlDown: 'ctrl+40',\n        moveDown: 'downarrow',\n        moveUp: 'uparrow',\n        moveLeft: 'leftarrow',\n        moveRight: 'rightarrow',\n        select: 'enter',\n        home: 'home',\n        end: 'end',\n        pageUp: 'pageup',\n        pageDown: 'pagedown',\n        shiftPageUp: 'shift+pageup',\n        shiftPageDown: 'shift+pagedown',\n        controlHome: 'ctrl+home',\n        controlEnd: 'ctrl+end',\n        altUpArrow: 'alt+uparrow',\n        spacebar: 'space',\n        altRightArrow: 'alt+rightarrow',\n        altLeftArrow: 'alt+leftarrow'\n      };\n      return this.defaultKeyConfigs;\n    }\n    validateDate(value) {\n      this.setProperties({\n        min: this.checkDateValue(new Date(this.checkValue(this.min)))\n      }, true);\n      this.setProperties({\n        max: this.checkDateValue(new Date(this.checkValue(this.max)))\n      }, true);\n      this.currentDate = this.currentDate ? this.currentDate : new Date(new Date().setHours(0, 0, 0, 0));\n      if (!isNullOrUndefined(value) && this.min <= this.max && value >= this.min && value <= this.max) {\n        this.currentDate = new Date(this.checkValue(value));\n      }\n    }\n    setOverlayIndex(popupWrapper, popupElement, modal, isDevice) {\n      if (isDevice && !isNullOrUndefined(popupElement) && !isNullOrUndefined(modal) && !isNullOrUndefined(popupWrapper)) {\n        const index = parseInt(popupElement.style.zIndex, 10) ? parseInt(popupElement.style.zIndex, 10) : 1000;\n        modal.style.zIndex = (index - 1).toString();\n        popupWrapper.style.zIndex = index.toString();\n      }\n    }\n    minMaxUpdate(value) {\n      if (!(+this.min <= +this.max)) {\n        this.setProperties({\n          min: this.min\n        }, true);\n        addClass([this.element], OVERLAY);\n      } else {\n        removeClass([this.element], OVERLAY);\n      }\n      this.min = isNullOrUndefined(this.min) || !+this.min ? this.min = new Date(1900, 0, 1) : this.min;\n      this.max = isNullOrUndefined(this.max) || !+this.max ? this.max = new Date(2099, 11, 31) : this.max;\n      if (+this.min <= +this.max && value && +value <= +this.max && +value >= +this.min) {\n        this.currentDate = new Date(this.checkValue(value));\n      } else {\n        if (+this.min <= +this.max && !value && +this.currentDate > +this.max) {\n          this.currentDate = new Date(this.checkValue(this.max));\n        } else {\n          if (+this.currentDate < +this.min) {\n            this.currentDate = new Date(this.checkValue(this.min));\n          }\n        }\n      }\n    }\n    createHeader() {\n      const ariaPrevAttrs = {\n        'aria-disabled': 'false',\n        'aria-label': 'previous month'\n      };\n      const ariaNextAttrs = {\n        'aria-disabled': 'false',\n        'aria-label': 'next month'\n      };\n      const ariaTitleAttrs = {\n        'aria-atomic': 'true',\n        'aria-live': 'assertive',\n        'aria-label': 'title'\n      };\n      this.headerElement = this.createElement('div', {\n        className: HEADER\n      });\n      const iconContainer = this.createElement('div', {\n        className: ICONCONTAINER\n      });\n      this.previousIcon = this.createElement('button', {\n        className: '' + PREVICON,\n        attrs: {\n          type: 'button'\n        }\n      });\n      rippleEffect(this.previousIcon, {\n        duration: 400,\n        selector: '.e-prev',\n        isCenterRipple: true\n      });\n      attributes(this.previousIcon, ariaPrevAttrs);\n      this.nextIcon = this.createElement('button', {\n        className: '' + NEXTICON,\n        attrs: {\n          type: 'button'\n        }\n      });\n      rippleEffect(this.nextIcon, {\n        selector: '.e-next',\n        duration: 400,\n        isCenterRipple: true\n      });\n      attributes(this.nextIcon, ariaNextAttrs);\n      this.headerTitleElement = this.createElement('div', {\n        className: '' + LINK + ' ' + TITLE\n      });\n      attributes(this.headerTitleElement, ariaTitleAttrs);\n      this.headerElement.appendChild(this.headerTitleElement);\n      this.previousIcon.appendChild(this.createElement('span', {\n        className: '' + PREVSPAN + ' ' + ICON\n      }));\n      this.nextIcon.appendChild(this.createElement('span', {\n        className: '' + NEXTSPAN + ' ' + ICON\n      }));\n      iconContainer.appendChild(this.previousIcon);\n      iconContainer.appendChild(this.nextIcon);\n      this.headerElement.appendChild(iconContainer);\n      if (this.getModuleName() === 'calendar') {\n        this.element.appendChild(this.headerElement);\n      } else {\n        this.calendarElement.appendChild(this.headerElement);\n      }\n      this.adjustLongHeaderSize();\n    }\n    createContent() {\n      this.contentElement = this.createElement('div', {\n        className: CONTENT\n      });\n      this.table = this.createElement('table', {\n        attrs: {\n          tabIndex: '0',\n          'role': 'grid',\n          'aria-activedescendant': ''\n        }\n      });\n      if (this.getModuleName() === 'calendar') {\n        this.element.appendChild(this.contentElement);\n      } else {\n        this.calendarElement.appendChild(this.contentElement);\n      }\n      this.contentElement.appendChild(this.table);\n      this.createContentHeader();\n      this.createContentBody();\n      if (this.showTodayButton) {\n        this.createContentFooter();\n      }\n    }\n    getCultureValues() {\n      const culShortNames = [];\n      let cldrObj;\n      const dayFormat = 'days.stand-alone.' + this.dayHeaderFormat.toLowerCase();\n      if (this.locale === 'en' || this.locale === 'en-US') {\n        cldrObj = getValue(dayFormat, getDefaultDateObject());\n      } else {\n        cldrObj = this.getCultureObjects(cldrData, '' + this.locale);\n      }\n      for (const obj of Object.keys(cldrObj)) {\n        culShortNames.push(getValue(obj, cldrObj));\n      }\n      return culShortNames;\n    }\n    toCapitalize(text) {\n      return !isNullOrUndefined(text) && text.length ? text[0].toUpperCase() + text.slice(1) : text;\n    }\n    createContentHeader() {\n      if (this.getModuleName() === 'calendar') {\n        if (!isNullOrUndefined(this.element.querySelectorAll('.e-content .e-week-header')[0])) {\n          detach(this.element.querySelectorAll('.e-content .e-week-header')[0]);\n        }\n      } else {\n        if (!isNullOrUndefined(this.calendarElement.querySelectorAll('.e-content .e-week-header')[0])) {\n          detach(this.calendarElement.querySelectorAll('.e-content .e-week-header')[0]);\n        }\n      }\n      const daysCount = 6;\n      let html = '';\n      if (this.firstDayOfWeek > 6 || this.firstDayOfWeek < 0) {\n        this.setProperties({\n          firstDayOfWeek: 0\n        }, true);\n      }\n      this.tableHeadElement = this.createElement('thead', {\n        className: WEEKHEADER\n      });\n      if (this.weekNumber) {\n        html += '<th class=\"e-week-number\"></th>';\n        if (this.getModuleName() === 'calendar') {\n          addClass([this.element], '' + WEEKNUMBER);\n        } else {\n          addClass([this.calendarElement], '' + WEEKNUMBER);\n        }\n      }\n      // eslint-disable-next-line max-len\n      const shortNames = this.shiftArray(this.getCultureValues().length > 0 && this.getCultureValues(), this.firstDayOfWeek);\n      for (let days = 0; days <= daysCount; days++) {\n        html += '<th  class=\"\">' + this.toCapitalize(shortNames[days]) + '</th>';\n      }\n      html = '<tr>' + html + '</tr>';\n      this.tableHeadElement.innerHTML = html;\n      this.table.appendChild(this.tableHeadElement);\n    }\n    createContentBody() {\n      if (this.getModuleName() === 'calendar') {\n        if (!isNullOrUndefined(this.element.querySelectorAll('.e-content tbody')[0])) {\n          detach(this.element.querySelectorAll('.e-content tbody')[0]);\n        }\n      } else {\n        if (!isNullOrUndefined(this.calendarElement.querySelectorAll('.e-content tbody')[0])) {\n          detach(this.calendarElement.querySelectorAll('.e-content tbody')[0]);\n        }\n      }\n      switch (this.start) {\n        case 'Year':\n          this.renderYears();\n          break;\n        case 'Decade':\n          this.renderDecades();\n          break;\n        default:\n          this.renderMonths();\n      }\n    }\n    updateFooter() {\n      this.todayElement.textContent = this.l10.getConstant('today');\n      this.todayElement.setAttribute('aria-label', this.l10.getConstant('today'));\n    }\n    createContentFooter() {\n      if (this.showTodayButton) {\n        const minimum = new Date(+this.min);\n        const maximum = new Date(+this.max);\n        const l10nLocale = {\n          today: 'Today'\n        };\n        this.globalize = new Internationalization(this.locale);\n        this.l10 = new L10n(this.getModuleName(), l10nLocale, this.locale);\n        this.todayElement = this.createElement('button', {\n          attrs: {\n            role: 'button'\n          }\n        });\n        rippleEffect(this.todayElement);\n        this.updateFooter();\n        addClass([this.todayElement], [BTN, TODAY, FLAT, PRIMARY, CSS]);\n        if (!(+new Date(minimum.setHours(0, 0, 0, 0)) <= +this.todayDate && +this.todayDate <= +new Date(maximum.setHours(0, 0, 0, 0))) || this.todayDisabled) {\n          addClass([this.todayElement], DISABLED);\n        }\n        this.footer = this.createElement('div', {\n          className: FOOTER\n        });\n        this.footer.appendChild(this.todayElement);\n        if (this.getModuleName() === 'calendar') {\n          this.element.appendChild(this.footer);\n        }\n        if (this.getModuleName() === 'datepicker') {\n          this.calendarElement.appendChild(this.footer);\n        }\n        if (this.getModuleName() === 'datetimepicker') {\n          this.calendarElement.appendChild(this.footer);\n        }\n        if (!this.todayElement.classList.contains(DISABLED)) {\n          EventHandler.add(this.todayElement, 'click', this.todayButtonClick, this);\n        }\n      }\n    }\n    wireEvents(id, ref, keyConfig, moduleName) {\n      EventHandler.add(this.headerTitleElement, 'click', this.navigateTitle, this);\n      this.defaultKeyConfigs = extend(this.defaultKeyConfigs, this.keyConfigs);\n      if (this.getModuleName() === 'calendar') {\n        this.keyboardModule = new KeyboardEvents(this.element, {\n          eventName: 'keydown',\n          keyAction: this.keyActionHandle.bind(this),\n          keyConfigs: this.defaultKeyConfigs\n        });\n      } else {\n        this.keyboardModule = new KeyboardEvents(this.calendarElement, {\n          eventName: 'keydown',\n          keyAction: this.keyActionHandle.bind(this),\n          keyConfigs: this.defaultKeyConfigs\n        });\n      }\n    }\n    dateWireEvents(id, ref, keyConfig, moduleName) {\n      this.defaultKeyConfigs = this.getDefaultKeyConfig();\n      this.defaultKeyConfigs = extend(this.defaultKeyConfigs, keyConfig);\n      this.serverModuleName = moduleName;\n    }\n    todayButtonClick(e, value, isCustomDate) {\n      if (this.showTodayButton) {\n        if (this.currentView() === this.depth) {\n          this.effect = '';\n        } else {\n          this.effect = 'e-zoomin';\n        }\n        if (this.getViewNumber(this.start) >= this.getViewNumber(this.depth)) {\n          this.navigateTo(this.depth, new Date(this.checkValue(value)), isCustomDate);\n        } else {\n          this.navigateTo('Month', new Date(this.checkValue(value)), isCustomDate);\n        }\n      }\n    }\n    resetCalendar() {\n      this.calendarElement && detach(this.calendarElement);\n      this.tableBodyElement && detach(this.tableBodyElement);\n      this.table && detach(this.table);\n      this.tableHeadElement && detach(this.tableHeadElement);\n      this.nextIcon && detach(this.nextIcon);\n      this.previousIcon && detach(this.previousIcon);\n      this.footer && detach(this.footer);\n      this.todayElement = null;\n      this.renderDayCellArgs = null;\n      this.calendarElement = this.tableBodyElement = this.footer = this.tableHeadElement = this.nextIcon = this.previousIcon = this.table = null;\n    }\n    keyActionHandle(e, value, multiSelection) {\n      const focusedDate = this.tableBodyElement.querySelector('tr td.e-focused-date');\n      let selectedDate;\n      if (multiSelection) {\n        if (!isNullOrUndefined(focusedDate) && +value === parseInt(focusedDate.getAttribute('id').split('_')[0], 10)) {\n          selectedDate = focusedDate;\n        } else {\n          selectedDate = this.tableBodyElement.querySelector('tr td.e-selected');\n        }\n      } else {\n        selectedDate = this.tableBodyElement.querySelector('tr td.e-selected');\n      }\n      let view = this.getViewNumber(this.currentView());\n      const depthValue = this.getViewNumber(this.depth);\n      const levelRestrict = view === depthValue && this.getViewNumber(this.start) >= depthValue;\n      this.effect = '';\n      switch (e.action) {\n        case 'moveLeft':\n          this.keyboardNavigate(-1, view, e, this.max, this.min);\n          e.preventDefault();\n          break;\n        case 'moveRight':\n          this.keyboardNavigate(1, view, e, this.max, this.min);\n          e.preventDefault();\n          break;\n        case 'moveUp':\n          if (view === 0) {\n            this.keyboardNavigate(-7, view, e, this.max, this.min); // move the current date to the previous seven days.\n          } else {\n            this.keyboardNavigate(-4, view, e, this.max, this.min); // move the current year to the previous four days.\n          }\n\n          e.preventDefault();\n          break;\n        case 'moveDown':\n          if (view === 0) {\n            this.keyboardNavigate(7, view, e, this.max, this.min);\n          } else {\n            this.keyboardNavigate(4, view, e, this.max, this.min);\n          }\n          e.preventDefault();\n          break;\n        case 'select':\n          if (e.target === this.todayElement) {\n            this.todayButtonClick(e, value);\n          } else {\n            const element = !isNullOrUndefined(focusedDate) ? focusedDate : selectedDate;\n            if (!isNullOrUndefined(element) && !element.classList.contains(DISABLED)) {\n              if (levelRestrict) {\n                // eslint-disable-next-line radix\n                const d = new Date(parseInt('' + element.id, 0));\n                this.selectDate(e, d, element);\n              } else {\n                this.contentClick(null, --view, element, value);\n              }\n            }\n          }\n          break;\n        case 'controlUp':\n          this.title();\n          e.preventDefault();\n          break;\n        case 'controlDown':\n          if (!isNullOrUndefined(focusedDate) || !isNullOrUndefined(selectedDate) && !levelRestrict) {\n            this.contentClick(null, --view, focusedDate || selectedDate, value);\n          }\n          e.preventDefault();\n          break;\n        case 'home':\n          this.currentDate = this.firstDay(this.currentDate);\n          detach(this.tableBodyElement);\n          if (view === 0) {\n            this.renderMonths(e);\n          } else if (view === 1) {\n            this.renderYears(e);\n          } else {\n            this.renderDecades(e);\n          }\n          e.preventDefault();\n          break;\n        case 'end':\n          this.currentDate = this.lastDay(this.currentDate, view);\n          detach(this.tableBodyElement);\n          if (view === 0) {\n            this.renderMonths(e);\n          } else if (view === 1) {\n            this.renderYears(e);\n          } else {\n            this.renderDecades(e);\n          }\n          e.preventDefault();\n          break;\n        case 'pageUp':\n          this.addMonths(this.currentDate, -1);\n          this.navigateTo('Month', this.currentDate);\n          e.preventDefault();\n          break;\n        case 'pageDown':\n          this.addMonths(this.currentDate, 1);\n          this.navigateTo('Month', this.currentDate);\n          e.preventDefault();\n          break;\n        case 'shiftPageUp':\n          this.addYears(this.currentDate, -1);\n          this.navigateTo('Month', this.currentDate);\n          e.preventDefault();\n          break;\n        case 'shiftPageDown':\n          this.addYears(this.currentDate, 1);\n          this.navigateTo('Month', this.currentDate);\n          e.preventDefault();\n          break;\n        case 'controlHome':\n          this.navigateTo('Month', new Date(this.currentDate.getFullYear(), 0, 1));\n          e.preventDefault();\n          break;\n        case 'controlEnd':\n          this.navigateTo('Month', new Date(this.currentDate.getFullYear(), 11, 31));\n          e.preventDefault();\n          break;\n      }\n      if (this.getModuleName() === 'calendar') {\n        this.table.focus();\n      }\n    }\n    keyboardNavigate(number, currentView, e, max, min) {\n      const date = new Date(this.checkValue(this.currentDate));\n      switch (currentView) {\n        case 2:\n          this.addYears(this.currentDate, number);\n          if (this.isMonthYearRange(this.currentDate)) {\n            detach(this.tableBodyElement);\n            this.renderDecades(e);\n          } else {\n            this.currentDate = date;\n          }\n          break;\n        case 1:\n          this.addMonths(this.currentDate, number);\n          if (this.calendarMode === 'Gregorian') {\n            if (this.isMonthYearRange(this.currentDate)) {\n              detach(this.tableBodyElement);\n              this.renderYears(e);\n            } else {\n              this.currentDate = date;\n            }\n          } else {\n            if (this.isMonthYearRange(this.currentDate)) {\n              detach(this.tableBodyElement);\n              this.renderYears(e);\n            } else {\n              this.currentDate = date;\n            }\n          }\n          break;\n        case 0:\n          this.addDay(this.currentDate, number, e, max, min);\n          if (this.isMinMaxRange(this.currentDate)) {\n            detach(this.tableBodyElement);\n            this.renderMonths(e);\n          } else {\n            this.currentDate = date;\n          }\n          break;\n      }\n    }\n    /**\n     * Initialize the event handler\n     *\n     * @param {Date} value - Specifies value of date.\n     * @returns {void}\n     * @private\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    preRender(value) {\n      this.navigatePreviousHandler = this.navigatePrevious.bind(this);\n      this.navigateNextHandler = this.navigateNext.bind(this);\n      this.defaultKeyConfigs = this.getDefaultKeyConfig();\n      this.navigateHandler = e => {\n        this.triggerNavigate(e);\n      };\n    }\n    minMaxDate(localDate) {\n      const currentDate = new Date(new Date(+localDate).setHours(0, 0, 0, 0));\n      const minDate = new Date(new Date(+this.min).setHours(0, 0, 0, 0));\n      const maxDate = new Date(new Date(+this.max).setHours(0, 0, 0, 0));\n      if (+currentDate === +minDate || +currentDate === +maxDate) {\n        if (+localDate < +this.min) {\n          localDate = new Date(+this.min);\n        }\n        if (+localDate > +this.max) {\n          localDate = new Date(+this.max);\n        }\n      }\n      return localDate;\n    }\n    renderMonths(e, value, isCustomDate) {\n      const numCells = this.weekNumber ? 8 : 7;\n      let tdEles;\n      if (this.calendarMode === 'Gregorian') {\n        tdEles = this.renderDays(this.currentDate, value, null, null, isCustomDate);\n      } else {\n        tdEles = this.islamicModule.islamicRenderDays(this.currentDate, value);\n      }\n      this.createContentHeader();\n      if (this.calendarMode === 'Gregorian') {\n        this.renderTemplate(tdEles, numCells, MONTH, e, value);\n      } else {\n        this.islamicModule.islamicRenderTemplate(tdEles, numCells, MONTH, e, value);\n      }\n    }\n    renderDays(currentDate, value, multiSelection, values, isTodayDate) {\n      const tdEles = [];\n      const cellsCount = 42;\n      const todayDate = isTodayDate ? new Date(+currentDate) : this.getDate(new Date(), this.timezone);\n      let localDate = new Date(this.checkValue(currentDate));\n      let minMaxDate;\n      const currentMonth = localDate.getMonth();\n      this.titleUpdate(currentDate, 'days');\n      const d = localDate;\n      localDate = new Date(d.getFullYear(), d.getMonth(), 0, d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds());\n      while (localDate.getDay() !== this.firstDayOfWeek) {\n        this.setStartDate(localDate, -1 * dayMilliSeconds);\n      }\n      for (let day = 0; day < cellsCount; ++day) {\n        const weekEle = this.createElement('td', {\n          className: CELL\n        });\n        const weekAnchor = this.createElement('span');\n        if (day % 7 === 0 && this.weekNumber) {\n          // 6 days are added to get Last day of the week and 3 days are added to get middle day of the week.\n          const numberOfDays = this.weekRule === 'FirstDay' ? 6 : this.weekRule === 'FirstFourDayWeek' ? 3 : 0;\n          const finalDate = new Date(localDate.getFullYear(), localDate.getMonth(), localDate.getDate() + numberOfDays);\n          weekAnchor.textContent = '' + this.getWeek(finalDate);\n          weekEle.appendChild(weekAnchor);\n          addClass([weekEle], '' + WEEKNUMBER);\n          tdEles.push(weekEle);\n        }\n        minMaxDate = new Date(+localDate);\n        localDate = this.minMaxDate(localDate);\n        const dateFormatOptions = {\n          type: 'dateTime',\n          skeleton: 'full'\n        };\n        const date = this.globalize.parseDate(this.globalize.formatDate(localDate, dateFormatOptions), dateFormatOptions);\n        const tdEle = this.dayCell(localDate);\n        const title = this.globalize.formatDate(localDate, {\n          type: 'date',\n          skeleton: 'full'\n        });\n        const dayLink = this.createElement('span');\n        dayLink.textContent = this.globalize.formatDate(localDate, {\n          format: 'd',\n          type: 'date',\n          skeleton: 'yMd'\n        });\n        const disabled = this.min > localDate || this.max < localDate;\n        if (disabled) {\n          addClass([tdEle], DISABLED);\n          addClass([tdEle], OVERLAY);\n        } else {\n          dayLink.setAttribute('title', '' + title);\n        }\n        if (currentMonth !== localDate.getMonth()) {\n          addClass([tdEle], OTHERMONTH);\n        }\n        if (localDate.getDay() === 0 || localDate.getDay() === 6) {\n          addClass([tdEle], WEEKEND);\n        }\n        tdEle.appendChild(dayLink);\n        this.renderDayCellArgs = {\n          date: localDate,\n          isDisabled: false,\n          element: tdEle,\n          isOutOfRange: disabled\n        };\n        const argument = this.renderDayCellArgs;\n        this.renderDayCellEvent(argument);\n        if (argument.isDisabled) {\n          const selectDate = new Date(this.checkValue(value));\n          const argsDate = new Date(this.checkValue(argument.date));\n          if (multiSelection) {\n            if (!isNullOrUndefined(values) && values.length > 0) {\n              for (let index = 0; index < values.length; index++) {\n                const localDateString = +new Date(this.globalize.formatDate(argument.date, {\n                  type: 'date',\n                  skeleton: 'yMd'\n                }));\n                const tempDateString = +new Date(this.globalize.formatDate(values[index], {\n                  type: 'date',\n                  skeleton: 'yMd'\n                }));\n                if (localDateString === tempDateString) {\n                  values.splice(index, 1);\n                  index = -1;\n                }\n              }\n            }\n          } else if (selectDate && +selectDate === +argsDate) {\n            this.setProperties({\n              value: null\n            }, true);\n          }\n        }\n        if (this.renderDayCellArgs.isDisabled && !tdEle.classList.contains(SELECTED)) {\n          addClass([tdEle], DISABLED);\n          addClass([tdEle], OVERLAY);\n          if (+this.renderDayCellArgs.date === +this.todayDate) {\n            this.todayDisabled = true;\n          }\n        }\n        const otherMnthBool = tdEle.classList.contains(OTHERMONTH);\n        const disabledCls = tdEle.classList.contains(DISABLED);\n        if (!disabledCls) {\n          EventHandler.add(tdEle, 'click', this.clickHandler, this);\n        }\n        // to set the value as null while setting the disabled date onProperty change.\n        // if (args.isDisabled && +this.value === +args.date) {\n        //     this.setProperties({ value: null }, true);\n        // }\n        if (multiSelection && !isNullOrUndefined(values) && !disabledCls) {\n          for (let tempValue = 0; tempValue < values.length; tempValue++) {\n            const type = this.calendarMode === 'Gregorian' ? 'gregorian' : 'islamic';\n            const formatOptions = {\n              format: null,\n              type: 'date',\n              skeleton: 'short',\n              calendar: type\n            };\n            const localDateString = this.globalize.formatDate(localDate, formatOptions);\n            const tempDateString = this.globalize.formatDate(values[tempValue], formatOptions);\n            if (localDateString === tempDateString && this.getDateVal(localDate, values[tempValue]) || this.getDateVal(localDate, value)) {\n              addClass([tdEle], SELECTED);\n            } else {\n              this.updateFocus(otherMnthBool, disabledCls, localDate, tdEle, currentDate);\n            }\n          }\n          if (values.length <= 0) {\n            this.updateFocus(otherMnthBool, disabledCls, localDate, tdEle, currentDate);\n          }\n        } else if (!disabledCls && this.getDateVal(localDate, value)) {\n          addClass([tdEle], SELECTED);\n        }\n        this.updateFocus(otherMnthBool, disabledCls, localDate, tdEle, currentDate);\n        if (date.getFullYear() === todayDate.getFullYear() && date.getMonth() === todayDate.getMonth() && date.getDate() === todayDate.getDate()) {\n          addClass([tdEle], TODAY);\n        }\n        tdEles.push(this.renderDayCellArgs.element);\n        localDate = new Date(+minMaxDate);\n        this.addDay(localDate, 1, null, this.max, this.min);\n      }\n      return tdEles;\n    }\n    updateFocus(otherMonth, disabled, localDate, tableElement, currentDate) {\n      if (currentDate.getDate() === localDate.getDate() && !otherMonth && !disabled) {\n        addClass([tableElement], FOCUSEDDATE);\n      } else {\n        // eslint-disable-next-line radix\n        if (currentDate >= this.max && parseInt(tableElement.id, 0) === +this.max && !otherMonth && !disabled) {\n          addClass([tableElement], FOCUSEDDATE);\n        }\n        // eslint-disable-next-line radix\n        if (currentDate <= this.min && parseInt(tableElement.id, 0) === +this.min && !otherMonth && !disabled) {\n          addClass([tableElement], FOCUSEDDATE);\n        }\n      }\n    }\n    renderYears(e, value) {\n      this.removeTableHeadElement();\n      const numCells = 4;\n      const tdEles = [];\n      const valueUtil = isNullOrUndefined(value);\n      const curDate = new Date(this.checkValue(this.currentDate));\n      const mon = curDate.getMonth();\n      const yr = curDate.getFullYear();\n      const localDate = curDate;\n      const curYrs = localDate.getFullYear();\n      const minYr = new Date(this.checkValue(this.min)).getFullYear();\n      const minMonth = new Date(this.checkValue(this.min)).getMonth();\n      const maxYr = new Date(this.checkValue(this.max)).getFullYear();\n      const maxMonth = new Date(this.checkValue(this.max)).getMonth();\n      localDate.setMonth(0);\n      this.titleUpdate(this.currentDate, 'months');\n      localDate.setDate(1);\n      for (let month = 0; month < 12; ++month) {\n        const tdEle = this.dayCell(localDate);\n        const dayLink = this.createElement('span');\n        const localMonth = value && value.getMonth() === localDate.getMonth();\n        const select$$1 = value && value.getFullYear() === yr && localMonth;\n        dayLink.textContent = this.toCapitalize(this.globalize.formatDate(localDate, {\n          format: null,\n          type: 'dateTime',\n          skeleton: 'MMM'\n        }));\n        if (this.min && (curYrs < minYr || month < minMonth && curYrs === minYr) || this.max && (curYrs > maxYr || month > maxMonth && curYrs >= maxYr)) {\n          addClass([tdEle], DISABLED);\n        } else if (!valueUtil && select$$1) {\n          addClass([tdEle], SELECTED);\n        } else {\n          if (localDate.getMonth() === mon && this.currentDate.getMonth() === mon) {\n            addClass([tdEle], FOCUSEDDATE);\n          }\n        }\n        localDate.setDate(1);\n        localDate.setMonth(localDate.getMonth() + 1);\n        if (!tdEle.classList.contains(DISABLED)) {\n          EventHandler.add(tdEle, 'click', this.clickHandler, this);\n        }\n        tdEle.appendChild(dayLink);\n        tdEles.push(tdEle);\n      }\n      this.renderTemplate(tdEles, numCells, YEAR, e, value);\n    }\n    renderDecades(e, value) {\n      this.removeTableHeadElement();\n      const numCells = 4;\n      const yearCell = 12;\n      const tdEles = [];\n      const localDate = new Date(this.checkValue(this.currentDate));\n      localDate.setMonth(0);\n      localDate.setDate(1);\n      const localYr = localDate.getFullYear();\n      const startYr = new Date(localDate.setFullYear(localYr - localYr % 10));\n      const endYr = new Date(localDate.setFullYear(localYr - localYr % 10 + (10 - 1)));\n      const startFullYr = startYr.getFullYear();\n      const endFullYr = endYr.getFullYear();\n      const startHdrYr = this.globalize.formatDate(startYr, {\n        format: null,\n        type: 'dateTime',\n        skeleton: 'y'\n      });\n      const endHdrYr = this.globalize.formatDate(endYr, {\n        format: null,\n        type: 'dateTime',\n        skeleton: 'y'\n      });\n      this.headerTitleElement.textContent = startHdrYr + ' - ' + endHdrYr;\n      const start = new Date(localYr - localYr % 10 - 1, 0, 1);\n      const startYear = start.getFullYear();\n      for (let rowIterator = 0; rowIterator < yearCell; ++rowIterator) {\n        const year = startYear + rowIterator;\n        localDate.setFullYear(year);\n        const tdEle = this.dayCell(localDate);\n        attributes(tdEle, {\n          'role': 'gridcell'\n        });\n        const dayLink = this.createElement('span');\n        dayLink.textContent = this.globalize.formatDate(localDate, {\n          format: null,\n          type: 'dateTime',\n          skeleton: 'y'\n        });\n        if (year < startFullYr || year > endFullYr) {\n          addClass([tdEle], OTHERDECADE);\n          if (!isNullOrUndefined(value) && localDate.getFullYear() === value.getFullYear()) {\n            addClass([tdEle], SELECTED);\n          }\n          if (year < new Date(this.checkValue(this.min)).getFullYear() || year > new Date(this.checkValue(this.max)).getFullYear()) {\n            addClass([tdEle], DISABLED);\n          }\n        } else if (year < new Date(this.checkValue(this.min)).getFullYear() || year > new Date(this.checkValue(this.max)).getFullYear()) {\n          addClass([tdEle], DISABLED);\n        } else if (!isNullOrUndefined(value) && localDate.getFullYear() === value.getFullYear()) {\n          addClass([tdEle], SELECTED);\n        } else {\n          if (localDate.getFullYear() === this.currentDate.getFullYear() && !tdEle.classList.contains(DISABLED)) {\n            addClass([tdEle], FOCUSEDDATE);\n          }\n        }\n        if (!tdEle.classList.contains(DISABLED)) {\n          EventHandler.add(tdEle, 'click', this.clickHandler, this);\n        }\n        tdEle.appendChild(dayLink);\n        tdEles.push(tdEle);\n      }\n      this.renderTemplate(tdEles, numCells, 'e-decade', e, value);\n    }\n    dayCell(localDate) {\n      const type = this.calendarMode === 'Gregorian' ? 'gregorian' : 'islamic';\n      const dateFormatOptions = {\n        skeleton: 'full',\n        type: 'dateTime',\n        calendar: type\n      };\n      const date = this.globalize.parseDate(this.globalize.formatDate(localDate, dateFormatOptions), dateFormatOptions);\n      const value = date.valueOf();\n      const attrs = {\n        className: CELL,\n        attrs: {\n          'id': '' + getUniqueID('' + value),\n          'aria-selected': 'false',\n          'role': 'gridcell'\n        }\n      };\n      return this.createElement('td', attrs);\n    }\n    firstDay(date) {\n      const collection = this.currentView() !== 'Decade' ? this.tableBodyElement.querySelectorAll('td' + ':not(.' + OTHERMONTH + '') : this.tableBodyElement.querySelectorAll('td' + ':not(.' + OTHERDECADE + '');\n      if (collection.length) {\n        for (let i = 0; i < collection.length; i++) {\n          if (!collection[i].classList.contains(DISABLED)) {\n            // eslint-disable-next-line radix\n            date = new Date(parseInt(collection[i].id, 0));\n            break;\n          }\n        }\n      }\n      return date;\n    }\n    lastDay(date, view) {\n      const lastDate = new Date(date.getFullYear(), date.getMonth() + 1, 0);\n      if (view !== 2) {\n        const timeOffset = Math.abs(lastDate.getTimezoneOffset() - this.firstDay(date).getTimezoneOffset());\n        if (timeOffset) {\n          lastDate.setHours(this.firstDay(date).getHours() + timeOffset / 60);\n        }\n        return this.findLastDay(lastDate);\n      } else {\n        return this.findLastDay(this.firstDay(lastDate));\n      }\n    }\n    checkDateValue(value) {\n      return !isNullOrUndefined(value) && value instanceof Date && !isNaN(+value) ? value : null;\n    }\n    findLastDay(date) {\n      const collection = this.currentView() === 'Decade' ? this.tableBodyElement.querySelectorAll('td' + ':not(.' + OTHERDECADE + '') : this.tableBodyElement.querySelectorAll('td' + ':not(.' + OTHERMONTH + '');\n      if (collection.length) {\n        for (let i = collection.length - 1; i >= 0; i--) {\n          if (!collection[i].classList.contains(DISABLED)) {\n            // eslint-disable-next-line radix\n            date = new Date(parseInt(collection[i].id, 0));\n            break;\n          }\n        }\n      }\n      return date;\n    }\n    removeTableHeadElement() {\n      if (this.getModuleName() === 'calendar') {\n        if (!isNullOrUndefined(this.element.querySelectorAll('.e-content table thead')[0])) {\n          detach(this.tableHeadElement);\n        }\n      } else {\n        if (!isNullOrUndefined(this.calendarElement.querySelectorAll('.e-content table thead')[0])) {\n          detach(this.tableHeadElement);\n        }\n      }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    renderTemplate(elements, count, classNm, e, value) {\n      const view = this.getViewNumber(this.currentView());\n      let trEle;\n      this.tableBodyElement = this.createElement('tbody');\n      this.table.appendChild(this.tableBodyElement);\n      removeClass([this.contentElement, this.headerElement], [MONTH, DECADE, YEAR]);\n      addClass([this.contentElement, this.headerElement], [classNm]);\n      const weekNumCell = 41;\n      const numberCell = 35;\n      const otherMonthCell = 6;\n      let row = count;\n      let rowIterator = 0;\n      for (let dayCell = 0; dayCell < elements.length / count; ++dayCell) {\n        trEle = this.createElement('tr', {\n          attrs: {\n            'role': 'row'\n          }\n        });\n        for (rowIterator = 0 + rowIterator; rowIterator < row; rowIterator++) {\n          if (!elements[rowIterator].classList.contains('e-week-number') && !isNullOrUndefined(elements[rowIterator].children[0])) {\n            addClass([elements[rowIterator].children[0]], [LINK]);\n            rippleEffect(elements[rowIterator].children[0], {\n              duration: 600,\n              isCenterRipple: true\n            });\n          }\n          trEle.appendChild(elements[rowIterator]);\n          if (this.weekNumber && rowIterator === otherMonthCell + 1 && elements[otherMonthCell + 1].classList.contains(OTHERMONTH)) {\n            addClass([trEle], OTHERMONTHROW);\n          }\n          if (!this.weekNumber && rowIterator === otherMonthCell && elements[otherMonthCell].classList.contains(OTHERMONTH)) {\n            addClass([trEle], OTHERMONTHROW);\n          }\n          if (this.weekNumber) {\n            if (rowIterator === weekNumCell && elements[weekNumCell].classList.contains(OTHERMONTH)) {\n              addClass([trEle], OTHERMONTHROW);\n            }\n          } else {\n            if (rowIterator === numberCell && elements[numberCell].classList.contains(OTHERMONTH)) {\n              addClass([trEle], OTHERMONTHROW);\n            }\n          }\n        }\n        row = row + count;\n        rowIterator = rowIterator + 0;\n        this.tableBodyElement.appendChild(trEle);\n      }\n      this.table.querySelector('tbody').className = this.effect;\n      if (this.calendarMode === 'Gregorian') {\n        this.iconHandler();\n      } else {\n        this.islamicModule.islamicIconHandler();\n      }\n      if (view !== this.getViewNumber(this.currentView()) || view === 0 && view !== this.getViewNumber(this.currentView())) {\n        this.navigateHandler(e);\n      }\n      this.setAriaActiveDescendant();\n    }\n    clickHandler(e, value) {\n      this.clickEventEmitter(e);\n      const eve = e.currentTarget;\n      const view = this.getViewNumber(this.currentView());\n      if (eve.classList.contains(OTHERMONTH)) {\n        this.contentClick(e, 0, null, value);\n      } else if (view === this.getViewNumber(this.depth) && this.getViewNumber(this.start) >= this.getViewNumber(this.depth)) {\n        this.contentClick(e, 1, null, value);\n      } else if (2 === view) {\n        this.contentClick(e, 1, null, value);\n      } else if (!eve.classList.contains(OTHERMONTH) && view === 0) {\n        this.selectDate(e, this.getIdValue(e, null), null);\n      } else {\n        this.contentClick(e, 0, eve, value);\n      }\n      if (this.getModuleName() === 'calendar') {\n        this.table.focus();\n      }\n    }\n    // Content click event handler required for extended components\n    clickEventEmitter(e) {\n      e.preventDefault();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    contentClick(e, view, element, value) {\n      const currentView = this.getViewNumber(this.currentView());\n      const d = this.getIdValue(e, element);\n      switch (view) {\n        case 0:\n          if (currentView === this.getViewNumber(this.depth) && this.getViewNumber(this.start) >= this.getViewNumber(this.depth)) {\n            detach(this.tableBodyElement);\n            this.currentDate = d;\n            this.effect = ZOOMIN;\n            this.renderMonths(e);\n          } else {\n            if (this.calendarMode === 'Gregorian') {\n              this.currentDate.setMonth(d.getMonth());\n              if (d.getMonth() > 0 && this.currentDate.getMonth() !== d.getMonth()) {\n                this.currentDate.setDate(0);\n              }\n              this.currentDate.setFullYear(d.getFullYear());\n            } else {\n              this.currentDate = d;\n            }\n            this.effect = ZOOMIN;\n            detach(this.tableBodyElement);\n            this.renderMonths(e);\n          }\n          break;\n        case 1:\n          if (currentView === this.getViewNumber(this.depth) && this.getViewNumber(this.start) >= this.getViewNumber(this.depth)) {\n            this.selectDate(e, d, null);\n          } else {\n            if (this.calendarMode === 'Gregorian') {\n              this.currentDate.setFullYear(d.getFullYear());\n            } else {\n              const islamicDate = this.islamicModule.getIslamicDate(d);\n              this.currentDate = this.islamicModule.toGregorian(islamicDate.year, islamicDate.month, 1);\n            }\n            this.effect = ZOOMIN;\n            detach(this.tableBodyElement);\n            this.renderYears(e);\n          }\n      }\n    }\n    switchView(view, e, multiSelection, isCustomDate) {\n      switch (view) {\n        case 0:\n          detach(this.tableBodyElement);\n          this.renderMonths(e, null, isCustomDate);\n          if (multiSelection && !isNullOrUndefined(this.tableBodyElement.querySelectorAll('.' + FOCUSEDDATE)[0])) {\n            this.tableBodyElement.querySelectorAll('.' + FOCUSEDDATE)[0].classList.remove(FOCUSEDDATE);\n          }\n          break;\n        case 1:\n          detach(this.tableBodyElement);\n          this.renderYears(e);\n          break;\n        case 2:\n          detach(this.tableBodyElement);\n          this.renderDecades(e);\n      }\n    }\n    /**\n     * To get component name\n     *\n     * @returns {string} Returns the component name.\n     * @private\n     */\n    getModuleName() {\n      return 'calendar';\n    }\n    /**\n     *\n     * @returns {void}\n     * @deprecated\n     */\n    requiredModules() {\n      const modules = [];\n      if (this) {\n        modules.push({\n          args: [this],\n          member: 'islamic'\n        });\n      }\n      return modules;\n    }\n    /* eslint-disable valid-jsdoc, jsdoc/require-returns-description */\n    /**\n     * Gets the properties to be maintained upon browser refresh.\n     *\n     * @returns {string}\n     */\n    getPersistData() {\n      const keyEntity = ['value'];\n      return this.addOnPersist(keyEntity);\n    }\n    /* eslint-enable valid-jsdoc, jsdoc/require-returns-description */\n    /**\n     * Called internally if any of the property value changed.\n     *\n     * @param {CalendarBaseModel} newProp - Returns the dynamic property value of the component.\n     * @param {CalendarBaseModel} oldProp - Returns the previous property value of the component.\n     * @param {boolean} multiSelection - - Specifies whether multiple date selection is enabled or not.\n     * @param {Date[]} values - Specifies the dates.\n     * @returns {void}\n     * @private\n     */\n    onPropertyChanged(newProp, oldProp, multiSelection, values) {\n      this.effect = '';\n      for (const prop of Object.keys(newProp)) {\n        switch (prop) {\n          case 'enableRtl':\n            if (newProp.enableRtl) {\n              if (this.getModuleName() === 'calendar') {\n                this.element.classList.add('e-rtl');\n              } else {\n                this.calendarElement.classList.add('e-rtl');\n              }\n            } else {\n              if (this.getModuleName() === 'calendar') {\n                this.element.classList.remove('e-rtl');\n              } else {\n                this.calendarElement.classList.remove('e-rtl');\n              }\n            }\n            break;\n          case 'dayHeaderFormat':\n            this.getCultureValues();\n            if (this.getModuleName() !== 'datepicker') {\n              this.createContentHeader();\n            } else if (this.calendarElement) {\n              this.createContentHeader();\n            }\n            this.adjustLongHeaderSize();\n            break;\n          case 'min':\n          case 'max':\n            this.rangeValidation(this.min, this.max);\n            if (prop === 'min') {\n              this.setProperties({\n                min: this.checkDateValue(new Date(this.checkValue(newProp.min)))\n              }, true);\n            } else {\n              this.setProperties({\n                max: this.checkDateValue(new Date(this.checkValue(newProp.max)))\n              }, true);\n            }\n            this.setProperties({\n              start: this.currentView()\n            }, true);\n            if (this.tableBodyElement) {\n              detach(this.tableBodyElement);\n            }\n            this.minMaxUpdate();\n            if (multiSelection) {\n              this.validateValues(multiSelection, values);\n            }\n            if (this.getModuleName() !== 'datepicker') {\n              this.createContentBody();\n            } else if (this.calendarElement) {\n              this.createContentBody();\n            }\n            if ((this.todayDate < this.min || this.max < this.todayDate) && this.footer && this.todayElement) {\n              detach(this.todayElement);\n              detach(this.footer);\n              this.todayElement = this.footer = null;\n              this.createContentFooter();\n            } else {\n              if (this.footer && this.todayElement && this.todayElement.classList.contains('e-disabled')) {\n                removeClass([this.todayElement], DISABLED);\n                detach(this.todayElement);\n                detach(this.footer);\n                this.todayElement = this.footer = null;\n                this.createContentFooter();\n              }\n            }\n            break;\n          case 'start':\n          case 'depth':\n          case 'weekNumber':\n          case 'firstDayOfWeek':\n          case 'weekRule':\n            this.checkView();\n            if (this.getModuleName() !== 'datepicker') {\n              this.createContentHeader();\n              this.createContentBody();\n            } else if (this.calendarElement) {\n              this.createContentHeader();\n              this.createContentBody();\n            }\n            break;\n          case 'locale':\n            this.globalize = new Internationalization(this.locale);\n            if (this.getModuleName() !== 'datepicker') {\n              this.createContentHeader();\n              this.createContentBody();\n            } else if (this.calendarElement) {\n              this.createContentHeader();\n              this.createContentBody();\n            }\n            this.l10.setLocale(this.locale);\n            this.updateFooter();\n            break;\n          case 'showTodayButton':\n            if (newProp.showTodayButton) {\n              this.createContentFooter();\n            } else {\n              if (!isNullOrUndefined(this.todayElement) && !isNullOrUndefined(this.footer)) {\n                detach(this.todayElement);\n                detach(this.footer);\n                this.todayElement = this.footer = undefined;\n              }\n            }\n            this.setProperties({\n              showTodayButton: newProp.showTodayButton\n            }, true);\n            break;\n        }\n      }\n    }\n    /**\n     * values property updated with considered disabled dates of the calendar.\n     *\n     * @param {boolean} multiSelection - Specifies whether multiple date selection is enabled.\n     * @param {Date[]} values - Specifies the dates to validate.\n     * @returns {void}\n     */\n    validateValues(multiSelection, values) {\n      if (multiSelection && !isNullOrUndefined(values) && values.length > 0) {\n        const copyValues = this.copyValues(values);\n        for (let skipIndex = 0; skipIndex < copyValues.length; skipIndex++) {\n          const tempValue = copyValues[skipIndex];\n          const type = this.calendarMode === 'Gregorian' ? 'gregorian' : 'islamic';\n          let tempValueString;\n          if (this.calendarMode === 'Gregorian') {\n            tempValueString = this.globalize.formatDate(tempValue, {\n              type: 'date',\n              skeleton: 'yMd'\n            });\n          } else {\n            tempValueString = this.globalize.formatDate(tempValue, {\n              type: 'dateTime',\n              skeleton: 'full',\n              calendar: 'islamic'\n            });\n          }\n          const minFormatOption = {\n            type: 'date',\n            skeleton: 'yMd',\n            calendar: type\n          };\n          const minStringValue = this.globalize.formatDate(this.min, minFormatOption);\n          const minString = minStringValue;\n          const maxFormatOption = {\n            type: 'date',\n            skeleton: 'yMd',\n            calendar: type\n          };\n          const maxStringValue = this.globalize.formatDate(this.max, maxFormatOption);\n          const maxString = maxStringValue;\n          if (+new Date(tempValueString) < +new Date(minString) || +new Date(tempValueString) > +new Date(maxString)) {\n            copyValues.splice(skipIndex, 1);\n            skipIndex = -1;\n          }\n        }\n        this.setProperties({\n          values: copyValues\n        }, true);\n      }\n    }\n    setValueUpdate() {\n      if (!isNullOrUndefined(this.tableBodyElement)) {\n        detach(this.tableBodyElement);\n        this.setProperties({\n          start: this.currentView()\n        }, true);\n        this.createContentBody();\n      }\n    }\n    copyValues(values) {\n      const copyValues = [];\n      if (!isNullOrUndefined(values) && values.length > 0) {\n        for (let index = 0; index < values.length; index++) {\n          copyValues.push(new Date(+values[index]));\n        }\n      }\n      return copyValues;\n    }\n    titleUpdate(date, view) {\n      const globalize = new Internationalization(this.locale);\n      let dayFormatOptions;\n      let monthFormatOptions;\n      const type = this.calendarMode === 'Gregorian' ? 'gregorian' : 'islamic';\n      if (this.calendarMode === 'Gregorian') {\n        dayFormatOptions = globalize.formatDate(date, {\n          type: 'dateTime',\n          skeleton: 'yMMMM',\n          calendar: type\n        });\n        monthFormatOptions = globalize.formatDate(date, {\n          format: null,\n          type: 'dateTime',\n          skeleton: 'y',\n          calendar: type\n        });\n      } else {\n        dayFormatOptions = globalize.formatDate(date, {\n          type: 'dateTime',\n          format: 'MMMM y',\n          calendar: type\n        });\n        monthFormatOptions = globalize.formatDate(date, {\n          type: 'dateTime',\n          format: 'y',\n          calendar: type\n        });\n      }\n      switch (view) {\n        case 'days':\n          this.headerTitleElement.textContent = this.toCapitalize(dayFormatOptions);\n          break;\n        case 'months':\n          this.headerTitleElement.textContent = monthFormatOptions;\n      }\n    }\n    setActiveDescendant() {\n      let id;\n      const focusedEle = this.tableBodyElement.querySelector('tr td.e-focused-date');\n      const selectedEle = this.tableBodyElement.querySelector('tr td.e-selected');\n      const type = this.calendarMode === 'Gregorian' ? 'gregorian' : 'islamic';\n      let title;\n      const view = this.currentView();\n      if (view === 'Month') {\n        title = this.globalize.formatDate(this.currentDate, {\n          type: 'date',\n          skeleton: 'full',\n          calendar: type\n        });\n      } else if (view === 'Year') {\n        if (type !== 'islamic') {\n          title = this.globalize.formatDate(this.currentDate, {\n            type: 'date',\n            skeleton: 'yMMMM',\n            calendar: type\n          });\n        } else {\n          title = this.globalize.formatDate(this.currentDate, {\n            type: 'date',\n            skeleton: 'GyMMM',\n            calendar: type\n          });\n        }\n      } else {\n        title = this.globalize.formatDate(this.currentDate, {\n          format: null,\n          type: 'date',\n          skeleton: 'y',\n          calendar: type\n        });\n      }\n      if (selectedEle || focusedEle) {\n        if (!isNullOrUndefined(selectedEle)) {\n          selectedEle.setAttribute('aria-selected', 'true');\n        }\n        (focusedEle || selectedEle).setAttribute('aria-label', title);\n        id = (focusedEle || selectedEle).getAttribute('id');\n      }\n      return id;\n    }\n    iconHandler() {\n      new Date(this.checkValue(this.currentDate)).setDate(1);\n      switch (this.currentView()) {\n        case 'Month':\n          this.previousIconHandler(this.compareMonth(new Date(this.checkValue(this.currentDate)), this.min) < 1);\n          this.nextIconHandler(this.compareMonth(new Date(this.checkValue(this.currentDate)), this.max) > -1);\n          break;\n        case 'Year':\n          this.previousIconHandler(this.compareYear(new Date(this.checkValue(this.currentDate)), this.min) < 1);\n          this.nextIconHandler(this.compareYear(new Date(this.checkValue(this.currentDate)), this.max) > -1);\n          break;\n        case 'Decade':\n          this.previousIconHandler(this.compareDecade(new Date(this.checkValue(this.currentDate)), this.min) < 1);\n          this.nextIconHandler(this.compareDecade(new Date(this.checkValue(this.currentDate)), this.max) > -1);\n      }\n    }\n    /**\n     * Destroys the widget.\n     *\n     * @returns {void}\n     */\n    destroy() {\n      if (this.getModuleName() === 'calendar' && this.element) {\n        removeClass([this.element], [ROOT]);\n      } else {\n        if (this.calendarElement && this.element) {\n          removeClass([this.element], [ROOT]);\n        }\n      }\n      if (this.getModuleName() === 'calendar' && this.element) {\n        EventHandler.remove(this.headerTitleElement, 'click', this.navigateTitle);\n        if (this.todayElement) {\n          EventHandler.remove(this.todayElement, 'click', this.todayButtonClick);\n        }\n        this.previousIconHandler(true);\n        this.nextIconHandler(true);\n        this.keyboardModule.destroy();\n        this.element.removeAttribute('data-role');\n        if (!isNullOrUndefined(this.calendarEleCopy.getAttribute('tabindex'))) {\n          this.element.setAttribute('tabindex', this.tabIndex);\n        } else {\n          this.element.removeAttribute('tabindex');\n        }\n      }\n      if (this.element) {\n        this.element.innerHTML = '';\n      }\n      super.destroy();\n    }\n    title(e) {\n      let currentView = this.getViewNumber(this.currentView());\n      this.effect = ZOOMIN;\n      this.switchView(++currentView, e);\n    }\n    getViewNumber(stringVal) {\n      if (stringVal === 'Month') {\n        return 0;\n      } else if (stringVal === 'Year') {\n        return 1;\n      } else {\n        return 2;\n      }\n    }\n    navigateTitle(e) {\n      e.preventDefault();\n      this.title(e);\n      if (this.getModuleName() === 'calendar') {\n        this.table.focus();\n      }\n    }\n    previous() {\n      this.effect = '';\n      const currentView = this.getViewNumber(this.currentView());\n      switch (this.currentView()) {\n        case 'Month':\n          this.addMonths(this.currentDate, -1);\n          this.switchView(currentView);\n          break;\n        case 'Year':\n          this.addYears(this.currentDate, -1);\n          this.switchView(currentView);\n          break;\n        case 'Decade':\n          this.addYears(this.currentDate, -10);\n          this.switchView(currentView);\n          break;\n      }\n    }\n    navigatePrevious(e) {\n      e.preventDefault();\n      if (this.calendarMode === 'Gregorian') {\n        this.previous();\n      } else {\n        this.islamicModule.islamicPrevious();\n      }\n      this.triggerNavigate(e);\n      if (this.getModuleName() === 'calendar') {\n        this.table.focus();\n      }\n    }\n    next() {\n      this.effect = '';\n      const currentView = this.getViewNumber(this.currentView());\n      switch (this.currentView()) {\n        case 'Month':\n          this.addMonths(this.currentDate, 1);\n          this.switchView(currentView);\n          break;\n        case 'Year':\n          this.addYears(this.currentDate, 1);\n          this.switchView(currentView);\n          break;\n        case 'Decade':\n          this.addYears(this.currentDate, 10);\n          this.switchView(currentView);\n          break;\n      }\n    }\n    navigateNext(eve) {\n      eve.preventDefault();\n      if (this.calendarMode === 'Gregorian') {\n        this.next();\n      } else {\n        this.islamicModule.islamicNext();\n      }\n      this.triggerNavigate(eve);\n      if (this.getModuleName() === 'calendar') {\n        this.table.focus();\n      }\n    }\n    /**\n     * This method is used to navigate to the month/year/decade view of the Calendar.\n     *\n     * @param {string} view - Specifies the view of the Calendar.\n     * @param {Date} date - Specifies the focused date in a view.\n     * @param {boolean} isCustomDate - Specifies whether the calendar is rendered with custom today date or not.\n     * @returns {void}\n     */\n    navigateTo(view, date, isCustomDate) {\n      if (+date >= +this.min && +date <= +this.max) {\n        this.currentDate = date;\n      }\n      if (+date <= +this.min) {\n        this.currentDate = new Date(this.checkValue(this.min));\n      }\n      if (+date >= +this.max) {\n        this.currentDate = new Date(this.checkValue(this.max));\n      }\n      if (this.getViewNumber(this.depth) >= this.getViewNumber(view)) {\n        if (this.getViewNumber(this.depth) <= this.getViewNumber(this.start) || this.getViewNumber(this.depth) === this.getViewNumber(view)) {\n          view = this.depth;\n        }\n      }\n      this.switchView(this.getViewNumber(view), null, null, isCustomDate);\n    }\n    /* eslint-disable valid-jsdoc, jsdoc/require-returns-description */\n    /**\n     * Gets the current view of the Calendar.\n     *\n     * @returns {string}\n     */\n    currentView() {\n      if (this.contentElement.classList.contains(YEAR)) {\n        return 'Year';\n      } else if (this.contentElement.classList.contains(DECADE)) {\n        return 'Decade';\n      } else {\n        return 'Month';\n      }\n    }\n    /* eslint-enable valid-jsdoc, jsdoc/require-returns-description */\n    getDateVal(date, value) {\n      return !isNullOrUndefined(value) && date.getDate() === value.getDate() && date.getMonth() === value.getMonth() && date.getFullYear() === value.getFullYear();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    getCultureObjects(ld, c) {\n      const gregorianFormat = '.dates.calendars.gregorian.days.format.' + this.dayHeaderFormat.toLowerCase();\n      const islamicFormat = '.dates.calendars.islamic.days.format.' + this.dayHeaderFormat.toLowerCase();\n      const mainVal = 'main.';\n      if (this.calendarMode === 'Gregorian') {\n        return getValue(mainVal + '' + this.locale + gregorianFormat, ld);\n      } else {\n        return getValue('main.' + '' + this.locale + islamicFormat, ld);\n      }\n    }\n    getWeek(d) {\n      const currentDate = new Date(this.checkValue(d)).valueOf();\n      const date = new Date(d.getFullYear(), 0, 1).valueOf();\n      return Math.ceil((currentDate - date + dayMilliSeconds) / dayMilliSeconds / 7);\n    }\n    setStartDate(date, time) {\n      const tzOffset = date.getTimezoneOffset();\n      const d = new Date(date.getTime() + time);\n      const tzOffsetDiff = d.getTimezoneOffset() - tzOffset;\n      date.setTime(d.getTime() + tzOffsetDiff * minutesMilliSeconds);\n    }\n    addMonths(date, i) {\n      if (this.calendarMode === 'Gregorian') {\n        const day = date.getDate();\n        date.setDate(1);\n        date.setMonth(date.getMonth() + i);\n        date.setDate(Math.min(day, this.getMaxDays(date)));\n      } else {\n        const islamicDate = this.islamicModule.getIslamicDate(date);\n        this.currentDate = this.islamicModule.toGregorian(islamicDate.year, islamicDate.month + i, 1);\n      }\n    }\n    addYears(date, i) {\n      if (this.calendarMode === 'Gregorian') {\n        const day = date.getDate();\n        date.setDate(1);\n        date.setFullYear(date.getFullYear() + i);\n        date.setDate(Math.min(day, this.getMaxDays(date)));\n      } else {\n        const islamicDate = this.islamicModule.getIslamicDate(date);\n        this.currentDate = this.islamicModule.toGregorian(islamicDate.year + i, islamicDate.month, 1);\n      }\n    }\n    getIdValue(e, element) {\n      let eve;\n      if (e) {\n        eve = e.currentTarget;\n      } else {\n        eve = element;\n      }\n      const type = this.calendarMode === 'Gregorian' ? 'gregorian' : 'islamic';\n      const dateFormatOptions = {\n        type: 'dateTime',\n        skeleton: 'full',\n        calendar: type\n      };\n      // eslint-disable-next-line radix\n      const dateString = this.globalize.formatDate(new Date(parseInt('' + eve.getAttribute('id'), 0)), dateFormatOptions);\n      const date = this.globalize.parseDate(dateString, dateFormatOptions);\n      const value = date.valueOf() - date.valueOf() % 1000;\n      return new Date(value);\n      //return this.globalize.parseDate(dateString, dateFormatOptions);\n    }\n\n    adjustLongHeaderSize() {\n      removeClass([this.element], DAYHEADERLONG);\n      if (this.dayHeaderFormat === 'Wide') {\n        addClass([this.getModuleName() === 'calendar' ? this.element : this.calendarElement], DAYHEADERLONG);\n      }\n    }\n    selectDate(e, date, node, multiSelection, values) {\n      const element = node || e.currentTarget;\n      this.isDateSelected = false;\n      if (this.currentView() === 'Decade') {\n        this.setDateDecade(this.currentDate, date.getFullYear());\n      } else if (this.currentView() === 'Year') {\n        this.setDateYear(this.currentDate, date);\n      } else {\n        if (multiSelection && !this.checkPresentDate(date, values)) {\n          const copyValues = this.copyValues(values);\n          if (!isNullOrUndefined(values) && copyValues.length > 0) {\n            copyValues.push(new Date(this.checkValue(date)));\n            this.setProperties({\n              values: copyValues\n            }, true);\n            this.setProperties({\n              value: values[values.length - 1]\n            }, true);\n          } else {\n            this.setProperties({\n              values: [new Date(this.checkValue(date))]\n            }, true);\n          }\n        } else {\n          this.setProperties({\n            value: new Date(this.checkValue(date))\n          }, true);\n        }\n        this.currentDate = new Date(this.checkValue(date));\n      }\n      let tableBodyElement = closest(element, '.' + ROOT);\n      if (isNullOrUndefined(tableBodyElement)) {\n        tableBodyElement = this.tableBodyElement;\n      }\n      if (!multiSelection && !isNullOrUndefined(tableBodyElement.querySelector('.' + SELECTED))) {\n        removeClass([tableBodyElement.querySelector('.' + SELECTED)], SELECTED);\n      }\n      if (!multiSelection && !isNullOrUndefined(tableBodyElement.querySelector('.' + FOCUSEDDATE))) {\n        removeClass([tableBodyElement.querySelector('.' + FOCUSEDDATE)], FOCUSEDDATE);\n      }\n      if (multiSelection) {\n        const copyValues = this.copyValues(values);\n        const collection = Array.prototype.slice.call(this.tableBodyElement.querySelectorAll('td'));\n        for (let index = 0; index < collection.length; index++) {\n          const tempElement = tableBodyElement.querySelectorAll('td' + '.' + FOCUSEDDATE)[0];\n          const selectedElement = tableBodyElement.querySelectorAll('td' + '.' + SELECTED)[0];\n          if (collection[index] === tempElement) {\n            removeClass([collection[index]], FOCUSEDDATE);\n          }\n          if (collection[index] === selectedElement && !this.checkPresentDate(new Date(parseInt(selectedElement.getAttribute('id').split('_')[0], 10)), values)) {\n            removeClass([collection[index]], SELECTED);\n          }\n        }\n        if (element.classList.contains(SELECTED)) {\n          removeClass([element], SELECTED);\n          for (let i = 0; i < copyValues.length; i++) {\n            const type = this.calendarMode === 'Gregorian' ? 'gregorian' : 'islamic';\n            const formatOptions = {\n              format: null,\n              type: 'date',\n              skeleton: 'short',\n              calendar: type\n            };\n            const localDateString = this.globalize.formatDate(date, formatOptions);\n            const tempDateString = this.globalize.formatDate(copyValues[i], formatOptions);\n            if (localDateString === tempDateString) {\n              const index = copyValues.indexOf(copyValues[i]);\n              copyValues.splice(index, 1);\n              addClass([element], FOCUSEDDATE);\n            }\n          }\n          this.setProperties({\n            values: copyValues\n          }, true);\n        } else {\n          addClass([element], SELECTED);\n        }\n      } else {\n        addClass([element], SELECTED);\n      }\n      this.isDateSelected = true;\n    }\n    checkPresentDate(dates, values) {\n      let previousValue = false;\n      if (!isNullOrUndefined(values)) {\n        for (let checkPrevious = 0; checkPrevious < values.length; checkPrevious++) {\n          const type = this.calendarMode === 'Gregorian' ? 'gregorian' : 'islamic';\n          const localDateString = this.globalize.formatDate(dates, {\n            format: null,\n            type: 'date',\n            skeleton: 'short',\n            calendar: type\n          });\n          const tempDateString = this.globalize.formatDate(values[checkPrevious], {\n            format: null,\n            type: 'date',\n            skeleton: 'short',\n            calendar: type\n          });\n          if (localDateString === tempDateString) {\n            previousValue = true;\n          }\n        }\n      }\n      return previousValue;\n    }\n    setAriaActiveDescendant() {\n      attributes(this.table, {\n        'aria-activedescendant': '' + this.setActiveDescendant()\n      });\n    }\n    previousIconHandler(disabled) {\n      if (disabled) {\n        EventHandler.remove(this.previousIcon, 'click', this.navigatePreviousHandler);\n        addClass([this.previousIcon], '' + DISABLED);\n        addClass([this.previousIcon], '' + OVERLAY);\n        this.previousIcon.setAttribute('aria-disabled', 'true');\n      } else {\n        EventHandler.add(this.previousIcon, 'click', this.navigatePreviousHandler);\n        removeClass([this.previousIcon], '' + DISABLED);\n        removeClass([this.previousIcon], '' + OVERLAY);\n        this.previousIcon.setAttribute('aria-disabled', 'false');\n      }\n    }\n    renderDayCellEvent(args) {\n      extend(this.renderDayCellArgs, {\n        name: 'renderDayCell'\n      });\n      this.trigger('renderDayCell', args);\n    }\n    navigatedEvent(eve) {\n      extend(this.navigatedArgs, {\n        name: 'navigated',\n        event: eve\n      });\n      this.trigger('navigated', this.navigatedArgs);\n    }\n    triggerNavigate(event) {\n      this.navigatedArgs = {\n        view: this.currentView(),\n        date: this.currentDate\n      };\n      this.navigatedEvent(event);\n    }\n    nextIconHandler(disabled) {\n      if (disabled) {\n        EventHandler.remove(this.nextIcon, 'click', this.navigateNextHandler);\n        addClass([this.nextIcon], DISABLED);\n        addClass([this.nextIcon], OVERLAY);\n        this.nextIcon.setAttribute('aria-disabled', 'true');\n      } else {\n        EventHandler.add(this.nextIcon, 'click', this.navigateNextHandler);\n        removeClass([this.nextIcon], DISABLED);\n        removeClass([this.nextIcon], OVERLAY);\n        this.nextIcon.setAttribute('aria-disabled', 'false');\n      }\n    }\n    compare(startDate, endDate, modifier) {\n      let start = endDate.getFullYear();\n      let end;\n      let result;\n      end = start;\n      result = 0;\n      if (modifier) {\n        start = start - start % modifier;\n        end = start - start % modifier + modifier - 1;\n      }\n      if (startDate.getFullYear() > end) {\n        result = 1;\n      } else if (startDate.getFullYear() < start) {\n        result = -1;\n      }\n      return result;\n    }\n    isMinMaxRange(date) {\n      return +date >= +this.min && +date <= +this.max;\n    }\n    isMonthYearRange(date) {\n      if (this.calendarMode === 'Gregorian') {\n        return date.getMonth() >= this.min.getMonth() && date.getFullYear() >= this.min.getFullYear() && date.getMonth() <= this.max.getMonth() && date.getFullYear() <= this.max.getFullYear();\n      } else {\n        const islamicDate = this.islamicModule.getIslamicDate(date);\n        return islamicDate.month >= this.islamicModule.getIslamicDate(new Date(1944, 1, 18)).month && islamicDate.year >= this.islamicModule.getIslamicDate(new Date(1944, 1, 18)).year && islamicDate.month <= this.islamicModule.getIslamicDate(new Date(2069, 1, 16)).month && islamicDate.year <= this.islamicModule.getIslamicDate(new Date(2069, 1, 16)).year;\n      }\n    }\n    compareYear(start, end) {\n      return this.compare(start, end, 0);\n    }\n    compareDecade(start, end) {\n      return this.compare(start, end, 10);\n    }\n    shiftArray(array, i) {\n      return array.slice(i).concat(array.slice(0, i));\n    }\n    addDay(date, i, e, max, min) {\n      let column = i;\n      const value = new Date(+date);\n      if (!isNullOrUndefined(this.tableBodyElement) && !isNullOrUndefined(e)) {\n        while (this.findNextTD(new Date(+date), column, max, min)) {\n          column += i;\n        }\n        const rangeValue = new Date(value.setDate(value.getDate() + column));\n        column = +rangeValue > +max || +rangeValue < +min ? column === i ? i - i : i : column;\n      }\n      date.setDate(date.getDate() + column);\n    }\n    findNextTD(date, column, max, min) {\n      const value = new Date(date.setDate(date.getDate() + column));\n      let collection = [];\n      let isDisabled = false;\n      if ((!isNullOrUndefined(value) && value.getMonth()) === (!isNullOrUndefined(this.currentDate) && this.currentDate.getMonth())) {\n        let tdEles;\n        if (this.calendarMode === 'Gregorian') {\n          tdEles = this.renderDays(value);\n        } else {\n          tdEles = this.islamicModule.islamicRenderDays(this.currentDate, value);\n        }\n        collection = tdEles.filter(element => {\n          return element.classList.contains(DISABLED);\n        });\n      } else {\n        collection = this.tableBodyElement.querySelectorAll('td.' + DISABLED);\n      }\n      if (+value <= +max && +value >= +min) {\n        if (collection.length) {\n          for (let i = 0; i < collection.length; i++) {\n            // eslint-disable-next-line radix\n            isDisabled = +value === +new Date(parseInt(collection[i].id, 0)) ? true : false;\n            if (isDisabled) {\n              break;\n            }\n          }\n        }\n      }\n      return isDisabled;\n    }\n    getMaxDays(d) {\n      let date;\n      const tmpDate = new Date(this.checkValue(d));\n      date = 28;\n      const month = tmpDate.getMonth();\n      while (tmpDate.getMonth() === month) {\n        ++date;\n        tmpDate.setDate(date);\n      }\n      return date - 1;\n    }\n    setDateDecade(date, year) {\n      date.setFullYear(year);\n      this.setProperties({\n        value: new Date(this.checkValue(date))\n      }, true);\n    }\n    setDateYear(date, value) {\n      date.setFullYear(value.getFullYear(), value.getMonth(), date.getDate());\n      if (value.getMonth() !== date.getMonth()) {\n        date.setDate(0);\n        this.currentDate = new Date(this.checkValue(value));\n      }\n      this.setProperties({\n        value: new Date(this.checkValue(date))\n      }, true);\n    }\n    compareMonth(start, end) {\n      let result;\n      if (start.getFullYear() > end.getFullYear()) {\n        result = 1;\n      } else if (start.getFullYear() < end.getFullYear()) {\n        result = -1;\n      } else {\n        result = start.getMonth() === end.getMonth() ? 0 : start.getMonth() > end.getMonth() ? 1 : -1;\n      }\n      return result;\n    }\n    checkValue(inValue) {\n      if (inValue instanceof Date) {\n        return inValue.toUTCString();\n      } else {\n        return '' + inValue;\n      }\n    }\n    checkView() {\n      if (this.start !== 'Decade' && this.start !== 'Year') {\n        this.setProperties({\n          start: 'Month'\n        }, true);\n      }\n      if (this.depth !== 'Decade' && this.depth !== 'Year') {\n        this.setProperties({\n          depth: 'Month'\n        }, true);\n      }\n      if (this.getViewNumber(this.depth) > this.getViewNumber(this.start)) {\n        this.setProperties({\n          depth: 'Month'\n        }, true);\n      }\n    }\n    getDate(date, timezone) {\n      if (timezone) {\n        date = new Date(date.toLocaleString('en-US', {\n          timeZone: timezone\n        }));\n      }\n      return date;\n    }\n  };\n  __decorate([Property(new Date(1900, 0, 1))], CalendarBase.prototype, \"min\", void 0);\n  __decorate([Property(true)], CalendarBase.prototype, \"enabled\", void 0);\n  __decorate([Property(null)], CalendarBase.prototype, \"cssClass\", void 0);\n  __decorate([Property(new Date(2099, 11, 31))], CalendarBase.prototype, \"max\", void 0);\n  __decorate([Property(null)], CalendarBase.prototype, \"firstDayOfWeek\", void 0);\n  __decorate([Property('Gregorian')], CalendarBase.prototype, \"calendarMode\", void 0);\n  __decorate([Property('Month')], CalendarBase.prototype, \"start\", void 0);\n  __decorate([Property('Month')], CalendarBase.prototype, \"depth\", void 0);\n  __decorate([Property(false)], CalendarBase.prototype, \"weekNumber\", void 0);\n  __decorate([Property('FirstDay')], CalendarBase.prototype, \"weekRule\", void 0);\n  __decorate([Property(true)], CalendarBase.prototype, \"showTodayButton\", void 0);\n  __decorate([Property('Short')], CalendarBase.prototype, \"dayHeaderFormat\", void 0);\n  __decorate([Property(false)], CalendarBase.prototype, \"enablePersistence\", void 0);\n  __decorate([Property(null)], CalendarBase.prototype, \"keyConfigs\", void 0);\n  __decorate([Property(null)], CalendarBase.prototype, \"serverTimezoneOffset\", void 0);\n  __decorate([Event()], CalendarBase.prototype, \"created\", void 0);\n  __decorate([Event()], CalendarBase.prototype, \"destroyed\", void 0);\n  __decorate([Event()], CalendarBase.prototype, \"navigated\", void 0);\n  __decorate([Event()], CalendarBase.prototype, \"renderDayCell\", void 0);\n  CalendarBase = __decorate([NotifyPropertyChanges], CalendarBase);\n  /**\n   * Represents the Calendar component that allows the user to select a date.\n   * ```html\n   * <div id=\"calendar\"/>\n   * ```\n   * ```typescript\n   * <script>\n   *   var calendarObj = new Calendar({ value: new Date() });\n   *   calendarObj.appendTo(\"#calendar\");\n   * </script>\n   * ```\n   */\n  return CalendarBase;\n})();\nlet Calendar = /*#__PURE__*/(() => {\n  let Calendar = class Calendar extends CalendarBase {\n    /**\n     * Initialized new instance of Calendar Class.\n     * Constructor for creating the widget\n     *\n     * @param {CalendarModel} options - Specifies the Calendar model.\n     * @param {string | HTMLElement} element - Specifies the element to render as component.\n     * @private\n     */\n    constructor(options, element) {\n      super(options, element);\n    }\n    /**\n     * To Initialize the control rendering.\n     *\n     * @returns {void}\n     * @private\n     */\n    render() {\n      if (this.calendarMode === 'Islamic' && this.islamicModule === undefined) {\n        throwError('Requires the injectable Islamic modules to render Calendar in Islamic mode');\n      }\n      if (this.isMultiSelection && typeof this.values === 'object' && !isNullOrUndefined(this.values) && this.values.length > 0) {\n        const tempValues = [];\n        const copyValues = [];\n        for (let limit = 0; limit < this.values.length; limit++) {\n          if (tempValues.indexOf(+this.values[limit]) === -1) {\n            tempValues.push(+this.values[limit]);\n            copyValues.push(this.values[limit]);\n          }\n        }\n        this.setProperties({\n          values: copyValues\n        }, true);\n        for (let index = 0; index < this.values.length; index++) {\n          if (!this.checkDateValue(this.values[index])) {\n            if (typeof this.values[index] === 'string' && this.checkDateValue(new Date(this.checkValue(this.values[index])))) {\n              const copyDate = new Date(this.checkValue(this.values[index]));\n              this.values.splice(index, 1);\n              this.values.splice(index, 0, copyDate);\n            } else {\n              this.values.splice(index, 1);\n            }\n          }\n        }\n        this.setProperties({\n          value: this.values[this.values.length - 1]\n        }, true);\n        this.previousValues = this.values.length;\n      }\n      this.validateDate();\n      this.minMaxUpdate();\n      if (this.getModuleName() === 'calendar') {\n        this.setEnable(this.enabled);\n        this.setClass(this.cssClass);\n      }\n      super.render();\n      if (this.getModuleName() === 'calendar') {\n        const form = closest(this.element, 'form');\n        if (form) {\n          EventHandler.add(form, 'reset', this.formResetHandler.bind(this));\n        }\n        this.setTimeZone(this.serverTimezoneOffset);\n      }\n      this.renderComplete();\n    }\n    setEnable(enable) {\n      if (!enable) {\n        addClass([this.element], DISABLED);\n      } else {\n        removeClass([this.element], DISABLED);\n      }\n    }\n    setClass(newCssClass, oldCssClass) {\n      if (!isNullOrUndefined(oldCssClass)) {\n        oldCssClass = oldCssClass.replace(/\\s+/g, ' ').trim();\n      }\n      if (!isNullOrUndefined(newCssClass)) {\n        newCssClass = newCssClass.replace(/\\s+/g, ' ').trim();\n      }\n      if (!isNullOrUndefined(oldCssClass) && oldCssClass !== '') {\n        removeClass([this.element], oldCssClass.split(' '));\n      }\n      if (!isNullOrUndefined(newCssClass)) {\n        addClass([this.element], newCssClass.split(' '));\n      }\n    }\n    isDayLightSaving() {\n      const secondOffset = new Date(this.value.getFullYear(), 6, 1).getTimezoneOffset();\n      const firstOffset = new Date(this.value.getFullYear(), 0, 1).getTimezoneOffset();\n      return this.value.getTimezoneOffset() < Math.max(firstOffset, secondOffset);\n    }\n    setTimeZone(offsetValue) {\n      if (!isNullOrUndefined(this.serverTimezoneOffset) && this.value) {\n        const serverTimezoneDiff = offsetValue;\n        const clientTimeZoneDiff = new Date().getTimezoneOffset() / 60;\n        let timeZoneDiff = serverTimezoneDiff + clientTimeZoneDiff;\n        timeZoneDiff = this.isDayLightSaving() ? timeZoneDiff-- : timeZoneDiff;\n        this.value = new Date(this.value.getTime() + timeZoneDiff * 60 * 60 * 1000);\n      }\n    }\n    formResetHandler() {\n      this.setProperties({\n        value: null\n      }, true);\n    }\n    validateDate() {\n      if (typeof this.value === 'string') {\n        this.setProperties({\n          value: this.checkDateValue(new Date(this.checkValue(this.value)))\n        }, true); // persist the value property.\n      }\n\n      super.validateDate(this.value);\n      if (!isNullOrUndefined(this.value) && this.min <= this.max && this.value >= this.min && this.value <= this.max) {\n        this.currentDate = new Date(this.checkValue(this.value));\n      }\n      if (isNaN(+this.value)) {\n        this.setProperties({\n          value: null\n        }, true);\n      }\n    }\n    minMaxUpdate() {\n      if (this.getModuleName() === 'calendar') {\n        if (!isNullOrUndefined(this.value) && this.value <= this.min && this.min <= this.max) {\n          this.setProperties({\n            value: this.min\n          }, true);\n          this.changedArgs = {\n            value: this.value\n          };\n        } else {\n          if (!isNullOrUndefined(this.value) && this.value >= this.max && this.min <= this.max) {\n            this.setProperties({\n              value: this.max\n            }, true);\n            this.changedArgs = {\n              value: this.value\n            };\n          }\n        }\n      }\n      if (this.getModuleName() !== 'calendar' && !isNullOrUndefined(this.value)) {\n        if (!isNullOrUndefined(this.value) && this.value < this.min && this.min <= this.max) {\n          super.minMaxUpdate(this.min);\n        } else {\n          if (!isNullOrUndefined(this.value) && this.value > this.max && this.min <= this.max) {\n            super.minMaxUpdate(this.max);\n          }\n        }\n      } else {\n        super.minMaxUpdate(this.value);\n      }\n    }\n    generateTodayVal(value) {\n      let tempValue = new Date();\n      if (!isNullOrUndefined(this.timezone)) {\n        tempValue = super.getDate(tempValue, this.timezone);\n      }\n      if (value && isNullOrUndefined(this.timezone)) {\n        tempValue.setHours(value.getHours());\n        tempValue.setMinutes(value.getMinutes());\n        tempValue.setSeconds(value.getSeconds());\n        tempValue.setMilliseconds(value.getMilliseconds());\n      } else {\n        tempValue = new Date(tempValue.getFullYear(), tempValue.getMonth(), tempValue.getDate(), 0, 0, 0, 0);\n      }\n      return tempValue;\n    }\n    todayButtonClick(e) {\n      if (this.showTodayButton) {\n        const tempValue = this.generateTodayVal(this.value);\n        this.setProperties({\n          value: tempValue\n        }, true);\n        this.isTodayClicked = true;\n        this.todayButtonEvent = e;\n        if (this.isMultiSelection) {\n          const copyValues = this.copyValues(this.values);\n          if (!super.checkPresentDate(tempValue, this.values)) {\n            copyValues.push(tempValue);\n            this.setProperties({\n              values: copyValues\n            });\n          }\n        }\n        super.todayButtonClick(e, new Date(+this.value));\n      }\n    }\n    keyActionHandle(e) {\n      super.keyActionHandle(e, this.value, this.isMultiSelection);\n    }\n    /**\n     * Initialize the event handler\n     *\n     * @returns {void}\n     * @private\n     */\n    preRender() {\n      this.changeHandler = e => {\n        this.triggerChange(e);\n      };\n      this.checkView();\n      super.preRender(this.value);\n    }\n    /**\n     * @returns {void}\n     * @deprecated\n     */\n    createContent() {\n      this.previousDate = this.value;\n      this.previousDateTime = this.value;\n      super.createContent();\n    }\n    minMaxDate(localDate) {\n      return super.minMaxDate(localDate);\n    }\n    renderMonths(e, value, isCustomDate) {\n      super.renderMonths(e, this.value, isCustomDate);\n    }\n    renderDays(currentDate, value, isMultiSelect, values, isCustomDate) {\n      const tempDays = super.renderDays(currentDate, this.value, this.isMultiSelection, this.values, isCustomDate);\n      if (this.isMultiSelection) {\n        super.validateValues(this.isMultiSelection, this.values);\n      }\n      return tempDays;\n    }\n    renderYears(e) {\n      if (this.calendarMode === 'Gregorian') {\n        super.renderYears(e, this.value);\n      } else {\n        this.islamicModule.islamicRenderYears(e, this.value);\n      }\n    }\n    renderDecades(e) {\n      if (this.calendarMode === 'Gregorian') {\n        super.renderDecades(e, this.value);\n      } else {\n        this.islamicModule.islamicRenderDecade(e, this.value);\n      }\n    }\n    renderTemplate(elements, count, classNm, e) {\n      if (this.calendarMode === 'Gregorian') {\n        super.renderTemplate(elements, count, classNm, e, this.value);\n      } else {\n        this.islamicModule.islamicRenderTemplate(elements, count, classNm, e, this.value);\n      }\n      this.changedArgs = {\n        value: this.value,\n        values: this.values\n      };\n      this.changeHandler();\n    }\n    clickHandler(e) {\n      const eve = e.currentTarget;\n      this.isPopupClicked = true;\n      if (eve.classList.contains(OTHERMONTH)) {\n        if (this.isMultiSelection) {\n          const copyValues = this.copyValues(this.values);\n          copyValues.push(this.getIdValue(e, null));\n          this.setProperties({\n            values: copyValues\n          }, true);\n          this.setProperties({\n            value: this.values[this.values.length - 1]\n          }, true);\n        } else {\n          this.setProperties({\n            value: this.getIdValue(e, null)\n          }, true);\n        }\n      }\n      const storeView = this.currentView();\n      super.clickHandler(e, this.value);\n      if (this.isMultiSelection && this.currentDate !== this.value && !isNullOrUndefined(this.tableBodyElement.querySelectorAll('.' + FOCUSEDDATE)[0]) && storeView === 'Year') {\n        this.tableBodyElement.querySelectorAll('.' + FOCUSEDDATE)[0].classList.remove(FOCUSEDDATE);\n      }\n    }\n    switchView(view, e, isMultiSelection, isCustomDate) {\n      super.switchView(view, e, this.isMultiSelection, isCustomDate);\n    }\n    /**\n     * To get component name\n     *\n     * @returns {string} Return the component name.\n     * @private\n     */\n    getModuleName() {\n      super.getModuleName();\n      return 'calendar';\n    }\n    /* eslint-disable valid-jsdoc, jsdoc/require-returns-description */\n    /**\n     * Gets the properties to be maintained upon browser refresh.\n     *\n     * @returns {string}\n     */\n    getPersistData() {\n      super.getPersistData();\n      const keyEntity = ['value', 'values'];\n      return this.addOnPersist(keyEntity);\n    }\n    /* eslint-enable valid-jsdoc, jsdoc/require-returns-description */\n    /**\n     * Called internally if any of the property value changed.\n     *\n     * @param {CalendarModel} newProp - Returns the dynamic property value of the component.\n     * @param {CalendarModel} oldProp - Returns the previous property value of the component.\n     * @returns {void}\n     * @private\n     */\n    onPropertyChanged(newProp, oldProp) {\n      this.effect = '';\n      this.rangeValidation(this.min, this.max);\n      for (const prop of Object.keys(newProp)) {\n        switch (prop) {\n          case 'value':\n            if (this.isDateSelected) {\n              if (typeof newProp.value === 'string') {\n                this.setProperties({\n                  value: new Date(this.checkValue(newProp.value))\n                }, true);\n              } else {\n                newProp.value = new Date(this.checkValue(newProp.value));\n              }\n              if (isNaN(+this.value)) {\n                this.setProperties({\n                  value: oldProp.value\n                }, true);\n              }\n              this.update();\n            }\n            break;\n          case 'values':\n            if (this.isDateSelected) {\n              if (typeof newProp.values === 'string' || typeof newProp.values === 'number') {\n                this.setProperties({\n                  values: null\n                }, true);\n              } else {\n                const copyValues = this.copyValues(this.values);\n                for (let index = 0; index < copyValues.length; index++) {\n                  const tempDate = copyValues[index];\n                  if (this.checkDateValue(tempDate) && !super.checkPresentDate(tempDate, copyValues)) {\n                    copyValues.push(tempDate);\n                  }\n                }\n                this.setProperties({\n                  values: copyValues\n                }, true);\n                if (this.values.length > 0) {\n                  this.setProperties({\n                    value: newProp.values[newProp.values.length - 1]\n                  }, true);\n                }\n              }\n              this.validateValues(this.isMultiSelection, this.values);\n              this.update();\n            }\n            break;\n          case 'isMultiSelection':\n            if (this.isDateSelected) {\n              this.setProperties({\n                isMultiSelection: newProp.isMultiSelection\n              }, true);\n              this.update();\n            }\n            break;\n          case 'enabled':\n            this.setEnable(this.enabled);\n            break;\n          case 'cssClass':\n            if (this.getModuleName() === 'calendar') {\n              this.setClass(newProp.cssClass, oldProp.cssClass);\n            }\n            break;\n          default:\n            super.onPropertyChanged(newProp, oldProp, this.isMultiSelection, this.values);\n        }\n      }\n      this.preventChange = this.isAngular && this.preventChange ? !this.preventChange : this.preventChange;\n    }\n    /**\n     * Destroys the widget.\n     *\n     * @returns {void}\n     */\n    destroy() {\n      super.destroy();\n      if (this.getModuleName() === 'calendar') {\n        const form = closest(this.element, 'form');\n        if (form) {\n          EventHandler.remove(form, 'reset', this.formResetHandler.bind(this));\n        }\n      }\n    }\n    /**\n     * This method is used to navigate to the month/year/decade view of the Calendar.\n     *\n     * @param {string} view - Specifies the view of the Calendar.\n     * @param {Date} date - Specifies the focused date in a view.\n     * @param {boolean} isCustomDate - Specifies whether the calendar is rendered with custom today date or not.\n     * @returns {void}\n     * @deprecated\n     */\n    navigateTo(view, date, isCustomDate) {\n      this.minMaxUpdate();\n      super.navigateTo(view, date, isCustomDate);\n    }\n    /* eslint-disable valid-jsdoc, jsdoc/require-returns-description */\n    /**\n     * Gets the current view of the Calendar.\n     *\n     * @returns {string}\n     * @deprecated\n     */\n    currentView() {\n      return super.currentView();\n    }\n    /* eslint-enable valid-jsdoc, jsdoc/require-returns-description */\n    /**\n     * This method is used to add the single or multiple dates to the values property of the Calendar.\n     *\n     * @param {Date | Date[]} dates - Specifies the date or dates to be added to the values property of the Calendar.\n     * @returns {void}\n     * @deprecated\n     */\n    addDate(dates) {\n      if (typeof dates !== 'string' && typeof dates !== 'number') {\n        let copyValues = this.copyValues(this.values);\n        if (typeof dates === 'object' && dates.length > 0) {\n          const tempDates = dates;\n          for (let i = 0; i < tempDates.length; i++) {\n            if (this.checkDateValue(tempDates[i]) && !super.checkPresentDate(tempDates[i], copyValues)) {\n              if (!isNullOrUndefined(copyValues) && copyValues.length > 0) {\n                copyValues.push(tempDates[i]);\n              } else {\n                copyValues = [new Date(+tempDates[i])];\n              }\n            }\n          }\n        } else {\n          if (this.checkDateValue(dates) && !super.checkPresentDate(dates, copyValues)) {\n            if (!isNullOrUndefined(copyValues) && copyValues.length > 0) {\n              copyValues.push(dates);\n            } else {\n              copyValues = [new Date(+dates)];\n            }\n          }\n        }\n        this.setProperties({\n          values: copyValues\n        }, true);\n        if (this.isMultiSelection) {\n          this.setProperties({\n            value: this.values[this.values.length - 1]\n          }, true);\n        }\n        this.validateValues(this.isMultiSelection, copyValues);\n        this.update();\n        this.changedArgs = {\n          value: this.value,\n          values: this.values\n        };\n        this.changeHandler();\n      }\n    }\n    /**\n     * This method is used to remove the single or multiple dates from the values property of the Calendar.\n     *\n     * @param {Date | Date[]} dates - Specifies the date or dates which need to be removed from the values property of the Calendar.\n     * @returns {void}\n     * @deprecated\n     */\n    removeDate(dates) {\n      if (typeof dates !== 'string' && typeof dates !== 'number' && !isNullOrUndefined(this.values) && this.values.length > 0) {\n        const copyValues = this.copyValues(this.values);\n        if (typeof dates === 'object' && dates.length > 0) {\n          const tempDates = dates;\n          for (let index = 0; index < tempDates.length; index++) {\n            for (let i = 0; i < copyValues.length; i++) {\n              if (+copyValues[i] === +tempDates[index]) {\n                copyValues.splice(i, 1);\n              }\n            }\n          }\n        } else {\n          for (let i = 0; i < copyValues.length; i++) {\n            if (+copyValues[i] === +dates) {\n              copyValues.splice(i, 1);\n            }\n          }\n        }\n        this.setProperties({\n          values: copyValues\n        }, false);\n        this.update();\n        if (this.isMultiSelection) {\n          this.setProperties({\n            value: this.values[this.values.length - 1]\n          }, true);\n        }\n        this.changedArgs = {\n          value: this.value,\n          values: this.values\n        };\n        this.changeHandler();\n      }\n    }\n    /**\n     * To set custom today date in calendar\n     *\n     * @param {Date} date - Specifies date value to be set.\n     * @private\n     * @returns {void}\n     */\n    setTodayDate(date) {\n      const todayDate = new Date(+date);\n      this.setProperties({\n        value: todayDate\n      }, true);\n      super.todayButtonClick(null, todayDate, true);\n    }\n    update() {\n      this.validateDate();\n      this.minMaxUpdate();\n      super.setValueUpdate();\n    }\n    selectDate(e, date, element) {\n      super.selectDate(e, date, element, this.isMultiSelection, this.values);\n      if (this.isMultiSelection && !isNullOrUndefined(this.values) && this.values.length > 0) {\n        this.setProperties({\n          value: this.values[this.values.length - 1]\n        }, true);\n      }\n      this.changedArgs = {\n        value: this.value,\n        values: this.values\n      };\n      this.changeHandler(e);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    changeEvent(e) {\n      if ((this.value && this.value.valueOf()) !== (this.previousDate && +this.previousDate.valueOf()) || this.isMultiSelection) {\n        if (this.isAngular && this.preventChange) {\n          this.preventChange = false;\n        } else {\n          this.trigger('change', this.changedArgs);\n        }\n        this.previousDate = new Date(+this.value);\n      }\n    }\n    triggerChange(e) {\n      if (!isNullOrUndefined(this.todayButtonEvent) && this.isTodayClicked) {\n        e = this.todayButtonEvent;\n        this.isTodayClicked = false;\n      }\n      this.changedArgs.event = e || null;\n      this.changedArgs.isInteracted = !isNullOrUndefined(e);\n      if (!isNullOrUndefined(this.value)) {\n        this.setProperties({\n          value: this.value\n        }, true);\n      }\n      if (!this.isMultiSelection && +this.value !== Number.NaN && (+this.value !== +this.previousDate || this.previousDate == null && !isNaN(+this.value))) {\n        this.changeEvent(e);\n      } else if (!isNullOrUndefined(this.values) && this.previousValues !== this.values.length) {\n        this.changeEvent(e);\n        this.previousValues = this.values.length;\n      }\n    }\n  };\n  __decorate([Property(null)], Calendar.prototype, \"value\", void 0);\n  __decorate([Property(null)], Calendar.prototype, \"values\", void 0);\n  __decorate([Property(false)], Calendar.prototype, \"isMultiSelection\", void 0);\n  __decorate([Event()], Calendar.prototype, \"change\", void 0);\n  Calendar = __decorate([NotifyPropertyChanges], Calendar);\n\n  /**\n   *\n   */\n  /* eslint-disable @typescript-eslint/no-explicit-any */\n  //class constant defination.\n  return Calendar;\n})();\nconst OTHERMONTH$1 = 'e-other-month';\nconst YEAR$1 = 'e-year';\nconst MONTH$1 = 'e-month';\nconst DECADE$1 = 'e-decade';\nconst DISABLED$1 = 'e-disabled';\nconst OVERLAY$1 = 'e-overlay';\nconst WEEKEND$1 = 'e-weekend';\nconst WEEKNUMBER$1 = 'e-week-number';\nconst SELECTED$1 = 'e-selected';\nconst FOCUSEDDATE$1 = 'e-focused-date';\nconst OTHERMONTHROW$1 = 'e-month-hide';\nconst TODAY$1 = 'e-today';\nconst LINK$1 = 'e-day';\nconst CELL$1 = 'e-cell';\nconst dayMilliSeconds$1 = 86400000;\nconst minDecade = 2060;\nconst maxDecade = 2069;\nclass Islamic {\n  constructor(instance) {\n    this.calendarInstance = instance;\n  }\n  getModuleName() {\n    return 'islamic';\n  }\n  islamicTitleUpdate(date, view) {\n    const globalize = new Internationalization(this.calendarInstance.locale);\n    switch (view) {\n      case 'days':\n        this.calendarInstance.headerTitleElement.textContent = globalize.formatDate(date, {\n          type: 'dateTime',\n          format: 'MMMMyyyy',\n          calendar: 'islamic'\n        });\n        break;\n      case 'months':\n        this.calendarInstance.headerTitleElement.textContent = globalize.formatDate(date, {\n          type: 'dateTime',\n          format: 'yyyy',\n          calendar: 'islamic'\n        });\n    }\n  }\n  islamicRenderDays(currentDate, value, multiSelection, values) {\n    const tdEles = [];\n    const cellsCount = 42;\n    let localDate = new Date(this.islamicInValue(currentDate));\n    let minMaxDate;\n    this.islamicTitleUpdate(currentDate, 'days');\n    const islamicDate = this.getIslamicDate(localDate);\n    const gregorianObject = this.toGregorian(islamicDate.year, islamicDate.month, 1);\n    const currentMonth = islamicDate.month;\n    localDate = gregorianObject;\n    while (localDate.getDay() !== this.calendarInstance.firstDayOfWeek) {\n      this.calendarInstance.setStartDate(localDate, -1 * dayMilliSeconds$1);\n    }\n    for (let day = 0; day < cellsCount; ++day) {\n      const weekEle = this.calendarInstance.createElement('td', {\n        className: CELL$1\n      });\n      const weekAnchor = this.calendarInstance.createElement('span');\n      if (day % 7 === 0 && this.calendarInstance.weekNumber) {\n        weekAnchor.textContent = '' + this.calendarInstance.getWeek(localDate);\n        weekEle.appendChild(weekAnchor);\n        addClass([weekEle], '' + WEEKNUMBER$1);\n        tdEles.push(weekEle);\n      }\n      minMaxDate = new Date(+localDate);\n      localDate = this.calendarInstance.minMaxDate(localDate);\n      const dateFormatOptions = {\n        type: 'dateTime',\n        skeleton: 'full',\n        calendar: 'islamic'\n      };\n      const date = this.calendarInstance.globalize.parseDate(this.calendarInstance.globalize.formatDate(localDate, dateFormatOptions), dateFormatOptions);\n      const tdEle = this.islamicDayCell(localDate);\n      const title = this.calendarInstance.globalize.formatDate(localDate, {\n        type: 'date',\n        skeleton: 'full',\n        calendar: 'islamic'\n      });\n      const dayLink = this.calendarInstance.createElement('span');\n      dayLink.textContent = this.calendarInstance.globalize.formatDate(localDate, {\n        type: 'date',\n        skeleton: 'd',\n        calendar: 'islamic'\n      });\n      const disabled = this.calendarInstance.min > localDate || this.calendarInstance.max < localDate;\n      if (disabled) {\n        addClass([tdEle], DISABLED$1);\n        addClass([tdEle], OVERLAY$1);\n      } else {\n        dayLink.setAttribute('title', '' + title);\n      }\n      const hijriMonthObject = this.getIslamicDate(localDate);\n      if (currentMonth !== hijriMonthObject.month) {\n        addClass([tdEle], OTHERMONTH$1);\n      }\n      if (localDate.getDay() === 0 || localDate.getDay() === 6) {\n        addClass([tdEle], WEEKEND$1);\n      }\n      tdEle.appendChild(dayLink);\n      this.calendarInstance.renderDayCellArgs = {\n        date: localDate,\n        isDisabled: false,\n        element: tdEle,\n        isOutOfRange: disabled\n      };\n      const argument = this.calendarInstance.renderDayCellArgs;\n      this.calendarInstance.renderDayCellEvent(argument);\n      if (argument.isDisabled) {\n        if (this.calendarInstance.isMultiSelection) {\n          if (!isNullOrUndefined(this.calendarInstance.values) && this.calendarInstance.values.length > 0) {\n            for (let index = 0; index < values.length; index++) {\n              const localDateString = +new Date(this.calendarInstance.globalize.formatDate(argument.date, {\n                type: 'date',\n                skeleton: 'yMd',\n                calendar: 'islamic'\n              }));\n              const tempDateString = +new Date(this.calendarInstance.globalize.formatDate(this.calendarInstance.values[index], {\n                type: 'date',\n                skeleton: 'yMd',\n                calendar: 'islamic'\n              }));\n              if (localDateString === tempDateString) {\n                this.calendarInstance.values.splice(index, 1);\n                index = -1;\n              }\n            }\n          }\n        } else if (value && +value === +argument.date) {\n          this.calendarInstance.setProperties({\n            value: null\n          }, true);\n        }\n      }\n      if (this.calendarInstance.renderDayCellArgs.isDisabled && !tdEle.classList.contains(SELECTED$1)) {\n        addClass([tdEle], DISABLED$1);\n        addClass([tdEle], OVERLAY$1);\n        if (+this.calendarInstance.renderDayCellArgs.date === +this.calendarInstance.todayDate) {\n          this.calendarInstance.todayDisabled = true;\n        }\n      }\n      const otherMnthBool = tdEle.classList.contains(OTHERMONTH$1);\n      const disabledCls = tdEle.classList.contains(DISABLED$1);\n      if (!disabledCls) {\n        EventHandler.add(tdEle, 'click', this.calendarInstance.clickHandler, this.calendarInstance);\n      }\n      if (this.calendarInstance.isMultiSelection && !isNullOrUndefined(this.calendarInstance.values) && !otherMnthBool && !disabledCls) {\n        for (let tempValue = 0; tempValue < this.calendarInstance.values.length; tempValue++) {\n          const localDateString = this.calendarInstance.globalize.formatDate(localDate, {\n            type: 'date',\n            skeleton: 'short',\n            calendar: 'islamic'\n          });\n          const tempDateString = this.calendarInstance.globalize.formatDate(this.calendarInstance.values[tempValue], {\n            type: 'date',\n            skeleton: 'short',\n            calendar: 'islamic'\n          });\n          if (localDateString === tempDateString && this.calendarInstance.getDateVal(localDate, this.calendarInstance.values[tempValue])) {\n            addClass([tdEle], SELECTED$1);\n          } else {\n            this.calendarInstance.updateFocus(otherMnthBool, disabledCls, localDate, tdEle, currentDate);\n          }\n        }\n        if (this.calendarInstance.values.length <= 0) {\n          this.calendarInstance.updateFocus(otherMnthBool, disabledCls, localDate, tdEle, currentDate);\n        }\n      } else if (!otherMnthBool && !disabledCls && this.calendarInstance.getDateVal(localDate, value)) {\n        addClass([tdEle], SELECTED$1);\n      } else {\n        this.calendarInstance.updateFocus(otherMnthBool, disabledCls, localDate, tdEle, currentDate);\n      }\n      if (date.getDate() === new Date().getDate() && date.getMonth() === new Date().getMonth()) {\n        if (date.getFullYear() === new Date().getFullYear()) {\n          addClass([tdEle], TODAY$1);\n        }\n      }\n      localDate = new Date(+minMaxDate);\n      tdEles.push(this.calendarInstance.renderDayCellArgs.element);\n      this.calendarInstance.addDay(localDate, 1, null, this.calendarInstance.max, this.calendarInstance.min);\n    }\n    return tdEles;\n  }\n  islamicIconHandler() {\n    new Date(this.islamicInValue(this.calendarInstance.currentDate)).setDate(1);\n    const date = new Date(this.islamicInValue(this.calendarInstance.currentDate));\n    switch (this.calendarInstance.currentView()) {\n      case 'Month':\n        {\n          const prevMonthCompare = this.islamicCompareMonth(date, this.calendarInstance.min) < 1;\n          const nextMonthCompare = this.islamicCompareMonth(date, this.calendarInstance.max) > -1;\n          this.calendarInstance.previousIconHandler(prevMonthCompare);\n          this.calendarInstance.nextIconHandler(nextMonthCompare);\n        }\n        break;\n      case 'Year':\n        {\n          const prevYearCompare = this.hijriCompareYear(date, this.calendarInstance.min) < 1;\n          const nextYearCompare = this.hijriCompareYear(date, this.calendarInstance.max) > -1;\n          this.calendarInstance.previousIconHandler(prevYearCompare);\n          this.calendarInstance.nextIconHandler(nextYearCompare);\n        }\n        break;\n      case 'Decade':\n        {\n          const prevDecadeCompare = this.hijriCompareDecade(date, this.calendarInstance.min) < 1;\n          const nextDecadeCompare = this.hijriCompareDecade(date, this.calendarInstance.max) > -1;\n          this.calendarInstance.previousIconHandler(prevDecadeCompare);\n          this.calendarInstance.nextIconHandler(nextDecadeCompare);\n        }\n    }\n  }\n  islamicNext() {\n    this.calendarInstance.effect = '';\n    const view = this.calendarInstance.getViewNumber(this.calendarInstance.currentView());\n    const islamicDate = this.getIslamicDate(this.calendarInstance.currentDate);\n    switch (this.calendarInstance.currentView()) {\n      case 'Year':\n        this.calendarInstance.currentDate = this.toGregorian(islamicDate.year + 1, islamicDate.month, 1);\n        this.calendarInstance.switchView(view);\n        break;\n      case 'Month':\n        this.calendarInstance.currentDate = this.toGregorian(islamicDate.year, islamicDate.month + 1, 1);\n        this.calendarInstance.switchView(view);\n        break;\n      case 'Decade':\n        this.calendarInstance.currentDate = this.toGregorian(islamicDate.year + 10, islamicDate.month, 1);\n        this.calendarInstance.switchView(view);\n        break;\n    }\n  }\n  islamicPrevious() {\n    const currentView = this.calendarInstance.getViewNumber(this.calendarInstance.currentView());\n    this.calendarInstance.effect = '';\n    const islamicDate = this.getIslamicDate(this.calendarInstance.currentDate);\n    switch (this.calendarInstance.currentView()) {\n      case 'Month':\n        this.calendarInstance.currentDate = this.toGregorian(islamicDate.year, islamicDate.month - 1, 1);\n        this.calendarInstance.switchView(currentView);\n        break;\n      case 'Year':\n        this.calendarInstance.currentDate = this.toGregorian(islamicDate.year - 1, islamicDate.month, 1);\n        this.calendarInstance.switchView(currentView);\n        break;\n      case 'Decade':\n        this.calendarInstance.currentDate = this.toGregorian(islamicDate.year - 10, islamicDate.month - 1, 1);\n        this.calendarInstance.switchView(currentView);\n        break;\n    }\n  }\n  islamicRenderYears(e, value) {\n    this.calendarInstance.removeTableHeadElement();\n    const numCells = 4;\n    const tdEles = [];\n    const valueUtil = isNullOrUndefined(value);\n    const curDate = new Date(this.islamicInValue(this.calendarInstance.currentDate));\n    let localDate = curDate;\n    const islamicDate = this.getIslamicDate(localDate);\n    const gregorianObject = HijriParser.toGregorian(islamicDate.year, 1, 1);\n    localDate = gregorianObject;\n    const mon = islamicDate.month;\n    const yr = islamicDate.year;\n    const curYrs = islamicDate.year;\n    const minYr = this.getIslamicDate(this.calendarInstance.min).year;\n    const minMonth = this.getIslamicDate(this.calendarInstance.min).month;\n    const maxYr = this.getIslamicDate(this.calendarInstance.max).year;\n    const maxMonth = this.getIslamicDate(this.calendarInstance.max).month;\n    this.islamicTitleUpdate(this.calendarInstance.currentDate, 'months');\n    for (let month = 1; month <= 12; ++month) {\n      const islamicDate = this.getIslamicDate(localDate);\n      const gregorianObject = HijriParser.toGregorian(islamicDate.year, month, 1);\n      localDate = gregorianObject;\n      const tdEle = this.islamicDayCell(localDate);\n      const dayLink = this.calendarInstance.createElement('span');\n      const localMonth = value && this.getIslamicDate(value).month === this.getIslamicDate(localDate).month;\n      const select$$1 = value && this.getIslamicDate(value).year === yr && localMonth;\n      dayLink.textContent = this.calendarInstance.globalize.formatDate(localDate, {\n        type: 'dateTime',\n        format: 'MMM',\n        calendar: 'islamic'\n      });\n      if (this.calendarInstance.min && (curYrs < minYr || month < minMonth && curYrs === minYr) || this.calendarInstance.max && (curYrs > maxYr || month > maxMonth && curYrs >= maxYr)) {\n        addClass([tdEle], DISABLED$1);\n      } else if (!valueUtil && select$$1) {\n        addClass([tdEle], SELECTED$1);\n      } else {\n        if (this.getIslamicDate(localDate).month === mon && this.getIslamicDate(this.calendarInstance.currentDate).month === mon) {\n          addClass([tdEle], FOCUSEDDATE$1);\n        }\n      }\n      if (!tdEle.classList.contains(DISABLED$1)) {\n        EventHandler.add(tdEle, 'click', this.calendarInstance.clickHandler, this.calendarInstance);\n      }\n      tdEle.appendChild(dayLink);\n      tdEles.push(tdEle);\n    }\n    this.islamicRenderTemplate(tdEles, numCells, YEAR$1, e, value);\n  }\n  islamicRenderDecade(e, value) {\n    this.calendarInstance.removeTableHeadElement();\n    const numCells = 4;\n    const yearCell = 12;\n    const tdEles = [];\n    let localDate = new Date(this.islamicInValue(this.calendarInstance.currentDate));\n    const islamicDate = this.getIslamicDate(localDate);\n    const gregorianObject = HijriParser.toGregorian(islamicDate.year, 1, 1);\n    localDate = gregorianObject;\n    const localYr = localDate.getFullYear();\n    const startYr = new Date(this.islamicInValue(localYr - localYr % 10));\n    const endYr = new Date(this.islamicInValue(localYr - localYr % 10 + (10 - 1)));\n    const startFullYr = startYr.getFullYear();\n    const endFullYr = endYr.getFullYear();\n    const startHdrYr = this.calendarInstance.globalize.formatDate(startYr, {\n      type: 'dateTime',\n      format: 'y',\n      calendar: 'islamic'\n    });\n    const endHdrYr = this.calendarInstance.globalize.formatDate(endYr, {\n      type: 'dateTime',\n      format: 'y',\n      calendar: 'islamic'\n    });\n    this.calendarInstance.headerTitleElement.textContent = startHdrYr + ' - ' + endHdrYr;\n    const start = new Date(localYr - localYr % 10 - 2, 0, 1);\n    const startYear = start.getFullYear();\n    for (let rowCount = 1; rowCount <= yearCell; ++rowCount) {\n      const year = startYear + rowCount;\n      localDate.setFullYear(year);\n      localDate.setDate(1);\n      localDate.setMonth(0);\n      const islamicDate = this.getIslamicDate(localDate);\n      const gregorianObject = HijriParser.toGregorian(islamicDate.year, 1, 1);\n      localDate = gregorianObject;\n      const tdEle = this.islamicDayCell(localDate);\n      attributes(tdEle, {\n        'role': 'gridcell'\n      });\n      const dayLink = this.calendarInstance.createElement('span');\n      dayLink.textContent = this.calendarInstance.globalize.formatDate(localDate, {\n        type: 'dateTime',\n        format: 'y',\n        calendar: 'islamic'\n      });\n      if (year < startFullYr || year > endFullYr) {\n        addClass([tdEle], OTHERMONTH$1);\n      } else if (year < new Date(this.islamicInValue(this.calendarInstance.min)).getFullYear() || year > new Date(this.islamicInValue(this.calendarInstance.max)).getFullYear()) {\n        addClass([tdEle], DISABLED$1);\n      } else if (!isNullOrUndefined(value) && this.getIslamicDate(localDate).year === this.getIslamicDate(value).year) {\n        addClass([tdEle], SELECTED$1);\n      } else {\n        if (localDate.getFullYear() === this.calendarInstance.currentDate.getFullYear() && !tdEle.classList.contains(DISABLED$1)) {\n          addClass([tdEle], FOCUSEDDATE$1);\n        }\n      }\n      if (!tdEle.classList.contains(DISABLED$1)) {\n        EventHandler.add(tdEle, 'click', this.calendarInstance.clickHandler, this.calendarInstance);\n      }\n      tdEle.appendChild(dayLink);\n      tdEles.push(tdEle);\n    }\n    this.islamicRenderTemplate(tdEles, numCells, 'e-decade', e, value);\n  }\n  islamicDayCell(localDate) {\n    const dateFormatOptions = {\n      skeleton: 'full',\n      type: 'dateTime',\n      calendar: 'islamic'\n    };\n    const formatDate = this.calendarInstance.globalize.formatDate(localDate, dateFormatOptions);\n    const date = this.calendarInstance.globalize.parseDate(formatDate, dateFormatOptions);\n    const value = date.valueOf();\n    const attrs = {\n      className: CELL$1,\n      attrs: {\n        'id': '' + getUniqueID('' + value),\n        'aria-selected': 'false',\n        'role': 'gridcell'\n      }\n    };\n    return this.calendarInstance.createElement('td', attrs);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  islamicRenderTemplate(elements, count, classNm, e, value) {\n    const view = this.calendarInstance.getViewNumber(this.calendarInstance.currentView());\n    let trEle;\n    this.calendarInstance.tableBodyElement = this.calendarInstance.createElement('tbody');\n    this.calendarInstance.table.appendChild(this.calendarInstance.tableBodyElement);\n    removeClass([this.calendarInstance.contentElement, this.calendarInstance.headerElement], [MONTH$1, DECADE$1, YEAR$1]);\n    addClass([this.calendarInstance.contentElement, this.calendarInstance.headerElement], [classNm]);\n    const weekNumCell = 41;\n    const numberCell = 35;\n    const otherMonthCell = 6;\n    let row = count;\n    let rowCount = 0;\n    for (let dayCell = 0; dayCell < elements.length / count; ++dayCell) {\n      trEle = this.calendarInstance.createElement('tr', {\n        attrs: {\n          'role': 'row'\n        }\n      });\n      for (rowCount = 0 + rowCount; rowCount < row; rowCount++) {\n        if (!elements[rowCount].classList.contains('e-week-number') && !isNullOrUndefined(elements[rowCount].children[0])) {\n          addClass([elements[rowCount].children[0]], [LINK$1]);\n          rippleEffect(elements[rowCount].children[0], {\n            duration: 600,\n            isCenterRipple: true\n          });\n        }\n        trEle.appendChild(elements[rowCount]);\n        if (this.calendarInstance.weekNumber && rowCount === otherMonthCell + 1 && elements[otherMonthCell + 1].classList.contains(OTHERMONTH$1)) {\n          addClass([trEle], OTHERMONTHROW$1);\n        }\n        if (!this.calendarInstance.weekNumber && rowCount === otherMonthCell && elements[otherMonthCell].classList.contains(OTHERMONTH$1)) {\n          addClass([trEle], OTHERMONTHROW$1);\n        }\n        if (this.calendarInstance.weekNumber) {\n          if (rowCount === weekNumCell && elements[weekNumCell].classList.contains(OTHERMONTH$1)) {\n            addClass([trEle], OTHERMONTHROW$1);\n          }\n        } else {\n          if (rowCount === numberCell && elements[numberCell].classList.contains(OTHERMONTH$1)) {\n            addClass([trEle], OTHERMONTHROW$1);\n          }\n        }\n      }\n      row = row + count;\n      rowCount = rowCount + 0;\n      this.calendarInstance.tableBodyElement.appendChild(trEle);\n    }\n    this.calendarInstance.table.querySelector('tbody').className = this.calendarInstance.effect;\n    this.islamicIconHandler();\n    if (view !== this.calendarInstance.getViewNumber(this.calendarInstance.currentView()) || view === 0 && view !== this.calendarInstance.getViewNumber(this.calendarInstance.currentView())) {\n      this.calendarInstance.navigateHandler(e);\n    }\n    this.calendarInstance.setAriaActiveDescendant();\n    this.calendarInstance.changedArgs = {\n      value: this.calendarInstance.value,\n      values: this.calendarInstance.values\n    };\n    this.calendarInstance.changeHandler();\n  }\n  islamicCompareMonth(start, end) {\n    const hijriStart = this.getIslamicDate(start);\n    const hijriEnd = this.getIslamicDate(end);\n    let result;\n    if (hijriStart.year > hijriEnd.year) {\n      result = 1;\n    } else if (hijriStart.year < hijriEnd.year) {\n      result = -1;\n    } else {\n      result = hijriStart.month === hijriEnd.month ? 0 : hijriStart.month > hijriEnd.month ? 1 : -1;\n    }\n    return result;\n  }\n  islamicCompare(startDate, endDate, modifier) {\n    const hijriStart = this.getIslamicDate(startDate);\n    const hijriEnd = this.getIslamicDate(endDate);\n    let start = hijriEnd.year;\n    let end;\n    let result;\n    end = start;\n    result = 0;\n    if (modifier) {\n      start = start - start % modifier;\n      end = start - start % modifier + modifier - 1;\n    }\n    if (hijriStart.year > end) {\n      result = 1;\n    } else if (this.calendarInstance.currentView() === 'Decade' && hijriStart.year < start && !(startDate.getFullYear() >= minDecade && startDate.getFullYear() <= maxDecade)) {\n      result = -1;\n    } else if (hijriStart.year < start && this.calendarInstance.currentView() === 'Year') {\n      result = -1;\n    }\n    return result;\n  }\n  getIslamicDate(date) {\n    return HijriParser.getHijriDate(date);\n  }\n  toGregorian(year, month, date) {\n    return HijriParser.toGregorian(year, month, date);\n  }\n  hijriCompareYear(start, end) {\n    return this.islamicCompare(start, end, 0);\n  }\n  hijriCompareDecade(start, end) {\n    return this.islamicCompare(start, end, 10);\n  }\n  destroy() {\n    this.calendarInstance = null;\n  }\n  islamicInValue(inValue) {\n    if (inValue instanceof Date) {\n      return inValue.toUTCString();\n    } else {\n      return '' + inValue;\n    }\n  }\n}\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\n/**\n * Calendar modules\n */\n\nvar __decorate$1 = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n// eslint-disable-next-line @typescript-eslint/triple-slash-reference\n/// <reference path='../calendar/calendar-model.d.ts'/>\n//class constant defination\nconst DATEWRAPPER = 'e-date-wrapper';\nconst ROOT$1 = 'e-datepicker';\nconst LIBRARY = 'e-lib';\nconst CONTROL = 'e-control';\nconst POPUPWRAPPER = 'e-popup-wrapper';\nconst INPUTWRAPPER = 'e-input-group-icon';\nconst POPUP = 'e-popup';\nconst INPUTCONTAINER = 'e-input-group';\nconst INPUTFOCUS = 'e-input-focus';\nconst INPUTROOT = 'e-input';\nconst ERROR = 'e-error';\nconst ACTIVE = 'e-active';\nconst OVERFLOW = 'e-date-overflow';\nconst DATEICON = 'e-date-icon';\nconst ICONS = 'e-icons';\nconst OPENDURATION = 300;\nconst OFFSETVALUE = 4;\nconst SELECTED$2 = 'e-selected';\nconst FOCUSEDDATE$2 = 'e-focused-date';\nconst NONEDIT = 'e-non-edit';\nconst containerAttr = ['title', 'class', 'style'];\n/**\n * Represents the DatePicker component that allows user to select\n * or enter a date value.\n * ```html\n * <input id='datepicker'/>\n * ```\n * ```typescript\n * <script>\n *   let datePickerObject:DatePicker = new DatePicker({ value: new Date() });\n *   datePickerObject.appendTo('#datepicker');\n * </script>\n * ```\n */\nlet DatePicker = class DatePicker extends Calendar {\n  /**\n   * Constructor for creating the widget.\n   *\n   * @param {DatePickerModel} options - Specifies the DatePicker model.\n   * @param {string | HTMLInputElement} element - Specifies the element to render as component.\n   * @private\n   */\n  constructor(options, element) {\n    super(options, element);\n    this.previousElementValue = '';\n    this.isDateIconClicked = false;\n    this.isAltKeyPressed = false;\n    this.isInteracted = true;\n    this.invalidValueString = null;\n    this.checkPreviousValue = null;\n    this.maskedDateValue = '';\n    this.isAngular = false;\n    this.preventChange = false;\n    this.isIconClicked = false;\n    this.isDynamicValueChanged = false;\n    this.moduleName = this.getModuleName();\n    this.datepickerOptions = options;\n  }\n  /**\n   * To Initialize the control rendering.\n   *\n   * @returns {void}\n   * @private\n   */\n  render() {\n    this.initialize();\n    this.bindEvents();\n    this.renderComplete();\n    this.setTimeZone(this.serverTimezoneOffset);\n  }\n  setTimeZone(offsetValue) {\n    if (!isNullOrUndefined(this.serverTimezoneOffset) && this.value) {\n      const clientTimeZoneDiff = new Date().getTimezoneOffset() / 60;\n      const serverTimezoneDiff = offsetValue;\n      let timeZoneDiff = serverTimezoneDiff + clientTimeZoneDiff;\n      timeZoneDiff = this.isDayLightSaving() ? timeZoneDiff-- : timeZoneDiff;\n      this.value = new Date(this.value.getTime() + timeZoneDiff * 60 * 60 * 1000);\n      this.updateInput();\n    }\n  }\n  isDayLightSaving() {\n    const firstOffset = new Date(this.value.getFullYear(), 0, 1).getTimezoneOffset();\n    const secondOffset = new Date(this.value.getFullYear(), 6, 1).getTimezoneOffset();\n    return this.value.getTimezoneOffset() < Math.max(firstOffset, secondOffset);\n  }\n  setAllowEdit() {\n    if (this.allowEdit) {\n      if (!this.readonly) {\n        this.inputElement.removeAttribute('readonly');\n      }\n    } else {\n      attributes(this.inputElement, {\n        'readonly': ''\n      });\n    }\n    this.updateIconState();\n  }\n  updateIconState() {\n    if (!this.allowEdit && this.inputWrapper && !this.readonly) {\n      if (this.inputElement.value === '') {\n        removeClass([this.inputWrapper.container], [NONEDIT]);\n      } else {\n        addClass([this.inputWrapper.container], [NONEDIT]);\n      }\n    } else if (this.inputWrapper) {\n      removeClass([this.inputWrapper.container], [NONEDIT]);\n    }\n  }\n  initialize() {\n    this.checkInvalidValue(this.value);\n    if (this.enableMask) {\n      this.notify(\"createMask\", {\n        module: \"MaskedDateTime\"\n      });\n    }\n    this.createInput();\n    this.updateHtmlAttributeToWrapper();\n    this.setAllowEdit();\n    this.updateInput();\n    if (this.enableMask && !this.value && this.maskedDateValue && (this.floatLabelType == 'Always' || !this.floatLabelType || !this.placeholder)) {\n      this.updateInputValue(this.maskedDateValue);\n    }\n    this.previousElementValue = this.inputElement.value;\n    this.previousDate = !isNullOrUndefined(this.value) ? new Date(+this.value) : null;\n    this.inputElement.setAttribute('value', this.inputElement.value);\n    this.inputValueCopy = this.value;\n  }\n  createInput() {\n    const ariaAttrs = {\n      'aria-live': 'assertive',\n      'aria-atomic': 'true',\n      'aria-haspopup': 'true',\n      'aria-activedescendant': 'null',\n      'aria-owns': this.element.id + '_options',\n      'aria-expanded': 'false',\n      'role': 'combobox',\n      'autocomplete': 'off',\n      'autocorrect': 'off',\n      'autocapitalize': 'off',\n      'spellcheck': 'false',\n      'aria-invalid': 'false'\n    };\n    if (this.getModuleName() === 'datepicker') {\n      const l10nLocale = {\n        placeholder: this.placeholder\n      };\n      this.globalize = new Internationalization(this.locale);\n      this.l10n = new L10n('datepicker', l10nLocale, this.locale);\n      this.setProperties({\n        placeholder: this.placeholder || this.l10n.getConstant('placeholder')\n      }, true);\n    }\n    let updatedCssClassValues = this.cssClass;\n    if (!isNullOrUndefined(this.cssClass) && this.cssClass !== '') {\n      updatedCssClassValues = this.cssClass.replace(/\\s+/g, ' ').trim();\n    }\n    let isBindClearAction = this.enableMask ? false : true;\n    this.inputWrapper = Input.createInput({\n      element: this.inputElement,\n      floatLabelType: this.floatLabelType,\n      bindClearAction: isBindClearAction,\n      properties: {\n        readonly: this.readonly,\n        placeholder: this.placeholder,\n        cssClass: updatedCssClassValues,\n        enabled: this.enabled,\n        enableRtl: this.enableRtl,\n        showClearButton: this.showClearButton\n      },\n      buttons: [INPUTWRAPPER + ' ' + DATEICON + ' ' + ICONS]\n    }, this.createElement);\n    this.setWidth(this.width);\n    if (this.inputElement.name !== '') {\n      this.inputElement.setAttribute('name', '' + this.inputElement.getAttribute('name'));\n    } else {\n      this.inputElement.setAttribute('name', '' + this.element.id);\n    }\n    attributes(this.inputElement, ariaAttrs);\n    if (!this.enabled) {\n      this.inputElement.setAttribute('aria-disabled', 'true');\n      this.inputElement.tabIndex = -1;\n    } else {\n      this.inputElement.setAttribute('aria-disabled', 'false');\n      this.inputElement.setAttribute('tabindex', this.tabIndex);\n    }\n    Input.addAttributes({\n      'aria-label': 'select'\n    }, this.inputWrapper.buttons[0]);\n    addClass([this.inputWrapper.container], DATEWRAPPER);\n  }\n  updateInput(isDynamic = false) {\n    let formatOptions;\n    if (this.value && !this.isCalendar() && !isDynamic) {\n      this.disabledDates();\n    }\n    if (isNaN(+new Date(this.checkValue(this.value)))) {\n      this.setProperties({\n        value: null\n      }, true);\n    }\n    if (this.strictMode) {\n      //calls the Calendar processDate protected method to update the date value according to the strictMode true behaviour.\n      super.validateDate();\n      this.minMaxUpdates();\n      super.minMaxUpdate();\n    }\n    if (!isNullOrUndefined(this.value)) {\n      const dateValue = this.value;\n      let dateString;\n      const tempFormat = !isNullOrUndefined(this.formatString) ? this.formatString : this.dateTimeFormat;\n      if (this.getModuleName() === 'datetimepicker') {\n        if (this.calendarMode === 'Gregorian') {\n          dateString = this.globalize.formatDate(this.value, {\n            format: tempFormat,\n            type: 'dateTime',\n            skeleton: 'yMd'\n          });\n        } else {\n          dateString = this.globalize.formatDate(this.value, {\n            format: tempFormat,\n            type: 'dateTime',\n            skeleton: 'yMd',\n            calendar: 'islamic'\n          });\n        }\n      } else {\n        if (this.calendarMode === 'Gregorian') {\n          formatOptions = {\n            format: this.formatString,\n            type: 'dateTime',\n            skeleton: 'yMd'\n          };\n        } else {\n          formatOptions = {\n            format: this.formatString,\n            type: 'dateTime',\n            skeleton: 'yMd',\n            calendar: 'islamic'\n          };\n        }\n        dateString = this.globalize.formatDate(this.value, formatOptions);\n      }\n      if (+dateValue <= +this.max && +dateValue >= +this.min) {\n        this.updateInputValue(dateString);\n      } else {\n        const value = +dateValue >= +this.max || !+this.value || !+this.value || +dateValue <= +this.min;\n        if (!this.strictMode && value) {\n          this.updateInputValue(dateString);\n        }\n      }\n    }\n    if (isNullOrUndefined(this.value) && this.strictMode) {\n      if (!this.enableMask) {\n        this.updateInputValue('');\n      } else {\n        this.updateInputValue(this.maskedDateValue);\n        this.notify(\"createMask\", {\n          module: \"MaskedDateTime\"\n        });\n      }\n    }\n    if (!this.strictMode && isNullOrUndefined(this.value) && this.invalidValueString) {\n      this.updateInputValue(this.invalidValueString);\n    }\n    this.changedArgs = {\n      value: this.value\n    };\n    this.errorClass();\n    this.updateIconState();\n  }\n  minMaxUpdates() {\n    if (!isNullOrUndefined(this.value) && this.value < this.min && this.min <= this.max && this.strictMode) {\n      this.setProperties({\n        value: this.min\n      }, true);\n      this.changedArgs = {\n        value: this.value\n      };\n    } else {\n      if (!isNullOrUndefined(this.value) && this.value > this.max && this.min <= this.max && this.strictMode) {\n        this.setProperties({\n          value: this.max\n        }, true);\n        this.changedArgs = {\n          value: this.value\n        };\n      }\n    }\n  }\n  checkStringValue(val) {\n    let returnDate = null;\n    let formatOptions = null;\n    let formatDateTime = null;\n    if (this.getModuleName() === 'datetimepicker') {\n      const culture = new Internationalization(this.locale);\n      if (this.calendarMode === 'Gregorian') {\n        formatOptions = {\n          format: this.dateTimeFormat,\n          type: 'dateTime',\n          skeleton: 'yMd'\n        };\n        formatDateTime = {\n          format: culture.getDatePattern({\n            skeleton: 'yMd'\n          }),\n          type: 'dateTime'\n        };\n      } else {\n        formatOptions = {\n          format: this.dateTimeFormat,\n          type: 'dateTime',\n          skeleton: 'yMd',\n          calendar: 'islamic'\n        };\n        formatDateTime = {\n          format: culture.getDatePattern({\n            skeleton: 'yMd'\n          }),\n          type: 'dateTime',\n          calendar: 'islamic'\n        };\n      }\n    } else {\n      if (this.calendarMode === 'Gregorian') {\n        formatOptions = {\n          format: this.formatString,\n          type: 'dateTime',\n          skeleton: 'yMd'\n        };\n      } else {\n        formatOptions = {\n          format: this.formatString,\n          type: 'dateTime',\n          skeleton: 'yMd',\n          calendar: 'islamic'\n        };\n      }\n    }\n    returnDate = this.checkDateValue(this.globalize.parseDate(val, formatOptions));\n    if (isNullOrUndefined(returnDate) && this.getModuleName() === 'datetimepicker') {\n      returnDate = this.checkDateValue(this.globalize.parseDate(val, formatDateTime));\n    }\n    return returnDate;\n  }\n  checkInvalidValue(value) {\n    if (!(value instanceof Date) && !isNullOrUndefined(value)) {\n      let valueDate = null;\n      let valueString = value;\n      if (typeof value === 'number') {\n        valueString = value.toString();\n      }\n      let formatOptions = null;\n      let formatDateTime = null;\n      if (this.getModuleName() === 'datetimepicker') {\n        const culture = new Internationalization(this.locale);\n        if (this.calendarMode === 'Gregorian') {\n          formatOptions = {\n            format: this.dateTimeFormat,\n            type: 'dateTime',\n            skeleton: 'yMd'\n          };\n          formatDateTime = {\n            format: culture.getDatePattern({\n              skeleton: 'yMd'\n            }),\n            type: 'dateTime'\n          };\n        } else {\n          formatOptions = {\n            format: this.dateTimeFormat,\n            type: 'dateTime',\n            skeleton: 'yMd',\n            calendar: 'islamic'\n          };\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          formatDateTime = {\n            format: culture.getDatePattern({\n              skeleton: 'yMd'\n            }),\n            type: 'dateTime',\n            calendar: 'islamic'\n          };\n        }\n      } else {\n        if (this.calendarMode === 'Gregorian') {\n          formatOptions = {\n            format: this.formatString,\n            type: 'dateTime',\n            skeleton: 'yMd'\n          };\n        } else {\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          formatOptions = {\n            format: this.formatString,\n            type: 'dateTime',\n            skeleton: 'yMd',\n            calendar: 'islamic'\n          };\n        }\n      }\n      let invalid = false;\n      if (typeof valueString !== 'string') {\n        valueString = null;\n        invalid = true;\n      } else {\n        if (typeof valueString === 'string') {\n          valueString = valueString.trim();\n        }\n        valueDate = this.checkStringValue(valueString);\n        if (!valueDate) {\n          let extISOString = null;\n          let basicISOString = null;\n          // eslint-disable-next-line\n          extISOString = /^\\s*((?:[+-]\\d{6}|\\d{4})-(?:\\d\\d-\\d\\d|W\\d\\d-\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?::\\d\\d(?::\\d\\d(?:[.,]\\d+)?)?)?)([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?/;\n          // eslint-disable-next-line\n          basicISOString = /^\\s*((?:[+-]\\d{6}|\\d{4})(?:\\d\\d\\d\\d|W\\d\\d\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?:\\d\\d(?:\\d\\d(?:[.,]\\d+)?)?)?)([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?/;\n          if (!extISOString.test(valueString) && !basicISOString.test(valueString) || /^[a-zA-Z0-9- ]*$/.test(valueString) || isNaN(+new Date(this.checkValue(valueString)))) {\n            invalid = true;\n          } else {\n            valueDate = new Date(valueString);\n          }\n        }\n      }\n      if (invalid) {\n        if (!this.strictMode) {\n          this.invalidValueString = valueString;\n        }\n        this.setProperties({\n          value: null\n        }, true);\n      } else {\n        this.setProperties({\n          value: valueDate\n        }, true);\n      }\n    }\n  }\n  bindInputEvent() {\n    if (!isNullOrUndefined(this.formatString) || this.enableMask) {\n      if (this.enableMask || this.formatString.indexOf('y') === -1) {\n        EventHandler.add(this.inputElement, 'input', this.inputHandler, this);\n      } else {\n        EventHandler.remove(this.inputElement, 'input', this.inputHandler);\n      }\n    }\n  }\n  bindEvents() {\n    EventHandler.add(this.inputWrapper.buttons[0], 'mousedown touchstart', this.dateIconHandler, this);\n    EventHandler.add(this.inputElement, 'mouseup', this.mouseUpHandler, this);\n    EventHandler.add(this.inputElement, 'focus', this.inputFocusHandler, this);\n    EventHandler.add(this.inputElement, 'blur', this.inputBlurHandler, this);\n    if (this.enableMask) {\n      EventHandler.add(this.inputElement, 'keydown', this.keydownHandler, this);\n    }\n    this.bindInputEvent();\n    // To prevent the twice triggering.\n    EventHandler.add(this.inputElement, 'change', this.inputChangeHandler, this);\n    if (this.showClearButton && this.inputWrapper.clearButton) {\n      EventHandler.add(this.inputWrapper.clearButton, 'mousedown touchstart', this.resetHandler, this);\n    }\n    if (this.formElement) {\n      EventHandler.add(this.formElement, 'reset', this.resetFormHandler, this);\n    }\n    this.defaultKeyConfigs = extend(this.defaultKeyConfigs, this.keyConfigs);\n    this.keyboardModules = new KeyboardEvents(this.inputElement, {\n      eventName: 'keydown',\n      keyAction: this.inputKeyActionHandle.bind(this),\n      keyConfigs: this.defaultKeyConfigs\n    });\n  }\n  keydownHandler(e) {\n    switch (e.code) {\n      case 'ArrowLeft':\n      case 'ArrowRight':\n      case 'ArrowUp':\n      case 'ArrowDown':\n      case 'Home':\n      case 'End':\n      case 'Delete':\n        if (this.enableMask && !this.popupObj && !this.readonly) {\n          if (e.code !== 'Delete') {\n            e.preventDefault();\n          }\n          this.notify(\"keyDownHandler\", {\n            module: \"MaskedDateTime\",\n            e: e\n          });\n        }\n        break;\n      default:\n        break;\n    }\n  }\n  unBindEvents() {\n    EventHandler.remove(this.inputWrapper.buttons[0], 'mousedown touchstart', this.dateIconHandler);\n    EventHandler.remove(this.inputElement, 'mouseup', this.mouseUpHandler);\n    EventHandler.remove(this.inputElement, 'focus', this.inputFocusHandler);\n    EventHandler.remove(this.inputElement, 'blur', this.inputBlurHandler);\n    EventHandler.remove(this.inputElement, 'change', this.inputChangeHandler);\n    if (this.enableMask) {\n      EventHandler.remove(this.inputElement, 'keydown', this.keydownHandler);\n    }\n    if (this.showClearButton && this.inputWrapper.clearButton) {\n      EventHandler.remove(this.inputWrapper.clearButton, 'mousedown touchstart', this.resetHandler);\n    }\n    if (this.formElement) {\n      EventHandler.remove(this.formElement, 'reset', this.resetFormHandler);\n    }\n  }\n  resetFormHandler() {\n    if (!this.enabled) {\n      return;\n    }\n    if (!this.inputElement.disabled) {\n      let value = this.inputElement.getAttribute('value');\n      if (this.element.tagName === 'EJS-DATEPICKER' || this.element.tagName === 'EJS-DATETIMEPICKER') {\n        value = '';\n        this.inputValueCopy = null;\n        this.inputElement.setAttribute('value', '');\n      }\n      this.setProperties({\n        value: this.inputValueCopy\n      }, true);\n      this.restoreValue();\n      if (this.inputElement) {\n        this.updateInputValue(value);\n        this.errorClass();\n      }\n    }\n  }\n  restoreValue() {\n    this.currentDate = this.value ? this.value : new Date();\n    this.previousDate = this.value;\n    this.previousElementValue = isNullOrUndefined(this.inputValueCopy) ? '' : this.globalize.formatDate(this.inputValueCopy, {\n      format: this.formatString,\n      type: 'dateTime',\n      skeleton: 'yMd'\n    });\n  }\n  inputChangeHandler(e) {\n    if (!this.enabled) {\n      return;\n    }\n    e.stopPropagation();\n  }\n  bindClearEvent() {\n    if (this.showClearButton && this.inputWrapper.clearButton) {\n      EventHandler.add(this.inputWrapper.clearButton, 'mousedown touchstart', this.resetHandler, this);\n    }\n  }\n  resetHandler(e) {\n    if (!this.enabled) {\n      return;\n    }\n    e.preventDefault();\n    this.clear(e);\n  }\n  mouseUpHandler(e) {\n    if (this.enableMask) {\n      e.preventDefault();\n      this.notify(\"setMaskSelection\", {\n        module: \"MaskedDateTime\"\n      });\n    }\n  }\n  clear(event) {\n    this.setProperties({\n      value: null\n    }, true);\n    if (!this.enableMask) {\n      this.updateInputValue('');\n    }\n    const clearedArgs = {\n      event: event\n    };\n    this.trigger('cleared', clearedArgs);\n    this.invalidValueString = '';\n    this.updateInput();\n    this.popupUpdate();\n    this.changeEvent(event);\n    if (this.enableMask) {\n      this.notify(\"clearHandler\", {\n        module: \"MaskedDateTime\"\n      });\n    }\n  }\n  preventEventBubbling(e) {\n    e.preventDefault();\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this.interopAdaptor.invokeMethodAsync('OnDateIconClick');\n  }\n  updateInputValue(value) {\n    Input.setValue(value, this.inputElement, this.floatLabelType, this.showClearButton);\n  }\n  dateIconHandler(e) {\n    if (!this.enabled) {\n      return;\n    }\n    this.isIconClicked = true;\n    if (Browser.isDevice) {\n      this.inputElement.setAttribute('readonly', '');\n      this.inputElement.blur();\n    }\n    e.preventDefault();\n    if (!this.readonly) {\n      if (this.isCalendar()) {\n        this.hide(e);\n      } else {\n        this.isDateIconClicked = true;\n        this.show(null, e);\n        if (this.getModuleName() === 'datetimepicker') {\n          this.inputElement.focus();\n        }\n        this.inputElement.focus();\n        addClass([this.inputWrapper.container], [INPUTFOCUS]);\n        addClass(this.inputWrapper.buttons, ACTIVE);\n      }\n    }\n    this.isIconClicked = false;\n  }\n  updateHtmlAttributeToWrapper() {\n    if (!isNullOrUndefined(this.htmlAttributes)) {\n      for (const key of Object.keys(this.htmlAttributes)) {\n        if (!isNullOrUndefined(this.htmlAttributes[key])) {\n          if (containerAttr.indexOf(key) > -1) {\n            if (key === 'class') {\n              const updatedClassValues = this.htmlAttributes[key].replace(/\\s+/g, ' ').trim();\n              if (updatedClassValues !== '') {\n                addClass([this.inputWrapper.container], updatedClassValues.split(' '));\n              }\n            } else if (key === 'style') {\n              let setStyle = this.inputWrapper.container.getAttribute(key);\n              if (!isNullOrUndefined(setStyle)) {\n                if (setStyle.charAt(setStyle.length - 1) === ';') {\n                  setStyle = setStyle + this.htmlAttributes[key];\n                } else {\n                  setStyle = setStyle + ';' + this.htmlAttributes[key];\n                }\n              } else {\n                setStyle = this.htmlAttributes[key];\n              }\n              this.inputWrapper.container.setAttribute(key, setStyle);\n            } else {\n              this.inputWrapper.container.setAttribute(key, this.htmlAttributes[key]);\n            }\n          }\n        }\n      }\n    }\n  }\n  updateHtmlAttributeToElement() {\n    if (!isNullOrUndefined(this.htmlAttributes)) {\n      for (const key of Object.keys(this.htmlAttributes)) {\n        if (containerAttr.indexOf(key) < 0) {\n          this.inputElement.setAttribute(key, this.htmlAttributes[key]);\n        }\n      }\n    }\n  }\n  updateCssClass(newCssClass, oldCssClass) {\n    if (!isNullOrUndefined(oldCssClass)) {\n      oldCssClass = oldCssClass.replace(/\\s+/g, ' ').trim();\n    }\n    if (!isNullOrUndefined(newCssClass)) {\n      newCssClass = newCssClass.replace(/\\s+/g, ' ').trim();\n    }\n    Input.setCssClass(newCssClass, [this.inputWrapper.container], oldCssClass);\n    if (this.popupWrapper) {\n      Input.setCssClass(newCssClass, [this.popupWrapper], oldCssClass);\n    }\n  }\n  calendarKeyActionHandle(e) {\n    switch (e.action) {\n      case 'escape':\n        if (this.isCalendar()) {\n          this.hide(e);\n        } else {\n          this.inputWrapper.container.children[this.index].blur();\n        }\n        break;\n      case 'enter':\n        if (!this.isCalendar()) {\n          this.show(null, e);\n        } else {\n          if (+this.value !== +this.currentDate && !this.isCalendar()) {\n            this.inputWrapper.container.children[this.index].focus();\n          }\n        }\n        if (this.getModuleName() === 'datetimepicker') {\n          this.inputElement.focus();\n        }\n        break;\n      case 'tab':\n        this.hide(e);\n    }\n  }\n  inputFocusHandler() {\n    if (!this.enabled) {\n      return;\n    }\n    if (this.enableMask && !this.inputElement.value && this.placeholder) {\n      if (this.maskedDateValue && !this.value && (this.floatLabelType == 'Auto' || this.floatLabelType == 'Never' || this.placeholder)) {\n        this.updateInputValue(this.maskedDateValue);\n        this.inputElement.selectionStart = 0;\n        this.inputElement.selectionEnd = this.inputElement.value.length;\n      }\n    }\n    const focusArguments = {\n      model: this\n    };\n    this.isDateIconClicked = false;\n    this.trigger('focus', focusArguments);\n    this.updateIconState();\n    if (this.openOnFocus && !this.isIconClicked) {\n      this.show();\n    }\n  }\n  inputHandler() {\n    this.isPopupClicked = false;\n    if (this.enableMask) {\n      this.notify(\"inputHandler\", {\n        module: \"MaskedDateTime\"\n      });\n    }\n  }\n  inputBlurHandler(e) {\n    if (!this.enabled) {\n      return;\n    }\n    this.strictModeUpdate();\n    if (this.inputElement.value === '' && isNullOrUndefined(this.value)) {\n      this.invalidValueString = null;\n      this.updateInputValue('');\n    }\n    this.updateInput();\n    this.popupUpdate();\n    this.changeTrigger(e);\n    if (this.enableMask && this.maskedDateValue && this.placeholder && this.floatLabelType !== 'Always') {\n      if (this.inputElement.value == this.maskedDateValue && !this.value && (this.floatLabelType == 'Auto' || this.floatLabelType == 'Never' || this.placeholder)) {\n        this.updateInputValue('');\n      }\n    }\n    this.errorClass();\n    if (this.isCalendar() && document.activeElement === this.inputElement) {\n      this.hide(e);\n    }\n    if (this.getModuleName() === 'datepicker') {\n      const blurArguments = {\n        model: this\n      };\n      this.trigger('blur', blurArguments);\n    }\n    if (this.isCalendar()) {\n      this.defaultKeyConfigs = extend(this.defaultKeyConfigs, this.keyConfigs);\n      this.calendarKeyboardModules = new KeyboardEvents(this.calendarElement.children[1].firstElementChild, {\n        eventName: 'keydown',\n        keyAction: this.calendarKeyActionHandle.bind(this),\n        keyConfigs: this.defaultKeyConfigs\n      });\n    }\n    this.isPopupClicked = false;\n  }\n  documentHandler(e) {\n    if (!isNullOrUndefined(this.popupObj) && (this.inputWrapper.container.contains(e.target) || this.popupObj.element && this.popupObj.element.contains(e.target)) && e.type !== 'touchstart') {\n      e.preventDefault();\n    }\n    const target = e.target;\n    if (!closest(target, '.e-datepicker.e-popup-wrapper') && !(closest(target, '.' + INPUTCONTAINER) === this.inputWrapper.container) && !target.classList.contains('e-day')) {\n      this.hide(e);\n      this.focusOut();\n    } else if (closest(target, '.e-datepicker.e-popup-wrapper')) {\n      // Fix for close the popup when select the previously selected value.\n      if (target.classList.contains('e-day') && !isNullOrUndefined(e.target.parentElement) && e.target.parentElement.classList.contains('e-selected') && closest(target, '.e-content') && closest(target, '.e-content').classList.contains('e-' + this.depth.toLowerCase())) {\n        this.hide(e);\n      } else if (closest(target, '.e-footer-container') && target.classList.contains('e-today') && target.classList.contains('e-btn') && +new Date(+this.value) === +super.generateTodayVal(this.value)) {\n        this.hide(e);\n      }\n    }\n  }\n  inputKeyActionHandle(e) {\n    const clickedView = this.currentView();\n    switch (e.action) {\n      case 'altUpArrow':\n        this.isAltKeyPressed = false;\n        this.hide(e);\n        this.inputElement.focus();\n        break;\n      case 'altDownArrow':\n        this.isAltKeyPressed = true;\n        this.strictModeUpdate();\n        this.updateInput();\n        this.changeTrigger(e);\n        if (this.getModuleName() === 'datepicker') {\n          this.show(null, e);\n        }\n        break;\n      case 'escape':\n        this.hide(e);\n        break;\n      case 'enter':\n        this.strictModeUpdate();\n        this.updateInput();\n        this.popupUpdate();\n        this.changeTrigger(e);\n        this.errorClass();\n        if (!this.isCalendar() && document.activeElement === this.inputElement) {\n          this.hide(e);\n        }\n        if (this.isCalendar()) {\n          e.preventDefault();\n          e.stopPropagation();\n        }\n        break;\n      case 'tab':\n      case 'shiftTab':\n        let start = this.inputElement.selectionStart;\n        let end = this.inputElement.selectionEnd;\n        if (this.enableMask && !this.popupObj && !this.readonly) {\n          let length = this.inputElement.value.length;\n          if (start == 0 && end == length || end !== length && e.action == 'tab' || start !== 0 && e.action == 'shiftTab') {\n            e.preventDefault();\n          }\n          this.notify(\"keyDownHandler\", {\n            module: \"MaskedDateTime\",\n            e: e\n          });\n          start = this.inputElement.selectionStart;\n          end = this.inputElement.selectionEnd;\n        }\n        this.strictModeUpdate();\n        this.updateInput();\n        this.popupUpdate();\n        this.changeTrigger(e);\n        this.errorClass();\n        if (this.enableMask) {\n          this.inputElement.selectionStart = start;\n          this.inputElement.selectionEnd = end;\n        }\n        this.hide(e);\n        break;\n      default:\n        this.defaultAction(e);\n        // Fix for close the popup when select the previously selected value.\n        if (e.action === 'select' && clickedView === this.depth) {\n          this.hide(e);\n        }\n    }\n  }\n  defaultAction(e) {\n    this.previousDate = !isNullOrUndefined(this.value) && new Date(+this.value) || null;\n    if (this.isCalendar()) {\n      super.keyActionHandle(e);\n      if (this.isCalendar()) {\n        attributes(this.inputElement, {\n          'aria-activedescendant': '' + this.setActiveDescendant()\n        });\n      }\n    }\n  }\n  popupUpdate() {\n    if (isNullOrUndefined(this.value) && !isNullOrUndefined(this.previousDate) || +this.value !== +this.previousDate) {\n      if (this.popupObj) {\n        if (this.popupObj.element.querySelectorAll('.' + SELECTED$2).length > 0) {\n          removeClass(this.popupObj.element.querySelectorAll('.' + SELECTED$2), [SELECTED$2]);\n        }\n      }\n      if (!isNullOrUndefined(this.value)) {\n        if (+this.value >= +this.min && +this.value <= +this.max) {\n          const targetdate = new Date(this.checkValue(this.value));\n          super.navigateTo('Month', targetdate);\n        }\n      }\n    }\n  }\n  strictModeUpdate() {\n    let format;\n    let formatOptions;\n    if (this.getModuleName() === 'datetimepicker') {\n      format = !isNullOrUndefined(this.formatString) ? this.formatString : this.dateTimeFormat;\n    } else {\n      format = isNullOrUndefined(this.formatString) ? this.formatString : this.formatString.replace('dd', 'd');\n    }\n    if (!isNullOrUndefined(format)) {\n      const len = format.split('M').length - 1;\n      if (len < 3) {\n        format = format.replace('MM', 'M');\n      }\n    }\n    let dateOptions;\n    if (this.getModuleName() === 'datetimepicker') {\n      if (this.calendarMode === 'Gregorian') {\n        dateOptions = {\n          format: !isNullOrUndefined(this.formatString) ? this.formatString : this.dateTimeFormat,\n          type: 'dateTime',\n          skeleton: 'yMd'\n        };\n      } else {\n        dateOptions = {\n          format: !isNullOrUndefined(this.formatString) ? this.formatString : this.dateTimeFormat,\n          type: 'dateTime',\n          skeleton: 'yMd',\n          calendar: 'islamic'\n        };\n      }\n    } else {\n      if (this.calendarMode === 'Gregorian') {\n        formatOptions = {\n          format: format,\n          type: 'dateTime',\n          skeleton: 'yMd'\n        };\n      } else {\n        formatOptions = {\n          format: format,\n          type: 'dateTime',\n          skeleton: 'yMd',\n          calendar: 'islamic'\n        };\n      }\n      dateOptions = formatOptions;\n    }\n    let date;\n    if (typeof this.inputElement.value === 'string') {\n      this.inputElement.value = this.inputElement.value.trim();\n    }\n    if (this.getModuleName() === 'datetimepicker') {\n      if (this.checkDateValue(this.globalize.parseDate(this.inputElement.value, dateOptions))) {\n        date = this.globalize.parseDate(this.inputElement.value, dateOptions);\n      } else {\n        if (this.calendarMode === 'Gregorian') {\n          formatOptions = {\n            type: 'dateTime',\n            skeleton: 'yMd'\n          };\n        } else {\n          formatOptions = {\n            type: 'dateTime',\n            skeleton: 'yMd',\n            calendar: 'islamic'\n          };\n        }\n        date = this.globalize.parseDate(this.inputElement.value, formatOptions);\n      }\n    } else {\n      date = this.globalize.parseDate(this.inputElement.value, dateOptions);\n      date = !isNullOrUndefined(date) && isNaN(+date) ? null : date;\n      if (!isNullOrUndefined(this.formatString) && this.inputElement.value !== '' && this.strictMode) {\n        if ((this.isPopupClicked || !this.isPopupClicked && this.inputElement.value === this.previousElementValue) && this.formatString.indexOf('y') === -1) {\n          date.setFullYear(this.value.getFullYear());\n        }\n      }\n    }\n    // EJ2-35061 - To prevent change event from triggering twice when using strictmode and format property\n    if (this.getModuleName() === 'datepicker' && this.value && !isNaN(+this.value) && date) {\n      date.setHours(this.value.getHours(), this.value.getMinutes(), this.value.getSeconds(), this.value.getMilliseconds());\n    }\n    if (this.strictMode && date) {\n      this.updateInputValue(this.globalize.formatDate(date, dateOptions));\n      if (this.inputElement.value !== this.previousElementValue) {\n        this.setProperties({\n          value: date\n        }, true);\n      }\n    } else if (!this.strictMode) {\n      if (this.inputElement.value !== this.previousElementValue) {\n        this.setProperties({\n          value: date\n        }, true);\n      }\n    }\n    if (this.strictMode && !date && this.inputElement.value === '') {\n      this.setProperties({\n        value: null\n      }, true);\n    }\n    if (isNaN(+this.value)) {\n      this.setProperties({\n        value: null\n      }, true);\n    }\n    if (isNullOrUndefined(this.value)) {\n      this.currentDate = new Date(new Date().setHours(0, 0, 0, 0));\n    }\n  }\n  createCalendar() {\n    this.popupWrapper = this.createElement('div', {\n      className: '' + ROOT$1 + ' ' + POPUPWRAPPER\n    });\n    if (!isNullOrUndefined(this.cssClass)) {\n      this.popupWrapper.className += ' ' + this.cssClass;\n    }\n    if (Browser.isDevice) {\n      this.modelHeader();\n      this.modal = this.createElement('div');\n      this.modal.className = '' + ROOT$1 + ' e-date-modal';\n      document.body.className += ' ' + OVERFLOW;\n      this.modal.style.display = 'block';\n      document.body.appendChild(this.modal);\n    }\n    //this.calendarElement represent the Calendar object from the Calendar class.\n    this.calendarElement.querySelector('table tbody').className = '';\n    this.popupObj = new Popup(this.popupWrapper, {\n      content: this.calendarElement,\n      relateTo: Browser.isDevice ? document.body : this.inputWrapper.container,\n      position: Browser.isDevice ? {\n        X: 'center',\n        Y: 'center'\n      } : {\n        X: 'left',\n        Y: 'bottom'\n      },\n      offsetY: OFFSETVALUE,\n      targetType: 'container',\n      enableRtl: this.enableRtl,\n      zIndex: this.zIndex,\n      collision: Browser.isDevice ? {\n        X: 'fit',\n        Y: 'fit'\n      } : {\n        X: 'flip',\n        Y: 'flip'\n      },\n      open: () => {\n        if (this.getModuleName() !== 'datetimepicker') {\n          if (document.activeElement !== this.inputElement) {\n            this.defaultKeyConfigs = extend(this.defaultKeyConfigs, this.keyConfigs);\n            this.calendarElement.children[1].firstElementChild.focus();\n            this.calendarKeyboardModules = new KeyboardEvents(this.calendarElement.children[1].firstElementChild, {\n              eventName: 'keydown',\n              keyAction: this.calendarKeyActionHandle.bind(this),\n              keyConfigs: this.defaultKeyConfigs\n            });\n            this.calendarKeyboardModules = new KeyboardEvents(this.inputWrapper.container.children[this.index], {\n              eventName: 'keydown',\n              keyAction: this.calendarKeyActionHandle.bind(this),\n              keyConfigs: this.defaultKeyConfigs\n            });\n          }\n        }\n      },\n      close: () => {\n        if (this.isDateIconClicked) {\n          this.inputWrapper.container.children[this.index].focus();\n        }\n        if (this.value) {\n          this.disabledDates();\n        }\n        if (this.popupObj) {\n          this.popupObj.destroy();\n        }\n        this.resetCalendar();\n        detach(this.popupWrapper);\n        this.popupObj = this.popupWrapper = null;\n        this.preventArgs = null;\n        this.calendarKeyboardModules = null;\n        this.setAriaAttributes();\n      },\n      targetExitViewport: () => {\n        if (!Browser.isDevice) {\n          this.hide();\n        }\n      }\n    });\n    this.popupObj.element.className += ' ' + this.cssClass;\n    this.setAriaAttributes();\n  }\n  setAriaDisabled() {\n    if (!this.enabled) {\n      this.inputElement.setAttribute('aria-disabled', 'true');\n      this.inputElement.tabIndex = -1;\n    } else {\n      this.inputElement.setAttribute('aria-disabled', 'false');\n      this.inputElement.setAttribute('tabindex', this.tabIndex);\n    }\n  }\n  modelHeader() {\n    let dateOptions;\n    const modelHeader = this.createElement('div', {\n      className: 'e-model-header'\n    });\n    const yearHeading = this.createElement('h1', {\n      className: 'e-model-year'\n    });\n    const h2 = this.createElement('div');\n    const daySpan = this.createElement('span', {\n      className: 'e-model-day'\n    });\n    const monthSpan = this.createElement('span', {\n      className: 'e-model-month'\n    });\n    if (this.calendarMode === 'Gregorian') {\n      dateOptions = {\n        format: 'y',\n        skeleton: 'dateTime'\n      };\n    } else {\n      dateOptions = {\n        format: 'y',\n        skeleton: 'dateTime',\n        calendar: 'islamic'\n      };\n    }\n    yearHeading.textContent = '' + this.globalize.formatDate(this.value || new Date(), dateOptions);\n    if (this.calendarMode === 'Gregorian') {\n      dateOptions = {\n        format: 'E',\n        skeleton: 'dateTime'\n      };\n    } else {\n      dateOptions = {\n        format: 'E',\n        skeleton: 'dateTime',\n        calendar: 'islamic'\n      };\n    }\n    daySpan.textContent = '' + this.globalize.formatDate(this.value || new Date(), dateOptions) + ', ';\n    if (this.calendarMode === 'Gregorian') {\n      dateOptions = {\n        format: 'MMM d',\n        skeleton: 'dateTime'\n      };\n    } else {\n      dateOptions = {\n        format: 'MMM d',\n        skeleton: 'dateTime',\n        calendar: 'islamic'\n      };\n    }\n    monthSpan.textContent = '' + this.globalize.formatDate(this.value || new Date(), dateOptions);\n    modelHeader.appendChild(yearHeading);\n    h2.appendChild(daySpan);\n    h2.appendChild(monthSpan);\n    modelHeader.appendChild(h2);\n    this.calendarElement.insertBefore(modelHeader, this.calendarElement.firstElementChild);\n  }\n  changeTrigger(event) {\n    if (this.inputElement.value !== this.previousElementValue) {\n      if ((this.previousDate && this.previousDate.valueOf()) !== (this.value && this.value.valueOf())) {\n        if (this.isDynamicValueChanged && this.isCalendar()) {\n          this.popupUpdate();\n        }\n        this.changedArgs.value = this.value;\n        this.changedArgs.event = event || null;\n        this.changedArgs.element = this.element;\n        this.changedArgs.isInteracted = !isNullOrUndefined(event);\n        if (this.isAngular && this.preventChange) {\n          this.preventChange = false;\n        } else {\n          this.trigger('change', this.changedArgs);\n        }\n        this.previousElementValue = this.inputElement.value;\n        this.previousDate = !isNaN(+new Date(this.checkValue(this.value))) ? new Date(this.checkValue(this.value)) : null;\n        this.isInteracted = true;\n      }\n    }\n  }\n  navigatedEvent() {\n    this.trigger('navigated', this.navigatedArgs);\n  }\n  changeEvent(event) {\n    if ((this.previousDate && this.previousDate.valueOf()) !== (this.value && this.value.valueOf())) {\n      this.selectCalendar(event);\n      this.changedArgs.event = event ? event : null;\n      this.changedArgs.element = this.element;\n      this.changedArgs.isInteracted = this.isInteracted;\n      if (!this.isDynamicValueChanged) {\n        this.trigger('change', this.changedArgs);\n      }\n      this.previousDate = this.value && new Date(+this.value);\n      if (!this.isDynamicValueChanged) {\n        this.hide(event);\n      }\n      this.previousElementValue = this.inputElement.value;\n      this.errorClass();\n    }\n  }\n  requiredModules() {\n    const modules = [];\n    if (this) {\n      modules.push({\n        args: [this],\n        member: 'islamic'\n      });\n    }\n    if (this.enableMask) {\n      modules.push({\n        args: [this],\n        member: 'MaskedDateTime'\n      });\n    }\n    return modules;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  selectCalendar(e) {\n    let date;\n    let tempFormat;\n    let formatOptions;\n    if (this.getModuleName() === 'datetimepicker') {\n      tempFormat = !isNullOrUndefined(this.formatString) ? this.formatString : this.dateTimeFormat;\n    } else {\n      tempFormat = this.formatString;\n    }\n    if (this.value) {\n      if (this.getModuleName() === 'datetimepicker') {\n        if (this.calendarMode === 'Gregorian') {\n          formatOptions = {\n            format: tempFormat,\n            type: 'dateTime',\n            skeleton: 'yMd'\n          };\n        } else {\n          formatOptions = {\n            format: tempFormat,\n            type: 'dateTime',\n            skeleton: 'yMd',\n            calendar: 'islamic'\n          };\n        }\n        date = this.globalize.formatDate(this.changedArgs.value, formatOptions);\n      } else {\n        if (this.calendarMode === 'Gregorian') {\n          formatOptions = {\n            format: this.formatString,\n            type: 'dateTime',\n            skeleton: 'yMd'\n          };\n        } else {\n          formatOptions = {\n            format: this.formatString,\n            type: 'dateTime',\n            skeleton: 'yMd',\n            calendar: 'islamic'\n          };\n        }\n        date = this.globalize.formatDate(this.changedArgs.value, formatOptions);\n      }\n      if (this.enableMask) {\n        this.notify(\"createMask\", {\n          module: \"MaskedDateTime\"\n        });\n      }\n    }\n    if (!isNullOrUndefined(date)) {\n      this.updateInputValue(date);\n      if (this.enableMask) {\n        this.notify(\"setMaskSelection\", {\n          module: \"MaskedDateTime\"\n        });\n      }\n    }\n  }\n  isCalendar() {\n    if (this.popupWrapper && this.popupWrapper.classList.contains('' + POPUPWRAPPER)) {\n      return true;\n    }\n    return false;\n  }\n  setWidth(width) {\n    if (typeof width === 'number') {\n      this.inputWrapper.container.style.width = formatUnit(this.width);\n    } else if (typeof width === 'string') {\n      this.inputWrapper.container.style.width = width.match(/px|%|em/) ? this.width : formatUnit(this.width);\n    } else {\n      this.inputWrapper.container.style.width = '100%';\n    }\n  }\n  /* eslint-disable valid-jsdoc, jsdoc/require-param */\n  /**\n   * Shows the Calendar.\n   *\n   * @returns {void}\n   * @deprecated\n   */\n  show(type, e) {\n    if (this.enabled && this.readonly || !this.enabled || this.popupObj) {\n      return;\n    } else {\n      let prevent = true;\n      let outOfRange;\n      if (!isNullOrUndefined(this.value) && !(+this.value >= +this.min && +this.value <= +this.max)) {\n        outOfRange = new Date(this.checkValue(this.value));\n        this.setProperties({\n          'value': null\n        }, true);\n      } else {\n        outOfRange = this.value || null;\n      }\n      if (!this.isCalendar()) {\n        super.render();\n        this.setProperties({\n          'value': outOfRange || null\n        }, true);\n        this.previousDate = outOfRange;\n        this.createCalendar();\n      }\n      if (Browser.isDevice) {\n        this.mobilePopupWrapper = this.createElement('div', {\n          className: 'e-datepick-mob-popup-wrap'\n        });\n        document.body.appendChild(this.mobilePopupWrapper);\n      }\n      this.preventArgs = {\n        preventDefault: () => {\n          prevent = false;\n        },\n        popup: this.popupObj,\n        event: e || null,\n        cancel: false,\n        appendTo: Browser.isDevice ? this.mobilePopupWrapper : document.body\n      };\n      const eventArgs = this.preventArgs;\n      this.trigger('open', eventArgs, eventArgs => {\n        this.preventArgs = eventArgs;\n        if (prevent && !this.preventArgs.cancel) {\n          addClass(this.inputWrapper.buttons, ACTIVE);\n          this.preventArgs.appendTo.appendChild(this.popupWrapper);\n          this.popupObj.refreshPosition(this.inputElement);\n          const openAnimation = {\n            name: 'FadeIn',\n            duration: Browser.isDevice ? 0 : OPENDURATION\n          };\n          if (this.zIndex === 1000) {\n            this.popupObj.show(new Animation(openAnimation), this.element);\n          } else {\n            this.popupObj.show(new Animation(openAnimation), null);\n          }\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          super.setOverlayIndex(this.mobilePopupWrapper, this.popupObj.element, this.modal, Browser.isDevice);\n          this.setAriaAttributes();\n        } else {\n          this.popupObj.destroy();\n          this.popupWrapper = this.popupObj = null;\n        }\n        if (!isNullOrUndefined(this.inputElement) && this.inputElement.value === '') {\n          if (!isNullOrUndefined(this.tableBodyElement) && this.tableBodyElement.querySelectorAll('td.e-selected').length > 0) {\n            addClass([this.tableBodyElement.querySelector('td.e-selected')], FOCUSEDDATE$2);\n            removeClass(this.tableBodyElement.querySelectorAll('td.e-selected'), SELECTED$2);\n          }\n        }\n        EventHandler.add(document, 'mousedown touchstart', this.documentHandler, this);\n      });\n    }\n  }\n  /**\n   * Hide the Calendar.\n   *\n   * @returns {void}\n   * @deprecated\n   */\n  hide(event) {\n    if (!isNullOrUndefined(this.popupWrapper)) {\n      let prevent = true;\n      this.preventArgs = {\n        preventDefault: () => {\n          prevent = false;\n        },\n        popup: this.popupObj,\n        event: event || null,\n        cancel: false\n      };\n      removeClass(this.inputWrapper.buttons, ACTIVE);\n      removeClass([document.body], OVERFLOW);\n      const eventArgs = this.preventArgs;\n      if (this.isCalendar()) {\n        this.trigger('close', eventArgs, eventArgs => {\n          this.closeEventCallback(prevent, eventArgs);\n        });\n      } else {\n        this.closeEventCallback(prevent, eventArgs);\n      }\n    } else {\n      if (Browser.isDevice && this.allowEdit && !this.readonly) {\n        this.inputElement.removeAttribute('readonly');\n      }\n      this.setAllowEdit();\n    }\n  }\n  /* eslint-enable valid-jsdoc, jsdoc/require-param */\n  closeEventCallback(prevent, eventArgs) {\n    this.preventArgs = eventArgs;\n    if (this.isCalendar() && prevent && !this.preventArgs.cancel) {\n      this.popupObj.hide();\n      this.isAltKeyPressed = false;\n      this.keyboardModule.destroy();\n      removeClass(this.inputWrapper.buttons, ACTIVE);\n    }\n    this.setAriaAttributes();\n    if (Browser.isDevice && this.modal) {\n      this.modal.style.display = 'none';\n      this.modal.outerHTML = '';\n      this.modal = null;\n    }\n    if (Browser.isDevice) {\n      if (!isNullOrUndefined(this.mobilePopupWrapper)) {\n        this.mobilePopupWrapper.remove();\n        this.mobilePopupWrapper = null;\n      }\n    }\n    EventHandler.remove(document, 'mousedown touchstart', this.documentHandler);\n    if (Browser.isDevice && this.allowEdit && !this.readonly) {\n      this.inputElement.removeAttribute('readonly');\n    }\n    this.setAllowEdit();\n  }\n  /* eslint-disable jsdoc/require-param */\n  /**\n   * Sets the focus to widget for interaction.\n   *\n   * @returns {void}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  focusIn(triggerEvent) {\n    if (document.activeElement !== this.inputElement && this.enabled) {\n      this.inputElement.focus();\n      addClass([this.inputWrapper.container], [INPUTFOCUS]);\n    }\n  }\n  /* eslint-enable jsdoc/require-param */\n  /**\n   * Remove the focus from widget, if the widget is in focus state.\n   *\n   * @returns {void}\n   */\n  focusOut() {\n    if (document.activeElement === this.inputElement) {\n      removeClass([this.inputWrapper.container], [INPUTFOCUS]);\n      this.inputElement.blur();\n    }\n  }\n  /* eslint-disable valid-jsdoc, jsdoc/require-returns-description */\n  /**\n   * Gets the current view of the DatePicker.\n   *\n   * @returns {string}\n   * @deprecated\n   */\n  currentView() {\n    let currentView;\n    if (this.calendarElement) {\n      // calls the Calendar currentView public method\n      currentView = super.currentView();\n    }\n    return currentView;\n  }\n  /* eslint-enable valid-jsdoc, jsdoc/require-returns-description */\n  /**\n   * Navigates to specified month or year or decade view of the DatePicker.\n   *\n   * @param  {string} view - Specifies the view of the calendar.\n   * @param  {Date} date - Specifies the focused date in a view.\n   * @returns {void}\n   * @deprecated\n   */\n  navigateTo(view, date) {\n    if (this.calendarElement) {\n      // calls the Calendar navigateTo public method\n      super.navigateTo(view, date);\n    }\n  }\n  /**\n   * To destroy the widget.\n   *\n   * @returns {void}\n   */\n  destroy() {\n    this.unBindEvents();\n    super.destroy();\n    this.keyboardModules.destroy();\n    if (this.popupObj && this.popupObj.element.classList.contains(POPUP)) {\n      super.destroy();\n    }\n    const ariaAttrs = {\n      'aria-live': 'assertive',\n      'aria-atomic': 'true',\n      'aria-disabled': 'true',\n      'aria-haspopup': 'true',\n      'aria-activedescendant': 'null',\n      'aria-owns': this.element.id + '_options',\n      'aria-expanded': 'false',\n      'role': 'combobox',\n      'autocomplete': 'off',\n      'autocorrect': 'off',\n      'autocapitalize': 'off',\n      'spellcheck': 'false'\n    };\n    if (this.inputElement) {\n      Input.removeAttributes(ariaAttrs, this.inputElement);\n      if (!isNullOrUndefined(this.inputElementCopy.getAttribute('tabindex'))) {\n        this.inputElement.setAttribute('tabindex', this.tabIndex);\n      } else {\n        this.inputElement.removeAttribute('tabindex');\n      }\n      EventHandler.remove(this.inputElement, 'blur', this.inputBlurHandler);\n      EventHandler.remove(this.inputElement, 'focus', this.inputFocusHandler);\n      this.ensureInputAttribute();\n    }\n    if (this.isCalendar()) {\n      if (this.popupWrapper) {\n        detach(this.popupWrapper);\n      }\n      this.popupObj = this.popupWrapper = null;\n      this.keyboardModule.destroy();\n    }\n    if (this.ngTag === null) {\n      if (this.inputElement) {\n        this.inputWrapper.container.insertAdjacentElement('afterend', this.inputElement);\n        removeClass([this.inputElement], [INPUTROOT]);\n      }\n      removeClass([this.element], [ROOT$1]);\n      detach(this.inputWrapper.container);\n    }\n    if (this.formElement) {\n      EventHandler.remove(this.formElement, 'reset', this.resetFormHandler);\n    }\n  }\n  ensureInputAttribute() {\n    const prop = [];\n    for (let i = 0; i < this.inputElement.attributes.length; i++) {\n      prop[i] = this.inputElement.attributes[i].name;\n    }\n    for (let i = 0; i < prop.length; i++) {\n      if (isNullOrUndefined(this.inputElementCopy.getAttribute(prop[i]))) {\n        if (prop[i].toLowerCase() === 'value') {\n          this.inputElement.value = '';\n        }\n        this.inputElement.removeAttribute(prop[i]);\n      } else {\n        if (prop[i].toLowerCase() === 'value') {\n          this.inputElement.value = this.inputElementCopy.getAttribute(prop[i]);\n        }\n        this.inputElement.setAttribute(prop[i], this.inputElementCopy.getAttribute(prop[i]));\n      }\n    }\n  }\n  /**\n   * Initialize the event handler\n   *\n   * @returns {void}\n   * @private\n   */\n  preRender() {\n    this.inputElementCopy = this.element.cloneNode(true);\n    removeClass([this.inputElementCopy], [ROOT$1, CONTROL, LIBRARY]);\n    this.inputElement = this.element;\n    this.formElement = closest(this.inputElement, 'form');\n    this.index = this.showClearButton ? 2 : 1;\n    this.ngTag = null;\n    if (this.element.tagName === 'EJS-DATEPICKER' || this.element.tagName === 'EJS-DATETIMEPICKER') {\n      this.ngTag = this.element.tagName;\n      this.inputElement = this.createElement('input');\n      this.element.appendChild(this.inputElement);\n    }\n    if (this.element.getAttribute('id')) {\n      if (this.ngTag !== null) {\n        this.inputElement.id = this.element.getAttribute('id') + '_input';\n      }\n    } else {\n      if (this.getModuleName() === 'datetimepicker') {\n        this.element.id = getUniqueID('ej2-datetimepicker');\n        if (this.ngTag !== null) {\n          attributes(this.inputElement, {\n            'id': this.element.id + '_input'\n          });\n        }\n      } else {\n        this.element.id = getUniqueID('ej2-datepicker');\n        if (this.ngTag !== null) {\n          attributes(this.inputElement, {\n            'id': this.element.id + '_input'\n          });\n        }\n      }\n    }\n    if (this.ngTag !== null) {\n      this.validationAttribute(this.element, this.inputElement);\n    }\n    this.updateHtmlAttributeToElement();\n    this.defaultKeyConfigs = this.getDefaultKeyConfig();\n    this.checkHtmlAttributes(false);\n    this.tabIndex = this.element.hasAttribute('tabindex') ? this.element.getAttribute('tabindex') : '0';\n    this.element.removeAttribute('tabindex');\n    super.preRender();\n  }\n  getDefaultKeyConfig() {\n    this.defaultKeyConfigs = {\n      altUpArrow: 'alt+uparrow',\n      altDownArrow: 'alt+downarrow',\n      escape: 'escape',\n      enter: 'enter',\n      controlUp: 'ctrl+38',\n      controlDown: 'ctrl+40',\n      moveDown: 'downarrow',\n      moveUp: 'uparrow',\n      moveLeft: 'leftarrow',\n      moveRight: 'rightarrow',\n      select: 'enter',\n      home: 'home',\n      end: 'end',\n      pageUp: 'pageup',\n      pageDown: 'pagedown',\n      shiftPageUp: 'shift+pageup',\n      shiftPageDown: 'shift+pagedown',\n      controlHome: 'ctrl+home',\n      controlEnd: 'ctrl+end',\n      shiftTab: 'shift+tab',\n      tab: 'tab'\n    };\n    return this.defaultKeyConfigs;\n  }\n  validationAttribute(target, inputElement) {\n    const nameAttribute = target.getAttribute('name') ? target.getAttribute('name') : target.getAttribute('id');\n    inputElement.setAttribute('name', nameAttribute);\n    target.removeAttribute('name');\n    const attribute = ['required', 'aria-required', 'form'];\n    for (let i = 0; i < attribute.length; i++) {\n      if (isNullOrUndefined(target.getAttribute(attribute[i]))) {\n        continue;\n      }\n      const attr = target.getAttribute(attribute[i]);\n      inputElement.setAttribute(attribute[i], attr);\n      target.removeAttribute(attribute[i]);\n    }\n  }\n  checkFormat() {\n    const culture = new Internationalization(this.locale);\n    if (this.format) {\n      if (typeof this.format === 'string') {\n        this.formatString = this.format;\n      } else if (this.format.skeleton !== '' && !isNullOrUndefined(this.format.skeleton)) {\n        const skeletonString = this.format.skeleton;\n        if (this.getModuleName() === 'datetimepicker') {\n          this.formatString = culture.getDatePattern({\n            skeleton: skeletonString,\n            type: 'dateTime'\n          });\n        } else {\n          this.formatString = culture.getDatePattern({\n            skeleton: skeletonString,\n            type: 'date'\n          });\n        }\n      } else {\n        if (this.getModuleName() === 'datetimepicker') {\n          this.formatString = this.dateTimeFormat;\n        } else {\n          this.formatString = null;\n        }\n      }\n    } else {\n      this.formatString = null;\n    }\n  }\n  checkHtmlAttributes(dynamic) {\n    this.globalize = new Internationalization(this.locale);\n    this.checkFormat();\n    this.checkView();\n    const attributes$$1 = dynamic ? isNullOrUndefined(this.htmlAttributes) ? [] : Object.keys(this.htmlAttributes) : ['value', 'min', 'max', 'disabled', 'readonly', 'style', 'name', 'placeholder', 'type'];\n    let options;\n    if (this.getModuleName() === 'datetimepicker') {\n      if (this.calendarMode === 'Gregorian') {\n        options = {\n          format: !isNullOrUndefined(this.formatString) ? this.formatString : this.dateTimeFormat,\n          type: 'dateTime',\n          skeleton: 'yMd'\n        };\n      } else {\n        options = {\n          format: !isNullOrUndefined(this.formatString) ? this.formatString : this.dateTimeFormat,\n          type: 'dateTime',\n          skeleton: 'yMd',\n          calendar: 'islamic'\n        };\n      }\n    } else {\n      if (this.calendarMode === 'Gregorian') {\n        options = {\n          format: this.formatString,\n          type: 'dateTime',\n          skeleton: 'yMd'\n        };\n      } else {\n        options = {\n          format: this.formatString,\n          type: 'dateTime',\n          skeleton: 'yMd',\n          calendar: 'islamic'\n        };\n      }\n    }\n    for (const prop of attributes$$1) {\n      if (!isNullOrUndefined(this.inputElement.getAttribute(prop))) {\n        switch (prop) {\n          case 'disabled':\n            if (isNullOrUndefined(this.datepickerOptions) || this.datepickerOptions['enabled'] === undefined || dynamic) {\n              const enabled = this.inputElement.getAttribute(prop) === 'disabled' || this.inputElement.getAttribute(prop) === '' || this.inputElement.getAttribute(prop) === 'true' ? false : true;\n              this.setProperties({\n                enabled: enabled\n              }, !dynamic);\n            }\n            break;\n          case 'readonly':\n            if (isNullOrUndefined(this.datepickerOptions) || this.datepickerOptions['readonly'] === undefined || dynamic) {\n              const readonly = this.inputElement.getAttribute(prop) === 'readonly' || this.inputElement.getAttribute(prop) === '' || this.inputElement.getAttribute(prop) === 'true' ? true : false;\n              this.setProperties({\n                readonly: readonly\n              }, !dynamic);\n            }\n            break;\n          case 'placeholder':\n            if (isNullOrUndefined(this.datepickerOptions) || this.datepickerOptions['placeholder'] === undefined || dynamic) {\n              this.setProperties({\n                placeholder: this.inputElement.getAttribute(prop)\n              }, !dynamic);\n            }\n            break;\n          case 'style':\n            this.inputElement.setAttribute('style', '' + this.inputElement.getAttribute(prop));\n            break;\n          case 'name':\n            this.inputElement.setAttribute('name', '' + this.inputElement.getAttribute(prop));\n            break;\n          case 'value':\n            if (isNullOrUndefined(this.datepickerOptions) || this.datepickerOptions['value'] === undefined || dynamic) {\n              const value = this.inputElement.getAttribute(prop);\n              this.setProperties(setValue(prop, this.globalize.parseDate(value, options), {}), !dynamic);\n            }\n            break;\n          case 'min':\n            if (+this.min === +new Date(1900, 0, 1) || dynamic) {\n              const min = this.inputElement.getAttribute(prop);\n              this.setProperties(setValue(prop, this.globalize.parseDate(min), {}), !dynamic);\n            }\n            break;\n          case 'max':\n            if (+this.max === +new Date(2099, 11, 31) || dynamic) {\n              const max = this.inputElement.getAttribute(prop);\n              this.setProperties(setValue(prop, this.globalize.parseDate(max), {}), !dynamic);\n            }\n            break;\n          case 'type':\n            if (this.inputElement.getAttribute(prop) !== 'text') {\n              this.inputElement.setAttribute('type', 'text');\n            }\n            break;\n        }\n      }\n    }\n  }\n  /**\n   * To get component name.\n   *\n   * @returns {string} Returns the component name.\n   * @private\n   */\n  getModuleName() {\n    return 'datepicker';\n  }\n  disabledDates() {\n    let formatOptions;\n    let globalize;\n    const valueCopy = this.checkDateValue(this.value) ? new Date(+this.value) : new Date(this.checkValue(this.value));\n    const previousValCopy = this.previousDate;\n    //calls the Calendar render method to check the disabled dates through renderDayCell event and update the input value accordingly.\n    this.minMaxUpdates();\n    super.render();\n    this.previousDate = previousValCopy;\n    const date = valueCopy && +valueCopy;\n    const dateIdString = '*[id^=\"/id\"]'.replace('/id', '' + date);\n    if (!this.strictMode) {\n      if (typeof this.value === 'string' || typeof this.value === 'object' && +this.value !== +valueCopy) {\n        this.setProperties({\n          value: valueCopy\n        }, true);\n      }\n    }\n    if (!isNullOrUndefined(this.calendarElement.querySelectorAll(dateIdString)[0])) {\n      if (this.calendarElement.querySelectorAll(dateIdString)[0].classList.contains('e-disabled')) {\n        if (!this.strictMode) {\n          this.currentDate = new Date(new Date().setHours(0, 0, 0, 0));\n        }\n      }\n    }\n    let inputVal;\n    if (this.getModuleName() === 'datetimepicker') {\n      if (this.calendarMode === 'Gregorian') {\n        globalize = this.globalize.formatDate(valueCopy, {\n          format: !isNullOrUndefined(this.formatString) ? this.formatString : this.dateTimeFormat,\n          type: 'dateTime',\n          skeleton: 'yMd'\n        });\n      } else {\n        globalize = this.globalize.formatDate(valueCopy, {\n          format: !isNullOrUndefined(this.formatString) ? this.formatString : this.dateTimeFormat,\n          type: 'dateTime',\n          skeleton: 'yMd',\n          calendar: 'islamic'\n        });\n      }\n      inputVal = globalize;\n    } else {\n      if (this.calendarMode === 'Gregorian') {\n        formatOptions = {\n          format: this.formatString,\n          type: 'dateTime',\n          skeleton: 'yMd'\n        };\n      } else {\n        formatOptions = {\n          format: this.formatString,\n          type: 'dateTime',\n          skeleton: 'yMd',\n          calendar: 'islamic'\n        };\n      }\n      inputVal = this.globalize.formatDate(valueCopy, formatOptions);\n    }\n    if (!this.popupObj) {\n      this.updateInputValue(inputVal);\n      if (this.enableMask) {\n        this.updateInputValue(this.maskedDateValue);\n        this.notify(\"createMask\", {\n          module: \"MaskedDateTime\"\n        });\n      }\n    }\n  }\n  setAriaAttributes() {\n    if (this.isCalendar()) {\n      Input.addAttributes({\n        'aria-expanded': 'true'\n      }, this.inputElement);\n      attributes(this.inputElement, {\n        'aria-activedescendant': '' + this.setActiveDescendant()\n      });\n    } else {\n      Input.addAttributes({\n        'aria-expanded': 'false'\n      }, this.inputElement);\n      attributes(this.inputElement, {\n        'aria-activedescendant': 'null'\n      });\n    }\n  }\n  errorClass() {\n    const dateIdString = '*[id^=\"/id\"]'.replace('/id', '' + +this.value);\n    const isDisabledDate = this.calendarElement && this.calendarElement.querySelectorAll(dateIdString)[0] && this.calendarElement.querySelectorAll(dateIdString)[0].classList.contains('e-disabled');\n    if (!isNullOrUndefined(this.value) && !(+new Date(+this.value).setMilliseconds(0) >= +this.min && +new Date(+this.value).setMilliseconds(0) <= +this.max) || !this.strictMode && this.inputElement.value !== '' && this.inputElement.value !== this.maskedDateValue && isNullOrUndefined(this.value) || isDisabledDate) {\n      addClass([this.inputWrapper.container], ERROR);\n      attributes(this.inputElement, {\n        'aria-invalid': 'true'\n      });\n    } else {\n      removeClass([this.inputWrapper.container], ERROR);\n      attributes(this.inputElement, {\n        'aria-invalid': 'false'\n      });\n    }\n  }\n  /**\n   * Called internally if any of the property value changed.\n   *\n   * @param {DatePickerModel} newProp - Returns the dynamic property value of the component.\n   * @param {DatePickerModel} oldProp - Returns the previous property value of the component.\n   * @returns {void}\n   * @private\n   */\n  onPropertyChanged(newProp, oldProp) {\n    for (const prop of Object.keys(newProp)) {\n      switch (prop) {\n        case 'value':\n          this.isDynamicValueChanged = true;\n          this.isInteracted = false;\n          this.invalidValueString = null;\n          this.checkInvalidValue(newProp.value);\n          newProp.value = this.value;\n          this.previousElementValue = this.inputElement.value;\n          if (isNullOrUndefined(this.value)) {\n            this.updateInputValue('');\n            this.currentDate = new Date(new Date().setHours(0, 0, 0, 0));\n          }\n          this.updateInput(true);\n          if (+this.previousDate !== +this.value) {\n            this.changeTrigger(null);\n          }\n          this.isInteracted = true;\n          this.preventChange = this.isAngular && this.preventChange ? !this.preventChange : this.preventChange;\n          if (this.enableMask) {\n            this.notify(\"createMask\", {\n              module: \"MaskedDateTime\"\n            });\n          }\n          break;\n        case 'format':\n          this.checkFormat();\n          this.bindInputEvent();\n          this.updateInput();\n          if (this.enableMask) {\n            this.notify(\"createMask\", {\n              module: \"MaskedDateTime\"\n            });\n            if (!this.value) {\n              this.updateInputValue(this.maskedDateValue);\n            }\n          }\n          break;\n        case 'allowEdit':\n          this.setAllowEdit();\n          break;\n        case 'placeholder':\n          Input.setPlaceholder(this.placeholder, this.inputElement);\n          break;\n        case 'readonly':\n          Input.setReadonly(this.readonly, this.inputElement);\n          break;\n        case 'enabled':\n          Input.setEnabled(this.enabled, this.inputElement);\n          this.setAriaDisabled();\n          break;\n        case 'htmlAttributes':\n          this.updateHtmlAttributeToElement();\n          this.updateHtmlAttributeToWrapper();\n          this.checkHtmlAttributes(true);\n          break;\n        case 'locale':\n          this.globalize = new Internationalization(this.locale);\n          this.l10n.setLocale(this.locale);\n          this.setProperties({\n            placeholder: this.l10n.getConstant('placeholder')\n          }, true);\n          Input.setPlaceholder(this.placeholder, this.inputElement);\n          this.updateInput();\n          if (this.enableMask) {\n            this.notify(\"createMask\", {\n              module: \"MaskedDateTime\"\n            });\n          }\n          break;\n        case 'enableRtl':\n          Input.setEnableRtl(this.enableRtl, [this.inputWrapper.container]);\n          break;\n        case 'start':\n        case 'depth':\n          this.checkView();\n          if (this.calendarElement) {\n            super.onPropertyChanged(newProp, oldProp);\n          }\n          break;\n        case 'zIndex':\n          this.setProperties({\n            zIndex: newProp.zIndex\n          }, true);\n          break;\n        case 'cssClass':\n          this.updateCssClass(newProp.cssClass, oldProp.cssClass);\n          break;\n        case 'showClearButton':\n          Input.setClearButton(this.showClearButton, this.inputElement, this.inputWrapper);\n          this.bindClearEvent();\n          this.index = this.showClearButton ? 2 : 1;\n          break;\n        case 'strictMode':\n          this.invalidValueString = null;\n          this.updateInput();\n          break;\n        case 'width':\n          this.setWidth(newProp.width);\n          break;\n        case 'floatLabelType':\n          this.floatLabelType = newProp.floatLabelType;\n          Input.removeFloating(this.inputWrapper);\n          Input.addFloating(this.inputElement, this.floatLabelType, this.placeholder);\n          break;\n        case 'enableMask':\n          if (this.enableMask) {\n            this.notify(\"createMask\", {\n              module: \"MaskedDateTime\"\n            });\n            this.updateInputValue(this.maskedDateValue);\n            this.bindInputEvent();\n          } else {\n            if (this.inputElement.value === this.maskedDateValue) {\n              this.updateInputValue('');\n            }\n          }\n          break;\n        default:\n          if (this.calendarElement && this.isCalendar()) {\n            super.onPropertyChanged(newProp, oldProp);\n          }\n          break;\n      }\n      if (!this.isDynamicValueChanged) {\n        this.hide(null);\n      }\n      this.isDynamicValueChanged = false;\n    }\n  }\n};\n__decorate$1([Property(null)], DatePicker.prototype, \"width\", void 0);\n__decorate$1([Property(null)], DatePicker.prototype, \"value\", void 0);\n__decorate$1([Property(null)], DatePicker.prototype, \"cssClass\", void 0);\n__decorate$1([Property(false)], DatePicker.prototype, \"strictMode\", void 0);\n__decorate$1([Property(null)], DatePicker.prototype, \"format\", void 0);\n__decorate$1([Property(true)], DatePicker.prototype, \"enabled\", void 0);\n__decorate$1([Property({})], DatePicker.prototype, \"htmlAttributes\", void 0);\n__decorate$1([Property(null)], DatePicker.prototype, \"values\", void 0);\n__decorate$1([Property(false)], DatePicker.prototype, \"isMultiSelection\", void 0);\n__decorate$1([Property(true)], DatePicker.prototype, \"showClearButton\", void 0);\n__decorate$1([Property(true)], DatePicker.prototype, \"allowEdit\", void 0);\n__decorate$1([Property(null)], DatePicker.prototype, \"keyConfigs\", void 0);\n__decorate$1([Property(false)], DatePicker.prototype, \"enablePersistence\", void 0);\n__decorate$1([Property(1000)], DatePicker.prototype, \"zIndex\", void 0);\n__decorate$1([Property(false)], DatePicker.prototype, \"readonly\", void 0);\n__decorate$1([Property(null)], DatePicker.prototype, \"placeholder\", void 0);\n__decorate$1([Property('Never')], DatePicker.prototype, \"floatLabelType\", void 0);\n__decorate$1([Property(null)], DatePicker.prototype, \"serverTimezoneOffset\", void 0);\n__decorate$1([Property(false)], DatePicker.prototype, \"openOnFocus\", void 0);\n__decorate$1([Property(false)], DatePicker.prototype, \"enableMask\", void 0);\n__decorate$1([Property({\n  day: 'day',\n  month: 'month',\n  year: 'year',\n  hour: 'hour',\n  minute: 'minute',\n  second: 'second',\n  dayOfTheWeek: 'day of the week'\n})], DatePicker.prototype, \"maskPlaceholder\", void 0);\n__decorate$1([Event()], DatePicker.prototype, \"open\", void 0);\n__decorate$1([Event()], DatePicker.prototype, \"cleared\", void 0);\n__decorate$1([Event()], DatePicker.prototype, \"close\", void 0);\n__decorate$1([Event()], DatePicker.prototype, \"blur\", void 0);\n__decorate$1([Event()], DatePicker.prototype, \"focus\", void 0);\n__decorate$1([Event()], DatePicker.prototype, \"created\", void 0);\n__decorate$1([Event()], DatePicker.prototype, \"destroyed\", void 0);\nDatePicker = __decorate$1([NotifyPropertyChanges], DatePicker);\n\n/**\n * Datepicker modules\n */\n\nvar __decorate$2 = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n// eslint-disable-next-line @typescript-eslint/triple-slash-reference\n/// <reference path='../calendar/calendar-model.d.ts'/>\nconst DATERANGEWRAPPER = 'e-date-range-wrapper';\nconst INPUTCONTAINER$1 = 'e-input-group';\nconst DATERANGEICON = 'e-input-group-icon e-range-icon e-icons';\nconst POPUP$1 = 'e-popup';\nconst LEFTCALENDER = 'e-left-calendar';\nconst RIGHTCALENDER = 'e-right-calendar';\nconst LEFTCONTAINER = 'e-left-container';\nconst RIGHTCONTAINER = 'e-right-container';\nconst ROOT$2 = 'e-daterangepicker';\nconst LIBRARY$1 = 'e-lib';\nconst CONTROL$1 = 'e-control';\nconst ERROR$1 = 'e-error';\nconst ACTIVE$1 = 'e-active';\nconst STARTENDCONTAINER = 'e-start-end';\nconst STARTDATE = 'e-start-date';\nconst ENDDATE = 'e-end-date';\nconst STARTBUTTON = 'e-start-btn';\nconst INPUTFOCUS$1 = 'e-input-focus';\nconst ENDBUTTON = 'e-end-btn';\nconst RANGEHOVER = 'e-range-hover';\nconst OTHERMONTH$2 = 'e-other-month';\nconst STARTLABEL = 'e-start-label';\nconst ENDLABEL = 'e-end-label';\nconst DISABLED$2 = 'e-disabled';\nconst SELECTED$3 = 'e-selected';\nconst CALENDAR = 'e-calendar';\nconst NEXTICON$1 = 'e-next';\nconst PREVICON$1 = 'e-prev';\nconst HEADER$1 = 'e-header';\nconst TITLE$1 = 'e-title';\nconst ICONCONTAINER$1 = 'e-icon-container';\nconst RANGECONTAINER = 'e-date-range-container';\nconst RANGEHEADER = 'e-range-header';\nconst PRESETS = 'e-presets';\nconst FOOTER$1 = 'e-footer';\nconst RANGEBORDER = 'e-range-border';\nconst TODAY$2 = 'e-today';\nconst FOCUSDATE = 'e-focused-date';\nconst CONTENT$1 = 'e-content';\nconst DAYSPAN = 'e-day-span';\nconst WEEKNUMBER$2 = 'e-week-number';\nconst DATEDISABLED = 'e-date-disabled';\nconst ICONDISABLED = 'e-icon-disabled';\nconst CALENDARCONTAINER = 'e-calendar-container';\nconst SEPARATOR = 'e-separator';\nconst APPLY = 'e-apply';\nconst CANCEL = 'e-cancel';\nconst DEVICE$1 = 'e-device';\nconst OVERLAY$2 = 'e-overlay';\nconst CHANGEICON = 'e-change-icon e-icons';\nconst LISTCLASS = 'e-list-item';\nconst RTL$1 = 'e-rtl';\nconst HOVER = 'e-hover';\nconst OVERFLOW$1 = 'e-range-overflow';\nconst OFFSETVALUE$1 = 4;\nconst PRIMARY$1 = 'e-primary';\nconst FLAT$1 = 'e-flat';\nconst CSS$1 = 'e-css';\nconst ZOOMIN$1 = 'e-zoomin';\nconst NONEDITABLE = 'e-non-edit';\nconst DAYHEADERLONG$1 = 'e-daterange-day-header-lg';\nconst HIDDENELEMENT = 'e-daterange-hidden';\nconst wrapperAttr = ['title', 'class', 'style'];\nclass Presets extends ChildProperty {}\n__decorate$2([Property()], Presets.prototype, \"label\", void 0);\n__decorate$2([Property()], Presets.prototype, \"start\", void 0);\n__decorate$2([Property()], Presets.prototype, \"end\", void 0);\n/**\n * Represents the DateRangePicker component that allows user to select the date range from the calendar\n * or entering the range through the input element.\n * ```html\n * <input id=\"daterangepicker\"/>\n * ```\n * ```typescript\n * <script>\n *   var dateRangePickerObj = new DateRangePicker({ startDate: new Date(\"05/07/2017\"), endDate: new Date(\"10/07/2017\") });\n *   dateRangePickerObj.appendTo(\"#daterangepicker\");\n * </script>\n * ```\n */\nlet DateRangePicker = class DateRangePicker extends CalendarBase {\n  /**\n   * Constructor for creating the widget\n   *\n   * @param {DateRangePickerModel} options - Specifies the DateRangePicker model.\n   * @param {string | HTMLInputElement} element - Specifies the element to render as component.\n   * @private\n   */\n  constructor(options, element) {\n    super(options, element);\n    this.isCustomRange = false;\n    this.isCustomWindow = false;\n    this.presetsItem = [];\n    this.liCollections = [];\n    this.previousEleValue = '';\n    this.isKeyPopup = false;\n    this.dateDisabled = false;\n    this.isRangeIconClicked = false;\n    this.isMaxDaysClicked = false;\n    this.disabledDays = [];\n    this.preventBlur = false;\n    this.preventFocus = false;\n    this.invalidValueString = null;\n    this.isAngular = false;\n    this.preventChange = false;\n    this.dateRangeOptions = options;\n  }\n  /**\n   * To Initialize the control rendering.\n   *\n   * @returns {void}\n   * @private\n   */\n  render() {\n    this.initialize();\n    this.setProperties({\n      startDate: this.startValue\n    }, true);\n    this.setProperties({\n      endDate: this.endValue\n    }, true);\n    this.setModelValue();\n    this.setDataAttribute(false);\n    if (this.element.hasAttribute('data-val')) {\n      this.element.setAttribute('data-val', 'false');\n    }\n    this.renderComplete();\n  }\n  /**\n   * Initialize the event handler\n   *\n   * @returns {void}\n   * @private\n   */\n  preRender() {\n    this.keyInputConfigs = {\n      altDownArrow: 'alt+downarrow',\n      escape: 'escape',\n      enter: 'enter',\n      tab: 'tab',\n      altRightArrow: 'alt+rightarrow',\n      altLeftArrow: 'alt+leftarrow',\n      moveUp: 'uparrow',\n      moveDown: 'downarrow',\n      spacebar: 'space'\n    };\n    this.defaultConstant = {\n      placeholder: this.placeholder,\n      startLabel: 'Start Date',\n      endLabel: 'End Date',\n      customRange: 'Custom Range',\n      applyText: 'Apply',\n      cancelText: 'Cancel',\n      selectedDays: 'Selected Days',\n      days: 'days'\n    };\n    /**\n     * Mobile View\n     */\n    this.isMobile = window.matchMedia('(max-width:550px)').matches;\n    this.inputElement = this.element;\n    this.angularTag = null;\n    if (this.element.tagName === 'EJS-DATERANGEPICKER') {\n      this.angularTag = this.element.tagName;\n      this.inputElement = this.createElement('input');\n      this.element.appendChild(this.inputElement);\n    }\n    this.cloneElement = this.element.cloneNode(true);\n    removeClass([this.cloneElement], [ROOT$2, CONTROL$1, LIBRARY$1]);\n    this.updateHtmlAttributeToElement();\n    if (this.element.getAttribute('id')) {\n      if (this.angularTag !== null) {\n        this.inputElement.id = this.element.getAttribute('id') + '_input';\n      }\n    } else {\n      this.element.id = getUniqueID('ej2-datetimepicker');\n      if (this.angularTag !== null) {\n        attributes(this.inputElement, {\n          'id': this.element.id + '_input'\n        });\n      }\n    }\n    this.checkInvalidRange(this.value);\n    if (!this.invalidValueString && typeof this.value === 'string') {\n      const rangeArray = this.value.split(' ' + this.separator + ' ');\n      this.value = [new Date(rangeArray[0]), new Date(rangeArray[1])];\n    }\n    this.initProperty();\n    this.tabIndex = this.element.hasAttribute('tabindex') ? this.element.getAttribute('tabindex') : '0';\n    this.element.removeAttribute('tabindex');\n    super.preRender();\n    this.navNextFunction = this.navNextMonth.bind(this);\n    this.navPrevFunction = this.navPrevMonth.bind(this);\n    this.deviceNavNextFunction = this.deviceNavNext.bind(this);\n    this.deviceNavPrevFunction = this.deviceNavPrevious.bind(this);\n    this.initStartDate = this.checkDateValue(this.startValue);\n    this.initEndDate = this.checkDateValue(this.endValue);\n    this.formElement = closest(this.element, 'form');\n  }\n  updateValue() {\n    if (this.value && this.value.length > 0) {\n      if (this.value[0] instanceof Date && !isNaN(+this.value[0])) {\n        this.setProperties({\n          startDate: this.value[0]\n        }, true);\n        this.startValue = this.value[0];\n      } else if (typeof this.value[0] === 'string') {\n        if (+this.value[0] === 0 || isNaN(+new Date(this.checkValue(this.value[0])))) {\n          this.startValue = null;\n          this.setValue();\n        } else {\n          this.setProperties({\n            startDate: new Date(this.checkValue(this.value[0]))\n          }, true);\n          this.startValue = new Date(this.checkValue(this.value[0]));\n        }\n      } else {\n        this.startValue = null;\n        this.setValue();\n      }\n      if (this.value[1] instanceof Date && !isNaN(+this.value[1])) {\n        this.setProperties({\n          endDate: this.value[1]\n        }, true);\n        this.endValue = this.value[1];\n      } else if (typeof this.value[1] === 'string') {\n        if (+this.value[0] === 0 || isNaN(+new Date(this.checkValue(this.value[0])))) {\n          this.setProperties({\n            endDate: null\n          }, true);\n          this.endValue = null;\n          this.setValue();\n        } else {\n          this.setProperties({\n            endDate: new Date(this.checkValue(this.value[1]))\n          }, true);\n          this.endValue = new Date(this.checkValue(this.value[1]));\n          this.setValue();\n        }\n      } else {\n        this.setProperties({\n          endDate: null\n        }, true);\n        this.endValue = null;\n        this.setValue();\n      }\n    } else if (this.value && this.value.start) {\n      if (this.value.start instanceof Date && !isNaN(+this.value.start)) {\n        this.setProperties({\n          startDate: this.value.start\n        }, true);\n        this.startValue = this.value.start;\n      } else if (typeof this.value.start === 'string') {\n        this.setProperties({\n          startDate: new Date(this.checkValue(this.value.start))\n        }, true);\n        this.startValue = new Date(this.checkValue(this.value.start));\n      } else {\n        this.startValue = null;\n        this.setValue();\n      }\n      if (this.value.end instanceof Date && !isNaN(+this.value.end)) {\n        this.setProperties({\n          endDate: this.value.end\n        }, true);\n        this.endValue = this.value.end;\n      } else if (typeof this.value.end === 'string') {\n        this.setProperties({\n          endDate: new Date(this.checkValue(this.value.end))\n        }, true);\n        this.endValue = new Date(this.checkValue(this.value.end));\n        this.setValue();\n      } else {\n        this.setProperties({\n          endDate: null\n        }, true);\n        this.endValue = null;\n        this.setValue();\n      }\n    } else if (isNullOrUndefined(this.value)) {\n      this.endValue = this.checkDateValue(new Date(this.checkValue(this.endDate)));\n      this.startValue = this.checkDateValue(new Date(this.checkValue(this.startDate)));\n      this.setValue();\n    }\n  }\n  initProperty() {\n    this.globalize = new Internationalization(this.locale);\n    this.checkFormat();\n    this.checkView();\n    if (isNullOrUndefined(this.firstDayOfWeek) || this.firstDayOfWeek > 6 || this.firstDayOfWeek < 0) {\n      this.setProperties({\n        firstDayOfWeek: this.globalize.getFirstDayOfWeek()\n      }, true);\n    }\n    this.updateValue();\n  }\n  checkFormat() {\n    if (this.format) {\n      if (typeof this.format === 'string') {\n        this.formatString = this.format;\n      } else if (this.format.skeleton !== '' && !isNullOrUndefined(this.format.skeleton)) {\n        const skeletonString = this.format.skeleton;\n        this.formatString = this.globalize.getDatePattern({\n          skeleton: skeletonString,\n          type: 'date'\n        });\n      } else {\n        this.formatString = null;\n      }\n    } else {\n      this.formatString = null;\n    }\n  }\n  initialize() {\n    if (this.angularTag !== null) {\n      this.validationAttribute(this.element, this.inputElement);\n    }\n    this.checkHtmlAttributes(false);\n    merge(this.defaultKeyConfigs, {\n      shiftTab: 'shift+tab'\n    });\n    const start = this.checkDateValue(new Date(this.checkValue(this.startValue)));\n    this.setProperties({\n      startDate: start\n    }, true); // persist the value propeerty.\n    this.setProperties({\n      endValue: this.checkDateValue(new Date(this.checkValue(this.endValue)))\n    }, true);\n    this.setValue();\n    this.setProperties({\n      min: this.checkDateValue(new Date(this.checkValue(this.min)))\n    }, true);\n    this.setProperties({\n      max: this.checkDateValue(new Date(this.checkValue(this.max)))\n    }, true);\n    this.l10n = new L10n('daterangepicker', this.defaultConstant, this.locale);\n    this.l10n.setLocale(this.locale);\n    this.setProperties({\n      placeholder: this.placeholder || this.l10n.getConstant('placeholder')\n    }, true);\n    this.processPresets();\n    this.createInput();\n    this.updateHtmlAttributeToWrapper();\n    this.setRangeAllowEdit();\n    this.bindEvents();\n  }\n  setDataAttribute(isDynamic) {\n    let attributes$$1 = {};\n    if (!isDynamic) {\n      for (let i = 0; i < this.element.attributes.length; i++) {\n        attributes$$1[this.element.attributes[i].name] = this.element.getAttribute(this.element.attributes[i].name);\n      }\n    } else {\n      attributes$$1 = this.htmlAttributes;\n    }\n    for (const pro of Object.keys(attributes$$1)) {\n      if (pro.indexOf('data') === 0) {\n        this.firstHiddenChild.setAttribute(pro, attributes$$1[pro]);\n        this.secondHiddenChild.setAttribute(pro, attributes$$1[pro]);\n      }\n    }\n  }\n  setRangeAllowEdit() {\n    if (this.allowEdit) {\n      if (!this.readonly) {\n        this.inputElement.removeAttribute('readonly');\n      }\n    } else {\n      attributes(this.inputElement, {\n        'readonly': ''\n      });\n    }\n    this.updateClearIconState();\n  }\n  updateClearIconState() {\n    if (!this.allowEdit && this.inputWrapper && !this.readonly) {\n      if (this.inputElement.value === '') {\n        removeClass([this.inputWrapper.container], [NONEDITABLE]);\n      } else {\n        addClass([this.inputWrapper.container], [NONEDITABLE]);\n      }\n    } else if (this.inputWrapper) {\n      removeClass([this.inputWrapper.container], [NONEDITABLE]);\n    }\n  }\n  validationAttribute(element, input) {\n    const name = element.getAttribute('name') ? element.getAttribute('name') : element.getAttribute('id');\n    input.setAttribute('name', name);\n    element.removeAttribute('name');\n    const attributes$$1 = ['required', 'aria-required', 'form'];\n    for (let i = 0; i < attributes$$1.length; i++) {\n      if (isNullOrUndefined(element.getAttribute(attributes$$1[i]))) {\n        continue;\n      }\n      const attr = element.getAttribute(attributes$$1[i]);\n      input.setAttribute(attributes$$1[i], attr);\n      element.removeAttribute(attributes$$1[i]);\n    }\n  }\n  updateHtmlAttributeToWrapper() {\n    if (!isNullOrUndefined(this.htmlAttributes)) {\n      for (const key of Object.keys(this.htmlAttributes)) {\n        if (wrapperAttr.indexOf(key) > -1) {\n          if (key === 'class') {\n            const updatedClassValue = this.htmlAttributes[key].replace(/\\s+/g, ' ').trim();\n            if (updatedClassValue !== '') {\n              addClass([this.inputWrapper.container], updatedClassValue.split(' '));\n            }\n          } else if (key === 'style') {\n            let dateRangeStyle = this.inputWrapper.container.getAttribute(key);\n            dateRangeStyle = !isNullOrUndefined(dateRangeStyle) ? dateRangeStyle + this.htmlAttributes[key] : this.htmlAttributes[key];\n            this.inputWrapper.container.setAttribute(key, dateRangeStyle);\n          } else {\n            this.inputWrapper.container.setAttribute(key, this.htmlAttributes[key]);\n          }\n        }\n      }\n    }\n  }\n  updateHtmlAttributeToElement() {\n    if (!isNullOrUndefined(this.htmlAttributes)) {\n      for (const key of Object.keys(this.htmlAttributes)) {\n        if (wrapperAttr.indexOf(key) < 0) {\n          this.inputElement.setAttribute(key, this.htmlAttributes[key]);\n        }\n      }\n    }\n  }\n  updateCssClass(cssNewClass, cssOldClass) {\n    if (!isNullOrUndefined(cssOldClass)) {\n      cssOldClass = cssOldClass.replace(/\\s+/g, ' ').trim();\n    }\n    if (!isNullOrUndefined(cssNewClass)) {\n      cssNewClass = cssNewClass.replace(/\\s+/g, ' ').trim();\n    }\n    Input.setCssClass(cssNewClass, [this.inputWrapper.container], cssOldClass);\n    if (this.popupWrapper) {\n      Input.setCssClass(cssNewClass, [this.popupWrapper], cssOldClass);\n    }\n  }\n  processPresets() {\n    this.presetsItem = [];\n    let i = 0;\n    if (!isUndefined(this.presets[0].start && this.presets[0].end && this.presets[0].label)) {\n      for (const range of this.presets) {\n        const id = range.label.replace(/\\s+/g, '') + '_' + ++i;\n        if (typeof range.end === 'string') {\n          this.presetsItem.push({\n            id: id,\n            text: range.label,\n            end: new Date(this.checkValue(range.end)),\n            start: new Date(this.checkValue(range.start))\n          });\n        } else {\n          this.presetsItem.push({\n            id: id,\n            text: range.label,\n            start: range.start,\n            end: range.end\n          });\n        }\n      }\n      const startDate = isNullOrUndefined(this.startValue) ? null : new Date(+this.startValue);\n      const endDate = isNullOrUndefined(this.endValue) ? null : new Date(+this.endValue);\n      this.presetsItem.push({\n        id: 'custom_range',\n        text: this.l10n.getConstant('customRange'),\n        start: startDate,\n        end: endDate\n      });\n      if (!isNullOrUndefined(this.startValue) && !isNullOrUndefined(this.endValue)) {\n        this.isCustomRange = true;\n        this.activeIndex = this.presetsItem.length - 1;\n      }\n    }\n  }\n  bindEvents() {\n    EventHandler.add(this.inputWrapper.buttons[0], 'mousedown', this.rangeIconHandler, this);\n    EventHandler.add(this.inputElement, 'focus', this.inputFocusHandler, this);\n    EventHandler.add(this.inputElement, 'blur', this.inputBlurHandler, this);\n    EventHandler.add(this.inputElement, 'change', this.inputChangeHandler, this);\n    if (this.showClearButton && this.inputWrapper.clearButton) {\n      EventHandler.add(this.inputWrapper.clearButton, 'mousedown', this.resetHandler, this);\n    }\n    if (!this.isMobile) {\n      this.keyInputConfigs = extend(this.keyInputConfigs, this.keyConfigs);\n      this.inputKeyboardModule = new KeyboardEvents(this.inputElement, {\n        eventName: 'keydown',\n        keyAction: this.inputHandler.bind(this),\n        keyConfigs: this.keyInputConfigs\n      });\n    }\n    if (this.formElement) {\n      EventHandler.add(this.formElement, 'reset', this.formResetHandler, this);\n    }\n    if (this.enabled) {\n      this.inputElement.setAttribute('tabindex', this.tabIndex);\n    } else {\n      this.inputElement.tabIndex = -1;\n    }\n  }\n  unBindEvents() {\n    EventHandler.remove(this.inputWrapper.buttons[0], 'mousedown', this.rangeIconHandler);\n    EventHandler.remove(this.inputElement, 'blur', this.inputBlurHandler);\n    EventHandler.remove(this.inputElement, 'focus', this.inputFocusHandler);\n    EventHandler.remove(this.inputElement, 'change', this.inputChangeHandler);\n    if (this.showClearButton && this.inputWrapper.clearButton) {\n      EventHandler.remove(this.inputWrapper.clearButton, 'mousedown touchstart', this.resetHandler);\n    }\n    if (!this.isMobile) {\n      if (!isNullOrUndefined(this.inputKeyboardModule)) {\n        this.inputKeyboardModule.destroy();\n      }\n    }\n    if (this.formElement) {\n      EventHandler.remove(this.formElement, 'reset', this.formResetHandler);\n    }\n    this.inputElement.tabIndex = -1;\n  }\n  updateHiddenInput() {\n    if (this.firstHiddenChild && this.secondHiddenChild) {\n      const format = {\n        type: 'datetime',\n        skeleton: 'yMd'\n      };\n      if (typeof this.startDate === 'string') {\n        this.startDate = this.globalize.parseDate(this.startDate, format);\n      }\n      if (typeof this.endDate === 'string') {\n        this.endDate = this.globalize.parseDate(this.endDate, format);\n      }\n      this.firstHiddenChild.value = this.startDate && this.globalize.formatDate(this.startDate, format) || this.inputElement.value;\n      this.secondHiddenChild.value = this.endDate && this.globalize.formatDate(this.endDate, format) || this.inputElement.value;\n      this.dispatchEvent(this.firstHiddenChild, 'focusout');\n      this.dispatchEvent(this.firstHiddenChild, 'change');\n    }\n  }\n  inputChangeHandler(e) {\n    if (!this.enabled) {\n      return;\n    }\n    e.stopPropagation();\n    this.updateHiddenInput();\n  }\n  bindClearEvent() {\n    if (this.showClearButton && this.inputWrapper.clearButton) {\n      EventHandler.add(this.inputWrapper.clearButton, 'mousedown', this.resetHandler, this);\n    }\n  }\n  resetHandler(e) {\n    if (!this.enabled) {\n      return;\n    }\n    this.valueType = this.value;\n    e.preventDefault();\n    this.clear();\n    const clearedArgs = {\n      event: e\n    };\n    this.setProperties({\n      endDate: this.checkDateValue(this.endValue)\n    }, true);\n    this.setProperties({\n      startDate: this.checkDateValue(this.startValue)\n    }, true);\n    this.trigger('cleared', clearedArgs);\n    this.changeTrigger(e);\n    this.clearRange();\n    this.hide(e);\n  }\n  restoreValue() {\n    this.previousEleValue = this.inputElement.value;\n    this.previousStartValue = this.startValue;\n    this.previousEndValue = this.endValue;\n    this.valueType = null;\n    this.initStartDate = this.checkDateValue(this.startValue);\n    this.initEndDate = this.checkDateValue(this.endValue);\n    this.setValue();\n    this.setModelValue();\n  }\n  formResetHandler(e) {\n    if (!this.enabled) {\n      return;\n    }\n    if (this.formElement && e.target === this.formElement && !this.inputElement.disabled) {\n      let val = this.inputElement.getAttribute('value');\n      if (!isNullOrUndefined(this.startCopy)) {\n        if (!isNullOrUndefined(this.value) && !isNullOrUndefined(this.value.start)) {\n          this.setProperties({\n            value: {\n              start: this.startCopy,\n              end: this.endCopy\n            }\n          }, true);\n          this.startValue = this.value.start;\n          this.endValue = this.value.end;\n        } else {\n          this.setProperties({\n            value: [this.startCopy, this.endCopy]\n          }, true);\n          this.startValue = this.value[0];\n          this.endValue = this.value[1];\n        }\n        this.setProperties({\n          startDate: this.startValue,\n          endDate: this.endValue\n        }, true);\n      } else {\n        this.setProperties({\n          value: null,\n          startDate: null,\n          endDate: null\n        }, true);\n        this.startValue = this.endValue = null;\n      }\n      if (this.element.tagName === 'EJS-DATERANGEPICKER') {\n        this.setProperties({\n          value: null,\n          startDate: null,\n          endDate: null\n        }, true);\n        val = '';\n        this.startValue = this.endValue = null;\n        this.inputElement.setAttribute('value', '');\n      }\n      this.restoreValue();\n      if (this.inputElement) {\n        Input.setValue(val, this.inputElement, this.floatLabelType, this.showClearButton);\n        this.errorClass();\n      }\n    }\n  }\n  clear() {\n    if (this.startValue !== null) {\n      this.startValue = null;\n    }\n    if (this.endValue !== null) {\n      this.endValue = null;\n    }\n    if (this.value && this.value.start) {\n      this.setProperties({\n        value: {\n          start: null,\n          end: null\n        }\n      }, true);\n    }\n    if (this.value !== null && this.value.length > 0) {\n      this.setProperties({\n        value: null\n      }, true);\n    }\n    Input.setValue('', this.inputElement, this.floatLabelType, this.showClearButton);\n    if (!isNullOrUndefined(this.applyButton)) {\n      this.applyButton.disabled = this.applyButton.element.disabled = true;\n    }\n    this.removeSelection();\n  }\n  rangeIconHandler(e) {\n    if (!this.enabled) {\n      return;\n    }\n    if (this.isMobile) {\n      this.inputElement.setAttribute('readonly', '');\n    }\n    e.preventDefault();\n    this.targetElement = null;\n    if (this.isPopupOpen() && document.body.contains(this.popupObj.element)) {\n      this.applyFunction(e);\n    } else {\n      this.isRangeIconClicked = true;\n      this.inputWrapper.container.children[0].focus();\n      this.show(null, e);\n      if (!this.isMobile) {\n        if (!isNullOrUndefined(this.leftCalendar)) {\n          this.isRangeIconClicked = false;\n          this.calendarFocus();\n          this.isRangeIconClicked = true;\n        }\n      }\n      addClass([this.inputWrapper.container], [INPUTFOCUS$1]);\n    }\n  }\n  checkHtmlAttributes(isDynamic) {\n    this.globalize = new Internationalization(this.locale);\n    const attributes$$1 = isDynamic ? isNullOrUndefined(this.htmlAttributes) ? [] : Object.keys(this.htmlAttributes) : ['startDate', 'endDate', 'minDays', 'maxDays', 'min', 'max', 'disabled', 'readonly', 'style', 'name', 'placeholder', 'type', 'value'];\n    const format = {\n      format: this.formatString,\n      type: 'date',\n      skeleton: 'yMd'\n    };\n    for (const prop of attributes$$1) {\n      if (!isNullOrUndefined(this.inputElement.getAttribute(prop))) {\n        switch (prop) {\n          case 'disabled':\n            if (isNullOrUndefined(this.dateRangeOptions) || this.dateRangeOptions['enabled'] === undefined || isDynamic) {\n              const disabled = this.inputElement.getAttribute(prop) === 'disabled' || this.inputElement.getAttribute(prop) === '' || this.inputElement.getAttribute(prop) === 'true' ? true : false;\n              this.setProperties({\n                enabled: !disabled\n              }, !isDynamic);\n            }\n            break;\n          case 'readonly':\n            if (isNullOrUndefined(this.dateRangeOptions) || this.dateRangeOptions['readonly'] === undefined || isDynamic) {\n              const readonly = this.inputElement.getAttribute(prop) === 'readonly' || this.inputElement.getAttribute(prop) === 'true' || this.inputElement.getAttribute(prop) === '' ? true : false;\n              this.setProperties({\n                readonly: readonly\n              }, !isDynamic);\n            }\n            break;\n          case 'placeholder':\n            if (isNullOrUndefined(this.dateRangeOptions) || this.dateRangeOptions['placeholder'] === undefined || isDynamic) {\n              this.setProperties({\n                placeholder: this.inputElement.getAttribute(prop)\n              }, !isDynamic);\n            }\n            break;\n          case 'value':\n            if (isNullOrUndefined(this.dateRangeOptions) || this.dateRangeOptions['value'] === undefined || isDynamic) {\n              const value = this.inputElement.getAttribute(prop);\n              this.setProperties(setValue(prop, value, {}), !isDynamic);\n            }\n            break;\n          case 'style':\n            this.inputElement.setAttribute('style', '' + this.inputElement.getAttribute(prop));\n            break;\n          case 'min':\n            if (isNullOrUndefined(this.min) || +this.min === +new Date(1900, 0, 1) || isDynamic) {\n              const dateValue = this.globalize.parseDate(this.inputElement.getAttribute(prop), format);\n              this.setProperties(setValue(prop, dateValue, {}), !isDynamic);\n            }\n            break;\n          case 'name':\n            this.inputElement.setAttribute('name', '' + this.inputElement.getAttribute(prop));\n            break;\n          case 'max':\n            if (isNullOrUndefined(this.max) || +this.max === +new Date(2099, 11, 31) || isDynamic) {\n              const dateValue = this.globalize.parseDate(this.inputElement.getAttribute(prop), format);\n              this.setProperties(setValue(prop, dateValue, {}), !isDynamic);\n            }\n            break;\n          case 'startDate':\n            if (isNullOrUndefined(this.startDate)) {\n              const dateValue = this.globalize.parseDate(this.inputElement.getAttribute(prop), format);\n              this.startValue = dateValue;\n              this.setValue();\n            }\n            break;\n          case 'endDate':\n            if (isNullOrUndefined(this.endDate)) {\n              const dateValue = this.globalize.parseDate(this.inputElement.getAttribute(prop), format);\n              this.endValue = dateValue;\n              this.setValue();\n            }\n            break;\n          case 'minDays':\n            if (isNullOrUndefined(this.minDays)) {\n              this.setProperties(setValue(prop, parseInt(this.inputElement.getAttribute(prop), 10), {}), true);\n            }\n            break;\n          case 'maxDays':\n            if (isNullOrUndefined(this.maxDays)) {\n              this.setProperties(setValue(prop, parseInt(this.inputElement.getAttribute(prop), 10), {}), true);\n            }\n            break;\n          case 'type':\n            if (this.inputElement.getAttribute(prop) !== 'text') {\n              this.inputElement.setAttribute('type', 'text');\n            }\n            break;\n        }\n      }\n    }\n  }\n  createPopup() {\n    for (let i = 0; i < this.presetsItem.length; i++) {\n      if (i !== this.presetsItem.length - 1 && this.presetsItem[i].id === 'custom_range') {\n        this.presetsItem.splice(i, 1);\n      }\n    }\n    this.activeIndex = this.presetsItem.length - 1;\n    this.isCustomRange = true;\n    for (let i = 0; i <= this.presetsItem.length - 2; i++) {\n      const startDate = this.presetsItem[i].start;\n      const endDate = this.presetsItem[i].end;\n      if (this.startValue && this.endValue) {\n        if (+new Date(startDate.setHours(0, 0, 0, 0)) === +new Date(this.startValue.setHours(0, 0, 0, 0)) && +new Date(endDate.setHours(0, 0, 0, 0)) === +new Date(this.endValue.setHours(0, 0, 0, 0))) {\n          this.activeIndex = i;\n          this.isCustomRange = false;\n        }\n      }\n    }\n    this.popupWrapper = createElement('div', {\n      id: this.element.id + '_popup',\n      className: ROOT$2 + ' ' + POPUP$1\n    });\n    this.adjustLongHeaderWidth();\n    const isPreset = !this.isCustomRange || this.isMobile;\n    if (!isUndefined(this.presets[0].start && this.presets[0].end && this.presets[0].label) && isPreset) {\n      this.isCustomWindow = false;\n      this.createPresets();\n      this.listRippleEffect();\n      this.renderPopup();\n    } else {\n      this.isCustomWindow = true;\n      this.renderControl();\n    }\n  }\n  renderControl() {\n    this.createControl();\n    this.bindCalendarEvents();\n    this.updateRange(this.isMobile ? [this.calendarElement] : [this.leftCalendar, this.rightCalendar]);\n    if (!isNullOrUndefined(this.endValue) && !isNullOrUndefined(this.startValue)) {\n      this.disabledDateRender();\n    }\n    this.updateHeader();\n  }\n  clearCalendarEvents() {\n    EventHandler.clearEvents(this.leftCalPrevIcon);\n    EventHandler.clearEvents(this.leftCalNextIcon);\n    EventHandler.clearEvents(this.rightCalPrevIcon);\n    EventHandler.clearEvents(this.rightCalNextIcon);\n  }\n  updateNavIcons() {\n    super.iconHandler();\n  }\n  calendarIconEvent() {\n    this.clearCalendarEvents();\n    if (this.leftCalPrevIcon && !this.leftCalPrevIcon.classList.contains(DISABLED$2)) {\n      EventHandler.add(this.leftCalPrevIcon, 'mousedown', this.navPrevFunction);\n    }\n    if (this.leftCalNextIcon && !this.leftCalNextIcon.classList.contains(DISABLED$2)) {\n      EventHandler.add(this.leftCalNextIcon, 'mousedown', this.navNextFunction);\n    }\n    if (this.rightCalPrevIcon && !this.rightCalPrevIcon.classList.contains(DISABLED$2)) {\n      EventHandler.add(this.rightCalPrevIcon, 'mousedown', this.navPrevFunction);\n    }\n    if (this.rightCalNextIcon && !this.rightCalNextIcon.classList.contains(DISABLED$2)) {\n      EventHandler.add(this.rightCalNextIcon, 'mousedown', this.navNextFunction);\n    }\n  }\n  bindCalendarEvents() {\n    if (!this.isMobile) {\n      this.updateNavIcons();\n      this.calendarIconEvent();\n      this.calendarIconRipple();\n      this.headerTitleElement = this.popupObj.element.querySelector('.' + RIGHTCALENDER + ' .' + HEADER$1 + ' .' + TITLE$1);\n      this.headerTitleElement = this.popupObj.element.querySelector('.' + LEFTCALENDER + ' .' + HEADER$1 + ' .' + TITLE$1);\n      this.defaultKeyConfigs = extend(this.defaultKeyConfigs, this.keyConfigs);\n      this.leftKeyboardModule = new KeyboardEvents(this.leftCalendar, {\n        eventName: 'keydown',\n        keyAction: this.keyInputHandler.bind(this),\n        keyConfigs: this.defaultKeyConfigs\n      });\n      this.rightKeyboardModule = new KeyboardEvents(this.rightCalendar, {\n        eventName: 'keydown',\n        keyAction: this.keyInputHandler.bind(this),\n        keyConfigs: this.defaultKeyConfigs\n      });\n    } else {\n      this.deviceCalendarEvent();\n      EventHandler.add(this.startButton.element, 'click', this.deviceHeaderClick, this);\n      EventHandler.add(this.endButton.element, 'click', this.deviceHeaderClick, this);\n    }\n    if (this.start === this.depth) {\n      this.bindCalendarCellEvents();\n    }\n    this.removeFocusedDate();\n  }\n  calendarIconRipple() {\n    rippleEffect(this.leftCalPrevIcon, {\n      selector: '.e-prev',\n      duration: 400,\n      isCenterRipple: true\n    });\n    rippleEffect(this.leftCalNextIcon, {\n      selector: '.e-next',\n      duration: 400,\n      isCenterRipple: true\n    });\n    rippleEffect(this.rightCalPrevIcon, {\n      selector: '.e-prev',\n      duration: 400,\n      isCenterRipple: true\n    });\n    rippleEffect(this.rightCalNextIcon, {\n      selector: '.e-next',\n      duration: 400,\n      isCenterRipple: true\n    });\n  }\n  deviceCalendarEvent() {\n    EventHandler.clearEvents(this.nextIcon);\n    EventHandler.clearEvents(this.previousIcon);\n    rippleEffect(this.nextIcon, {\n      selector: '.e-prev',\n      duration: 400,\n      isCenterRipple: true\n    });\n    rippleEffect(this.previousIcon, {\n      selector: '.e-next',\n      duration: 400,\n      isCenterRipple: true\n    });\n    if (this.nextIcon && !this.nextIcon.classList.contains(DISABLED$2)) {\n      EventHandler.add(this.nextIcon, 'mousedown', this.deviceNavNextFunction);\n    }\n    if (this.previousIcon && !this.previousIcon.classList.contains(DISABLED$2)) {\n      EventHandler.add(this.previousIcon, 'mousedown', this.deviceNavPrevFunction);\n    }\n  }\n  deviceNavNext(e) {\n    const calendar = closest(e.target, '.' + CALENDAR);\n    this.updateDeviceCalendar(calendar);\n    this.navigateNext(e);\n    this.deviceNavigation();\n  }\n  deviceNavPrevious(e) {\n    const calendar = closest(e.target, '.' + CALENDAR);\n    this.updateDeviceCalendar(calendar);\n    this.navigatePrevious(e);\n    this.deviceNavigation();\n  }\n  updateDeviceCalendar(calendar) {\n    if (calendar) {\n      this.previousIcon = calendar.querySelector('.' + PREVICON$1);\n      this.nextIcon = calendar.querySelector('.' + NEXTICON$1);\n      this.calendarElement = calendar;\n      this.deviceCalendar = calendar;\n      this.contentElement = calendar.querySelector('.' + CONTENT$1);\n      this.tableBodyElement = select('.' + CONTENT$1 + ' tbody', calendar);\n      this.table = calendar.querySelector('.' + CONTENT$1).getElementsByTagName('table')[0];\n      this.headerTitleElement = calendar.querySelector('.' + HEADER$1 + ' .' + TITLE$1);\n      this.headerElement = calendar.querySelector('.' + HEADER$1);\n    }\n  }\n  deviceHeaderClick(event) {\n    const element = event.currentTarget;\n    if (element.classList.contains(STARTBUTTON) && !isNullOrUndefined(this.startValue)) {\n      this.endButton.element.classList.remove(ACTIVE$1);\n      this.startButton.element.classList.add(ACTIVE$1);\n      const calendar = this.popupObj.element.querySelector('.' + CALENDAR);\n      this.updateDeviceCalendar(calendar);\n      if (isNullOrUndefined(this.calendarElement.querySelector('.' + STARTDATE + ':not(.e-other-month)'))) {\n        this.currentDate = new Date(+this.startValue);\n        remove(this.tableBodyElement);\n        this.createContentBody();\n        this.deviceNavigation();\n      }\n      this.removeClassDisabled();\n    } else if (!isNullOrUndefined(this.startValue) && !isNullOrUndefined(this.endValue)) {\n      this.startButton.element.classList.remove(ACTIVE$1);\n      this.endButton.element.classList.add(ACTIVE$1);\n      const calendar = this.popupObj.element.querySelector('.' + CALENDAR);\n      this.updateDeviceCalendar(calendar);\n      if (isNullOrUndefined(this.calendarElement.querySelector('.' + ENDDATE + ':not(.e-other-month)'))) {\n        this.currentDate = new Date(+this.endValue);\n        remove(this.tableBodyElement);\n        this.createContentBody();\n        this.deviceNavigation();\n      }\n      this.updateMinMaxDays(this.popupObj.element.querySelector('.' + CALENDAR));\n      this.selectableDates();\n    }\n  }\n  inputFocusHandler() {\n    if (!this.enabled) {\n      return;\n    }\n    this.preventBlur = false;\n    const focusArguments = {\n      model: this\n    };\n    if (!this.preventFocus) {\n      this.trigger('focus', focusArguments);\n    }\n    this.updateClearIconState();\n    this.updateHiddenInput();\n    if (this.openOnFocus && !this.preventFocus) {\n      this.preventFocus = true;\n      this.show();\n    } else {\n      this.preventFocus = true;\n    }\n  }\n  inputBlurHandler(e) {\n    if (!this.enabled) {\n      return;\n    }\n    if (!this.preventBlur) {\n      const value = this.inputElement.value;\n      if (!isNullOrUndefined(this.presetsItem)) {\n        if (this.presetsItem.length > 0 && this.previousEleValue !== this.inputElement.value) {\n          this.activeIndex = this.presetsItem.length - 1;\n          this.isCustomRange = true;\n        }\n      }\n      if (!isNullOrUndefined(value) && value.trim() !== '') {\n        const range = value.split(' ' + this.separator + ' ');\n        if (range.length > 1) {\n          this.invalidValueString = null;\n          const dateOptions = {\n            format: this.formatString,\n            type: 'date',\n            skeleton: 'yMd'\n          };\n          const startDate = this.globalize.parseDate(range[0].trim(), dateOptions);\n          const endDate = this.globalize.parseDate(range[1].trim(), dateOptions);\n          if (!isNullOrUndefined(startDate) && !isNaN(+startDate) && !isNullOrUndefined(endDate) && !isNaN(+endDate)) {\n            const prevStartVal = this.startValue;\n            this.startValue = startDate;\n            const prevEndVal = this.endValue;\n            this.endValue = endDate;\n            this.setValue();\n            this.refreshControl();\n            if (value !== this.previousEleValue) {\n              this.changeTrigger(e);\n            }\n            if (!this.preventBlur && document.activeElement !== this.inputElement) {\n              this.preventFocus = false;\n              const blurArguments = {\n                model: this\n              };\n              this.trigger('blur', blurArguments);\n            }\n            this.updateHiddenInput();\n            // For Mobile mode, when a value is present and choose another range and click on console\n            // when popup is open, two startvalues and end values are updated in the popup.\n            if (this.isMobile && this.isPopupOpen()) {\n              this.startValue = prevStartVal;\n              this.endValue = prevEndVal;\n            }\n            return;\n          } else {\n            if (!this.strictMode) {\n              this.startValue = null;\n              this.endValue = null;\n              this.setValue();\n            }\n          }\n        } else {\n          if (!this.strictMode) {\n            this.startValue = null;\n            this.endValue = null;\n            this.setValue();\n          }\n        }\n      }\n      if (!this.strictMode) {\n        if (isNullOrUndefined(this.popupObj)) {\n          this.currentDate = null;\n        }\n        this.previousStartValue = this.previousEndValue = null;\n        this.startValue = null;\n        this.endValue = null;\n        this.setValue();\n      } else {\n        if (!isNullOrUndefined(value) && value.trim() === '') {\n          this.startValue = null;\n          this.endValue = null;\n        }\n        Input.setValue('', this.inputElement, this.floatLabelType, this.showClearButton);\n        this.updateInput();\n      }\n      this.errorClass();\n      this.changeTrigger(e);\n      if (!this.preventBlur && document.activeElement !== this.inputElement) {\n        this.preventFocus = false;\n        const blurArguments = {\n          model: this\n        };\n        this.trigger('blur', blurArguments);\n      }\n    }\n    this.updateHiddenInput();\n  }\n  clearRange() {\n    this.previousStartValue = this.previousEndValue = null;\n    this.currentDate = null;\n  }\n  errorClass() {\n    const inputStr = this.inputElement.value.trim();\n    if ((isNullOrUndefined(this.endValue) && isNullOrUndefined(this.startValue) && inputStr !== '' || !isNullOrUndefined(this.startValue) && +this.startValue < +this.min || !isNullOrUndefined(this.startValue) && !isNullOrUndefined(this.endValue) && +this.startValue > +this.endValue || !isNullOrUndefined(this.endValue) && +this.endValue > +this.max || this.startValue && this.isDateDisabled(this.startValue) || this.endValue && this.isDateDisabled(this.endValue)) && inputStr !== '') {\n      addClass([this.inputWrapper.container], ERROR$1);\n      attributes(this.inputElement, {\n        'aria-invalid': 'true'\n      });\n    } else {\n      if (this.inputWrapper) {\n        removeClass([this.inputWrapper.container], ERROR$1);\n        attributes(this.inputElement, {\n          'aria-invalid': 'false'\n        });\n      }\n    }\n  }\n  keyCalendarUpdate(isLeftCalendar, ele) {\n    this.removeFocusedDate();\n    if (isLeftCalendar) {\n      this.leftCalCurrentDate = new Date(+this.currentDate);\n      ele = this.leftCalendar;\n    } else {\n      this.rightCalCurrentDate = new Date(+this.currentDate);\n      ele = this.rightCalendar;\n    }\n    this.updateCalendarElement(ele);\n    this.table.focus();\n    return ele;\n  }\n  navInCalendar(e, isLeftCalendar, leftLimit, rightLimit, ele) {\n    const view = this.getViewNumber(this.currentView());\n    let date;\n    const min = this.min;\n    let max;\n    if (!isNullOrUndefined(this.maxDays) && this.isMaxDaysClicked && !isNullOrUndefined(this.startValue)) {\n      max = new Date(new Date(+this.startValue).setDate(this.startValue.getDate() + (this.maxDays - 1)));\n    } else {\n      max = this.max;\n    }\n    switch (e.action) {\n      case 'moveRight':\n        date = new Date(+this.currentDate);\n        this.addDay(date, 1, e, max, min);\n        if (isLeftCalendar && +date === +rightLimit) {\n          ele = this.keyCalendarUpdate(false, ele);\n        }\n        this.keyboardNavigate(1, view, e, max, min);\n        this.keyNavigation(ele, e);\n        break;\n      case 'moveLeft':\n        date = new Date(+this.currentDate);\n        this.addDay(date, -1, e, max, min);\n        if (!isLeftCalendar) {\n          if (+date === +leftLimit) {\n            ele = this.keyCalendarUpdate(true, ele);\n          }\n        }\n        this.keyboardNavigate(-1, view, e, max, min);\n        this.keyNavigation(ele, e);\n        break;\n      case 'moveUp':\n        if (view === 0) {\n          date = new Date(+this.currentDate);\n          this.addDay(date, -7, e, max, min);\n          if (+date <= +leftLimit && !isLeftCalendar) {\n            ele = this.keyCalendarUpdate(true, ele);\n          }\n          this.keyboardNavigate(-7, view, e, max, min);\n        } else {\n          this.keyboardNavigate(-4, view, e, this.max, this.min); // move the current year to the previous four days.\n        }\n\n        this.keyNavigation(ele, e);\n        break;\n      case 'moveDown':\n        if (view === 0) {\n          date = new Date(+this.currentDate);\n          this.addDay(date, 7, e, max, min);\n          if (isLeftCalendar && +date >= +rightLimit) {\n            ele = this.keyCalendarUpdate(false, ele);\n          }\n          this.keyboardNavigate(7, view, e, max, min);\n        } else {\n          this.keyboardNavigate(4, view, e, this.max, this.min);\n        }\n        this.keyNavigation(ele, e);\n        break;\n      case 'home':\n        this.currentDate = this.firstDay(this.currentDate);\n        remove(this.tableBodyElement);\n        if (view === 0) {\n          this.renderMonths(e);\n        } else if (view === 1) {\n          this.renderYears(e);\n        } else {\n          this.renderDecades(e);\n        }\n        this.keyNavigation(ele, e);\n        break;\n      case 'end':\n        this.currentDate = this.lastDay(this.currentDate, view);\n        remove(this.tableBodyElement);\n        if (view === 0) {\n          this.renderMonths(e);\n        } else if (view === 1) {\n          this.renderYears(e);\n        } else {\n          this.renderDecades(e);\n        }\n        this.keyNavigation(ele, e);\n        break;\n    }\n  }\n  keyInputHandler(e, value) {\n    let date;\n    let view = this.getViewNumber(this.currentView());\n    const rightDateLimit = new Date(this.rightCalCurrentDate.getFullYear(), this.rightCalCurrentDate.getMonth(), 1);\n    const leftDateLimit = new Date(this.leftCalCurrentDate.getFullYear(), this.leftCalCurrentDate.getMonth() + 1, 0);\n    let ele = closest(e.target, '.' + RIGHTCALENDER);\n    ele = isNullOrUndefined(ele) ? this.leftCalendar : ele;\n    const isLeftCalendar = ele.classList.contains(LEFTCALENDER);\n    this.updateCalendarElement(ele);\n    const selectedDate = this.tableBodyElement.querySelector('tr td.e-selected');\n    const focusedDate = ele.querySelector('tr td.' + FOCUSDATE);\n    const startDate = ele.querySelector('tr td.' + STARTDATE);\n    const endDate = ele.querySelector('tr td.' + ENDDATE);\n    const depthValue = this.getViewNumber(this.depth);\n    const levelRestrict = view === depthValue && this.getViewNumber(this.start) >= depthValue;\n    const leftCalendar = closest(e.target, '.' + LEFTCALENDER);\n    const rightCalendar = closest(e.target, '.' + RIGHTCALENDER);\n    const presetElement = closest(e.target, '.' + PRESETS);\n    if (!isNullOrUndefined(focusedDate)) {\n      // eslint-disable-next-line no-self-assign\n      this.currentDate = this.currentDate;\n    } else if (!isNullOrUndefined(endDate) && !this.dateDisabled) {\n      this.currentDate = new Date(+this.endValue);\n    } else if (!isNullOrUndefined(startDate) && !this.dateDisabled) {\n      this.currentDate = new Date(+this.startValue);\n    } else if (!this.dateDisabled) {\n      this.currentDate.setDate(1);\n    }\n    this.effect = '';\n    switch (e.action) {\n      case 'altUpArrow':\n        if (this.isPopupOpen()) {\n          this.hide(e);\n          this.preventFocus = true;\n          this.inputElement.focus();\n          addClass([this.inputWrapper.container], [INPUTFOCUS$1]);\n        }\n        break;\n      case 'select':\n        if (levelRestrict) {\n          const element = !isNullOrUndefined(focusedDate) ? focusedDate : startDate;\n          if (!isNullOrUndefined(element) && !element.classList.contains(DISABLED$2)) {\n            this.selectRange(null, element);\n          }\n        } else {\n          if (!isNullOrUndefined(selectedDate) && !levelRestrict || !isNullOrUndefined(focusedDate)) {\n            if (!isNullOrUndefined(this.value)) {\n              if (this.calendarElement.classList.contains(LEFTCALENDER)) {\n                value = this.startDate;\n              } else {\n                value = this.endDate;\n              }\n            }\n            this.controlDown = e;\n            this.contentClick(null, --view, focusedDate || selectedDate, value);\n          }\n        }\n        e.preventDefault();\n        break;\n      case 'controlHome':\n        {\n          const yearDate = new Date(this.currentDate.getFullYear(), 0, 1);\n          if (!isLeftCalendar && +yearDate < +leftDateLimit) {\n            ele = this.keyCalendarUpdate(true, ele);\n          }\n          super.navigateTo.call(this, 'Month', new Date(this.currentDate.getFullYear(), 0, 1));\n          this.keyNavigation(ele, e);\n        }\n        break;\n      case 'altRightArrow':\n        if (!isNullOrUndefined(leftCalendar)) {\n          this.rightCalendar.children[1].firstElementChild.focus();\n        } else if (!isNullOrUndefined(rightCalendar)) {\n          if (!isNullOrUndefined(this.presetElement)) {\n            this.presetElement.focus();\n            this.removeFocusedDate();\n          } else {\n            this.cancelButton.element.focus();\n          }\n        } else {\n          if (!isNullOrUndefined(presetElement)) {\n            this.cancelButton.element.focus();\n          }\n        }\n        e.preventDefault();\n        break;\n      case 'altLeftArrow':\n        if (!isNullOrUndefined(leftCalendar)) {\n          if (this.applyButton.element.disabled !== true) {\n            this.applyButton.element.focus();\n          } else {\n            this.cancelButton.element.focus();\n          }\n        } else {\n          if (!isNullOrUndefined(rightCalendar)) {\n            this.leftCalendar.children[1].firstElementChild.focus();\n          }\n        }\n        e.preventDefault();\n        break;\n      case 'controlUp':\n        if (this.calendarElement.classList.contains(LEFTCALENDER)) {\n          this.calendarNavigation(e, this.calendarElement);\n        } else {\n          this.calendarNavigation(e, this.calendarElement);\n        }\n        e.preventDefault();\n        break;\n      case 'controlDown':\n        if ((!isNullOrUndefined(selectedDate) || !isNullOrUndefined(focusedDate)) && !levelRestrict) {\n          if (!isNullOrUndefined(this.value)) {\n            if (this.calendarElement.classList.contains(LEFTCALENDER)) {\n              value = this.startDate;\n            } else {\n              value = this.endDate;\n            }\n          }\n          this.controlDown = e;\n          this.contentClick(null, --view, selectedDate || focusedDate, value);\n        }\n        e.preventDefault();\n        break;\n      case 'controlEnd':\n        {\n          const yearDate = new Date(this.currentDate.getFullYear(), 11, 31);\n          if (isLeftCalendar && +yearDate > +rightDateLimit) {\n            ele = this.keyCalendarUpdate(false, ele);\n          }\n          super.navigateTo.call(this, 'Month', new Date(this.currentDate.getFullYear(), 11, 31));\n          this.keyNavigation(ele, e);\n        }\n        break;\n      case 'pageUp':\n        date = new Date(+this.currentDate);\n        this.addMonths(date, -1);\n        if (!isLeftCalendar && +date <= +leftDateLimit) {\n          ele = this.keyCalendarUpdate(true, ele);\n        }\n        this.addMonths(this.currentDate, -1);\n        super.navigateTo.call(this, 'Month', this.currentDate);\n        this.keyNavigation(ele, e);\n        break;\n      case 'pageDown':\n        date = new Date(+this.currentDate);\n        this.addMonths(date, 1);\n        if (isLeftCalendar && +date >= +rightDateLimit) {\n          ele = this.keyCalendarUpdate(false, ele);\n        }\n        this.addMonths(this.currentDate, 1);\n        super.navigateTo.call(this, 'Month', this.currentDate);\n        this.keyNavigation(ele, e);\n        break;\n      case 'shiftPageUp':\n        date = new Date(+this.currentDate);\n        this.addYears(date, -1);\n        if (!isLeftCalendar && +date <= +leftDateLimit) {\n          ele = this.keyCalendarUpdate(true, ele);\n        }\n        this.addYears(this.currentDate, -1);\n        super.navigateTo.call(this, 'Month', this.currentDate);\n        this.keyNavigation(ele, e);\n        break;\n      case 'shiftPageDown':\n        date = new Date(+this.currentDate);\n        this.addYears(date, 1);\n        if (isLeftCalendar && +date >= +rightDateLimit) {\n          ele = this.keyCalendarUpdate(false, ele);\n        }\n        this.addYears(this.currentDate, 1);\n        super.navigateTo.call(this, 'Month', this.currentDate);\n        this.keyNavigation(ele, e);\n        break;\n      case 'shiftTab':\n        if (!isNullOrUndefined(this.presetElement)) {\n          this.presetElement.setAttribute('tabindex', '0');\n          this.presetElement.focus();\n          this.removeFocusedDate();\n        }\n        e.preventDefault();\n        break;\n      case 'spacebar':\n        if (this.applyButton && !this.applyButton.disabled) {\n          this.applyFunction(e);\n        }\n        break;\n      default:\n        this.navInCalendar(e, isLeftCalendar, leftDateLimit, rightDateLimit, ele);\n        this.checkMinMaxDays();\n    }\n    this.presetHeight();\n  }\n  keyNavigation(calendar, e) {\n    this.bindCalendarCellEvents(calendar);\n    if (calendar.classList.contains(LEFTCALENDER)) {\n      this.leftCalCurrentDate = new Date(+this.currentDate);\n    } else {\n      this.rightCalCurrentDate = new Date(+this.currentDate);\n    }\n    this.updateNavIcons();\n    this.calendarIconEvent();\n    this.updateRange([calendar]);\n    this.dateDisabled = this.isDateDisabled(this.currentDate);\n    e.preventDefault();\n  }\n  inputHandler(e) {\n    switch (e.action) {\n      case 'altDownArrow':\n        if (!this.isPopupOpen()) {\n          if (this.inputElement.value === '') {\n            this.clear();\n            this.changeTrigger(e);\n            this.clearRange();\n          }\n          this.show(null, e);\n          this.isRangeIconClicked = false;\n          if (!this.isMobile) {\n            if (!isNullOrUndefined(this.leftCalendar)) {\n              this.calendarFocus();\n            }\n          }\n          this.isKeyPopup = true;\n        }\n        break;\n      case 'escape':\n        if (this.isPopupOpen()) {\n          this.hide(e);\n        }\n        break;\n      case 'enter':\n        if (document.activeElement === this.inputElement) {\n          this.inputBlurHandler(e);\n          this.hide(e);\n        }\n        break;\n      case 'tab':\n        if (document.activeElement === this.inputElement && this.isPopupOpen()) {\n          this.hide(e);\n          e.preventDefault();\n        }\n        break;\n    }\n  }\n  bindCalendarCellEvents(calendar) {\n    let tdCells;\n    if (calendar) {\n      tdCells = calendar.querySelectorAll('.' + CALENDAR + ' td');\n    } else {\n      tdCells = this.popupObj.element.querySelectorAll('.' + CALENDAR + ' td');\n    }\n    for (const cell of tdCells) {\n      EventHandler.clearEvents(cell);\n      const disabledCell = cell.classList.contains(DISABLED$2) || cell.classList.contains(DATEDISABLED);\n      if (!disabledCell && !cell.classList.contains(WEEKNUMBER$2)) {\n        if (!this.isMobile) {\n          EventHandler.add(cell, 'mouseover', this.hoverSelection, this);\n        }\n        EventHandler.add(cell, 'mousedown', this.selectRange, this);\n      }\n    }\n  }\n  removeFocusedDate() {\n    const isDate = !isNullOrUndefined(this.startValue) || !isNullOrUndefined(this.endValue);\n    const focusedDate = this.popupObj.element.querySelectorAll('.' + CALENDAR + ' .' + FOCUSDATE);\n    for (const ele of focusedDate) {\n      const today = new Date();\n      const eleDate = this.getIdValue(null, ele);\n      if (this.depth === 'Month' && this.currentView() === 'Month' && (!ele.classList.contains(TODAY$2) || ele.classList.contains(TODAY$2) && isDate) || this.depth === 'Year' && this.currentView() === 'Year' && (!this.isSameMonth(today, eleDate) && !this.isSameYear(today, eleDate) || isDate) || this.depth === 'Decade' && this.currentView() === 'Decade' && (!this.isSameYear(today, eleDate) || isDate)) {\n        ele.classList.remove(FOCUSDATE);\n        if (!ele.classList.contains(STARTDATE) && !ele.classList.contains(ENDDATE)) {\n          ele.removeAttribute('aria-label');\n        }\n      }\n    }\n  }\n  hoverSelection(event, element) {\n    const currentElement = element || event.currentTarget;\n    const currentDate = this.getIdValue(null, currentElement);\n    if (!isNullOrUndefined(this.startValue) && +this.startValue >= +this.min && +this.startValue <= +this.max) {\n      if (!this.isDateDisabled(this.endValue) && !this.isDateDisabled(this.startValue) && isNullOrUndefined(this.endValue) && isNullOrUndefined(this.startValue) || !isNullOrUndefined(this.startValue) && isNullOrUndefined(this.endValue)) {\n        const tdCells = this.popupObj.element.querySelectorAll('.' + CALENDAR + ' td');\n        for (const ele of tdCells) {\n          const isDisabledCell = !ele.classList.contains(DISABLED$2) || ele.classList.contains(DATEDISABLED);\n          if (!ele.classList.contains(WEEKNUMBER$2) && isDisabledCell) {\n            const eleDate = this.getIdValue(null, ele);\n            const startDateValue = new Date(+this.startValue);\n            const eleDateValue = new Date(+eleDate);\n            if (eleDateValue.setHours(0, 0, 0, 0) >= startDateValue.setHours(0, 0, 0, 0) && +eleDate <= +currentDate) {\n              addClass([ele], RANGEHOVER);\n            } else {\n              removeClass([ele], [RANGEHOVER]);\n            }\n          }\n        }\n      }\n    }\n  }\n  isSameStartEnd(startVal, endVal) {\n    let isSame = false;\n    if (this.depth === 'Month') {\n      if (startVal.setHours(0, 0, 0, 0) === endVal.setHours(0, 0, 0, 0)) {\n        isSame = true;\n      }\n    } else if (this.depth === 'Year') {\n      if (startVal.getFullYear() === endVal.getFullYear() && startVal.getMonth() === endVal.getMonth()) {\n        isSame = true;\n      }\n    } else if (this.depth === 'Decade') {\n      if (startVal.getFullYear() === endVal.getFullYear()) {\n        isSame = true;\n      }\n    }\n    return isSame;\n  }\n  updateRange(elementCollection) {\n    if (!isNullOrUndefined(this.startValue)) {\n      for (const calendar of elementCollection) {\n        const tdCells = calendar.querySelectorAll('.' + CALENDAR + ' td');\n        for (const ele of tdCells) {\n          if (!ele.classList.contains(WEEKNUMBER$2) && !ele.classList.contains(DISABLED$2)) {\n            const eleDate = this.getIdValue(null, ele);\n            const eleDateValue = this.getIdValue(null, ele);\n            if (!isNullOrUndefined(this.endValue)) {\n              if (this.currentView() === this.depth && +eleDateValue.setHours(0, 0, 0, 0) >= +new Date(+this.startValue).setHours(0, 0, 0, 0) && +eleDateValue.setHours(0, 0, 0, 0) <= +new Date(+this.endValue).setHours(0, 0, 0, 0) && !this.isSameStartEnd(new Date(+this.startValue), new Date(+this.endValue)) && +new Date(+this.startValue).setHours(0, 0, 0, 0) >= +this.min && +new Date(+this.endValue).setHours(0, 0, 0, 0) <= +this.max && !(this.isDateDisabled(this.startValue) || this.isDateDisabled(this.endValue))) {\n                addClass([ele], RANGEHOVER);\n              }\n            } else {\n              removeClass([ele], [RANGEHOVER]);\n            }\n            if (ele.classList.contains(SELECTED$3) && ele.classList.contains(ENDDATE) && +eleDateValue !== +this.endValue) {\n              removeClass([ele], [SELECTED$3]);\n              removeClass([ele], [ENDDATE]);\n            }\n            if (ele.classList.contains(RANGEHOVER) && +eleDateValue > +this.endValue) {\n              removeClass([ele], [RANGEHOVER]);\n            }\n            if (!ele.classList.contains(OTHERMONTH$2)) {\n              const startDateValue = new Date(+this.startValue);\n              let eleDateValue = new Date(+eleDate);\n              if (this.currentView() === this.depth && +eleDateValue.setHours(0, 0, 0, 0) === +startDateValue.setHours(0, 0, 0, 0) && +eleDateValue.setHours(0, 0, 0, 0) >= +startDateValue.setHours(0, 0, 0, 0) && +this.startValue >= +this.min && !this.inputWrapper.container.classList.contains('e-error') && !(this.isDateDisabled(this.startValue) || this.isDateDisabled(this.endValue))) {\n                addClass([ele], [STARTDATE, SELECTED$3]);\n                this.addSelectedAttributes(ele, this.startValue, true);\n              }\n              const endDateValue = new Date(+this.endValue);\n              if (this.currentView() === 'Year') {\n                eleDateValue = new Date(eleDateValue.getFullYear(), eleDateValue.getMonth() + 1, 0);\n              } else if (this.currentView() === 'Decade') {\n                eleDateValue = new Date(eleDateValue.getFullYear(), 11, 31);\n              }\n              if (this.currentView() === this.depth && !isNullOrUndefined(this.endValue) && +eleDateValue.setHours(0, 0, 0, 0) === +endDateValue.setHours(0, 0, 0, 0) && +eleDateValue.setHours(0, 0, 0, 0) <= +endDateValue.setHours(0, 0, 0, 0) && +this.startValue >= +this.min && !this.inputWrapper.container.classList.contains('e-error') && !(this.isDateDisabled(this.startValue) || this.isDateDisabled(this.endValue))) {\n                addClass([ele], [ENDDATE, SELECTED$3]);\n                this.addSelectedAttributes(ele, this.startValue, false);\n              }\n              if (+eleDate === +this.startValue && !isNullOrUndefined(this.endValue) && +eleDate === +this.endValue) {\n                this.addSelectedAttributes(ele, this.endValue, false, true);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  checkMinMaxDays() {\n    if (!isNullOrUndefined(this.minDays) && this.minDays > 0 || !isNullOrUndefined(this.maxDays) && this.maxDays > 0) {\n      if (!this.isMobile) {\n        this.updateMinMaxDays(this.popupObj.element.querySelector('.' + LEFTCALENDER));\n        this.updateMinMaxDays(this.popupObj.element.querySelector('.' + RIGHTCALENDER));\n      } else {\n        this.updateMinMaxDays(this.popupObj.element.querySelector('.' + CALENDAR));\n      }\n    }\n  }\n  rangeArgs(e) {\n    let inputValue;\n    let range;\n    const startDate = !isNullOrUndefined(this.startValue) ? this.globalize.formatDate(this.startValue, {\n      format: this.formatString,\n      type: 'date',\n      skeleton: 'yMd'\n    }) : null;\n    const endDate = !isNullOrUndefined(this.endValue) ? this.globalize.formatDate(this.endValue, {\n      format: this.formatString,\n      type: 'date',\n      skeleton: 'yMd'\n    }) : null;\n    if (!isNullOrUndefined(this.endValue) && !isNullOrUndefined(this.startValue)) {\n      inputValue = startDate + ' ' + this.separator + ' ' + endDate;\n      range = Math.round(Math.abs((this.removeTimeValueFromDate(this.startValue).getTime() - this.removeTimeValueFromDate(this.endValue).getTime()) / (1000 * 60 * 60 * 24))) + 1;\n    } else {\n      inputValue = '';\n      range = 0;\n    }\n    const args = {\n      value: this.value,\n      startDate: this.startValue,\n      endDate: this.endValue,\n      daySpan: range,\n      event: e || null,\n      element: this.element,\n      isInteracted: !isNullOrUndefined(e),\n      text: inputValue\n    };\n    return args;\n  }\n  otherMonthSelect(ele, isStartDate, sameDate) {\n    const value = +this.getIdValue(null, ele);\n    const dateIdString = '*[id^=\"/id\"]:not(.e-other-month)'.replace('/id', '' + value);\n    const tdCell = this.popupObj && this.popupObj.element.querySelector(dateIdString);\n    if (!isNullOrUndefined(tdCell)) {\n      if (isStartDate) {\n        addClass([tdCell], [STARTDATE, SELECTED$3]);\n        this.addSelectedAttributes(tdCell, this.startValue, true);\n      } else {\n        addClass([tdCell], [ENDDATE, SELECTED$3]);\n        this.addSelectedAttributes(tdCell, this.endValue, true);\n      }\n      if (sameDate) {\n        this.addSelectedAttributes(ele, this.endValue, false, true);\n      }\n    }\n  }\n  selectRange(event, element) {\n    let leftCalendar;\n    let rightCalendar;\n    if (event) {\n      event.preventDefault();\n    }\n    const date = isNullOrUndefined(event) ? this.getIdValue(null, element) : this.getIdValue(event, null);\n    const y = date.getFullYear();\n    const m = date.getMonth();\n    const firstDay = new Date(y, m, 1);\n    const lastDay = new Date(y, m + 1, 0);\n    const firstMonth = new Date(y, 0, 1);\n    const lastMonth = new Date(y, 11, 31);\n    if (!isNullOrUndefined(this.endValue) && !isNullOrUndefined(this.startValue)) {\n      if (!this.isMobile || this.isMobile && !this.endButton.element.classList.contains(ACTIVE$1)) {\n        this.removeSelection();\n      }\n    } else if (this.isMobile && this.startButton.element.classList.contains(ACTIVE$1)) {\n      this.removeSelection();\n    }\n    const ele = element || event.currentTarget;\n    if (isNullOrUndefined(this.startValue)) {\n      if (!isNullOrUndefined(this.previousStartValue)) {\n        date.setHours(this.previousStartValue.getHours());\n        date.setMinutes(this.previousStartValue.getMinutes());\n        date.setSeconds(this.previousStartValue.getSeconds());\n      }\n      this.startValue = this.depth === 'Month' ? new Date(this.checkValue(date)) : this.depth === 'Year' ? firstDay : firstMonth;\n      this.endValue = null;\n      this.setValue();\n      addClass([ele], STARTDATE);\n      this.addSelectedAttributes(ele, this.startValue, true);\n      if (ele.classList.contains(OTHERMONTH$2)) {\n        this.otherMonthSelect(ele, true);\n      }\n      this.checkMinMaxDays();\n      this.applyButton.disabled = true;\n      this.applyButton.element.disabled = true;\n      if (this.isMobile) {\n        this.endButton.element.classList.add(ACTIVE$1);\n        this.startButton.element.classList.remove(ACTIVE$1);\n        this.endButton.element.removeAttribute('disabled');\n        this.selectableDates();\n      }\n      this.trigger('select', this.rangeArgs(event));\n    } else {\n      if (+date === +this.startValue || +date > +this.startValue) {\n        if (+date === +this.startValue && !isNullOrUndefined(this.minDays) && this.minDays > 1) {\n          return;\n        }\n        this.endValue = null;\n        this.setValue();\n        if (this.isMobile || element) {\n          this.hoverSelection(event, element);\n        }\n        if (!isNullOrUndefined(this.previousEndValue)) {\n          date.setHours(this.previousEndValue.getHours());\n          date.setMinutes(this.previousEndValue.getMinutes());\n          date.setSeconds(this.previousEndValue.getSeconds());\n        }\n        this.endValue = this.depth === 'Month' ? new Date(this.checkValue(date)) : this.depth === 'Year' ? lastDay : lastMonth;\n        this.setValue();\n        let endEle = this.popupObj.element.querySelectorAll('.' + ENDDATE);\n        if (this.isMobile) {\n          this.startButton.element.classList.remove(ACTIVE$1);\n          this.endButton.element.classList.add(ACTIVE$1);\n          for (const ele of endEle) {\n            ele.removeAttribute('aria-label');\n            if (!ele.classList.contains(STARTDATE)) {\n              ele.setAttribute('aria-selected', 'false');\n              removeClass([ele], [ENDDATE, SELECTED$3]);\n            } else {\n              this.addSelectedAttributes(ele, this.startValue, true);\n              removeClass([ele], [ENDDATE]);\n            }\n          }\n        }\n        addClass([ele], ENDDATE);\n        if (+this.endValue === +this.startValue) {\n          this.addSelectedAttributes(ele, this.endValue, false, true);\n        } else {\n          this.addSelectedAttributes(ele, this.endValue, false);\n        }\n        if (ele.classList.contains(OTHERMONTH$2)) {\n          if (+this.endValue === +this.startValue) {\n            this.otherMonthSelect(ele, false, true);\n          } else {\n            this.otherMonthSelect(ele, false);\n          }\n        }\n        endEle = this.popupObj.element.querySelectorAll('.' + ENDDATE);\n        for (const ele of endEle) {\n          if (ele.classList.contains(STARTDATE)) {\n            removeClass([ele], [RANGEHOVER]);\n          }\n        }\n        this.applyButton.disabled = false;\n        this.applyButton.element.disabled = false;\n        if (!this.isMobile) {\n          this.removeClassDisabled();\n        }\n        this.disabledDateRender();\n        this.trigger('select', this.rangeArgs(event));\n      } else if (+date < +this.startValue) {\n        this.removeClassDisabled();\n        this.startValue = this.depth === 'Month' ? new Date(this.checkValue(date)) : this.depth === 'Year' ? firstDay : firstMonth;\n        this.setValue();\n        this.removeSelectedAttributes();\n        removeClass(this.popupObj.element.querySelectorAll('.' + STARTDATE), [STARTDATE, SELECTED$3]);\n        addClass([ele], STARTDATE);\n        this.addSelectedAttributes(ele, this.startValue, true);\n        if (ele.classList.contains(OTHERMONTH$2)) {\n          this.otherMonthSelect(ele, true);\n        }\n        this.checkMinMaxDays();\n      }\n    }\n    if (event) {\n      leftCalendar = closest(event.target, '.' + LEFTCALENDER);\n    }\n    if (!isNullOrUndefined(leftCalendar)) {\n      this.leftCalendar.children[1].firstElementChild.focus();\n    } else {\n      if (event) {\n        rightCalendar = event && closest(event.target, '.' + RIGHTCALENDER);\n      }\n      if (!isNullOrUndefined(rightCalendar)) {\n        this.rightCalendar.children[1].firstElementChild.focus();\n      }\n    }\n    addClass([ele], SELECTED$3);\n    this.updateHeader();\n    this.removeFocusedDate();\n  }\n  selectableDates() {\n    if (!isNullOrUndefined(this.startValue)) {\n      const tdCells = this.calendarElement.querySelectorAll('.' + CALENDAR + ' td');\n      let isStartDate = false;\n      if (this.currentView() === this.depth) {\n        for (const ele of tdCells) {\n          if (!ele.classList.contains(STARTDATE) && !ele.classList.contains(WEEKNUMBER$2)) {\n            if (!ele.classList.contains(DISABLED$2)) {\n              const eleDate = this.getIdValue(null, ele);\n              if (+eleDate < +this.startValue) {\n                addClass([ele], [DATEDISABLED, DISABLED$2, OVERLAY$2]);\n                EventHandler.clearEvents(ele);\n                continue;\n              } else {\n                break;\n              }\n            }\n          }\n          if (ele.classList.contains(STARTDATE) && !ele.classList.contains(OTHERMONTH$2)) {\n            isStartDate = true;\n            break;\n          }\n        }\n        if (isStartDate) {\n          if (!this.previousIcon.classList.contains(DISABLED$2)) {\n            addClass([this.previousIcon], [ICONDISABLED, DISABLED$2, OVERLAY$2]);\n          }\n        }\n      } else {\n        for (const ele of tdCells) {\n          const startMonth = this.startValue.getMonth();\n          const startYear = this.startValue.getFullYear();\n          const element = this.getIdValue(null, ele);\n          if (!this.startButton.element.classList.contains(ACTIVE$1) && (this.currentView() === 'Year' && element.getMonth() < startMonth && element.getFullYear() <= startYear || this.currentView() === 'Decade' && element.getMonth() <= startMonth && element.getFullYear() < startYear)) {\n            addClass([ele], [DISABLED$2]);\n          } else {\n            break;\n          }\n        }\n        if (tdCells[0].classList.contains(DISABLED$2)) {\n          this.previousIconHandler(true);\n        } else if (tdCells[tdCells.length - 1].classList.contains(DISABLED$2)) {\n          this.nextIconHandler(true);\n        }\n      }\n    }\n  }\n  updateMinMaxDays(calendar) {\n    if (!isNullOrUndefined(this.startValue) && isNullOrUndefined(this.endValue) || this.isMobile && this.endButton.element.classList.contains(ACTIVE$1)) {\n      if (!isNullOrUndefined(this.minDays) && this.minDays > 0 || !isNullOrUndefined(this.maxDays) && this.maxDays > 0) {\n        const startValueSelected = this.removeTimeValueFromDate(this.startValue);\n        let minDate = new Date(new Date(+startValueSelected).setDate(startValueSelected.getDate() + (this.minDays - 1)));\n        let maxDate = new Date(new Date(+startValueSelected).setDate(startValueSelected.getDate() + (this.maxDays - 1)));\n        minDate = !isNullOrUndefined(this.minDays) && this.minDays > 0 ? minDate : null;\n        maxDate = !isNullOrUndefined(this.maxDays) && this.maxDays > 0 ? maxDate : null;\n        if (this.currentView() === 'Year') {\n          minDate = isNullOrUndefined(minDate) ? null : new Date(minDate.getFullYear(), minDate.getMonth(), 0);\n          maxDate = isNullOrUndefined(maxDate) ? null : new Date(maxDate.getFullYear(), maxDate.getMonth(), 1);\n        } else if (this.currentView() === 'Decade') {\n          minDate = isNullOrUndefined(minDate) ? null : new Date(minDate.getFullYear() - 1, 11, 1);\n          maxDate = isNullOrUndefined(maxDate) ? null : new Date(maxDate.getFullYear(), 0, 1);\n        }\n        const tdCells = calendar.querySelectorAll('.' + CALENDAR + ' td');\n        let maxEle;\n        for (const ele of tdCells) {\n          if (!ele.classList.contains(STARTDATE) && !ele.classList.contains(WEEKNUMBER$2)) {\n            let eleDate = this.getIdValue(null, ele);\n            eleDate = this.removeTimeValueFromDate(eleDate);\n            if (!isNullOrUndefined(minDate) && +eleDate === +minDate && ele.classList.contains(DISABLED$2)) {\n              minDate.setDate(minDate.getDate() + 1);\n            }\n            if (!ele.classList.contains(DISABLED$2)) {\n              if (+eleDate <= +startValueSelected) {\n                continue;\n              }\n              if (!isNullOrUndefined(minDate) && +eleDate < +minDate) {\n                addClass([ele], [DATEDISABLED, DISABLED$2, OVERLAY$2]);\n                EventHandler.clearEvents(ele);\n              }\n              if (!isNullOrUndefined(maxDate) && +eleDate > +maxDate) {\n                addClass([ele], [DATEDISABLED, DISABLED$2, OVERLAY$2]);\n                this.isMaxDaysClicked = true;\n                EventHandler.clearEvents(ele);\n                if (isNullOrUndefined(maxEle) && !ele.classList.contains(OTHERMONTH$2)) {\n                  maxEle = ele;\n                }\n              }\n            }\n          }\n        }\n        if (!isNullOrUndefined(maxEle)) {\n          if (this.isMobile) {\n            if (!this.nextIcon.classList.contains(DISABLED$2)) {\n              addClass([this.nextIcon], [ICONDISABLED, DISABLED$2, OVERLAY$2]);\n            }\n          } else {\n            let calendar = closest(maxEle, '.' + RIGHTCALENDER);\n            calendar = isNullOrUndefined(calendar) ? this.leftCalendar : calendar;\n            const isLeftCalendar = calendar.classList.contains(LEFTCALENDER);\n            if (!isLeftCalendar) {\n              if (!this.rightCalNextIcon.classList.contains(DISABLED$2)) {\n                addClass([this.rightCalNextIcon], [ICONDISABLED, DISABLED$2, OVERLAY$2]);\n              }\n            } else {\n              if (!this.rightCalNextIcon.classList.contains(DISABLED$2)) {\n                addClass([this.rightCalNextIcon], [ICONDISABLED, DISABLED$2, OVERLAY$2]);\n              }\n              if (!this.leftCalNextIcon.classList.contains(DISABLED$2)) {\n                addClass([this.leftCalNextIcon], [ICONDISABLED, DISABLED$2, OVERLAY$2]);\n              }\n              if (!this.rightCalPrevIcon.classList.contains(DISABLED$2)) {\n                addClass([this.rightCalPrevIcon], [ICONDISABLED, DISABLED$2, OVERLAY$2]);\n              }\n            }\n          }\n        }\n      }\n    } else {\n      this.isMaxDaysClicked = false;\n    }\n  }\n  removeTimeValueFromDate(value) {\n    const dateValue = new Date(value.getFullYear(), value.getMonth(), value.getDate());\n    return dateValue;\n  }\n  removeClassDisabled() {\n    const tdCells = this.popupObj.element.querySelectorAll('.' + CALENDAR + ' td' + '.' + DATEDISABLED);\n    for (const ele of tdCells) {\n      if (ele.classList.contains(DATEDISABLED)) {\n        removeClass([ele], [DATEDISABLED, DISABLED$2, OVERLAY$2]);\n        EventHandler.add(ele, 'click', this.selectRange, this);\n        if (!this.isMobile) {\n          EventHandler.add(ele, 'mouseover', this.hoverSelection, this);\n        }\n      }\n    }\n    if (this.isMobile) {\n      if (this.nextIcon.classList.contains(ICONDISABLED)) {\n        removeClass([this.nextIcon], [ICONDISABLED, DISABLED$2, OVERLAY$2]);\n      }\n      if (this.previousIcon.classList.contains(ICONDISABLED)) {\n        removeClass([this.previousIcon], [ICONDISABLED, DISABLED$2, OVERLAY$2]);\n      }\n    } else {\n      if (this.rightCalNextIcon.classList.contains(ICONDISABLED)) {\n        removeClass([this.rightCalNextIcon], [ICONDISABLED, DISABLED$2, OVERLAY$2]);\n      }\n      if (this.rightCalPrevIcon.classList.contains(ICONDISABLED)) {\n        removeClass([this.rightCalPrevIcon], [ICONDISABLED, DISABLED$2, OVERLAY$2]);\n      }\n      if (this.leftCalNextIcon.classList.contains(ICONDISABLED)) {\n        removeClass([this.leftCalNextIcon], [ICONDISABLED, DISABLED$2, OVERLAY$2]);\n      }\n    }\n  }\n  updateHeader() {\n    const format = {\n      type: 'date',\n      skeleton: 'yMMMd'\n    };\n    if (!isNullOrUndefined(this.endValue) && !isNullOrUndefined(this.startValue)) {\n      let range = Math.round(Math.abs((this.removeTimeValueFromDate(this.startValue).getTime() - this.removeTimeValueFromDate(this.endValue).getTime()) / (1000 * 60 * 60 * 24))) + 1;\n      if (!isNullOrUndefined(this.disabledDayCnt)) {\n        range = range - this.disabledDayCnt;\n        this.disabledDayCnt = null;\n      }\n      this.popupObj.element.querySelector('.' + DAYSPAN).textContent = range.toString() + ' ' + this.l10n.getConstant('days');\n    } else {\n      this.popupObj.element.querySelector('.' + DAYSPAN).textContent = this.l10n.getConstant('selectedDays');\n    }\n    if (!this.isMobile) {\n      if (!isNullOrUndefined(this.endValue) && !isNullOrUndefined(this.startValue)) {\n        this.popupObj.element.querySelector('.' + ENDLABEL).textContent = this.globalize.formatDate(this.endValue, format);\n      } else {\n        this.popupObj.element.querySelector('.' + ENDLABEL).textContent = this.l10n.getConstant('endLabel');\n      }\n      if (!isNullOrUndefined(this.startValue)) {\n        this.popupObj.element.querySelector('.' + STARTLABEL).textContent = this.globalize.formatDate(this.startValue, format);\n      } else {\n        this.popupObj.element.querySelector('.' + STARTLABEL).textContent = this.l10n.getConstant('startLabel');\n      }\n    } else {\n      if (!isNullOrUndefined(this.startValue)) {\n        this.startButton.element.textContent = this.globalize.formatDate(this.startValue, format);\n      } else {\n        this.startButton.element.textContent = this.l10n.getConstant('startLabel');\n      }\n      if (!isNullOrUndefined(this.endValue) && !isNullOrUndefined(this.startValue)) {\n        this.endButton.element.textContent = this.globalize.formatDate(this.endValue, format);\n      } else {\n        this.endButton.element.textContent = this.l10n.getConstant('endLabel');\n      }\n    }\n    if (this.isDateDisabled(this.startValue) || this.isDateDisabled(this.endValue) || !isNullOrUndefined(this.startValue) && +this.startValue < +this.min || !isNullOrUndefined(this.endValue) && +this.endValue > +this.max || !isNullOrUndefined(this.startValue) && !isNullOrUndefined(this.endValue) && +this.startValue > +this.endValue) {\n      if (!this.isMobile) {\n        this.popupObj.element.querySelector('.' + DAYSPAN).textContent = this.l10n.getConstant('selectedDays');\n        this.popupObj.element.querySelector('.' + STARTLABEL).textContent = this.l10n.getConstant('startLabel');\n        this.popupObj.element.querySelector('.' + ENDLABEL).textContent = this.l10n.getConstant('endLabel');\n      } else {\n        this.startButton.element.textContent = this.l10n.getConstant('startLabel');\n        this.endButton.element.textContent = this.l10n.getConstant('endLabel');\n        this.popupObj.element.querySelector('.' + DAYSPAN).textContent = this.l10n.getConstant('selectedDays');\n      }\n    }\n    if (this.popupObj.element.querySelector('#custom_range')) {\n      this.popupObj.element.querySelector('#custom_range').textContent = this.l10n.getConstant('customRange') !== '' ? this.l10n.getConstant('customRange') : 'Custom Range';\n    }\n  }\n  removeSelection() {\n    this.startValue = null;\n    this.endValue = null;\n    this.setValue();\n    this.removeSelectedAttributes();\n    if (this.popupObj) {\n      if (this.popupObj.element.querySelectorAll('.' + SELECTED$3).length > 0) {\n        removeClass(this.popupObj.element.querySelectorAll('.' + SELECTED$3), [STARTDATE, ENDDATE, SELECTED$3]);\n      }\n      if (this.popupObj.element.querySelectorAll('.' + FOCUSDATE).length > 0) {\n        removeClass(this.popupObj.element.querySelectorAll('.' + FOCUSDATE), FOCUSDATE);\n      }\n      if (this.popupObj.element.querySelectorAll('.' + RANGEHOVER).length > 0) {\n        removeClass(this.popupObj.element.querySelectorAll('.' + RANGEHOVER), [RANGEHOVER]);\n      }\n    }\n  }\n  addSelectedAttributes(ele, date, isStartDate, sameDate) {\n    if (ele) {\n      const title = this.globalize.formatDate(date, {\n        type: 'date',\n        skeleton: 'full'\n      });\n      if (!isNullOrUndefined(sameDate) && sameDate) {\n        ele.setAttribute('aria-label', 'The current start and end date is ' + '' + title);\n      } else {\n        ele.setAttribute('aria-label', 'The current ' + (isStartDate ? 'start' : 'end') + ' date is ' + '' + title);\n      }\n      ele.setAttribute('aria-selected', 'true');\n    }\n  }\n  removeSelectedAttributes() {\n    if (this.popupObj) {\n      const start = this.popupObj.element.querySelectorAll('.' + STARTDATE);\n      for (const ele of start) {\n        ele.setAttribute('aria-selected', 'false');\n        ele.removeAttribute('aria-label');\n      }\n      const end = this.popupObj.element.querySelectorAll('.' + ENDDATE);\n      for (const ele of end) {\n        ele.setAttribute('aria-selected', 'false');\n        ele.removeAttribute('aria-label');\n      }\n    }\n  }\n  updateCalendarElement(calendar) {\n    if (calendar.classList.contains(LEFTCALENDER)) {\n      this.calendarElement = this.leftCalendar;\n      this.currentDate = this.leftCalCurrentDate;\n      this.previousIcon = this.leftCalPrevIcon;\n      this.nextIcon = this.leftCalNextIcon;\n    } else {\n      this.calendarElement = this.rightCalendar;\n      this.currentDate = this.rightCalCurrentDate;\n      this.previousIcon = this.rightCalPrevIcon;\n      this.nextIcon = this.rightCalNextIcon;\n    }\n    this.contentElement = calendar.querySelector('.' + CONTENT$1);\n    this.tableBodyElement = select('.' + CONTENT$1 + ' tbody', calendar);\n    this.table = calendar.querySelector('.' + CONTENT$1).getElementsByTagName('table')[0];\n    this.headerTitleElement = calendar.querySelector('.' + HEADER$1 + ' .' + TITLE$1);\n    this.headerElement = calendar.querySelector('.' + HEADER$1);\n  }\n  navPrevMonth(e) {\n    e.preventDefault();\n    let ele = closest(e.target, '.' + LEFTCALENDER);\n    ele = isNullOrUndefined(ele) ? closest(e.target, '.' + RIGHTCALENDER) : ele;\n    this.updateCalendarElement(ele);\n    this.navigatePrevious(e);\n    if (!isNullOrUndefined(this.startValue) && isNullOrUndefined(this.endValue)) {\n      this.updateMinMaxDays(ele);\n    }\n    this.updateControl(ele);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  deviceNavigation(ele) {\n    this.deviceCalendarEvent();\n    this.updateRange([this.popupObj.element.querySelector('.' + CALENDAR)]);\n    if (this.endButton.element.classList.contains(ACTIVE$1)) {\n      this.updateMinMaxDays(this.popupObj.element.querySelector('.' + CALENDAR));\n    }\n    if (this.endButton.element.classList.contains(ACTIVE$1)) {\n      this.selectableDates();\n    }\n    if (this.currentView() === this.depth) {\n      this.bindCalendarCellEvents();\n    }\n    this.removeFocusedDate();\n  }\n  updateControl(calendar) {\n    if (calendar.classList.contains(RIGHTCALENDER)) {\n      this.rightCalCurrentDate = new Date(+this.currentDate);\n    } else {\n      this.leftCalCurrentDate = new Date(+this.currentDate);\n    }\n    this.calendarIconEvent();\n    if (this.depth === 'Month' && this.leftCalendar.querySelector('.e-content').classList.contains('e-month') && this.rightCalendar.querySelector('.e-content').classList.contains('e-month') || this.depth === 'Year' && this.leftCalendar.querySelector('.e-content').classList.contains('e-year') && this.rightCalendar.querySelector('.e-content').classList.contains('e-year') || this.depth === 'Decade' && this.leftCalendar.querySelector('.e-content').classList.contains('e-decade') && this.rightCalendar.querySelector('.e-content').classList.contains('e-decade') || this.isMobile) {\n      this.bindCalendarCellEvents();\n    }\n    this.removeFocusedDate();\n    this.updateRange([calendar]);\n  }\n  navNextMonth(event) {\n    event.preventDefault();\n    let ele = closest(event.target, '.' + LEFTCALENDER);\n    ele = isNullOrUndefined(ele) ? closest(event.target, '.' + RIGHTCALENDER) : ele;\n    this.updateCalendarElement(ele);\n    this.navigateNext(event);\n    if (!isNullOrUndefined(this.startValue) && isNullOrUndefined(this.endValue)) {\n      this.updateMinMaxDays(ele);\n    }\n    this.updateControl(ele);\n  }\n  isPopupOpen() {\n    if (!isNullOrUndefined(this.popupObj) && this.popupObj.element.classList.contains(POPUP$1)) {\n      return true;\n    }\n    return false;\n  }\n  createRangeHeader() {\n    const labelContainer = this.createElement('div', {\n      className: STARTENDCONTAINER\n    });\n    if (!this.isMobile) {\n      const startLabel = this.createElement('a', {\n        className: STARTLABEL\n      });\n      const endLabel = this.createElement('a', {\n        className: ENDLABEL\n      });\n      const changeIcon = this.createElement('span', {\n        className: CHANGEICON\n      });\n      attributes(startLabel, {\n        'aria-atomic': 'true',\n        'aria-live': 'assertive',\n        'aria-label': 'Start Date',\n        'role': 'button'\n      });\n      attributes(endLabel, {\n        'aria-atomic': 'true',\n        'aria-live': 'assertive',\n        'aria-label': 'End Date',\n        'role': 'button'\n      });\n      labelContainer.appendChild(startLabel);\n      labelContainer.appendChild(changeIcon);\n      labelContainer.appendChild(endLabel);\n      startLabel.textContent = this.l10n.getConstant('startLabel');\n      endLabel.textContent = this.l10n.getConstant('endLabel');\n    } else {\n      const endBtn = this.createElement('button', {\n        className: ENDBUTTON\n      });\n      const startBtn = this.createElement('button', {\n        className: STARTBUTTON\n      });\n      this.startButton = new Button({\n        content: this.l10n.getConstant('startLabel')\n      }, startBtn);\n      this.endButton = new Button({\n        content: this.l10n.getConstant('endLabel')\n      }, endBtn);\n      labelContainer.appendChild(startBtn);\n      labelContainer.appendChild(endBtn);\n    }\n    return labelContainer;\n  }\n  disableInput() {\n    if (this.strictMode) {\n      if (!isNullOrUndefined(this.previousStartValue) && !isNullOrUndefined(this.previousEndValue)) {\n        this.startValue = this.previousStartValue;\n        this.endValue = this.previousEndValue;\n        this.setValue();\n        this.updateInput();\n      }\n    } else {\n      this.updateInput();\n      this.clearRange();\n      this.setProperties({\n        startDate: null\n      }, true);\n      this.setProperties({\n        endDate: null\n      }, true);\n      this.startValue = null;\n      this.endValue = null;\n      this.setValue();\n      this.errorClass();\n    }\n    this.setProperties({\n      enabled: false\n    }, true);\n    Input.setEnabled(this.enabled, this.inputElement);\n    this.bindEvents();\n  }\n  validateMinMax() {\n    this.min = isNullOrUndefined(this.min) || !+this.min ? this.min = new Date(1900, 0, 1) : this.min;\n    this.max = isNullOrUndefined(this.max) || !+this.max ? this.max = new Date(2099, 11, 31) : this.max;\n    if (!(this.min <= this.max)) {\n      this.disableInput();\n      return;\n    }\n    if (!isNullOrUndefined(this.minDays) && !isNullOrUndefined(this.maxDays)) {\n      if (this.maxDays > 0 && this.minDays > 0 && this.minDays > this.maxDays) {\n        this.maxDays = null;\n      }\n    }\n    if (!isNullOrUndefined(this.minDays) && this.minDays < 0) {\n      this.minDays = null;\n    }\n    if (!isNullOrUndefined(this.maxDays) && this.maxDays < 0) {\n      this.maxDays = null;\n    }\n  }\n  validateRangeStrict() {\n    if (!isNullOrUndefined(this.startValue)) {\n      if (+this.startValue <= +this.min) {\n        this.startValue = this.min;\n        this.setValue();\n      } else if (+this.startValue >= +this.min && +this.startValue >= +this.max) {\n        this.startValue = this.max;\n      }\n    }\n    if (!isNullOrUndefined(this.endValue)) {\n      if (+this.endValue > +this.max) {\n        this.endValue = this.max;\n        this.setValue();\n      } else if (+this.endValue < +this.min) {\n        this.endValue = this.min;\n        this.setValue();\n      }\n    }\n    this.validateMinMaxDays();\n  }\n  validateRange() {\n    this.validateMinMaxDays();\n  }\n  validateMinMaxDays() {\n    if (!isNullOrUndefined(this.startValue) && !isNullOrUndefined(this.endValue)) {\n      const range = Math.round(Math.abs((this.removeTimeValueFromDate(this.startValue).getTime() - this.removeTimeValueFromDate(this.endValue).getTime()) / (1000 * 60 * 60 * 24))) + 1;\n      if (!isNullOrUndefined(this.minDays) && this.minDays > 0 && !(range >= this.minDays)) {\n        if (this.strictMode) {\n          const date = new Date(+this.startValue);\n          date.setDate(date.getDate() + (this.minDays - 1));\n          if (+date > +this.max) {\n            this.endValue = this.max;\n            this.setValue();\n          } else {\n            this.endValue = date;\n            this.setValue();\n          }\n        } else {\n          this.startValue = null;\n          this.endValue = null;\n          this.setValue();\n        }\n      }\n      if (!isNullOrUndefined(this.maxDays) && this.maxDays > 0 && !(range <= this.maxDays)) {\n        if (this.strictMode) {\n          this.endValue = new Date(+this.startValue);\n          this.endValue.setDate(this.endValue.getDate() + (this.maxDays - 1));\n          this.setValue();\n        } else {\n          this.startValue = null;\n          this.endValue = null;\n          this.setValue();\n        }\n      }\n    }\n  }\n  renderCalendar() {\n    this.calendarElement = this.createElement('div');\n    this.calendarElement.classList.add(CALENDAR);\n    if (this.enableRtl) {\n      this.calendarElement.classList.add(RTL$1);\n    }\n    attributes(this.calendarElement, {\n      'role': 'calendar'\n    });\n    super.createHeader();\n    super.createContent();\n  }\n  isSameMonth(start, end) {\n    if (start.getMonth() === end.getMonth() && start.getFullYear() === end.getFullYear()) {\n      return true;\n    }\n    return false;\n  }\n  isSameYear(start, end) {\n    if (start.getFullYear() === end.getFullYear()) {\n      return true;\n    }\n    return false;\n  }\n  isSameDecade(start, end) {\n    const startYear = start.getFullYear();\n    const endYear = end.getFullYear();\n    if (startYear - startYear % 10 === endYear - endYear % 10) {\n      return true;\n    }\n    return false;\n  }\n  startMonthCurrentDate() {\n    if (this.isSameMonth(this.min, this.max) || +this.currentDate > +this.max || this.isSameMonth(this.currentDate, this.max)) {\n      this.currentDate = new Date(+this.max);\n      this.currentDate.setDate(1);\n      this.currentDate.setMonth(this.currentDate.getMonth() - 1);\n    } else if (this.currentDate < this.min) {\n      this.currentDate = new Date(this.checkValue(this.min));\n    }\n  }\n  selectNextMonth() {\n    if (!isNullOrUndefined(this.endValue) && !isNullOrUndefined(this.startValue) && !this.isSameMonth(this.endValue, this.currentDate) && !this.isDateDisabled(this.endValue) && !this.isDateDisabled(this.startValue)) {\n      this.currentDate = new Date(+this.endValue);\n    } else {\n      this.currentDate.setDate(1);\n      this.currentDate.setMonth(this.currentDate.getMonth() + 1);\n      return;\n    }\n    if (!isNullOrUndefined(this.startValue) && +this.startValue < +this.min || !isNullOrUndefined(this.endValue) && +this.endValue > +this.max || !isNullOrUndefined(this.startValue) && !isNullOrUndefined(this.endValue) && +this.startValue > +this.endValue) {\n      this.currentDate = new Date(new Date().setHours(0, 0, 0, 0));\n      this.currentDate.setDate(1);\n      const month = this.currentDate.getMonth() + 1;\n      this.currentDate.setMonth(month);\n    }\n  }\n  selectNextYear() {\n    if (!isNullOrUndefined(this.endValue) && !isNullOrUndefined(this.startValue) && !this.isSameYear(this.endValue, this.currentDate) && !this.isDateDisabled(this.endValue) && !this.isDateDisabled(this.startValue)) {\n      this.currentDate = new Date(+this.endValue);\n    } else {\n      this.currentDate.setMonth(0);\n      const yr = this.currentDate.getFullYear() + 1;\n      this.currentDate.setFullYear(yr);\n      return;\n    }\n    if (!isNullOrUndefined(this.endValue) && +this.endValue > +this.max || !isNullOrUndefined(this.startValue) && !isNullOrUndefined(this.endValue) && +this.startValue > +this.endValue || !isNullOrUndefined(this.startValue) && +this.startValue < +this.min) {\n      this.currentDate = new Date(new Date().setHours(0, 0, 0, 0));\n      this.currentDate.setMonth(0);\n      this.currentDate.setFullYear(this.currentDate.getFullYear() + 1);\n    }\n  }\n  selectNextDecade() {\n    if (!isNullOrUndefined(this.endValue) && !isNullOrUndefined(this.startValue) && !this.isSameDecade(this.endValue, this.currentDate) && !this.isDateDisabled(this.endValue) && !this.isDateDisabled(this.startValue)) {\n      this.currentDate = new Date(+this.endValue);\n    } else {\n      const decyr = this.currentDate.getFullYear() + 10;\n      this.currentDate.setFullYear(decyr);\n      return;\n    }\n    if (!isNullOrUndefined(this.startValue) && !isNullOrUndefined(this.endValue) && +this.startValue > +this.endValue || !isNullOrUndefined(this.endValue) && +this.endValue > +this.max || !isNullOrUndefined(this.startValue) && +this.startValue < +this.min) {\n      this.currentDate = new Date(new Date().setHours(0, 0, 0, 0));\n      this.currentDate.setFullYear(this.currentDate.getFullYear() + 10);\n    }\n  }\n  selectStartMonth() {\n    if (!isNullOrUndefined(this.startValue)) {\n      if (!isNullOrUndefined(this.max) && this.isSameMonth(this.startValue, this.max)) {\n        this.currentDate = new Date(+this.max);\n        this.currentDate.setDate(1);\n        this.currentDate.setMonth(this.currentDate.getMonth() - 1);\n      } else if (!(this.startValue >= this.min && this.startValue <= this.max) || this.isDateDisabled(this.startValue)) {\n        this.currentDate = new Date(new Date().setHours(0, 0, 0, 0));\n      } else {\n        this.currentDate = new Date(+this.startValue);\n      }\n    } else {\n      this.currentDate = new Date(new Date().setHours(0, 0, 0, 0));\n      this.startMonthCurrentDate();\n    }\n    if (!isNullOrUndefined(this.endValue) && +this.endValue > +this.max || !isNullOrUndefined(this.startValue) && +this.startValue < +this.min || !isNullOrUndefined(this.startValue) && !isNullOrUndefined(this.endValue) && +this.startValue > +this.endValue) {\n      this.currentDate = new Date(new Date().setHours(0, 0, 0, 0));\n    }\n    this.startMonthCurrentDate();\n  }\n  createCalendar() {\n    const calendarContainer = this.createElement('div', {\n      className: CALENDARCONTAINER\n    });\n    if (!this.isMobile) {\n      this.selectStartMonth();\n      this.renderCalendar();\n      this.leftCalCurrentDate = new Date(+this.currentDate);\n      this.calendarElement.classList.add(LEFTCALENDER);\n      this.leftCalPrevIcon = this.calendarElement.querySelector('.' + LEFTCALENDER + ' .' + PREVICON$1);\n      this.leftCalNextIcon = this.calendarElement.querySelector('.' + LEFTCALENDER + ' .' + NEXTICON$1);\n      this.leftTitle = this.calendarElement.querySelector('.' + LEFTCALENDER + ' .' + TITLE$1);\n      remove(this.calendarElement.querySelector('.' + LEFTCALENDER + ' .' + ICONCONTAINER$1));\n      this.calendarElement.querySelector('.' + LEFTCALENDER + ' .' + HEADER$1).appendChild(this.leftCalNextIcon);\n      this.calendarElement.querySelector('.' + LEFTCALENDER + ' .' + HEADER$1).appendChild(this.leftCalPrevIcon);\n      prepend([this.leftCalPrevIcon], this.calendarElement.querySelector('.' + LEFTCALENDER + ' .' + HEADER$1));\n      this.leftCalendar = this.calendarElement;\n      const leftContainer = this.createElement('div', {\n        className: LEFTCONTAINER\n      });\n      const rightContainer = this.createElement('div', {\n        className: RIGHTCONTAINER\n      });\n      leftContainer.appendChild(this.leftCalendar);\n      calendarContainer.appendChild(leftContainer);\n      if (!this.isMobile) {\n        EventHandler.add(this.leftTitle, 'click', this.leftNavTitle, this);\n      }\n      if (this.start === 'Month') {\n        this.selectNextMonth();\n      }\n      if (this.start === 'Year') {\n        this.selectNextYear();\n      }\n      if (this.start === 'Decade') {\n        this.selectNextDecade();\n      }\n      this.renderCalendar();\n      this.rightCalCurrentDate = new Date(+this.currentDate);\n      addClass([this.calendarElement], RIGHTCALENDER);\n      this.rightCalendar = this.calendarElement;\n      removeClass([this.leftCalendar && this.leftCalendar.querySelector('.e-content tbody')], 'e-zoomin');\n      removeClass([this.rightCalendar && this.rightCalendar.querySelector('.e-content tbody')], 'e-zoomin');\n      this.rightCalPrevIcon = this.calendarElement.querySelector('.' + RIGHTCALENDER + ' .' + PREVICON$1);\n      this.rightCalNextIcon = this.calendarElement.querySelector('.' + RIGHTCALENDER + ' .' + NEXTICON$1);\n      this.rightTitle = this.calendarElement.querySelector('.' + RIGHTCALENDER + ' .' + TITLE$1);\n      remove(this.calendarElement.querySelector('.' + RIGHTCALENDER + ' .' + ICONCONTAINER$1));\n      this.calendarElement.querySelector('table').setAttribute('tabindex', '-1');\n      this.calendarElement.querySelector('.' + RIGHTCALENDER + ' .' + HEADER$1).appendChild(this.rightCalNextIcon);\n      this.calendarElement.querySelector('.' + RIGHTCALENDER + ' .' + HEADER$1).appendChild(this.rightCalPrevIcon);\n      prepend([this.rightCalPrevIcon], this.calendarElement.querySelector('.' + RIGHTCALENDER + ' .' + HEADER$1));\n      rightContainer.appendChild(this.rightCalendar);\n      calendarContainer.appendChild(rightContainer);\n      if (!this.isMobile) {\n        EventHandler.add(this.rightTitle, 'click', this.rightNavTitle, this);\n      }\n    } else {\n      if (!isNullOrUndefined(this.startValue)) {\n        this.currentDate = new Date(+this.startValue);\n      }\n      super.validateDate();\n      super.minMaxUpdate();\n      super.render();\n      const prevIcon = this.calendarElement.querySelector('.' + CALENDAR + ' .' + PREVICON$1);\n      const nextIcon = this.calendarElement.querySelector('.' + CALENDAR + ' .' + NEXTICON$1);\n      remove(this.calendarElement.querySelector('.' + CALENDAR + ' .' + ICONCONTAINER$1));\n      this.calendarElement.querySelector('.' + CALENDAR + ' .' + HEADER$1).appendChild(nextIcon);\n      this.calendarElement.querySelector('.' + CALENDAR + ' .' + HEADER$1).appendChild(prevIcon);\n      prepend([prevIcon], this.calendarElement.querySelector('.' + CALENDAR + ' .' + HEADER$1));\n      this.deviceCalendar = this.calendarElement;\n      calendarContainer.appendChild(this.calendarElement);\n      this.headerTitleElement = this.calendarElement.querySelector('.' + CALENDAR + ' .' + HEADER$1 + ' .' + TITLE$1);\n    }\n    return calendarContainer;\n  }\n  leftNavTitle(e) {\n    if (this.isPopupOpen()) {\n      this.calendarElement = this.leftCalendar;\n      this.calendarNavigation(e, this.calendarElement);\n    }\n  }\n  calendarNavigation(e, element) {\n    this.table = element.querySelector('table');\n    this.headerTitleElement = element.querySelector('.e-title');\n    this.tableBodyElement = element.querySelector('tbody');\n    this.tableHeadElement = element.querySelector('thead');\n    this.contentElement = element.querySelector('.e-content');\n    this.updateCalendarElement(element);\n    super.navigateTitle(e);\n    this.updateNavIcons();\n  }\n  rightNavTitle(e) {\n    if (this.isPopupOpen()) {\n      this.calendarElement = this.rightCalendar;\n      this.calendarNavigation(e, this.calendarElement);\n    }\n  }\n  clickEventEmitter(e) {\n    if (!this.isMobile) {\n      if (closest(e.target, '.e-calendar.e-left-calendar')) {\n        this.calendarElement = this.leftCalendar;\n        this.updateCalendarElement(this.leftCalendar);\n      } else {\n        this.calendarElement = this.rightCalendar;\n        this.updateCalendarElement(this.rightCalendar);\n      }\n    }\n  }\n  /* eslint-disable valid-jsdoc, jsdoc/require-returns-description */\n  /**\n   * Gets the current view of the Calendar.\n   *\n   * @returns {string}\n   * @private\n   * @hidden\n   */\n  currentView() {\n    return super.currentView();\n  }\n  /* eslint-enable valid-jsdoc, jsdoc/require-returns-description */\n  getCalendarView(view) {\n    if (view === 'Year') {\n      return 'Year';\n    } else if (view === 'Decade') {\n      return 'Decade';\n    } else {\n      return 'Month';\n    }\n  }\n  navigatedEvent(e) {\n    this.trigger('navigated', this.navigatedArgs);\n    if (!isNullOrUndefined(this.popupObj)) {\n      let element;\n      const view = this.getCalendarView(this.currentView());\n      if (this.isMobile) {\n        if (view === this.depth) {\n          this.bindCalendarCellEvents();\n          this.deviceNavigation();\n          this.removeFocusedDate();\n          this.checkMinMaxDays();\n        } else {\n          this.selectableDates();\n        }\n      } else {\n        if (!this.isMobile && view === this.depth) {\n          element = this.calendarElement.classList.contains('e-left-calendar') ? this.leftCalendar : this.rightCalendar;\n          if (element === this.leftCalendar && (e && !e.currentTarget.children[0].classList.contains('e-icons') || !isNullOrUndefined(this.controlDown))) {\n            this.leftCalCurrentDate = new Date(+this.currentDate);\n            this.effect = '';\n            this.currentDate = this.leftCalCurrentDate;\n            this.updateCalendarElement(this.leftCalendar);\n            this.updateControl(this.leftCalendar);\n            this.updateCalendarElement(this.rightCalendar);\n            super.navigateTo.call(this, view, this.rightCalCurrentDate);\n            this.updateControl(this.rightCalendar);\n            this.updateNavIcons();\n            this.calendarIconEvent();\n            this.calendarIconRipple();\n            this.controlDown = null;\n          } else if (e && !e.currentTarget.children[0].classList.contains('e-icons') || !isNullOrUndefined(this.controlDown)) {\n            this.rightCalCurrentDate = new Date(+this.currentDate);\n            this.effect = '';\n            this.currentDate = this.rightCalCurrentDate;\n            this.updateCalendarElement(this.rightCalendar);\n            this.updateControl(this.rightCalendar);\n            this.updateCalendarElement(this.leftCalendar);\n            if (this.startValue && isNullOrUndefined(this.endValue)) {\n              if (view === 'Month' && this.startValue.getMonth() < this.rightCalCurrentDate.getMonth() && this.startValue.getFullYear() <= this.rightCalCurrentDate.getFullYear()) {\n                super.navigateTo.call(this, view, new Date(+this.startValue));\n              } else if (view === 'Year' && this.startValue.getFullYear() < this.rightCalCurrentDate.getFullYear()) {\n                super.navigateTo.call(this, view, new Date(+this.startValue));\n              } else {\n                super.navigateTo.call(this, view, this.leftCalCurrentDate);\n              }\n            } else {\n              super.navigateTo.call(this, view, this.leftCalCurrentDate);\n            }\n            this.updateControl(this.leftCalendar);\n            this.updateNavIcons();\n            this.calendarIconEvent();\n            this.calendarIconRipple();\n            this.controlDown = null;\n          }\n          this.checkMinMaxDays();\n        } else {\n          this.updateNavIcons();\n          this.calendarIconEvent();\n        }\n      }\n    }\n  }\n  createControl() {\n    const controlContainer = this.createElement('div', {\n      className: RANGECONTAINER\n    });\n    const headerContainer = this.createElement('div', {\n      className: RANGEHEADER\n    });\n    const labelContainer = this.createRangeHeader();\n    headerContainer.appendChild(labelContainer);\n    const daySpan = this.createElement('div', {\n      className: DAYSPAN\n    });\n    attributes(daySpan, {\n      'aria-label': 'Selected Days'\n    });\n    daySpan.textContent = this.l10n.getConstant('selectedDays');\n    headerContainer.appendChild(daySpan);\n    const separator = this.createElement('div', {\n      className: SEPARATOR\n    });\n    const calendarContainer = this.createCalendar();\n    controlContainer.appendChild(headerContainer);\n    controlContainer.appendChild(separator);\n    controlContainer.appendChild(calendarContainer);\n    const footerSection = this.createElement('div', {\n      className: FOOTER$1\n    });\n    const cancelBtn = this.createElement('button', {\n      className: CANCEL + ' ' + FLAT$1 + ' ' + CSS$1\n    });\n    const applyBtn = this.createElement('button');\n    addClass([applyBtn], [APPLY, FLAT$1, PRIMARY$1, CSS$1]);\n    footerSection.appendChild(applyBtn);\n    footerSection.appendChild(cancelBtn);\n    const enable = !isNullOrUndefined(this.startValue) && !isNullOrUndefined(this.endValue);\n    this.cancelButton = new Button({\n      content: this.l10n.getConstant('cancelText')\n    }, cancelBtn);\n    this.applyButton = new Button({\n      content: this.l10n.getConstant('applyText'),\n      disabled: !enable\n    }, applyBtn);\n    EventHandler.add(applyBtn, 'click', this.applyFunction, this);\n    EventHandler.add(cancelBtn, 'click', this.cancelFunction, this);\n    this.popupWrapper.appendChild(controlContainer);\n    if (!this.isMobile) {\n      if (!isUndefined(this.presets[0].start && this.presets[0].end && this.presets[0].label)) {\n        this.createPresets();\n        this.listRippleEffect();\n        addClass([controlContainer], RANGEBORDER);\n        addClass([this.popupWrapper], 'e-preset-wrapper');\n        const presets = this.popupWrapper.querySelector('.' + PRESETS);\n        presets.style.height = this.popupWrapper.querySelector('.' + RANGECONTAINER).getBoundingClientRect().height + 'px';\n      }\n    }\n    this.popupWrapper.appendChild(footerSection);\n    if (this.isMobile) {\n      this.deviceHeaderUpdate();\n    }\n    this.renderPopup();\n  }\n  cancelFunction(eve) {\n    if (document.activeElement !== this.inputElement) {\n      this.preventFocus = true;\n      this.inputElement.focus();\n      addClass([this.inputWrapper.container], [INPUTFOCUS$1]);\n    }\n    eve.preventDefault();\n    if (this.isKeyPopup) {\n      this.inputElement.focus();\n      this.isKeyPopup = false;\n    }\n    this.startValue = null;\n    this.endValue = null;\n    this.removeSelection();\n    this.hide(eve);\n  }\n  deviceHeaderUpdate() {\n    if (isNullOrUndefined(this.startValue) && isNullOrUndefined(this.endValue)) {\n      this.endButton.element.setAttribute('disabled', '');\n      this.startButton.element.classList.add(ACTIVE$1);\n    } else if (!isNullOrUndefined(this.startValue)) {\n      this.startButton.element.classList.add(ACTIVE$1);\n    }\n  }\n  applyFunction(eve) {\n    let isValueChanged = false;\n    if (eve.type !== 'touchstart') {\n      eve.preventDefault();\n    }\n    if (this.closeEventArgs && this.closeEventArgs.cancel) {\n      this.startValue = this.popupWrapper.querySelector('.e-start-date') && this.getIdValue(null, this.popupWrapper.querySelector('.e-start-date'));\n      this.endValue = this.popupWrapper.querySelector('.e-end-date') && this.getIdValue(null, this.popupWrapper.querySelector('.e-end-date'));\n      this.setValue();\n    }\n    if (document.activeElement !== this.inputElement) {\n      this.preventFocus = true;\n      this.inputElement.focus();\n      addClass([this.inputWrapper.container], [INPUTFOCUS$1]);\n    }\n    if (eve.type !== 'touchstart' && this.closeEventArgs && !this.closeEventArgs.cancel) {\n      eve.preventDefault();\n    }\n    if (!isNullOrUndefined(this.startValue) && !isNullOrUndefined(this.endValue)) {\n      this.previousStartValue = new Date(+this.startValue);\n      this.previousEndValue = new Date(+this.endValue);\n      this.previousEleValue = this.inputElement.value;\n      Input.setValue(this.rangeArgs(eve).text, this.inputElement, this.floatLabelType, this.showClearButton);\n      if (+this.initStartDate !== +this.startValue || +this.initEndDate !== +this.endValue) {\n        isValueChanged = true;\n      }\n      this.changeTrigger(eve);\n      this.hide(eve ? eve : null);\n      this.errorClass();\n      isValueChanged = true;\n    } else {\n      this.hide(eve ? eve : null);\n    }\n    if (!closest(eve.target, '.' + INPUTCONTAINER$1) && !isValueChanged) {\n      this.focusOut();\n    }\n    if (!this.isMobile) {\n      this.isKeyPopup = false;\n      if (this.isRangeIconClicked) {\n        this.inputWrapper.container.children[1].focus();\n        this.keyInputConfigs = extend(this.keyInputConfigs, this.keyConfigs);\n        this.popupKeyboardModule = new KeyboardEvents(this.inputWrapper.container.children[1], {\n          eventName: 'keydown',\n          keyConfigs: this.keyInputConfigs,\n          keyAction: this.popupKeyActionHandle.bind(this)\n        });\n      }\n    }\n  }\n  onMouseClick(event, item) {\n    if (event.type === 'touchstart') {\n      return;\n    }\n    const target = item || event.target;\n    const li = closest(target, '.' + LISTCLASS);\n    const isClick = li && li.classList.contains(ACTIVE$1);\n    if (li && li.classList.contains(LISTCLASS)) {\n      this.setListSelection(li, event);\n    }\n    this.preventFocus = true;\n    this.inputElement.focus();\n    if (!this.isMobile) {\n      this.preventFocus = true;\n      if (li && li.classList.contains(LISTCLASS) && li.getAttribute('id') === 'custom_range') {\n        this.leftCalendar.children[1].firstElementChild.focus();\n      } else {\n        if (!isClick && event.type === 'keydown') {\n          this.inputElement.focus();\n        }\n      }\n    }\n  }\n  onMouseOver(event) {\n    const li = closest(event.target, '.' + LISTCLASS);\n    if (li && li.classList.contains(LISTCLASS) && !li.classList.contains(HOVER)) {\n      addClass([li], HOVER);\n    }\n  }\n  onMouseLeave(event) {\n    const item = closest(event.target, '.' + HOVER);\n    if (!isNullOrUndefined(item)) {\n      removeClass([item], HOVER);\n    }\n  }\n  setListSelection(li, event) {\n    if (li && (!li.classList.contains(ACTIVE$1) || this.isMobile && li.classList.contains(ACTIVE$1))) {\n      if (this.isMobile && li.classList.contains(ACTIVE$1)) {\n        this.activeIndex = Array.prototype.slice.call(this.liCollections).indexOf(li);\n        const values = this.presetsItem[this.activeIndex];\n        if (values.id === 'custom_range') {\n          this.renderCustomPopup();\n          return;\n        }\n        return;\n      }\n      this.removeListSelection();\n      this.activeIndex = Array.prototype.slice.call(this.liCollections).indexOf(li);\n      addClass([li], ACTIVE$1);\n      li.setAttribute('aria-selected', 'true');\n      const values = this.presetsItem[this.activeIndex];\n      if (values.id === 'custom_range') {\n        this.renderCustomPopup();\n      } else {\n        this.applyPresetRange(values, event);\n      }\n    }\n  }\n  removeListSelection() {\n    const item = this.presetElement.querySelector('.' + ACTIVE$1);\n    if (!isNullOrUndefined(item)) {\n      removeClass([item], ACTIVE$1);\n      item.removeAttribute('aria-selected');\n    }\n  }\n  setValue() {\n    this.modelValue = [this.startValue, this.endValue];\n  }\n  applyPresetRange(values, e) {\n    this.hide(null);\n    this.presetsItem[this.presetsItem.length - 1].start = null;\n    this.presetsItem[this.presetsItem.length - 1].end = null;\n    this.startValue = values.start;\n    this.endValue = values.end;\n    this.setValue();\n    this.refreshControl();\n    this.trigger('select', this.rangeArgs(e));\n    this.changeTrigger(e);\n    this.previousEleValue = this.inputElement.value;\n    this.isCustomRange = false;\n    this.leftCalendar = this.rightCalendar = null;\n    if (this.isKeyPopup) {\n      this.isRangeIconClicked = false;\n      this.inputElement.focus();\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  showPopup(element, event) {\n    this.presetHeight();\n    if (this.zIndex === 1000) {\n      this.popupObj.show(null, this.element);\n    } else {\n      this.popupObj.show(null, null);\n    }\n    if (this.isMobile) {\n      this.popupObj.refreshPosition();\n    }\n  }\n  renderCustomPopup() {\n    this.isCustomWindow = true;\n    this.popupObj.hide();\n    this.popupWrapper = this.createElement('div', {\n      id: this.element.id + '_popup',\n      className: ROOT$2 + ' ' + POPUP$1\n    });\n    this.renderControl();\n    this.openEventArgs.appendTo.appendChild(this.popupWrapper);\n    this.showPopup();\n    this.isCustomRange = true;\n    if (!this.isMobile) {\n      this.calendarFocus();\n    }\n  }\n  listRippleEffect() {\n    for (const li of this.liCollections) {\n      rippleEffect(li);\n    }\n  }\n  createPresets() {\n    if (!isUndefined(this.presets[0].start && this.presets[0].end && this.presets[0].label)) {\n      this.presetElement = this.createElement('div', {\n        className: PRESETS,\n        attrs: {\n          'tabindex': '0'\n        }\n      });\n      const listTag = ListBase.createList(this.createElement, this.presetsItem, null, true);\n      attributes(listTag, {\n        'role': 'listbox',\n        'aria-hidden': 'false',\n        'id': this.element.id + '_options'\n      });\n      this.presetElement.appendChild(listTag);\n      this.popupWrapper.appendChild(this.presetElement);\n      const customElement = this.presetElement.querySelector('#custom_range');\n      if (!isNullOrUndefined(customElement)) {\n        customElement.textContent = this.l10n.getConstant('customRange') !== '' ? this.l10n.getConstant('customRange') : 'Custom Range';\n      }\n      this.liCollections = this.presetElement.querySelectorAll('.' + LISTCLASS);\n      this.wireListEvents();\n      if (this.isMobile) {\n        this.presetElement.style.width = this.inputWrapper.container.getBoundingClientRect().width + 'px';\n      }\n      if (!isNullOrUndefined(this.activeIndex) && this.activeIndex > -1) {\n        addClass([this.liCollections[this.activeIndex]], ACTIVE$1);\n      }\n    }\n  }\n  wireListEvents() {\n    EventHandler.add(this.presetElement, 'click', this.onMouseClick, this);\n    if (!this.isMobile) {\n      EventHandler.add(this.presetElement, 'mouseover', this.onMouseOver, this);\n      EventHandler.add(this.presetElement, 'mouseout', this.onMouseLeave, this);\n    }\n  }\n  unWireListEvents() {\n    if (!isNullOrUndefined(this.presetElement)) {\n      EventHandler.remove(this.presetElement, 'click touchstart', this.onMouseClick);\n      if (!this.isMobile) {\n        EventHandler.remove(this.presetElement, 'mouseover', this.onMouseOver);\n        EventHandler.remove(this.presetElement, 'mouseout', this.onMouseLeave);\n      }\n    }\n  }\n  renderPopup() {\n    this.popupWrapper.classList.add('e-control');\n    const popupWidth = this.popupWrapper.getBoundingClientRect().width;\n    if (!isNullOrUndefined(this.cssClass) && this.cssClass.trim() !== '') {\n      this.popupWrapper.className += ' ' + this.cssClass;\n    }\n    if (this.isMobile && this.isCustomWindow) {\n      this.modal = this.createElement('div');\n      document.body.appendChild(this.modal);\n    }\n    this.popupObj = new Popup(this.popupWrapper, {\n      relateTo: this.isMobile && this.isCustomWindow ? document.body : !isNullOrUndefined(this.targetElement) ? this.targetElement : this.inputWrapper.container,\n      position: this.isMobile ? !isUndefined(this.presets[0].start && this.presets[0].end && this.presets[0].label) && !this.isCustomWindow ? {\n        X: 'left',\n        Y: 'bottom'\n      } : {\n        X: 'center',\n        Y: 'center'\n      } : this.enableRtl ? {\n        X: 'left',\n        Y: 'bottom'\n      } : {\n        X: 'right',\n        Y: 'bottom'\n      },\n      offsetX: this.isMobile || this.enableRtl ? 0 : -popupWidth,\n      offsetY: OFFSETVALUE$1,\n      collision: this.isMobile ? !isUndefined(this.presets[0].start && this.presets[0].end && this.presets[0].label) && !this.isCustomWindow ? {\n        X: 'fit'\n      } : {\n        X: 'fit',\n        Y: 'fit'\n      } : {\n        X: 'fit',\n        Y: 'flip'\n      },\n      targetType: this.isMobile && this.isCustomWindow ? 'container' : 'relative',\n      enableRtl: this.enableRtl,\n      zIndex: this.zIndex,\n      open: () => {\n        attributes(this.inputElement, {\n          'aria-expanded': 'true'\n        });\n        addClass([this.inputWrapper.buttons[0]], ACTIVE$1);\n        if (!this.isMobile) {\n          if (this.cancelButton) {\n            this.btnKeyboardModule = new KeyboardEvents(this.cancelButton.element, {\n              eventName: 'keydown',\n              keyAction: this.popupKeyActionHandle.bind(this),\n              keyConfigs: {\n                tab: 'tab',\n                altRightArrow: 'alt+rightarrow',\n                altLeftArrow: 'alt+leftarrow'\n              }\n            });\n            this.btnKeyboardModule = new KeyboardEvents(this.applyButton.element, {\n              eventName: 'keydown',\n              keyAction: this.popupKeyActionHandle.bind(this),\n              keyConfigs: {\n                altRightArrow: 'alt+rightarrow',\n                altLeftArrow: 'alt+leftarrow'\n              }\n            });\n          }\n          if (!isNullOrUndefined(this.leftCalendar)) {\n            if (!this.isRangeIconClicked) {\n              this.calendarFocus();\n            }\n          }\n          if (!isNullOrUndefined(this.presetElement)) {\n            this.keyInputConfigs = extend(this.keyInputConfigs, this.keyConfigs);\n            this.presetKeyboardModule = new KeyboardEvents(this.presetElement, {\n              eventName: 'keydown',\n              keyAction: this.presetKeyActionHandler.bind(this),\n              keyConfigs: this.keyInputConfigs\n            });\n            this.presetKeyboardModule = new KeyboardEvents(this.presetElement, {\n              eventName: 'keydown',\n              keyAction: this.popupKeyActionHandle.bind(this),\n              keyConfigs: {\n                altRightArrow: 'alt+rightarrow',\n                altLeftArrow: 'alt+leftarrow'\n              }\n            });\n            if (isNullOrUndefined(this.leftCalendar)) {\n              this.preventBlur = true;\n              this.presetElement.focus();\n            } else {\n              this.presetElement.setAttribute('tabindex', '-1');\n            }\n          }\n          this.popupKeyBoardHandler();\n        }\n        if (this.isMobile && !Browser.isDevice) {\n          EventHandler.add(document, 'keydown', this.popupCloseHandler, this);\n        }\n      },\n      close: () => {\n        attributes(this.inputElement, {\n          'aria-expanded': 'false'\n        });\n        removeClass([this.inputWrapper.buttons[0]], ACTIVE$1);\n        if (this.isRangeIconClicked) {\n          this.inputWrapper.container.children[1].focus();\n        }\n        if (!isUndefined(this.presets[0].start && this.presets[0].end && this.presets[0].label)) {\n          this.unWireListEvents();\n        }\n        if (!isNullOrUndefined(this.popupObj)) {\n          if (!isNullOrUndefined(this.popupObj.element.parentElement)) {\n            detach(this.popupObj.element);\n          }\n          this.popupObj.destroy();\n          this.popupObj = null;\n        }\n        if (this.isMobile && !Browser.isDevice) {\n          EventHandler.remove(document, 'keydown', this.popupCloseHandler);\n        }\n      },\n      targetExitViewport: () => {\n        if (!Browser.isDevice) {\n          this.hide();\n        }\n      }\n    });\n    if (this.isMobile) {\n      this.popupObj.element.classList.add(DEVICE$1);\n      if (!this.isMobile) {\n        this.popupObj.element.classList.add('e-bigger');\n      }\n    }\n    if (this.isMobile && this.isCustomWindow) {\n      addClass([this.modal], [DEVICE$1, ROOT$2, 'e-range-modal']);\n      document.body.className += ' ' + OVERFLOW$1;\n      this.modal.style.display = 'block';\n    }\n    EventHandler.add(document, 'mousedown touchstart', this.documentHandler, this);\n  }\n  popupCloseHandler(e) {\n    switch (e.keyCode) {\n      case 27:\n        this.hide(e);\n        break;\n    }\n  }\n  calendarFocus() {\n    const startDate = this.popupObj && this.popupObj.element.querySelector('.' + STARTDATE);\n    if (startDate) {\n      let ele = closest(startDate, '.' + RIGHTCALENDER);\n      ele = isNullOrUndefined(ele) ? this.leftCalendar : ele;\n      if (this.isRangeIconClicked) {\n        this.inputWrapper.container.focus();\n      } else {\n        this.preventBlur = true;\n        ele.children[1].firstElementChild.focus();\n      }\n      addClass([startDate], FOCUSDATE);\n    } else {\n      if (this.isRangeIconClicked) {\n        this.inputWrapper.container.focus();\n      } else {\n        this.preventBlur = true;\n        this.leftCalendar.children[1].firstElementChild.focus();\n      }\n    }\n  }\n  presetHeight() {\n    const presets = this.popupObj && this.popupObj.element.querySelector('.' + PRESETS);\n    const rangeContainer = this.popupObj && this.popupObj.element.querySelector('.' + RANGECONTAINER);\n    if (!isNullOrUndefined(presets) && !isNullOrUndefined(rangeContainer)) {\n      presets.style.height = rangeContainer.getBoundingClientRect().height + 'px';\n    }\n  }\n  presetKeyActionHandler(e) {\n    switch (e.action) {\n      case 'moveDown':\n        this.listMoveDown(e);\n        this.setScrollPosition();\n        e.preventDefault();\n        break;\n      case 'moveUp':\n        this.listMoveUp(e);\n        this.setScrollPosition();\n        e.preventDefault();\n        break;\n      case 'enter':\n        {\n          const hvrItem = this.getHoverLI();\n          const actItem = this.getActiveLI();\n          if (!isNullOrUndefined(this.leftCalendar) && !isNullOrUndefined(actItem)) {\n            if (isNullOrUndefined(hvrItem) || !isNullOrUndefined(actItem) && actItem === hvrItem) {\n              this.activeIndex = Array.prototype.slice.call(this.liCollections).indexOf(actItem);\n              const values = this.presetsItem[this.activeIndex];\n              if (values.id === 'custom_range') {\n                this.calendarFocus();\n                actItem.classList.remove(HOVER);\n                e.preventDefault();\n                return;\n              }\n            }\n          }\n          if (!isNullOrUndefined(hvrItem) || !isNullOrUndefined(actItem)) {\n            this.onMouseClick(e, hvrItem || actItem);\n          }\n          e.preventDefault();\n        }\n        break;\n      case 'tab':\n        if (this.leftCalendar) {\n          const item = this.getHoverLI();\n          if (!isNullOrUndefined(item)) {\n            item.classList.remove(HOVER);\n          }\n        } else {\n          this.hide(e);\n          e.preventDefault();\n        }\n        break;\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  listMoveDown(e) {\n    const hvrItem = this.getHoverLI();\n    const actItem = this.getActiveLI();\n    if (!isNullOrUndefined(hvrItem)) {\n      const li = hvrItem.nextElementSibling;\n      if (!isNullOrUndefined(li) && li.classList.contains(LISTCLASS)) {\n        removeClass([hvrItem], HOVER);\n        addClass([li], HOVER);\n      }\n    } else if (!isNullOrUndefined(actItem)) {\n      const li = actItem.nextElementSibling;\n      if (!isNullOrUndefined(li) && li.classList.contains(LISTCLASS)) {\n        addClass([li], HOVER);\n      }\n    } else {\n      addClass([this.liCollections[0]], HOVER);\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  listMoveUp(e) {\n    const hvrItem = this.getHoverLI();\n    const actItem = this.getActiveLI();\n    if (!isNullOrUndefined(hvrItem)) {\n      const li = hvrItem.previousElementSibling;\n      if (!isNullOrUndefined(li) && li.classList.contains(LISTCLASS)) {\n        removeClass([hvrItem], HOVER);\n        addClass([li], HOVER);\n      }\n    } else if (!isNullOrUndefined(actItem)) {\n      const li = actItem.previousElementSibling;\n      if (!isNullOrUndefined(li) && li.classList.contains(LISTCLASS)) {\n        addClass([li], HOVER);\n      }\n    }\n  }\n  getHoverLI() {\n    const item = this.presetElement.querySelector('.' + HOVER);\n    return item;\n  }\n  getActiveLI() {\n    const item = this.presetElement.querySelector('.' + ACTIVE$1);\n    return item;\n  }\n  popupKeyBoardHandler() {\n    this.popupKeyboardModule = new KeyboardEvents(this.popupWrapper, {\n      eventName: 'keydown',\n      keyAction: this.popupKeyActionHandle.bind(this),\n      keyConfigs: {\n        escape: 'escape'\n      }\n    });\n    this.keyInputConfigs = extend(this.keyInputConfigs, this.keyConfigs);\n    this.popupKeyboardModule = new KeyboardEvents(this.inputWrapper.container.children[1], {\n      eventName: 'keydown',\n      keyAction: this.popupKeyActionHandle.bind(this),\n      keyConfigs: this.keyInputConfigs\n    });\n  }\n  setScrollPosition() {\n    const listHeight = this.presetElement.getBoundingClientRect().height;\n    const hover = this.presetElement.querySelector('.' + HOVER);\n    const active = this.presetElement.querySelector('.' + ACTIVE$1);\n    const element = !isNullOrUndefined(hover) ? hover : active;\n    if (!isNullOrUndefined(element)) {\n      const nextEle = element.nextElementSibling;\n      const height = nextEle ? nextEle.offsetTop : element.offsetTop;\n      const liHeight = element.getBoundingClientRect().height;\n      if (height + element.offsetTop > listHeight) {\n        this.presetElement.scrollTop = nextEle ? height - (listHeight / 2 + liHeight / 2) : height;\n      } else {\n        this.presetElement.scrollTop = 0;\n      }\n    }\n  }\n  popupKeyActionHandle(e) {\n    const presetElement = closest(e.target, '.' + PRESETS);\n    switch (e.action) {\n      case 'escape':\n        if (this.isPopupOpen()) {\n          if (this.isKeyPopup) {\n            this.inputElement.focus();\n            this.isKeyPopup = false;\n          }\n          this.hide(e);\n        } else {\n          this.inputWrapper.container.children[1].blur();\n        }\n        break;\n      case 'enter':\n        if (!this.isPopupOpen()) {\n          this.show(null, e);\n        } else {\n          this.inputWrapper.container.children[1].focus();\n        }\n        break;\n      case 'tab':\n        this.hide(e);\n        break;\n      case 'altRightArrow':\n        if (!isNullOrUndefined(presetElement)) {\n          this.cancelButton.element.focus();\n        } else {\n          if (document.activeElement === this.cancelButton.element && this.applyButton.element.disabled !== true) {\n            this.applyButton.element.focus();\n          } else {\n            this.leftCalendar.children[1].firstElementChild.focus();\n          }\n        }\n        e.preventDefault();\n        break;\n      case 'altLeftArrow':\n        if (!isNullOrUndefined(presetElement)) {\n          this.rightCalendar.children[1].firstElementChild.focus();\n        } else {\n          if (document.activeElement === this.applyButton.element && this.applyButton.element.disabled !== true) {\n            this.cancelButton.element.focus();\n          } else {\n            if (!isNullOrUndefined(this.presetElement) && document.activeElement === this.cancelButton.element) {\n              this.presetElement.focus();\n            } else {\n              this.rightCalendar.children[1].firstElementChild.focus();\n            }\n          }\n        }\n        e.preventDefault();\n        break;\n    }\n  }\n  documentHandler(e) {\n    if (isNullOrUndefined(this.popupObj)) {\n      return;\n    }\n    const target = e.target;\n    if (!this.inputWrapper.container.contains(target) || !isNullOrUndefined(this.popupObj) && !closest(target, '[id=\"' + this.popupWrapper.id + '\"]')) {\n      if (e.type !== 'touchstart' && (e.type === 'mousedown' || this.closeEventArgs && !this.closeEventArgs.cancel)) {\n        e.preventDefault();\n      }\n    }\n    if ((isNullOrUndefined(this.targetElement) || !isNullOrUndefined(this.targetElement) && !(target === this.targetElement)) && !closest(target, '[id=\"' + this.popupWrapper.id + '\"]') && !(closest(target, '.' + INPUTCONTAINER$1) === this.inputWrapper.container) && !(closest(target, '.e-daterangepicker.e-popup') && !target.classList.contains('e-day'))) {\n      this.preventBlur = false;\n      if (this.isPopupOpen() && document.body.contains(this.popupObj.element)) {\n        this.applyFunction(e);\n        if (!this.isMobile) {\n          this.isRangeIconClicked = false;\n        }\n      }\n    }\n  }\n  createInput() {\n    let updatedCssClassValue = this.cssClass;\n    if (!isNullOrUndefined(this.cssClass) && this.cssClass !== '') {\n      updatedCssClassValue = this.cssClass.replace(/\\s+/g, ' ').trim();\n    }\n    this.inputWrapper = Input.createInput({\n      floatLabelType: this.floatLabelType,\n      element: this.inputElement,\n      properties: {\n        readonly: this.readonly,\n        placeholder: this.placeholder,\n        cssClass: updatedCssClassValue,\n        enabled: this.enabled,\n        enableRtl: this.enableRtl,\n        showClearButton: this.showClearButton\n      },\n      buttons: [DATERANGEICON]\n    }, this.createElement);\n    attributes(this.inputElement, {\n      'aria-readonly': this.readonly ? 'true' : 'false',\n      'tabindex': '0',\n      'aria-haspopup': 'true',\n      'aria-activedescendant': 'null',\n      'aria-owns': this.element.id + '_popup',\n      'aria-expanded': 'false',\n      'role': 'combobox',\n      'autocomplete': 'off',\n      'aria-disabled': !this.enabled ? 'true' : 'false',\n      'autocorrect': 'off',\n      'autocapitalize': 'off',\n      'spellcheck': 'false'\n    });\n    Input.addAttributes({\n      'aria-label': 'select'\n    }, this.inputWrapper.buttons[0]);\n    if (!isNullOrUndefined(this.placeholder) && this.placeholder.trim() !== '') {\n      Input.addAttributes({\n        'aria-placeholder': this.placeholder\n      }, this.inputElement);\n    }\n    this.setEleWidth(this.width);\n    addClass([this.inputWrapper.container], DATERANGEWRAPPER);\n    if (isNullOrUndefined(this.inputElement.getAttribute('name'))) {\n      attributes(this.inputElement, {\n        'name': this.element.id\n      });\n    }\n    if (this.inputElement.type === 'hidden') {\n      this.inputWrapper.container.style.display = 'none';\n    }\n    this.refreshControl();\n    this.previousEleValue = this.inputElement.value;\n    this.inputElement.setAttribute('value', this.inputElement.value);\n    this.startCopy = this.startDate;\n    this.endCopy = this.endDate;\n  }\n  setEleWidth(width) {\n    if (typeof width === 'string') {\n      this.inputWrapper.container.style.width = this.width;\n    } else if (typeof width === 'number') {\n      this.inputWrapper.container.style.width = formatUnit(this.width);\n    } else {\n      this.inputWrapper.container.style.width = '100%';\n    }\n  }\n  adjustLongHeaderWidth() {\n    if (this.dayHeaderFormat === 'Wide') {\n      addClass([this.popupWrapper], DAYHEADERLONG$1);\n    }\n  }\n  refreshControl() {\n    this.validateMinMax();\n    if (this.strictMode) {\n      this.validateRangeStrict();\n    }\n    const isDisabled = this.disabledDates();\n    if (this.strictMode && isDisabled) {\n      this.startValue = this.previousStartValue;\n      this.setProperties({\n        startDate: this.startValue\n      }, true);\n      this.endValue = this.previousEndValue;\n      this.setProperties({\n        endDate: this.endValue\n      }, true);\n      this.setValue();\n    }\n    this.updateInput();\n    if (!this.strictMode) {\n      this.validateRange();\n    }\n    if (!this.strictMode && isDisabled) {\n      this.clearRange();\n    }\n    if (!isNullOrUndefined(this.endValue) && !isNullOrUndefined(this.startValue) && !isDisabled) {\n      this.disabledDateRender();\n    }\n    this.errorClass();\n    this.previousStartValue = isNullOrUndefined(this.startValue) || isNaN(+this.startValue) ? null : new Date(+this.startValue);\n    this.previousEndValue = isNullOrUndefined(this.endValue) || isNaN(+this.endValue) ? null : new Date(+this.endValue);\n  }\n  updateInput() {\n    if (!isNullOrUndefined(this.endValue) && !isNullOrUndefined(this.startValue)) {\n      const formatOption = {\n        format: this.formatString,\n        type: 'date',\n        skeleton: 'yMd'\n      };\n      const startDate = this.globalize.formatDate(this.startValue, formatOption);\n      const endDate = this.globalize.formatDate(this.endValue, formatOption);\n      Input.setValue(startDate + ' ' + this.separator + ' ' + endDate, this.inputElement, this.floatLabelType, this.showClearButton);\n      this.previousStartValue = new Date(+this.startValue);\n      this.previousEndValue = new Date(+this.endValue);\n    }\n    if (!this.strictMode && isNullOrUndefined(this.value) && this.invalidValueString) {\n      Input.setValue(this.invalidValueString, this.inputElement, this.floatLabelType, this.showClearButton);\n    }\n  }\n  checkInvalidRange(value) {\n    if (!isNullOrUndefined(value)) {\n      let invalid = false;\n      let startinvalue;\n      let endinvalue;\n      let startString = null;\n      let endString = null;\n      let valueString = null;\n      let startObject = false;\n      let endObject = false;\n      let invalidobject = false;\n      if (typeof value === 'string') {\n        const range = value.split(' ' + this.separator + ' ');\n        if (range.length === 2) {\n          startString = range[0];\n          endString = range[1];\n        } else {\n          invalid = true;\n          valueString = value;\n        }\n      } else {\n        if (value.length > 0) {\n          startinvalue = value[0];\n          endinvalue = value[1];\n        } else {\n          startinvalue = value.start;\n          endinvalue = value.end;\n        }\n        if (!(startinvalue instanceof Date) && typeof startinvalue !== 'object') {\n          startString = this.getstringvalue(startinvalue);\n        } else if (startinvalue instanceof Date) {\n          startObject = true;\n        } else if (!isNullOrUndefined(startinvalue)) {\n          invalidobject = true;\n        }\n        if (!(endinvalue instanceof Date) && typeof endinvalue !== 'object') {\n          endString = this.getstringvalue(endinvalue);\n        } else if (endinvalue instanceof Date) {\n          endObject = true;\n        } else if (!isNullOrUndefined(endinvalue)) {\n          invalidobject = true;\n        }\n      }\n      if (isNullOrUndefined(startString) && !startObject && !isNullOrUndefined(endString) || !isNullOrUndefined(startString) && !endObject && isNullOrUndefined(endString)) {\n        invalid = true;\n      }\n      if (invalidobject) {\n        startString = endString = valueString = null;\n        invalid = true;\n      }\n      if (startString) {\n        invalid = invalid || this.checkInvalidValue(startString);\n      }\n      if (endString) {\n        invalid = invalid || this.checkInvalidValue(endString);\n      }\n      if (invalid) {\n        if (startObject && !invalidobject) {\n          startString = startinvalue.toLocaleDateString();\n        }\n        if (endObject && !invalidobject) {\n          endString = endinvalue.toLocaleDateString();\n        }\n        if (!isNullOrUndefined(startString) && !isNullOrUndefined(endString)) {\n          valueString = startString + ' ' + this.separator + ' ' + endString;\n        } else if (!isNullOrUndefined(startString)) {\n          valueString = startString;\n        } else if (!isNullOrUndefined(endString)) {\n          valueString = endString;\n        }\n        this.invalidValueString = valueString;\n        this.setProperties({\n          value: null\n        }, true);\n        this.setProperties({\n          startValue: null\n        }, true);\n        this.setProperties({\n          endValue: null\n        }, true);\n        this.startDate = null;\n        this.endDate = null;\n      }\n    }\n  }\n  getstringvalue(value) {\n    let stringValue = null;\n    if (!isNullOrUndefined(value) && typeof value === 'number') {\n      stringValue = value.toString();\n    } else if (!isNullOrUndefined(value) && typeof value === 'string') {\n      stringValue = '' + value;\n    }\n    return stringValue;\n  }\n  checkInvalidValue(value) {\n    const valueString = value;\n    let invalid = false;\n    let formatOpt = null;\n    formatOpt = {\n      format: this.formatString,\n      type: 'date',\n      skeleton: 'yMd'\n    };\n    if (typeof valueString !== 'string') {\n      invalid = true;\n    } else {\n      const globalize = new Internationalization(this.locale);\n      if (!this.checkDateValue(globalize.parseDate(valueString, formatOpt))) {\n        let extISOStr = null;\n        let basISOString = null;\n        // eslint-disable-next-line\n        extISOStr = /^\\s*((?:[+-]\\d{6}|\\d{4})-(?:\\d\\d-\\d\\d|W\\d\\d-\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?::\\d\\d(?::\\d\\d(?:[.,]\\d+)?)?)?)([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?/;\n        // eslint-disable-next-line\n        basISOString = /^\\s*((?:[+-]\\d{6}|\\d{4})(?:\\d\\d\\d\\d|W\\d\\d\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?:\\d\\d(?:\\d\\d(?:[.,]\\d+)?)?)?)([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?/;\n        if (!extISOStr.test(valueString) && !basISOString.test(valueString) || /^[a-zA-Z0-9- ]*$/.test(valueString) || isNaN(+new Date(this.checkValue(valueString)))) {\n          invalid = true;\n        }\n      }\n    }\n    return invalid;\n  }\n  isDateDisabled(date) {\n    if (isNullOrUndefined(date)) {\n      return false;\n    }\n    const value = new Date(+date);\n    if (+value < +this.min || +value > +this.max) {\n      return true;\n    }\n    this.virtualRenderCellArgs = {\n      date: value,\n      isDisabled: false\n    };\n    const args = this.virtualRenderCellArgs;\n    this.virtualRenderCellEvent(args);\n    if (args.isDisabled) {\n      return true;\n    }\n    return false;\n  }\n  disabledDateRender() {\n    this.disabledDays = [];\n    this.disabledDayCnt = null;\n    const localDate = new Date(+this.startValue);\n    let count = 0;\n    while (+localDate <= +this.endValue && +this.endValue <= +this.max) {\n      this.virtualRenderCellArgs = {\n        date: localDate,\n        isDisabled: false\n      };\n      const args = this.virtualRenderCellArgs;\n      this.virtualRenderCellEvent(args);\n      if (args.isDisabled) {\n        this.disabledDays.push(new Date(+args.date));\n        if (+localDate > +this.startValue && +localDate < +this.endValue) {\n          count++;\n        }\n      }\n      this.addDay(localDate, 1, null, this.max, this.min);\n    }\n    this.disabledDayCnt = count;\n  }\n  virtualRenderCellEvent(args) {\n    extend(this.virtualRenderCellArgs, {\n      name: 'renderDayCell'\n    });\n    this.trigger('renderDayCell', args);\n  }\n  disabledDates() {\n    let isStartDisabled = false;\n    let isEndDisabled = false;\n    if (!isNullOrUndefined(this.endValue) && !isNullOrUndefined(this.startValue)) {\n      isStartDisabled = this.isDateDisabled(this.startValue);\n      isEndDisabled = this.isDateDisabled(this.endValue);\n      if (!this.isPopupOpen()) {\n        this.currentDate = null;\n      }\n      this.setValue();\n    }\n    return isStartDisabled || isEndDisabled;\n  }\n  setModelValue() {\n    if (!this.value && this.startDate === null && this.endDate === null) {\n      this.setProperties({\n        value: null\n      }, true);\n    } else if (this.value === null || this.value.start === null) {\n      if (this.value === null) {\n        this.setProperties({\n          value: [this.startDate, this.endDate]\n        }, true);\n      } else if (this.value.start === null) {\n        this.setProperties({\n          value: {\n            start: this.startDate,\n            end: this.endDate\n          }\n        }, true);\n      }\n    } else {\n      if (this.value && this.value.length > 0 || this.valueType && this.valueType.length > 0) {\n        if (+this.startDate !== +this.value[0] || +this.endDate !== +this.value[1]) {\n          this.setProperties({\n            value: [this.startDate, this.endDate]\n          }, true);\n        }\n        if (this.value && this.value[0] == null && this.value[1] == null) {\n          this.setProperties({\n            value: null\n          }, true);\n        }\n      } else {\n        if (this.value && this.value.start) {\n          this.setProperties({\n            value: {\n              start: this.startDate,\n              end: this.endDate\n            }\n          }, true);\n        }\n      }\n    }\n    this.createHiddenInput();\n  }\n  /**\n   * To dispatch the event manually\n   *\n   * @param {HTMLElement} element - Specifies the element to dispatch the event.\n   * @param {string} type - Specifies the name of the event.\n   * @returns {void}\n   */\n  dispatchEvent(element, type) {\n    const evt = document.createEvent('HTMLEvents');\n    evt.initEvent(type, false, true);\n    element.dispatchEvent(evt);\n    this.firstHiddenChild.dispatchEvent(evt);\n  }\n  changeTrigger(e) {\n    if (+this.initStartDate !== +this.startValue || +this.initEndDate !== +this.endValue) {\n      this.setProperties({\n        endDate: this.checkDateValue(this.endValue)\n      }, true);\n      this.setProperties({\n        startDate: this.checkDateValue(this.startValue)\n      }, true);\n      this.setModelValue();\n      if (this.isAngular && this.preventChange) {\n        this.preventChange = false;\n      } else {\n        this.trigger('change', this.rangeArgs(e));\n      }\n    }\n    this.previousEleValue = this.inputElement.value;\n    this.initStartDate = this.checkDateValue(this.startValue);\n    this.initEndDate = this.checkDateValue(this.endValue);\n  }\n  /**\n   * This method is used to navigate to the month/year/decade view of the Calendar.\n   *\n   * @param  {string} view - Specifies the view of the Calendar.\n   * @param  {Date} date - Specifies the focused date in a view.\n   * @returns {void}\n   * @hidden\n   */\n  navigateTo(view, date) {\n    if (this.isPopupOpen()) {\n      if (view.toLowerCase() === 'month') {\n        view = 'Month';\n      } else if (view.toLowerCase() === 'year') {\n        view = 'Year';\n      } else if (view.toLowerCase() === 'decade') {\n        view = 'Decade';\n      } else {\n        return;\n      }\n      if (this.getViewNumber(view) < this.getViewNumber(this.depth)) {\n        view = this.depth;\n      }\n      if (this.isMobile) {\n        super.navigateTo.call(this, view, date);\n      } else {\n        if (date < this.min) {\n          date = new Date(+this.min);\n        } else if (date >= this.max) {\n          date = new Date(+this.max);\n        }\n        if (view === 'Month' && this.isSameMonth(date, this.max)) {\n          date = new Date(this.max.getFullYear(), this.max.getMonth() - 1, this.min.getDate());\n        } else if (view === 'Year' && this.isSameYear(date, this.max)) {\n          date = new Date(this.max.getFullYear() - 1, this.max.getMonth(), this.max.getDate());\n        } else if (view === 'Decade' && this.isSameDecade(date, this.max)) {\n          date = new Date(this.max.getFullYear() - 10, this.max.getMonth(), this.max.getDate());\n        }\n        this.leftCalCurrentDate = date;\n        this.navigate(this.leftCalendar, this.leftCalCurrentDate, view);\n        if (view === 'Month') {\n          date = new Date(this.currentDate.setMonth(this.currentDate.getMonth() + 1));\n        } else if (view === 'Year') {\n          date = new Date(this.currentDate.setFullYear(this.currentDate.getFullYear() + 1));\n        } else {\n          date = new Date(this.currentDate.setFullYear(this.currentDate.getFullYear() + 10));\n        }\n        this.rightCalCurrentDate = date;\n        this.navigate(this.rightCalendar, this.rightCalCurrentDate, view);\n        this.leftKeyboardModule = this.rightKeyboardModule = null;\n        this.updateNavIcons();\n      }\n      if (this.currentView() === this.depth) {\n        this.bindCalendarCellEvents();\n      }\n      this.removeFocusedDate();\n      this.updateRange(this.isMobile ? [this.calendarElement] : [this.leftCalendar, this.rightCalendar]);\n    }\n  }\n  navigate(calendar, date, view) {\n    this.calendarElement = calendar;\n    this.table = calendar.querySelector('table');\n    this.tableBodyElement = calendar.querySelector('tbody');\n    this.headerTitleElement = calendar.querySelector('.e-title');\n    this.tableHeadElement = calendar.querySelector('thead');\n    this.contentElement = calendar.querySelector('.e-content');\n    this.previousIcon = calendar.querySelector('.e-prev');\n    this.nextIcon = calendar.querySelector('.e-next');\n    this.effect = ZOOMIN$1;\n    super.navigateTo.call(this, view, date);\n  }\n  /**\n   * Sets the focus to widget for interaction.\n   *\n   * @returns {void}\n   */\n  focusIn() {\n    if (document.activeElement !== this.inputElement && this.enabled) {\n      addClass([this.inputWrapper.container], [INPUTFOCUS$1]);\n      this.inputElement.focus();\n    }\n  }\n  /**\n   * Remove the focus from widget, if the widget is in focus state.\n   *\n   * @returns {void}\n   */\n  focusOut() {\n    const isBlur = this.preventBlur;\n    if (document.activeElement === this.inputElement) {\n      removeClass([this.inputWrapper.container], [INPUTFOCUS$1]);\n      this.preventBlur = false;\n      this.inputElement.blur();\n      this.preventBlur = isBlur;\n    }\n  }\n  /**\n   * To destroy the widget.\n   *\n   * @returns {void}\n   */\n  destroy() {\n    this.unBindEvents();\n    this.hide(null);\n    const ariaAttrs = {\n      'aria-readonly': this.readonly ? 'true' : 'false',\n      'tabindex': '0',\n      'aria-haspopup': 'true',\n      'aria-activedescendant': 'null',\n      'aria-owns': this.element.id + '_popup',\n      'aria-expanded': 'false',\n      'role': 'combobox',\n      'autocomplete': 'off',\n      'aria-disabled': !this.enabled ? 'true' : 'false',\n      'autocorrect': 'off',\n      'autocapitalize': 'off',\n      'aria-invalid': 'false',\n      'spellcheck': 'false'\n    };\n    if (this.inputElement) {\n      removeClass([this.inputElement], [ROOT$2]);\n      EventHandler.remove(this.inputElement, 'blur', this.inputBlurHandler);\n      Input.removeAttributes(ariaAttrs, this.inputElement);\n      if (!isNullOrUndefined(this.cloneElement.getAttribute('tabindex'))) {\n        this.inputElement.setAttribute('tabindex', this.tabIndex);\n      } else {\n        this.inputElement.removeAttribute('tabindex');\n      }\n      this.ensureInputAttribute();\n      this.inputElement.classList.remove('e-input');\n      if (!isNullOrUndefined(this.inputWrapper)) {\n        EventHandler.remove(this.inputWrapper.buttons[0], 'mousedown', this.rangeIconHandler);\n        if (this.angularTag === null) {\n          this.inputWrapper.container.parentElement.appendChild(this.inputElement);\n        }\n        detach(this.inputWrapper.container);\n      }\n    }\n    if (!isNullOrUndefined(this.inputKeyboardModule) && !this.isMobile) {\n      this.inputKeyboardModule.destroy();\n    }\n    if (this.popupObj) {\n      if (!this.isMobile) {\n        this.clearCalendarEvents();\n      }\n    }\n    super.destroy();\n    this.inputWrapper = this.popupWrapper = this.popupObj = this.cloneElement = this.presetElement = null;\n    if (this.formElement) {\n      EventHandler.remove(this.formElement, 'reset', this.formResetHandler);\n    }\n    if (!isNullOrUndefined(this.firstHiddenChild) && !isNullOrUndefined(this.secondHiddenChild)) {\n      detach(this.firstHiddenChild);\n      detach(this.secondHiddenChild);\n      this.firstHiddenChild = this.secondHiddenChild = null;\n      this.inputElement.setAttribute('name', this.element.getAttribute('data-name'));\n      this.inputElement.removeAttribute('data-name');\n    }\n  }\n  ensureInputAttribute() {\n    const attr = [];\n    for (let i = 0; i < this.inputElement.attributes.length; i++) {\n      attr[i] = this.inputElement.attributes[i].name;\n    }\n    for (let i = 0; i < attr.length; i++) {\n      if (isNullOrUndefined(this.cloneElement.getAttribute(attr[i]))) {\n        if (attr[i].toLowerCase() === 'value') {\n          this.inputElement.value = '';\n        }\n        this.inputElement.removeAttribute(attr[i]);\n      } else {\n        if (attr[i].toLowerCase() === 'value') {\n          this.inputElement.value = this.cloneElement.getAttribute(attr[i]);\n        }\n        this.inputElement.setAttribute(attr[i], this.cloneElement.getAttribute(attr[i]));\n      }\n    }\n  }\n  /**\n   * To get component name\n   *\n   * @returns {string} Returns the component name.\n   * @private\n   */\n  getModuleName() {\n    return 'daterangepicker';\n  }\n  /* eslint-disable valid-jsdoc, jsdoc/require-returns-description */\n  /**\n   * Return the properties that are maintained upon browser refresh.\n   *\n   * @returns {string}\n   */\n  getPersistData() {\n    const keyEntity = ['startDate', 'endDate', 'value'];\n    return this.addOnPersist(keyEntity);\n  }\n  /**\n   * Return the selected range and day span in the DateRangePicker.\n   *\n   * @returns {Object}\n   */\n  getSelectedRange() {\n    let range;\n    if (!isNullOrUndefined(this.startValue) && !isNullOrUndefined(this.endValue)) {\n      range = Math.round(Math.abs((this.removeTimeValueFromDate(this.startValue).getTime() - this.removeTimeValueFromDate(this.endValue).getTime()) / (1000 * 60 * 60 * 24))) + 1;\n      this.disabledDateRender();\n      if (!isNullOrUndefined(this.disabledDayCnt)) {\n        range = range - this.disabledDayCnt;\n        this.disabledDayCnt = null;\n      }\n    } else {\n      range = 0;\n    }\n    return {\n      startDate: this.startValue,\n      endDate: this.endValue,\n      daySpan: range\n    };\n  }\n  /* eslint-enable valid-jsdoc, jsdoc/require-returns-description */\n  /* eslint-disable valid-jsdoc, jsdoc/require-param */\n  /**\n   * To open the Popup container in the DateRangePicker component.\n   *\n   * @param {HTMLElement} element - Specifies element.\n   * @returns {void}\n   */\n  show(element, event) {\n    if (this.isMobile && this.popupObj) {\n      this.popupObj.refreshPosition();\n    }\n    if (this.enabled && this.readonly || !this.enabled || this.popupObj) {\n      return;\n    } else {\n      if (!this.isPopupOpen()) {\n        if (element) {\n          this.targetElement = element;\n        }\n        this.createPopup();\n        if (this.isMobile || Browser.isDevice) {\n          this.mobileRangePopupWrap = this.createElement('div', {\n            className: 'e-daterangepick-mob-popup-wrap'\n          });\n          document.body.appendChild(this.mobileRangePopupWrap);\n        }\n        this.openEventArgs = {\n          popup: this.popupObj || null,\n          cancel: false,\n          date: this.inputElement.value,\n          model: this,\n          event: event ? event : null,\n          appendTo: this.isMobile || Browser.isDevice ? this.mobileRangePopupWrap : document.body\n        };\n        const eventArgs = this.openEventArgs;\n        this.trigger('open', eventArgs, eventArgs => {\n          this.openEventArgs = eventArgs;\n          if (!this.openEventArgs.cancel) {\n            this.openEventArgs.appendTo.appendChild(this.popupWrapper);\n            this.showPopup(element, event);\n            const isPreset = !this.isCustomRange || this.isMobile && this.isCustomRange;\n            if (!isUndefined(this.presets[0].start && this.presets[0].end && this.presets[0].label) && isPreset) {\n              this.setScrollPosition();\n            }\n            this.checkMinMaxDays();\n            if (this.isMobile && !isNullOrUndefined(this.startDate) && isNullOrUndefined(this.endDate)) {\n              this.endButton.element.classList.add(ACTIVE$1);\n              this.startButton.element.classList.remove(ACTIVE$1);\n              this.endButton.element.removeAttribute('disabled');\n              this.selectableDates();\n            }\n            super.setOverlayIndex(this.mobileRangePopupWrap, this.popupObj.element, this.modal,\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.isMobile || Browser.isDevice);\n          }\n        });\n      }\n    }\n  }\n  /**\n   * To close the Popup container in the DateRangePicker component.\n   *\n   * @returns {void}\n   */\n  hide(event) {\n    if (this.popupObj) {\n      if (isNullOrUndefined(this.previousEndValue) && isNullOrUndefined(this.previousStartValue)) {\n        this.clearRange();\n      } else {\n        if (!isNullOrUndefined(this.previousStartValue)) {\n          this.startValue = new Date(this.checkValue(this.previousStartValue));\n          this.setValue();\n          this.currentDate = new Date(this.checkValue(this.startValue));\n        } else {\n          this.startValue = null;\n          this.setValue();\n        }\n        if (!isNullOrUndefined(this.previousEndValue)) {\n          this.endValue = new Date(this.checkValue(this.previousEndValue));\n          this.setValue();\n        } else {\n          this.endValue = null;\n          this.setValue();\n        }\n      }\n      if (this.isPopupOpen()) {\n        this.closeEventArgs = {\n          cancel: false,\n          popup: this.popupObj,\n          date: this.inputElement.value,\n          model: this,\n          event: event ? event : null\n        };\n        const eventArgs = this.closeEventArgs;\n        this.trigger('close', eventArgs, eventArgs => {\n          this.closeEventArgs = eventArgs;\n          if (!this.closeEventArgs.cancel) {\n            if (this.isMobile) {\n              if (!isNullOrUndefined(this.startButton) && !isNullOrUndefined(this.endButton)) {\n                EventHandler.remove(this.startButton.element, 'click touchstart', this.deviceHeaderClick);\n                EventHandler.remove(this.endButton.element, 'click touchstart', this.deviceHeaderClick);\n              }\n            }\n            if (this.popupObj) {\n              this.popupObj.hide();\n              if (this.preventBlur) {\n                this.inputElement.focus();\n                addClass([this.inputWrapper.container], [INPUTFOCUS$1]);\n              }\n            }\n            if (!this.isMobile) {\n              if (!isNullOrUndefined(this.leftKeyboardModule) && !isNullOrUndefined(this.rightKeyboardModule)) {\n                this.leftKeyboardModule.destroy();\n                this.rightKeyboardModule.destroy();\n              }\n              if (!isNullOrUndefined(this.presetElement)) {\n                this.presetKeyboardModule.destroy();\n              }\n              if (!isNullOrUndefined(this.cancelButton)) {\n                this.btnKeyboardModule.destroy();\n              }\n            }\n            this.targetElement = null;\n            removeClass([document.body], OVERFLOW$1);\n            EventHandler.remove(document, 'mousedown touchstart', this.documentHandler);\n            if (this.isMobile && this.modal) {\n              this.modal.style.display = 'none';\n              this.modal.outerHTML = '';\n              this.modal = null;\n            }\n            if (this.isMobile || Browser.isDevice) {\n              if (!isNullOrUndefined(this.mobileRangePopupWrap)) {\n                this.mobileRangePopupWrap.remove();\n                this.mobileRangePopupWrap = null;\n              }\n            }\n            this.isKeyPopup = this.dateDisabled = false;\n          } else {\n            removeClass([this.inputWrapper.buttons[0]], ACTIVE$1);\n          }\n          this.updateClearIconState();\n          this.updateHiddenInput();\n          if (this.isMobile && this.allowEdit && !this.readonly) {\n            this.inputElement.removeAttribute('readonly');\n          }\n        });\n      }\n    } else {\n      this.updateClearIconState();\n      this.updateHiddenInput();\n      if (this.isMobile && this.allowEdit && !this.readonly) {\n        this.inputElement.removeAttribute('readonly');\n      }\n    }\n  }\n  /* eslint-enable valid-jsdoc, jsdoc/require-param */\n  setLocale() {\n    this.globalize = new Internationalization(this.locale);\n    this.l10n.setLocale(this.locale);\n    this.setProperties({\n      placeholder: this.l10n.getConstant('placeholder')\n    }, true);\n    Input.setPlaceholder(this.placeholder, this.inputElement);\n    this.updateInput();\n    this.updateHiddenInput();\n    this.changeTrigger();\n  }\n  refreshChange() {\n    this.checkView();\n    this.refreshControl();\n    this.changeTrigger();\n  }\n  setDate() {\n    Input.setValue('', this.inputElement, this.floatLabelType, this.showClearButton);\n    this.refreshChange();\n  }\n  enableInput() {\n    if (+this.min <= +this.max) {\n      this.setProperties({\n        enabled: true\n      }, true);\n      Input.setEnabled(this.enabled, this.inputElement);\n      if (this.element.hasAttribute('disabled')) {\n        this.bindEvents();\n      }\n    }\n  }\n  clearModelvalue(newProp, oldProp) {\n    this.setProperties({\n      startDate: null\n    }, true);\n    this.setProperties({\n      endDate: null\n    }, true);\n    if (oldProp.value && oldProp.value.length > 0) {\n      this.setProperties({\n        value: null\n      }, true);\n    } else if (oldProp.value && oldProp.value.start) {\n      this.setProperties({\n        value: {\n          start: null,\n          end: null\n        }\n      }, true);\n    } else if (oldProp.value && !oldProp.value.start) {\n      this.setProperties({\n        value: {\n          start: null,\n          end: null\n        }\n      }, true);\n    }\n    this.updateValue();\n    this.setDate();\n  }\n  createHiddenInput() {\n    if (isNullOrUndefined(this.firstHiddenChild) && isNullOrUndefined(this.secondHiddenChild)) {\n      this.firstHiddenChild = this.createElement('input');\n      this.secondHiddenChild = this.createElement('input');\n    }\n    if (!isNullOrUndefined(this.inputElement.getAttribute('name'))) {\n      this.inputElement.setAttribute('data-name', this.inputElement.getAttribute('name'));\n      this.inputElement.removeAttribute('name');\n    }\n    attributes(this.firstHiddenChild, {\n      'type': 'text',\n      'name': this.inputElement.getAttribute('data-name'),\n      'class': HIDDENELEMENT\n    });\n    attributes(this.secondHiddenChild, {\n      'type': 'text',\n      'name': this.inputElement.getAttribute('data-name'),\n      'class': HIDDENELEMENT\n    });\n    const format = {\n      type: 'datetime',\n      skeleton: 'yMd'\n    };\n    this.firstHiddenChild.value = this.startDate && this.globalize.formatDate(this.startDate, format);\n    this.secondHiddenChild.value = this.endDate && this.globalize.formatDate(this.endDate, format);\n    this.inputElement.parentElement.appendChild(this.firstHiddenChild);\n    this.inputElement.parentElement.appendChild(this.secondHiddenChild);\n  }\n  setMinMaxDays() {\n    if (this.isPopupOpen()) {\n      this.removeClassDisabled();\n      this.checkMinMaxDays();\n      if (this.isMobile) {\n        this.selectableDates();\n      }\n      if (!this.strictMode && isNullOrUndefined(this.startValue) && isNullOrUndefined(this.endValue)) {\n        this.removeSelection();\n      } else {\n        this.updateRange(this.isMobile ? [this.calendarElement] : [this.leftCalendar, this.rightCalendar]);\n      }\n      this.updateHeader();\n    }\n  }\n  /**\n   * Called internally if any of the property value changed.\n   *\n   * @param {DateRangePickerModel} newProp - Returns the dynamic property value of the component.\n   * @param {DateRangePickerModel} oldProp - Returns the previous property value of the component.\n   * @returns {void}\n   * @private\n   */\n  onPropertyChanged(newProp, oldProp) {\n    const format = {\n      format: this.formatString,\n      type: 'date',\n      skeleton: 'yMd'\n    };\n    for (const prop of Object.keys(newProp)) {\n      const openPopup = ['maxDays', 'minDays', 'value'];\n      if (openPopup.indexOf(prop) < 0) {\n        this.hide(null);\n      }\n      switch (prop) {\n        case 'width':\n          this.setEleWidth(this.width);\n          break;\n        case 'separator':\n          this.previousEleValue = this.inputElement.value;\n          this.setProperties({\n            separator: newProp.separator\n          }, true);\n          this.updateInput();\n          this.changeTrigger();\n          break;\n        case 'placeholder':\n          Input.setPlaceholder(newProp.placeholder, this.inputElement);\n          this.setProperties({\n            placeholder: newProp.placeholder\n          }, true);\n          break;\n        case 'readonly':\n          Input.setReadonly(this.readonly, this.inputElement);\n          this.inputElement.setAttribute('aria-readonly', '' + this.readonly);\n          this.setRangeAllowEdit();\n          break;\n        case 'cssClass':\n          this.updateCssClass(newProp.cssClass, oldProp.cssClass);\n          break;\n        case 'enabled':\n          this.setProperties({\n            enabled: newProp.enabled\n          }, true);\n          Input.setEnabled(this.enabled, this.inputElement);\n          if (this.enabled) {\n            this.inputElement.setAttribute('tabindex', this.tabIndex);\n          } else {\n            this.inputElement.tabIndex = -1;\n          }\n          break;\n        case 'allowEdit':\n          this.setRangeAllowEdit();\n          break;\n        case 'enableRtl':\n          this.setProperties({\n            enableRtl: newProp.enableRtl\n          }, true);\n          Input.setEnableRtl(this.enableRtl, [this.inputWrapper.container]);\n          break;\n        case 'zIndex':\n          this.setProperties({\n            zIndex: newProp.zIndex\n          }, true);\n          break;\n        case 'format':\n          this.setProperties({\n            format: newProp.format\n          }, true);\n          this.checkFormat();\n          this.updateInput();\n          this.changeTrigger();\n          break;\n        case 'locale':\n          this.globalize = new Internationalization(this.locale);\n          this.l10n.setLocale(this.locale);\n          this.setProperties({\n            placeholder: this.l10n.getConstant('placeholder')\n          }, true);\n          Input.setPlaceholder(this.placeholder, this.inputElement);\n          this.setLocale();\n          break;\n        case 'htmlAttributes':\n          this.updateHtmlAttributeToElement();\n          this.updateHtmlAttributeToWrapper();\n          this.setDataAttribute(true);\n          this.checkHtmlAttributes(true);\n          break;\n        case 'showClearButton':\n          Input.setClearButton(this.showClearButton, this.inputElement, this.inputWrapper);\n          this.bindClearEvent();\n          break;\n        case 'startDate':\n          if (typeof newProp.startDate === 'string') {\n            newProp.startDate = this.globalize.parseDate(newProp.startDate, format);\n          }\n          if (+this.initStartDate !== +newProp.startDate) {\n            this.startValue = this.checkDateValue(new Date(this.checkValue(newProp.startDate)));\n            this.setDate();\n            this.setValue();\n          }\n          break;\n        case 'endDate':\n          if (typeof newProp.endDate === 'string') {\n            newProp.endDate = this.globalize.parseDate(newProp.endDate, format);\n          }\n          if (+this.initEndDate !== +newProp.endDate) {\n            this.endValue = this.checkDateValue(new Date(this.checkValue(newProp.endDate)));\n            this.setDate();\n            this.setValue();\n          }\n          break;\n        case 'value':\n          this.invalidValueString = null;\n          this.checkInvalidRange(newProp.value);\n          if (typeof newProp.value === 'string') {\n            if (!this.invalidValueString) {\n              const rangeArray = newProp.value.split(' ' + this.separator + ' ');\n              this.value = [new Date(rangeArray[0]), new Date(rangeArray[1])];\n              this.updateValue();\n              this.setDate();\n            } else {\n              this.clearModelvalue(newProp, oldProp);\n            }\n          } else {\n            if (!isNullOrUndefined(newProp.value) && newProp.value.length > 0 || !isNullOrUndefined(newProp.value) && newProp.value.start) {\n              this.valueType = newProp.value;\n              if (newProp.value[0] === null || newProp.value.start === null) {\n                if (newProp.value.length === 1 || newProp.value.start) {\n                  this.clearModelvalue(newProp, oldProp);\n                } else if (newProp.value[1] === null || newProp.value.start === null) {\n                  this.clearModelvalue(newProp, oldProp);\n                }\n              } else if (+this.initStartDate !== +newProp.value[0] || +this.initEndDate !== +newProp.value[1] || +this.initStartDate !== +(newProp.value.start || +this.initEndDate !== +newProp.value.start)) {\n                if (newProp.value.length === 1) {\n                  this.modelValue = newProp.value;\n                } else if (newProp.value.start) {\n                  this.modelValue = newProp.value;\n                }\n                this.updateValue();\n                this.setDate();\n              }\n            } else {\n              if (isNullOrUndefined(this.value) || newProp.value.start == null) {\n                this.valueType = newProp.value;\n                this.startValue = null;\n                this.endValue = null;\n                this.clearModelvalue(newProp, oldProp);\n              }\n            }\n          }\n          if (this.isPopupOpen()) {\n            if (isNullOrUndefined(this.startValue) && isNullOrUndefined(this.endValue)) {\n              this.removeSelection();\n              if (this.isMobile) {\n                this.deviceHeaderUpdate();\n              }\n              return;\n            }\n            if (this.isMobile) {\n              this.navigate(this.deviceCalendar, this.startValue, this.currentView());\n              this.deviceHeaderUpdate();\n            } else {\n              this.navigate(this.leftCalendar, this.startValue, this.currentView());\n              this.updateControl(this.leftCalendar);\n              this.navigate(this.rightCalendar, this.endValue, this.currentView());\n              this.updateControl(this.rightCalendar);\n            }\n            this.updateRange(this.isMobile ? [this.calendarElement] : [this.leftCalendar, this.rightCalendar]);\n            this.updateHeader();\n            this.applyButton.disabled = this.applyButton.element.disabled = false;\n          }\n          this.preventChange = this.isAngular && this.preventChange ? !this.preventChange : this.preventChange;\n          break;\n        case 'minDays':\n          this.setProperties({\n            minDays: newProp.minDays\n          }, true);\n          this.refreshChange();\n          this.setMinMaxDays();\n          break;\n        case 'maxDays':\n          this.setProperties({\n            maxDays: newProp.maxDays\n          }, true);\n          this.refreshChange();\n          this.setMinMaxDays();\n          break;\n        case 'min':\n          this.setProperties({\n            min: this.checkDateValue(new Date(this.checkValue(newProp.min)))\n          }, true);\n          this.previousEleValue = this.inputElement.value;\n          this.enableInput();\n          this.refreshChange();\n          break;\n        case 'max':\n          this.setProperties({\n            max: this.checkDateValue(new Date(this.checkValue(newProp.max)))\n          }, true);\n          this.enableInput();\n          this.refreshChange();\n          break;\n        case 'strictMode':\n          this.invalidValueString = null;\n          this.setProperties({\n            strictMode: newProp.strictMode\n          }, true);\n          this.refreshChange();\n          break;\n        case 'presets':\n          this.setProperties({\n            presets: newProp.presets\n          }, true);\n          this.processPresets();\n          break;\n        case 'floatLabelType':\n          this.floatLabelType = newProp.floatLabelType;\n          Input.removeFloating(this.inputWrapper);\n          Input.addFloating(this.inputElement, this.floatLabelType, this.placeholder);\n          break;\n        case 'start':\n          this.setProperties({\n            start: newProp.start\n          }, true);\n          this.refreshChange();\n          break;\n        case 'depth':\n          this.setProperties({\n            depth: newProp.depth\n          }, true);\n          this.refreshChange();\n          break;\n      }\n    }\n  }\n};\n__decorate$2([Property(null)], DateRangePicker.prototype, \"value\", void 0);\n__decorate$2([Property(false)], DateRangePicker.prototype, \"enablePersistence\", void 0);\n__decorate$2([Property(new Date(1900, 0, 1))], DateRangePicker.prototype, \"min\", void 0);\n__decorate$2([Property(new Date(2099, 11, 31))], DateRangePicker.prototype, \"max\", void 0);\n__decorate$2([Property(null)], DateRangePicker.prototype, \"locale\", void 0);\n__decorate$2([Property(null)], DateRangePicker.prototype, \"firstDayOfWeek\", void 0);\n__decorate$2([Property(false)], DateRangePicker.prototype, \"weekNumber\", void 0);\n__decorate$2([Property('Gregorian')], DateRangePicker.prototype, \"calendarMode\", void 0);\n__decorate$2([Property(false)], DateRangePicker.prototype, \"openOnFocus\", void 0);\n__decorate$2([Event()], DateRangePicker.prototype, \"created\", void 0);\n__decorate$2([Event()], DateRangePicker.prototype, \"destroyed\", void 0);\n__decorate$2([Event()], DateRangePicker.prototype, \"change\", void 0);\n__decorate$2([Event()], DateRangePicker.prototype, \"cleared\", void 0);\n__decorate$2([Event()], DateRangePicker.prototype, \"navigated\", void 0);\n__decorate$2([Event()], DateRangePicker.prototype, \"renderDayCell\", void 0);\n__decorate$2([Property(null)], DateRangePicker.prototype, \"startDate\", void 0);\n__decorate$2([Property(null)], DateRangePicker.prototype, \"endDate\", void 0);\n__decorate$2([Collection([{}], Presets)], DateRangePicker.prototype, \"presets\", void 0);\n__decorate$2([Property('')], DateRangePicker.prototype, \"width\", void 0);\n__decorate$2([Property(1000)], DateRangePicker.prototype, \"zIndex\", void 0);\n__decorate$2([Property(true)], DateRangePicker.prototype, \"showClearButton\", void 0);\n__decorate$2([Property(true)], DateRangePicker.prototype, \"showTodayButton\", void 0);\n__decorate$2([Property('Month')], DateRangePicker.prototype, \"start\", void 0);\n__decorate$2([Property('Month')], DateRangePicker.prototype, \"depth\", void 0);\n__decorate$2([Property('')], DateRangePicker.prototype, \"cssClass\", void 0);\n__decorate$2([Property('-')], DateRangePicker.prototype, \"separator\", void 0);\n__decorate$2([Property(null)], DateRangePicker.prototype, \"minDays\", void 0);\n__decorate$2([Property(null)], DateRangePicker.prototype, \"maxDays\", void 0);\n__decorate$2([Property(false)], DateRangePicker.prototype, \"strictMode\", void 0);\n__decorate$2([Property(null)], DateRangePicker.prototype, \"keyConfigs\", void 0);\n__decorate$2([Property(null)], DateRangePicker.prototype, \"format\", void 0);\n__decorate$2([Property(true)], DateRangePicker.prototype, \"enabled\", void 0);\n__decorate$2([Property(false)], DateRangePicker.prototype, \"readonly\", void 0);\n__decorate$2([Property(true)], DateRangePicker.prototype, \"allowEdit\", void 0);\n__decorate$2([Property('Never')], DateRangePicker.prototype, \"floatLabelType\", void 0);\n__decorate$2([Property(null)], DateRangePicker.prototype, \"placeholder\", void 0);\n__decorate$2([Property({})], DateRangePicker.prototype, \"htmlAttributes\", void 0);\n__decorate$2([Event()], DateRangePicker.prototype, \"open\", void 0);\n__decorate$2([Event()], DateRangePicker.prototype, \"close\", void 0);\n__decorate$2([Event()], DateRangePicker.prototype, \"select\", void 0);\n__decorate$2([Event()], DateRangePicker.prototype, \"focus\", void 0);\n__decorate$2([Event()], DateRangePicker.prototype, \"blur\", void 0);\nDateRangePicker = __decorate$2([NotifyPropertyChanges], DateRangePicker);\n\n/**\n * DateRangePicker modules\n */\n\nvar __decorate$3 = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst WRAPPERCLASS = 'e-time-wrapper';\nconst POPUP$2 = 'e-popup';\nconst ERROR$2 = 'e-error';\nconst POPUPDIMENSION = '240px';\nconst DAY = new Date().getDate();\nconst MONTH$2 = new Date().getMonth();\nconst YEAR$2 = new Date().getFullYear();\nconst ROOT$3 = 'e-timepicker';\nconst LIBRARY$2 = 'e-lib';\nconst CONTROL$2 = 'e-control';\nconst CONTENT$2 = 'e-content';\nconst SELECTED$4 = 'e-active';\nconst HOVER$1 = 'e-hover';\nconst NAVIGATION = 'e-navigation';\nconst DISABLED$3 = 'e-disabled';\nconst ICONANIMATION = 'e-icon-anim';\nconst FOCUS = 'e-input-focus';\nconst LISTCLASS$1 = 'e-list-item';\nconst HALFPOSITION = 2;\nconst ANIMATIONDURATION = 50;\nconst OVERFLOW$2 = 'e-time-overflow';\nconst OFFSETVAL = 4;\nconst EDITABLE = 'e-non-edit';\nconst wrapperAttributes = ['title', 'class', 'style'];\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar TimePickerBase;\n(function (TimePickerBase) {\n  // eslint-disable-next-line max-len, jsdoc/require-jsdoc\n  function createListItems(createdEl, min, max, globalize, timeFormat, step) {\n    if (this.calendarMode === 'Gregorian') {} else {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    }\n    let start;\n    const interval = step * 60000;\n    const listItems = [];\n    const timeCollections = [];\n    start = +min.setMilliseconds(0);\n    const end = +max.setMilliseconds(0);\n    while (end >= start) {\n      timeCollections.push(start);\n      listItems.push(globalize.formatDate(new Date(start), {\n        format: timeFormat,\n        type: 'time'\n      }));\n      start += interval;\n    }\n    const listTag = ListBase.createList(createdEl, listItems, null, true);\n    return {\n      collection: timeCollections,\n      list: listTag\n    };\n  }\n  TimePickerBase.createListItems = createListItems;\n})(TimePickerBase || (TimePickerBase = {}));\nclass TimeMaskPlaceholder extends ChildProperty {}\n__decorate$3([Property('day')], TimeMaskPlaceholder.prototype, \"day\", void 0);\n__decorate$3([Property('month')], TimeMaskPlaceholder.prototype, \"month\", void 0);\n__decorate$3([Property('year')], TimeMaskPlaceholder.prototype, \"year\", void 0);\n__decorate$3([Property('day of the week')], TimeMaskPlaceholder.prototype, \"dayOfTheWeek\", void 0);\n__decorate$3([Property('hour')], TimeMaskPlaceholder.prototype, \"hour\", void 0);\n__decorate$3([Property('minute')], TimeMaskPlaceholder.prototype, \"minute\", void 0);\n__decorate$3([Property('second')], TimeMaskPlaceholder.prototype, \"second\", void 0);\n/**\n * TimePicker is an intuitive interface component which provides an options to select a time value\n * from popup list or to set a desired time value.\n * ```\n * <input id='timepicker' type='text'/>\n * <script>\n *   var timePickerObj = new TimePicker({ value: new Date() });\n *   timePickerObj.appendTo('#timepicker');\n * </script>\n * ```\n */\nlet TimePicker = class TimePicker extends Component {\n  /**\n   * Constructor for creating the widget\n   *\n   * @param {TimePickerModel} options - Specifies the TimePicker model.\n   * @param {string | HTMLInputElement} element - Specifies the element to render as component.\n   * @private\n   */\n  constructor(options, element) {\n    super(options, element);\n    this.liCollections = [];\n    this.timeCollections = [];\n    this.disableItemCollection = [];\n    this.invalidValueString = null;\n    this.isAngular = false;\n    this.preventChange = false;\n    this.maskedDateValue = '';\n    this.moduleName = this.getModuleName();\n    this.timeOptions = options;\n  }\n  /**\n   * Initialize the event handler\n   *\n   * @returns {void}\n   * @private\n   */\n  preRender() {\n    this.keyConfigure = {\n      enter: 'enter',\n      escape: 'escape',\n      end: 'end',\n      tab: 'tab',\n      home: 'home',\n      down: 'downarrow',\n      up: 'uparrow',\n      left: 'leftarrow',\n      right: 'rightarrow',\n      open: 'alt+downarrow',\n      close: 'alt+uparrow'\n    };\n    this.cloneElement = this.element.cloneNode(true);\n    removeClass([this.cloneElement], [ROOT$3, CONTROL$2, LIBRARY$2]);\n    this.inputElement = this.element;\n    this.angularTag = null;\n    this.formElement = closest(this.element, 'form');\n    if (this.element.tagName === 'EJS-TIMEPICKER') {\n      this.angularTag = this.element.tagName;\n      this.inputElement = this.createElement('input');\n      this.element.appendChild(this.inputElement);\n    }\n    this.tabIndex = this.element.hasAttribute('tabindex') ? this.element.getAttribute('tabindex') : '0';\n    this.element.removeAttribute('tabindex');\n    this.openPopupEventArgs = {\n      appendTo: document.body\n    };\n  }\n  // element creation\n  render() {\n    this.initialize();\n    this.createInputElement();\n    this.updateHtmlAttributeToWrapper();\n    this.setTimeAllowEdit();\n    this.setEnable();\n    this.validateInterval();\n    this.bindEvents();\n    this.validateDisable();\n    this.setValue(this.getFormattedValue(this.value));\n    if (this.enableMask && !this.value && this.maskedDateValue && (this.floatLabelType == 'Always' || !this.floatLabelType || !this.placeholder)) {\n      this.updateInputValue(this.maskedDateValue);\n      this.checkErrorState(this.maskedDateValue);\n    }\n    this.anchor = this.inputElement;\n    this.inputElement.setAttribute('value', this.inputElement.value);\n    this.inputEleValue = this.getDateObject(this.inputElement.value);\n    this.renderComplete();\n  }\n  setTimeAllowEdit() {\n    if (this.allowEdit) {\n      if (!this.readonly) {\n        this.inputElement.removeAttribute('readonly');\n      }\n    } else {\n      attributes(this.inputElement, {\n        'readonly': ''\n      });\n    }\n    this.clearIconState();\n  }\n  clearIconState() {\n    if (!this.allowEdit && this.inputWrapper && !this.readonly) {\n      if (this.inputElement.value === '') {\n        removeClass([this.inputWrapper.container], [EDITABLE]);\n      } else {\n        addClass([this.inputWrapper.container], [EDITABLE]);\n      }\n    } else if (this.inputWrapper) {\n      removeClass([this.inputWrapper.container], [EDITABLE]);\n    }\n  }\n  validateDisable() {\n    this.setMinMax(this.initMin, this.initMax);\n    this.popupCreation();\n    this.popupObj.destroy();\n    this.popupWrapper = this.popupObj = null;\n    if (!isNaN(+this.value) && this.value !== null) {\n      if (!this.valueIsDisable(this.value)) {\n        //disable value given in value property so reset the date based on current date\n        if (this.strictMode) {\n          this.resetState();\n        }\n        this.initValue = null;\n        this.initMax = this.getDateObject(this.initMax);\n        this.initMin = this.getDateObject(this.initMin);\n        this.timeCollections = this.liCollections = [];\n        this.setMinMax(this.initMin, this.initMax);\n      }\n    }\n  }\n  validationAttribute(target, input) {\n    const name = target.getAttribute('name') ? target.getAttribute('name') : target.getAttribute('id');\n    input.setAttribute('name', name);\n    target.removeAttribute('name');\n    const attributes$$1 = ['required', 'aria-required', 'form'];\n    for (let i = 0; i < attributes$$1.length; i++) {\n      if (isNullOrUndefined(target.getAttribute(attributes$$1[i]))) {\n        continue;\n      }\n      const attr = target.getAttribute(attributes$$1[i]);\n      input.setAttribute(attributes$$1[i], attr);\n      target.removeAttribute(attributes$$1[i]);\n    }\n  }\n  initialize() {\n    this.globalize = new Internationalization(this.locale);\n    this.defaultCulture = new Internationalization('en');\n    this.checkTimeFormat();\n    this.checkInvalidValue(this.value);\n    // persist the value property.\n    this.setProperties({\n      value: this.checkDateValue(new Date(this.checkInValue(this.value)))\n    }, true);\n    this.setProperties({\n      min: this.checkDateValue(new Date(this.checkInValue(this.min)))\n    }, true);\n    this.setProperties({\n      max: this.checkDateValue(new Date(this.checkInValue(this.max)))\n    }, true);\n    this.setProperties({\n      scrollTo: this.checkDateValue(new Date(this.checkInValue(this.scrollTo)))\n    }, true);\n    if (this.angularTag !== null) {\n      this.validationAttribute(this.element, this.inputElement);\n    }\n    this.updateHtmlAttributeToElement();\n    this.checkAttributes(false); //check the input element attributes\n    const localeText = {\n      placeholder: this.placeholder\n    };\n    this.l10n = new L10n('timepicker', localeText, this.locale);\n    this.setProperties({\n      placeholder: this.placeholder || this.l10n.getConstant('placeholder')\n    }, true);\n    this.initValue = this.checkDateValue(this.value);\n    this.initMin = this.checkDateValue(this.min);\n    this.initMax = this.checkDateValue(this.max);\n    this.isNavigate = this.isPreventBlur = this.isTextSelected = false;\n    this.activeIndex = this.valueWithMinutes = this.prevDate = null;\n    if (!isNullOrUndefined(this.element.getAttribute('id'))) {\n      if (this.angularTag !== null) {\n        this.inputElement.id = this.element.getAttribute('id') + '_input';\n      }\n    } else {\n      //for angular case\n      this.element.id = getUniqueID('ej2_timepicker');\n      if (this.angularTag !== null) {\n        attributes(this.inputElement, {\n          'id': this.element.id + '_input'\n        });\n      }\n    }\n    if (isNullOrUndefined(this.inputElement.getAttribute('name'))) {\n      attributes(this.inputElement, {\n        'name': this.element.id\n      });\n    }\n    if (this.enableMask) {\n      this.notify(\"createMask\", {\n        module: \"MaskedDateTime\"\n      });\n    }\n  }\n  checkTimeFormat() {\n    if (this.format) {\n      if (typeof this.format === 'string') {\n        this.formatString = this.format;\n      } else if (!isNullOrUndefined(this.format.skeleton) && this.format.skeleton !== '') {\n        const skeletonString = this.format.skeleton;\n        this.formatString = this.globalize.getDatePattern({\n          type: 'time',\n          skeleton: skeletonString\n        });\n      } else {\n        this.formatString = this.globalize.getDatePattern({\n          type: 'time',\n          skeleton: 'short'\n        });\n      }\n    } else {\n      this.formatString = null;\n    }\n  }\n  checkDateValue(value) {\n    return !isNullOrUndefined(value) && value instanceof Date && !isNaN(+value) ? value : null;\n  }\n  createInputElement() {\n    let updatedCssClassesValue = this.cssClass;\n    let isBindClearAction = this.enableMask ? false : true;\n    if (!isNullOrUndefined(this.cssClass) && this.cssClass !== '') {\n      updatedCssClassesValue = this.cssClass.replace(/\\s+/g, ' ').trim();\n    }\n    this.inputWrapper = Input.createInput({\n      element: this.inputElement,\n      bindClearAction: isBindClearAction,\n      floatLabelType: this.floatLabelType,\n      properties: {\n        readonly: this.readonly,\n        placeholder: this.placeholder,\n        cssClass: updatedCssClassesValue,\n        enabled: this.enabled,\n        enableRtl: this.enableRtl,\n        showClearButton: this.showClearButton\n      },\n      buttons: [' e-input-group-icon e-time-icon e-icons']\n    }, this.createElement);\n    this.inputWrapper.container.style.width = this.setWidth(this.width);\n    attributes(this.inputElement, {\n      'aria-haspopup': 'true',\n      'aria-autocomplete': 'list',\n      'tabindex': '0',\n      'aria-activedescendant': 'null',\n      'aria-owns': this.element.id + '_options',\n      'aria-expanded': 'false',\n      'role': 'combobox',\n      'autocomplete': 'off',\n      'autocorrect': 'off',\n      'autocapitalize': 'off',\n      'spellcheck': 'false',\n      'aria-disabled': 'false',\n      'aria-invalid': 'false'\n    });\n    if (!this.isNullOrEmpty(this.inputStyle)) {\n      Input.addAttributes({\n        'style': this.inputStyle\n      }, this.inputElement);\n    }\n    addClass([this.inputWrapper.container], WRAPPERCLASS);\n  }\n  getCldrDateTimeFormat() {\n    const culture = new Internationalization(this.locale);\n    let cldrTime;\n    const dateFormat = culture.getDatePattern({\n      skeleton: 'yMd'\n    });\n    if (this.isNullOrEmpty(this.formatString)) {\n      cldrTime = dateFormat + ' ' + this.cldrFormat('time');\n    } else {\n      cldrTime = this.formatString;\n    }\n    return cldrTime;\n  }\n  checkInvalidValue(value) {\n    let isInvalid = false;\n    if (typeof value !== 'object' && !isNullOrUndefined(value)) {\n      let valueString = value;\n      if (typeof valueString === 'string') {\n        valueString = valueString.trim();\n      }\n      let valueExpression = null;\n      let valueExp = null;\n      if (typeof value === 'number') {\n        valueString = value.toString();\n      } else if (typeof value === 'string') {\n        if (!/^[a-zA-Z0-9- ]*$/.test(value)) {\n          valueExpression = this.setCurrentDate(this.getDateObject(value));\n          if (isNullOrUndefined(valueExpression)) {\n            valueExpression = this.checkDateValue(this.globalize.parseDate(valueString, {\n              format: this.getCldrDateTimeFormat(),\n              type: 'datetime'\n            }));\n            if (isNullOrUndefined(valueExpression)) {\n              valueExpression = this.checkDateValue(this.globalize.parseDate(valueString, {\n                format: this.formatString,\n                type: 'dateTime',\n                skeleton: 'yMd'\n              }));\n            }\n          }\n        }\n      }\n      valueExp = this.globalize.parseDate(valueString, {\n        format: this.getCldrDateTimeFormat(),\n        type: 'datetime'\n      });\n      valueExpression = !isNullOrUndefined(valueExp) && valueExp instanceof Date && !isNaN(+valueExp) ? valueExp : null;\n      if (isNullOrUndefined(valueExpression) && valueString.replace(/\\s/g, '').length) {\n        let extISOString = null;\n        let basicISOString = null;\n        // eslint-disable-next-line\n        extISOString = /^\\s*((?:[+-]\\d{6}|\\d{4})-(?:\\d\\d-\\d\\d|W\\d\\d-\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?::\\d\\d(?::\\d\\d(?:[.,]\\d+)?)?)?)([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?/;\n        // eslint-disable-next-line\n        basicISOString = /^\\s*((?:[+-]\\d{6}|\\d{4})(?:\\d\\d\\d\\d|W\\d\\d\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?:\\d\\d(?:\\d\\d(?:[.,]\\d+)?)?)?)([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?/;\n        if (!extISOString.test(valueString) && !basicISOString.test(valueString) || /^[a-zA-Z0-9- ]*$/.test(value) || isNaN(+new Date('' + valueString))) {\n          isInvalid = true;\n        } else {\n          valueExpression = new Date('' + valueString);\n        }\n      }\n      if (isInvalid) {\n        if (!this.strictMode) {\n          this.invalidValueString = valueString;\n        }\n        this.setProperties({\n          value: null\n        }, true);\n        this.initValue = null;\n      } else {\n        this.setProperties({\n          value: valueExpression\n        }, true);\n        this.initValue = this.value;\n      }\n    }\n  }\n  requiredModules() {\n    const modules = [];\n    if (this.enableMask) {\n      modules.push({\n        args: [this],\n        member: 'MaskedDateTime'\n      });\n    }\n    return modules;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  cldrFormat(type) {\n    let cldrDateTimeString;\n    if (this.locale === 'en' || this.locale === 'en-US') {\n      cldrDateTimeString = getValue('timeFormats.short', getDefaultDateObject());\n    } else {\n      cldrDateTimeString = this.getCultureTimeObject(cldrData, '' + this.locale);\n    }\n    return cldrDateTimeString;\n  }\n  // destroy function\n  destroy() {\n    this.hide();\n    this.unBindEvents();\n    const ariaAttribute = {\n      'aria-haspopup': 'true',\n      'aria-autocomplete': 'list',\n      'tabindex': '0',\n      'aria-activedescendant': 'null',\n      'aria-owns': this.element.id + '_options',\n      'aria-expanded': 'false',\n      'role': 'combobox',\n      'autocomplete': 'off',\n      'autocorrect': 'off',\n      'autocapitalize': 'off',\n      'spellcheck': 'false',\n      'aria-disabled': 'true',\n      'aria-invalid': 'false'\n    };\n    if (this.inputElement) {\n      Input.removeAttributes(ariaAttribute, this.inputElement);\n      if (this.angularTag === null) {\n        this.inputWrapper.container.parentElement.appendChild(this.inputElement);\n      }\n      if (!isNullOrUndefined(this.cloneElement.getAttribute('tabindex'))) {\n        this.inputElement.setAttribute('tabindex', this.tabIndex);\n      } else {\n        this.inputElement.removeAttribute('tabindex');\n      }\n      this.ensureInputAttribute();\n      this.enableElement([this.inputElement]);\n      this.inputElement.classList.remove('e-input');\n      if (isNullOrUndefined(this.cloneElement.getAttribute('disabled'))) {\n        Input.setEnabled(true, this.inputElement, this.floatLabelType);\n      }\n    }\n    if (this.inputWrapper.container) {\n      detach(this.inputWrapper.container);\n    }\n    this.inputWrapper = this.popupWrapper = this.cloneElement = undefined;\n    this.liCollections = this.timeCollections = this.disableItemCollection = [];\n    if (!isNullOrUndefined(this.rippleFn)) {\n      this.rippleFn();\n    }\n    super.destroy();\n    if (this.formElement) {\n      EventHandler.remove(this.formElement, 'reset', this.formResetHandler);\n    }\n  }\n  ensureInputAttribute() {\n    const propertyList = [];\n    for (let i = 0; i < this.inputElement.attributes.length; i++) {\n      propertyList[i] = this.inputElement.attributes[i].name;\n    }\n    for (let i = 0; i < propertyList.length; i++) {\n      if (!isNullOrUndefined(this.cloneElement.getAttribute(propertyList[i]))) {\n        this.inputElement.setAttribute(propertyList[i], this.cloneElement.getAttribute(propertyList[i]));\n        if (propertyList[i].toLowerCase() === 'value') {\n          this.inputElement.value = this.cloneElement.getAttribute(propertyList[i]);\n        }\n      } else {\n        this.inputElement.removeAttribute(propertyList[i]);\n        if (propertyList[i].toLowerCase() === 'value') {\n          this.inputElement.value = '';\n        }\n      }\n    }\n  }\n  //popup creation\n  popupCreation() {\n    this.popupWrapper = this.createElement('div', {\n      className: ROOT$3 + ' ' + POPUP$2,\n      attrs: {\n        'id': this.element.id + '_popup',\n        'style': 'visibility:hidden'\n      }\n    });\n    if (!isNullOrUndefined(this.cssClass)) {\n      this.popupWrapper.className += ' ' + this.cssClass;\n    }\n    if (!isNullOrUndefined(this.step) && this.step > 0) {\n      this.generateList();\n      append([this.listWrapper], this.popupWrapper);\n    }\n    this.openPopupEventArgs.appendTo.appendChild(this.popupWrapper);\n    this.addSelection();\n    this.renderPopup();\n    detach(this.popupWrapper);\n  }\n  getPopupHeight() {\n    const height = parseInt(POPUPDIMENSION, 10);\n    const popupHeight = this.popupWrapper.getBoundingClientRect().height;\n    return popupHeight > height ? height : popupHeight;\n  }\n  generateList() {\n    this.createListItems();\n    this.wireListEvents();\n    const rippleModel = {\n      duration: 300,\n      selector: '.' + LISTCLASS$1\n    };\n    this.rippleFn = rippleEffect(this.listWrapper, rippleModel);\n    this.liCollections = this.listWrapper.querySelectorAll('.' + LISTCLASS$1);\n  }\n  renderPopup() {\n    this.containerStyle = this.inputWrapper.container.getBoundingClientRect();\n    this.popupObj = new Popup(this.popupWrapper, {\n      width: this.setPopupWidth(this.width),\n      zIndex: this.zIndex,\n      targetType: 'relative',\n      position: Browser.isDevice ? {\n        X: 'center',\n        Y: 'center'\n      } : {\n        X: 'left',\n        Y: 'bottom'\n      },\n      collision: Browser.isDevice ? {\n        X: 'fit',\n        Y: 'fit'\n      } : {\n        X: 'flip',\n        Y: 'flip'\n      },\n      enableRtl: this.enableRtl,\n      relateTo: Browser.isDevice ? document.body : this.inputWrapper.container,\n      offsetY: OFFSETVAL,\n      open: () => {\n        this.popupWrapper.style.visibility = 'visible';\n        addClass([this.inputWrapper.buttons[0]], SELECTED$4);\n      },\n      close: () => {\n        removeClass([this.inputWrapper.buttons[0]], SELECTED$4);\n        this.unWireListEvents();\n        this.inputElement.setAttribute('aria-activedescendant', 'null');\n        remove(this.popupObj.element);\n        this.popupObj.destroy();\n        this.popupWrapper.innerHTML = '';\n        this.listWrapper = this.popupWrapper = this.listTag = undefined;\n      },\n      targetExitViewport: () => {\n        if (!Browser.isDevice) {\n          this.hide();\n        }\n      }\n    });\n    if (!Browser.isDevice) {\n      this.popupObj.collision = {\n        X: 'none',\n        Y: 'flip'\n      };\n    }\n    this.popupObj.element.style.maxHeight = POPUPDIMENSION;\n  }\n  //util function\n  getFormattedValue(value) {\n    if (isNullOrUndefined(this.checkDateValue(value))) {\n      return null;\n    } else {\n      return this.globalize.formatDate(value, {\n        skeleton: 'medium',\n        type: 'time'\n      });\n    }\n  }\n  getDateObject(text) {\n    if (!this.isNullOrEmpty(text)) {\n      const dateValue = this.createDateObj(text);\n      const value = !this.isNullOrEmpty(this.initValue);\n      if (this.checkDateValue(dateValue)) {\n        const date = value ? this.initValue.getDate() : DAY;\n        const month = value ? this.initValue.getMonth() : MONTH$2;\n        const year = value ? this.initValue.getFullYear() : YEAR$2;\n        return new Date(year, month, date, dateValue.getHours(), dateValue.getMinutes(), dateValue.getSeconds());\n      }\n    }\n    return null;\n  }\n  updateHtmlAttributeToWrapper() {\n    if (!isNullOrUndefined(this.htmlAttributes)) {\n      for (const key of Object.keys(this.htmlAttributes)) {\n        if (wrapperAttributes.indexOf(key) > -1) {\n          if (key === 'class') {\n            const updatedClassesValue = this.htmlAttributes[key].replace(/\\s+/g, ' ').trim();\n            if (updatedClassesValue !== '') {\n              addClass([this.inputWrapper.container], updatedClassesValue.split(' '));\n            }\n          } else if (key === 'style') {\n            let timeStyle = this.inputWrapper.container.getAttribute(key);\n            timeStyle = !isNullOrUndefined(timeStyle) ? timeStyle + this.htmlAttributes[key] : this.htmlAttributes[key];\n            this.inputWrapper.container.setAttribute(key, timeStyle);\n          } else {\n            this.inputWrapper.container.setAttribute(key, this.htmlAttributes[key]);\n          }\n        }\n      }\n    }\n  }\n  updateHtmlAttributeToElement() {\n    if (!isNullOrUndefined(this.htmlAttributes)) {\n      for (const key of Object.keys(this.htmlAttributes)) {\n        if (wrapperAttributes.indexOf(key) < 0) {\n          this.inputElement.setAttribute(key, this.htmlAttributes[key]);\n        }\n      }\n    }\n  }\n  updateCssClass(cssClassNew, cssClassOld) {\n    if (!isNullOrUndefined(cssClassOld)) {\n      cssClassOld = cssClassOld.replace(/\\s+/g, ' ').trim();\n    }\n    if (!isNullOrUndefined(cssClassNew)) {\n      cssClassNew = cssClassNew.replace(/\\s+/g, ' ').trim();\n    }\n    Input.setCssClass(cssClassNew, [this.inputWrapper.container], cssClassOld);\n    if (this.popupWrapper) {\n      Input.setCssClass(cssClassNew, [this.popupWrapper], cssClassOld);\n    }\n  }\n  removeErrorClass() {\n    removeClass([this.inputWrapper.container], ERROR$2);\n    attributes(this.inputElement, {\n      'aria-invalid': 'false'\n    });\n  }\n  checkErrorState(val) {\n    const value = this.getDateObject(val);\n    if (this.validateState(value) && !this.invalidValueString || this.enableMask && this.inputElement.value === this.maskedDateValue) {\n      this.removeErrorClass();\n    } else {\n      addClass([this.inputWrapper.container], ERROR$2);\n      attributes(this.inputElement, {\n        'aria-invalid': 'true'\n      });\n    }\n  }\n  validateInterval() {\n    if (!isNullOrUndefined(this.step) && this.step > 0) {\n      this.enableElement([this.inputWrapper.buttons[0]]);\n    } else {\n      this.disableTimeIcon();\n    }\n  }\n  disableTimeIcon() {\n    this.disableElement([this.inputWrapper.buttons[0]]);\n    this.hide();\n  }\n  disableElement(element) {\n    addClass(element, DISABLED$3);\n  }\n  enableElement(element) {\n    removeClass(element, DISABLED$3);\n  }\n  selectInputText() {\n    this.inputElement.setSelectionRange(0, this.inputElement.value.length);\n  }\n  setCursorToEnd() {\n    this.inputElement.setSelectionRange(this.inputElement.value.length, this.inputElement.value.length);\n  }\n  getMeridianText() {\n    let meridian;\n    if (this.locale === 'en' || this.locale === 'en-US') {\n      meridian = getValue('dayPeriods.format.wide', getDefaultDateObject());\n    } else {\n      const gregorianFormat = '.dates.calendars.gregorian.dayPeriods.format.abbreviated';\n      const mainVal = 'main.';\n      meridian = getValue(mainVal + '' + this.locale + gregorianFormat, cldrData);\n    }\n    return meridian;\n  }\n  getCursorSelection() {\n    const input = this.inputElement;\n    let start = 0;\n    let end = 0;\n    if (!isNaN(input.selectionStart)) {\n      start = input.selectionStart;\n      end = input.selectionEnd;\n    }\n    return {\n      start: Math.abs(start),\n      end: Math.abs(end)\n    };\n  }\n  getActiveElement() {\n    if (!isNullOrUndefined(this.popupWrapper)) {\n      return this.popupWrapper.querySelectorAll('.' + SELECTED$4);\n    } else {\n      return null;\n    }\n  }\n  isNullOrEmpty(value) {\n    if (isNullOrUndefined(value) || typeof value === 'string' && value.trim() === '') {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  setWidth(width) {\n    if (typeof width === 'number') {\n      width = formatUnit(width);\n    } else if (typeof width === 'string') {\n      width = width.match(/px|%|em/) ? width : formatUnit(width);\n    } else {\n      width = '100%';\n    }\n    return width;\n  }\n  setPopupWidth(width) {\n    width = this.setWidth(width);\n    if (width.indexOf('%') > -1) {\n      const inputWidth = this.containerStyle.width * parseFloat(width) / 100;\n      width = inputWidth.toString() + 'px';\n    }\n    return width;\n  }\n  setScrollPosition() {\n    const element = this.selectedElement;\n    if (!isNullOrUndefined(element)) {\n      this.findScrollTop(element);\n    } else if (this.popupWrapper && this.checkDateValue(this.scrollTo)) {\n      this.setScrollTo();\n    }\n  }\n  findScrollTop(element) {\n    const listHeight = this.getPopupHeight();\n    const nextEle = element.nextElementSibling;\n    const height = nextEle ? nextEle.offsetTop : element.offsetTop;\n    const liHeight = element.getBoundingClientRect().height;\n    if (height + element.offsetTop > listHeight) {\n      this.popupWrapper.scrollTop = nextEle ? height - (listHeight / HALFPOSITION + liHeight / HALFPOSITION) : height;\n    } else {\n      this.popupWrapper.scrollTop = 0;\n    }\n  }\n  setScrollTo() {\n    let element;\n    if (!isNullOrUndefined(this.popupWrapper)) {\n      const items = this.popupWrapper.querySelectorAll('.' + LISTCLASS$1);\n      if (items.length) {\n        const initialTime = this.timeCollections[0];\n        const scrollTime = this.getDateObject(this.checkDateValue(this.scrollTo)).getTime();\n        element = items[Math.round((scrollTime - initialTime) / (this.step * 60000))];\n      }\n    } else {\n      this.popupWrapper.scrollTop = 0;\n    }\n    if (!isNullOrUndefined(element)) {\n      this.findScrollTop(element);\n    } else {\n      this.popupWrapper.scrollTop = 0;\n    }\n  }\n  getText() {\n    return isNullOrUndefined(this.checkDateValue(this.value)) ? '' : this.getValue(this.value);\n  }\n  getValue(value) {\n    return isNullOrUndefined(this.checkDateValue(value)) ? null : this.globalize.formatDate(value, {\n      format: this.cldrTimeFormat(),\n      type: 'time'\n    });\n  }\n  cldrDateFormat() {\n    let cldrDate;\n    if (this.locale === 'en' || this.locale === 'en-US') {\n      cldrDate = getValue('dateFormats.short', getDefaultDateObject());\n    } else {\n      cldrDate = this.getCultureDateObject(cldrData, '' + this.locale);\n    }\n    return cldrDate;\n  }\n  cldrTimeFormat() {\n    let cldrTime;\n    if (this.isNullOrEmpty(this.formatString)) {\n      if (this.locale === 'en' || this.locale === 'en-US') {\n        cldrTime = getValue('timeFormats.short', getDefaultDateObject());\n      } else {\n        cldrTime = this.getCultureTimeObject(cldrData, '' + this.locale);\n      }\n    } else {\n      cldrTime = this.formatString;\n    }\n    return cldrTime;\n  }\n  dateToNumeric() {\n    let cldrTime;\n    if (this.locale === 'en' || this.locale === 'en-US') {\n      cldrTime = getValue('timeFormats.medium', getDefaultDateObject());\n    } else {\n      cldrTime = getValue('main.' + '' + this.locale + '.dates.calendars.gregorian.timeFormats.medium', cldrData);\n    }\n    return cldrTime;\n  }\n  getExactDateTime(value) {\n    if (isNullOrUndefined(this.checkDateValue(value))) {\n      return null;\n    } else {\n      return this.globalize.formatDate(value, {\n        format: this.dateToNumeric(),\n        type: 'time'\n      });\n    }\n  }\n  setValue(value) {\n    const time = this.checkValue(value);\n    if (!this.strictMode && !this.validateState(time)) {\n      if (this.checkDateValue(this.valueWithMinutes) === null) {\n        this.initValue = this.valueWithMinutes = null;\n      }\n      this.validateMinMax(this.value, this.min, this.max);\n    } else {\n      if (this.isNullOrEmpty(time)) {\n        this.initValue = null;\n        this.validateMinMax(this.value, this.min, this.max);\n      } else {\n        this.initValue = this.compareFormatChange(time);\n      }\n    }\n    this.updateInput(true, this.initValue);\n  }\n  compareFormatChange(value) {\n    if (isNullOrUndefined(value)) {\n      return null;\n    }\n    return value !== this.getText() ? this.getDateObject(value) : this.getDateObject(this.value);\n  }\n  updatePlaceHolder() {\n    Input.setPlaceholder(this.l10n.getConstant('placeholder'), this.inputElement);\n  }\n  //event related functions\n  updateInputValue(value) {\n    Input.setValue(value, this.inputElement, this.floatLabelType, this.showClearButton);\n  }\n  preventEventBubbling(e) {\n    e.preventDefault();\n    this.interopAdaptor.invokeMethodAsync('OnTimeIconClick');\n  }\n  popupHandler(e) {\n    if (!this.enabled) {\n      return;\n    }\n    if (Browser.isDevice) {\n      this.inputElement.setAttribute('readonly', '');\n    }\n    e.preventDefault();\n    if (this.isPopupOpen()) {\n      this.closePopup(0, e);\n    } else {\n      this.inputElement.focus();\n      this.show(e);\n    }\n  }\n  mouseDownHandler() {\n    if (!this.enabled) {\n      return;\n    }\n    if (!this.readonly) {\n      this.inputElement.setSelectionRange(0, 0);\n      EventHandler.add(this.inputElement, 'mouseup', this.mouseUpHandler, this);\n    }\n  }\n  mouseUpHandler(event) {\n    if (!this.readonly) {\n      event.preventDefault();\n      if (this.enableMask) {\n        event.preventDefault();\n        this.notify(\"setMaskSelection\", {\n          module: \"MaskedDateTime\"\n        });\n        return;\n      } else {\n        EventHandler.remove(this.inputElement, 'mouseup', this.mouseUpHandler);\n        const curPos = this.getCursorSelection();\n        if (!(curPos.start === 0 && curPos.end === this.inputElement.value.length)) {\n          if (this.inputElement.value.length > 0) {\n            this.cursorDetails = this.focusSelection();\n          }\n          this.inputElement.setSelectionRange(this.cursorDetails.start, this.cursorDetails.end);\n        }\n      }\n    }\n  }\n  focusSelection() {\n    const regex = new RegExp('^[a-zA-Z0-9]+$');\n    const split = this.inputElement.value.split('');\n    split.push(' ');\n    const curPos = this.getCursorSelection();\n    let start = 0;\n    let end = 0;\n    let isSeparator = false;\n    if (!this.isTextSelected) {\n      for (let i = 0; i < split.length; i++) {\n        if (!regex.test(split[i])) {\n          end = i;\n          isSeparator = true;\n        }\n        if (isSeparator) {\n          if (curPos.start >= start && curPos.end <= end) {\n            // eslint-disable-next-line no-self-assign\n            end = end;\n            this.isTextSelected = true;\n            break;\n          } else {\n            start = i + 1;\n            isSeparator = false;\n          }\n        }\n      }\n    } else {\n      start = curPos.start;\n      end = curPos.end;\n      this.isTextSelected = false;\n    }\n    return {\n      start: start,\n      end: end\n    };\n  }\n  inputHandler(event) {\n    if (!this.readonly && this.enabled) {\n      if (event.action !== 'right' && event.action !== 'left' && event.action !== 'tab') {\n        event.preventDefault();\n      }\n      switch (event.action) {\n        case 'home':\n        case 'end':\n        case 'up':\n        case 'down':\n          if (this.enableMask && !this.readonly && !this.isPopupOpen()) {\n            event.preventDefault();\n            this.notify(\"keyDownHandler\", {\n              module: \"MaskedDateTime\",\n              e: event\n            });\n          }\n          if (!this.enableMask || this.isPopupOpen()) {\n            this.keyHandler(event);\n          }\n          break;\n        case 'enter':\n          if (this.isNavigate) {\n            this.selectedElement = this.liCollections[this.activeIndex];\n            this.valueWithMinutes = new Date(this.timeCollections[this.activeIndex]);\n            this.updateValue(this.valueWithMinutes, event);\n          } else {\n            this.updateValue(this.inputElement.value, event);\n          }\n          this.hide();\n          this.isNavigate = false;\n          if (this.isPopupOpen()) {\n            event.stopPropagation();\n          }\n          break;\n        case 'open':\n          this.show(event);\n          break;\n        case 'escape':\n          this.updateInputValue(this.objToString(this.value));\n          if (this.enableMask) {\n            if (!this.value) {\n              this.updateInputValue(this.maskedDateValue);\n            }\n            this.createMask();\n          }\n          this.previousState(this.value);\n          this.hide();\n          break;\n        case 'close':\n          this.hide();\n          break;\n        case 'right':\n        case 'left':\n        case 'tab':\n        case 'shiftTab':\n          if (!this.isPopupOpen() && this.enableMask && !this.readonly) {\n            if (this.inputElement.selectionStart == 0 && this.inputElement.selectionEnd == this.inputElement.value.length || this.inputElement.selectionEnd !== this.inputElement.value.length && event.action == 'tab' || this.inputElement.selectionStart !== 0 && event.action == 'shiftTab' || event.action == 'left' || event.action == 'right') {\n              event.preventDefault();\n            }\n            this.notify(\"keyDownHandler\", {\n              module: \"MaskedDateTime\",\n              e: event\n            });\n          }\n          break;\n        default:\n          this.isNavigate = false;\n          break;\n      }\n    }\n  }\n  onMouseClick(event) {\n    const target = event.target;\n    const li = this.selectedElement = closest(target, '.' + LISTCLASS$1);\n    this.setSelection(li, event);\n    if (li && li.classList.contains(LISTCLASS$1)) {\n      this.hide();\n    }\n  }\n  closePopup(delay, e) {\n    if (this.isPopupOpen() && this.popupWrapper) {\n      const args = {\n        popup: this.popupObj,\n        event: e || null,\n        cancel: false,\n        name: 'open'\n      };\n      removeClass([document.body], OVERFLOW$2);\n      this.trigger('close', args, args => {\n        if (!args.cancel) {\n          const animModel = {\n            name: 'FadeOut',\n            duration: ANIMATIONDURATION,\n            delay: delay ? delay : 0\n          };\n          this.popupObj.hide(new Animation(animModel));\n          removeClass([this.inputWrapper.container], [ICONANIMATION]);\n          attributes(this.inputElement, {\n            'aria-expanded': 'false'\n          });\n          EventHandler.remove(document, 'mousedown touchstart', this.documentClickHandler);\n        }\n        if (Browser.isDevice && this.modal) {\n          this.modal.style.display = 'none';\n          this.modal.outerHTML = '';\n          this.modal = null;\n        }\n        if (Browser.isDevice) {\n          if (!isNullOrUndefined(this.mobileTimePopupWrap)) {\n            this.mobileTimePopupWrap.remove();\n            this.mobileTimePopupWrap = null;\n          }\n        }\n        if (Browser.isDevice && this.allowEdit && !this.readonly) {\n          this.inputElement.removeAttribute('readonly');\n        }\n      });\n    } else {\n      if (Browser.isDevice && this.allowEdit && !this.readonly) {\n        this.inputElement.removeAttribute('readonly');\n      }\n    }\n  }\n  disposeServerPopup() {\n    if (this.popupWrapper) {\n      this.popupWrapper.style.visibility = 'hidden';\n      this.popupWrapper.style.top = '-9999px';\n      this.popupWrapper.style.left = '-9999px';\n      this.popupWrapper.style.width = '0px';\n      this.popupWrapper.style.height = '0px';\n    }\n  }\n  checkValueChange(event, isNavigation) {\n    if (!this.strictMode && !this.validateState(this.valueWithMinutes)) {\n      if (this.checkDateValue(this.valueWithMinutes) === null) {\n        this.initValue = this.valueWithMinutes = null;\n      }\n      this.setProperties({\n        value: this.compareFormatChange(this.inputElement.value)\n      }, true);\n      this.initValue = this.valueWithMinutes = this.compareFormatChange(this.inputElement.value);\n      this.prevValue = this.inputElement.value;\n      if (+this.prevDate !== +this.value) {\n        this.changeEvent(event);\n      }\n    } else {\n      if (!isNavigation) {\n        if (this.prevValue !== this.inputElement.value || isNullOrUndefined(this.checkDateValue(this.value))) {\n          this.valueProcess(event, this.compareFormatChange(this.inputElement.value));\n        }\n      } else {\n        const value = this.getDateObject(new Date(this.timeCollections[this.activeIndex]));\n        if (+this.prevDate !== +value) {\n          this.valueProcess(event, value);\n        }\n      }\n    }\n  }\n  onMouseOver(event) {\n    const currentLi = closest(event.target, '.' + LISTCLASS$1);\n    this.setHover(currentLi, HOVER$1);\n  }\n  setHover(li, className) {\n    if (this.enabled && this.isValidLI(li) && !li.classList.contains(className)) {\n      this.removeHover(className);\n      addClass([li], className);\n      if (className === NAVIGATION) {\n        li.setAttribute('aria-selected', 'true');\n      }\n    }\n  }\n  setSelection(li, event) {\n    if (this.isValidLI(li)) {\n      this.checkValue(li.getAttribute('data-value'));\n      if (this.enableMask) {\n        this.notify(\"setMaskSelection\", {\n          module: \"MaskedDateTime\"\n        });\n      }\n      this.selectedElement = li;\n      this.activeIndex = Array.prototype.slice.call(this.liCollections).indexOf(li);\n      this.valueWithMinutes = new Date(this.timeCollections[this.activeIndex]);\n      addClass([this.selectedElement], SELECTED$4);\n      this.selectedElement.setAttribute('aria-selected', 'true');\n      this.checkValueChange(event, true);\n    }\n  }\n  onMouseLeave() {\n    this.removeHover(HOVER$1);\n  }\n  scrollHandler() {\n    if (this.getModuleName() === 'timepicker' && Browser.isDevice) {\n      return;\n    } else {\n      this.hide();\n    }\n  }\n  setMinMax(minVal, maxVal) {\n    if (isNullOrUndefined(this.checkDateValue(minVal))) {\n      this.initMin = this.getDateObject('12:00:00 AM');\n    }\n    if (isNullOrUndefined(this.checkDateValue(maxVal))) {\n      this.initMax = this.getDateObject('11:59:59 PM');\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  validateMinMax(dateVal, minVal, maxVal) {\n    const value = dateVal instanceof Date ? dateVal : this.getDateObject(dateVal);\n    if (!isNullOrUndefined(this.checkDateValue(value))) {\n      dateVal = this.strictOperation(this.initMin, this.initMax, dateVal, value);\n    } else if (+this.createDateObj(this.getFormattedValue(this.initMin)) > +this.createDateObj(this.getFormattedValue(this.initMax))) {\n      this.disableTimeIcon();\n    }\n    if (this.strictMode) {\n      dateVal = this.valueIsDisable(dateVal) ? dateVal : null;\n    }\n    this.checkErrorState(dateVal);\n    return dateVal;\n  }\n  valueIsDisable(value) {\n    if (this.disableItemCollection.length > 0) {\n      if (this.disableItemCollection.length === this.timeCollections.length) {\n        return false;\n      }\n      const time = value instanceof Date ? this.objToString(value) : value;\n      for (let index = 0; index < this.disableItemCollection.length; index++) {\n        if (time === this.disableItemCollection[index]) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  validateState(val) {\n    if (!this.strictMode) {\n      if (this.valueIsDisable(val)) {\n        const value = typeof val === 'string' ? this.setCurrentDate(this.getDateObject(val)) : this.setCurrentDate(this.getDateObject(val));\n        const maxValue = this.setCurrentDate(this.getDateObject(this.initMax));\n        const minValue = this.setCurrentDate(this.getDateObject(this.initMin));\n        if (!isNullOrUndefined(this.checkDateValue(value))) {\n          if (+value > +maxValue || +value < +minValue) {\n            return false;\n          }\n        } else {\n          if (+maxValue < +minValue || this.inputElement.value !== '') {\n            return false;\n          }\n        }\n      } else {\n        return false;\n      }\n    }\n    return true;\n  }\n  strictOperation(minimum, maximum, dateVal, val) {\n    const maxValue = this.createDateObj(this.getFormattedValue(maximum));\n    const minValue = this.createDateObj(this.getFormattedValue(minimum));\n    const value = this.createDateObj(this.getFormattedValue(val));\n    if (this.strictMode) {\n      if (+minValue > +maxValue) {\n        this.disableTimeIcon();\n        this.initValue = this.getDateObject(maxValue);\n        this.updateInputValue(this.getValue(this.initValue));\n        if (this.enableMask) {\n          this.createMask();\n        }\n        return this.inputElement.value;\n      } else if (+minValue >= +value) {\n        return this.getDateObject(minValue);\n      } else if (+value >= +maxValue || +minValue === +maxValue) {\n        return this.getDateObject(maxValue);\n      }\n    } else {\n      if (+minValue > +maxValue) {\n        this.disableTimeIcon();\n        if (!isNaN(+this.createDateObj(dateVal))) {\n          return dateVal;\n        }\n      }\n    }\n    return dateVal;\n  }\n  bindEvents() {\n    EventHandler.add(this.inputWrapper.buttons[0], 'mousedown', this.popupHandler, this);\n    EventHandler.add(this.inputElement, 'blur', this.inputBlurHandler, this);\n    EventHandler.add(this.inputElement, 'focus', this.inputFocusHandler, this);\n    EventHandler.add(this.inputElement, 'change', this.inputChangeHandler, this);\n    EventHandler.add(this.inputElement, 'input', this.inputEventHandler, this);\n    if (this.enableMask) {\n      EventHandler.add(this.inputElement, 'keydown', this.keydownHandler, this);\n    }\n    if (this.showClearButton && this.inputWrapper.clearButton) {\n      EventHandler.add(this.inputWrapper.clearButton, 'mousedown', this.clearHandler, this);\n    }\n    if (this.formElement) {\n      EventHandler.add(this.formElement, 'reset', this.formResetHandler, this);\n    }\n    if (!Browser.isDevice) {\n      this.keyConfigure = extend(this.keyConfigure, this.keyConfigs);\n      this.inputEvent = new KeyboardEvents(this.inputWrapper.container, {\n        keyAction: this.inputHandler.bind(this),\n        keyConfigs: this.keyConfigure,\n        eventName: 'keydown'\n      });\n      if (this.showClearButton && this.inputElement) {\n        EventHandler.add(this.inputElement, 'mousedown', this.mouseDownHandler, this);\n      }\n    }\n  }\n  keydownHandler(e) {\n    switch (e.code) {\n      case 'Delete':\n        if (this.enableMask && !this.popupObj && !this.readonly) {\n          this.notify(\"keyDownHandler\", {\n            module: \"MaskedDateTime\",\n            e: e\n          });\n        }\n        break;\n      default:\n        break;\n    }\n  }\n  formResetHandler() {\n    if (!this.enabled) {\n      return;\n    }\n    if (!this.inputElement.disabled) {\n      let timeValue = this.inputElement.getAttribute('value');\n      let val = this.checkDateValue(this.inputEleValue);\n      if (this.element.tagName === 'EJS-TIMEPICKER') {\n        val = null;\n        timeValue = '';\n        this.inputElement.setAttribute('value', '');\n      }\n      this.setProperties({\n        value: val\n      }, true);\n      this.prevDate = this.value;\n      this.valueWithMinutes = this.value;\n      this.initValue = this.value;\n      if (this.inputElement) {\n        this.updateInputValue(timeValue);\n        if (this.enableMask) {\n          if (!timeValue) {\n            this.updateInputValue(this.maskedDateValue);\n          }\n          this.createMask();\n        }\n        this.checkErrorState(timeValue);\n        this.prevValue = this.inputElement.value;\n      }\n    }\n  }\n  inputChangeHandler(e) {\n    if (!this.enabled) {\n      return;\n    }\n    e.stopPropagation();\n  }\n  inputEventHandler() {\n    if (this.enableMask) {\n      this.notify(\"inputHandler\", {\n        module: \"MaskedDateTime\"\n      });\n    }\n  }\n  unBindEvents() {\n    if (this.inputWrapper) {\n      EventHandler.remove(this.inputWrapper.buttons[0], 'mousedown touchstart', this.popupHandler);\n    }\n    EventHandler.remove(this.inputElement, 'blur', this.inputBlurHandler);\n    EventHandler.remove(this.inputElement, 'focus', this.inputFocusHandler);\n    EventHandler.remove(this.inputElement, 'change', this.inputChangeHandler);\n    EventHandler.remove(this.inputElement, 'input', this.inputEventHandler);\n    if (this.inputEvent) {\n      this.inputEvent.destroy();\n    }\n    EventHandler.remove(this.inputElement, 'mousedown touchstart', this.mouseDownHandler);\n    if (this.showClearButton && !isNullOrUndefined(this.inputWrapper.clearButton)) {\n      EventHandler.remove(this.inputWrapper.clearButton, 'mousedown touchstart', this.clearHandler);\n    }\n    if (this.formElement) {\n      EventHandler.remove(this.formElement, 'reset', this.formResetHandler);\n    }\n  }\n  bindClearEvent() {\n    if (this.showClearButton && this.inputWrapper.clearButton) {\n      EventHandler.add(this.inputWrapper.clearButton, 'mousedown', this.clearHandler, this);\n    }\n  }\n  raiseClearedEvent(e) {\n    const clearedArgs = {\n      event: e\n    };\n    this.trigger('cleared', clearedArgs);\n  }\n  clearHandler(e) {\n    if (!this.enabled) {\n      return;\n    }\n    e.preventDefault();\n    if (!isNullOrUndefined(this.value)) {\n      this.clear(e);\n    } else {\n      this.resetState();\n      this.raiseClearedEvent(e);\n    }\n    if (this.popupWrapper) {\n      this.popupWrapper.scrollTop = 0;\n    }\n    if (this.enableMask) {\n      this.notify(\"clearHandler\", {\n        module: \"MaskedDateTime\"\n      });\n    }\n  }\n  clear(event) {\n    this.setProperties({\n      value: null\n    }, true);\n    this.initValue = null;\n    this.resetState();\n    this.raiseClearedEvent(event);\n    this.changeEvent(event);\n  }\n  setZIndex() {\n    if (this.popupObj) {\n      this.popupObj.zIndex = this.zIndex;\n      this.popupObj.dataBind();\n    }\n  }\n  checkAttributes(isDynamic) {\n    const attributes$$1 = isDynamic ? isNullOrUndefined(this.htmlAttributes) ? [] : Object.keys(this.htmlAttributes) : ['step', 'disabled', 'readonly', 'style', 'name', 'value', 'min', 'max', 'placeholder'];\n    let value;\n    for (const prop of attributes$$1) {\n      if (!isNullOrUndefined(this.inputElement.getAttribute(prop))) {\n        switch (prop) {\n          case 'disabled':\n            if (isNullOrUndefined(this.timeOptions) || this.timeOptions['enabled'] === undefined || isDynamic) {\n              const enabled = this.inputElement.getAttribute(prop) === 'disabled' || this.inputElement.getAttribute(prop) === '' || this.inputElement.getAttribute(prop) === 'true' ? false : true;\n              this.setProperties({\n                enabled: enabled\n              }, !isDynamic);\n            }\n            break;\n          case 'style':\n            this.inputStyle = this.inputElement.getAttribute(prop);\n            break;\n          case 'readonly':\n            if (isNullOrUndefined(this.timeOptions) || this.timeOptions['readonly'] === undefined || isDynamic) {\n              const readonly = this.inputElement.getAttribute(prop) === 'readonly' || this.inputElement.getAttribute(prop) === '' || this.inputElement.getAttribute(prop) === 'true' ? true : false;\n              this.setProperties({\n                readonly: readonly\n              }, !isDynamic);\n            }\n            break;\n          case 'name':\n            this.inputElement.setAttribute('name', this.inputElement.getAttribute(prop));\n            break;\n          case 'step':\n            this.step = parseInt(this.inputElement.getAttribute(prop), 10);\n            break;\n          case 'placeholder':\n            if (isNullOrUndefined(this.timeOptions) || this.timeOptions['placeholder'] === undefined || isDynamic) {\n              this.setProperties({\n                placeholder: this.inputElement.getAttribute(prop)\n              }, !isDynamic);\n            }\n            break;\n          case 'min':\n            if (isNullOrUndefined(this.timeOptions) || this.timeOptions['min'] === undefined || isDynamic) {\n              value = new Date(this.inputElement.getAttribute(prop));\n              if (!isNullOrUndefined(this.checkDateValue(value))) {\n                this.setProperties({\n                  min: value\n                }, !isDynamic);\n              }\n            }\n            break;\n          case 'max':\n            if (isNullOrUndefined(this.timeOptions) || this.timeOptions['max'] === undefined || isDynamic) {\n              value = new Date(this.inputElement.getAttribute(prop));\n              if (!isNullOrUndefined(this.checkDateValue(value))) {\n                this.setProperties({\n                  max: value\n                }, !isDynamic);\n              }\n            }\n            break;\n          case 'value':\n            if (isNullOrUndefined(this.timeOptions) || this.timeOptions['value'] === undefined || isDynamic) {\n              value = new Date(this.inputElement.getAttribute(prop));\n              if (!isNullOrUndefined(this.checkDateValue(value))) {\n                this.initValue = value;\n                this.updateInput(false, this.initValue);\n                this.setProperties({\n                  value: value\n                }, !isDynamic);\n              }\n            }\n            break;\n        }\n      }\n    }\n  }\n  setCurrentDate(value) {\n    if (isNullOrUndefined(this.checkDateValue(value))) {\n      return null;\n    }\n    return new Date(YEAR$2, MONTH$2, DAY, value.getHours(), value.getMinutes(), value.getSeconds());\n  }\n  getTextFormat() {\n    let time = 0;\n    if (this.cldrTimeFormat().split(' ')[0] === 'a' || this.cldrTimeFormat().indexOf('a') === 0) {\n      time = 1;\n    } else if (this.cldrTimeFormat().indexOf('a') < 0) {\n      const strArray = this.cldrTimeFormat().split(' ');\n      for (let i = 0; i < strArray.length; i++) {\n        if (strArray[i].toLowerCase().indexOf('h') >= 0) {\n          time = i;\n          break;\n        }\n      }\n    }\n    return time;\n  }\n  updateValue(value, event) {\n    let val;\n    if (this.isNullOrEmpty(value)) {\n      this.resetState();\n    } else {\n      val = this.checkValue(value);\n      if (this.strictMode) {\n        // this case set previous value to the text box when set invalid date\n        const inputVal = val === null && value.trim().length > 0 ? this.previousState(this.prevDate) : this.inputElement.value;\n        this.updateInputValue(inputVal);\n        if (this.enableMask) {\n          if (!inputVal) {\n            this.updateInputValue(this.maskedDateValue);\n          }\n          if (isNullOrUndefined(val) && value != this.maskedDateValue) {\n            this.createMask();\n          }\n          if (isNullOrUndefined(val) && value == this.maskedDateValue) {\n            this.updateInputValue(this.maskedDateValue);\n          }\n        }\n      }\n    }\n    this.checkValueChange(event, typeof value === 'string' ? false : true);\n  }\n  previousState(date) {\n    const value = this.getDateObject(date);\n    for (let i = 0; i < this.timeCollections.length; i++) {\n      if (+value === this.timeCollections[i]) {\n        this.activeIndex = i;\n        this.selectedElement = this.liCollections[i];\n        this.valueWithMinutes = new Date(this.timeCollections[i]);\n        break;\n      }\n    }\n    return this.prevValue;\n  }\n  resetState() {\n    this.removeSelection();\n    Input.setValue('', this.inputElement, this.floatLabelType, false);\n    this.valueWithMinutes = this.activeIndex = null;\n    if (!this.strictMode) {\n      this.checkErrorState(null);\n    }\n  }\n  objToString(val) {\n    if (isNullOrUndefined(this.checkDateValue(val))) {\n      return null;\n    } else {\n      return this.globalize.formatDate(val, {\n        format: this.cldrTimeFormat(),\n        type: 'time'\n      });\n    }\n  }\n  checkValue(value) {\n    if (!this.isNullOrEmpty(value)) {\n      const date = value instanceof Date ? value : this.getDateObject(value);\n      return this.validateValue(date, value);\n    }\n    this.resetState();\n    return this.valueWithMinutes = null;\n  }\n  validateValue(date, value) {\n    let time;\n    const val = this.validateMinMax(value, this.min, this.max);\n    const newval = this.createDateObj(val);\n    if (this.getFormattedValue(newval) !== this.getFormattedValue(this.value)) {\n      this.valueWithMinutes = isNullOrUndefined(newval) ? null : newval;\n      time = this.objToString(this.valueWithMinutes);\n    } else {\n      if (this.strictMode) {\n        //for strict mode case, when value not present within a range. Reset the nearest range value.\n        date = newval;\n      }\n      this.valueWithMinutes = this.checkDateValue(date);\n      time = this.objToString(this.valueWithMinutes);\n    }\n    if (!this.strictMode && isNullOrUndefined(time)) {\n      const value = val.trim().length > 0 ? val : '';\n      this.updateInputValue(value);\n      if (this.enableMask) {\n        if (!value) {\n          this.updateInputValue(this.maskedDateValue);\n        }\n      }\n    } else {\n      this.updateInputValue(time);\n      if (this.enableMask) {\n        if (time == '') {\n          this.updateInputValue(this.maskedDateValue);\n        }\n        if (isNullOrUndefined(time) && value != this.maskedDateValue) {\n          this.createMask();\n        }\n        if (isNullOrUndefined(time) && value == this.maskedDateValue) {\n          this.updateInputValue(this.maskedDateValue);\n        }\n      }\n    }\n    return time;\n  }\n  createMask() {\n    this.notify(\"createMask\", {\n      module: \"MaskedDateTime\"\n    });\n  }\n  findNextElement(event) {\n    const textVal = this.inputElement.value;\n    const value = isNullOrUndefined(this.valueWithMinutes) ? this.createDateObj(textVal) : this.getDateObject(this.valueWithMinutes);\n    let timeVal = null;\n    const count = this.liCollections.length;\n    const collections = this.timeCollections;\n    if (!isNullOrUndefined(this.checkDateValue(value)) || !isNullOrUndefined(this.activeIndex)) {\n      if (event.action === 'home') {\n        const index = this.validLiElement(0);\n        timeVal = +this.createDateObj(new Date(this.timeCollections[index]));\n        this.activeIndex = index;\n      } else if (event.action === 'end') {\n        const index = this.validLiElement(collections.length - 1, true);\n        timeVal = +this.createDateObj(new Date(this.timeCollections[index]));\n        this.activeIndex = index;\n      } else {\n        if (event.action === 'down') {\n          for (let i = 0; i < count; i++) {\n            if (+value < this.timeCollections[i]) {\n              const index = this.validLiElement(i);\n              timeVal = +this.createDateObj(new Date(this.timeCollections[index]));\n              this.activeIndex = index;\n              break;\n            } else if (i === count - 1) {\n              const index = this.validLiElement(0);\n              timeVal = +this.createDateObj(new Date(this.timeCollections[index]));\n              this.activeIndex = index;\n              break;\n            }\n          }\n        } else {\n          for (let i = count - 1; i >= 0; i--) {\n            if (+value > this.timeCollections[i]) {\n              const index = this.validLiElement(i, true);\n              timeVal = +this.createDateObj(new Date(this.timeCollections[index]));\n              this.activeIndex = index;\n              break;\n            } else if (i === 0) {\n              const index = this.validLiElement(count - 1);\n              timeVal = +this.createDateObj(new Date(this.timeCollections[index]));\n              this.activeIndex = index;\n              break;\n            }\n          }\n        }\n      }\n      this.selectedElement = this.liCollections[this.activeIndex];\n      this.elementValue(isNullOrUndefined(timeVal) ? null : new Date(timeVal));\n    } else {\n      this.selectNextItem(event);\n    }\n  }\n  selectNextItem(event) {\n    const index = this.validLiElement(0, event.action === 'down' ? false : true);\n    this.activeIndex = index;\n    this.selectedElement = this.liCollections[index];\n    this.elementValue(new Date(this.timeCollections[index]));\n  }\n  elementValue(value) {\n    if (!isNullOrUndefined(this.checkDateValue(value))) {\n      this.checkValue(value);\n    }\n  }\n  validLiElement(index, backward) {\n    let elementIndex = null;\n    const items = isNullOrUndefined(this.popupWrapper) ? this.liCollections : this.popupWrapper.querySelectorAll('.' + LISTCLASS$1);\n    let isCheck = true;\n    if (items.length) {\n      if (backward) {\n        for (let i = index; i >= 0; i--) {\n          if (!items[i].classList.contains(DISABLED$3)) {\n            elementIndex = i;\n            break;\n          } else if (i === 0) {\n            if (isCheck) {\n              index = i = items.length;\n              isCheck = false;\n            }\n          }\n        }\n      } else {\n        for (let i = index; i <= items.length - 1; i++) {\n          if (!items[i].classList.contains(DISABLED$3)) {\n            elementIndex = i;\n            break;\n          } else if (i === items.length - 1) {\n            if (isCheck) {\n              index = i = -1;\n              isCheck = false;\n            }\n          }\n        }\n      }\n    }\n    return elementIndex;\n  }\n  keyHandler(event) {\n    if (isNullOrUndefined(this.step) || this.step <= 0 || this.inputWrapper.buttons[0].classList.contains(DISABLED$3)) {\n      return;\n    }\n    const count = this.timeCollections.length;\n    if (isNullOrUndefined(this.getActiveElement()) || this.getActiveElement().length === 0) {\n      if (this.liCollections.length > 0) {\n        if (isNullOrUndefined(this.value) && isNullOrUndefined(this.activeIndex)) {\n          const index = this.validLiElement(0, event.action === 'down' ? false : true);\n          this.activeIndex = index;\n          this.selectedElement = this.liCollections[index];\n          this.elementValue(new Date(this.timeCollections[index]));\n        } else {\n          this.findNextElement(event);\n        }\n      } else {\n        this.findNextElement(event);\n      }\n    } else {\n      let nextItem;\n      if (event.keyCode >= 37 && event.keyCode <= 40) {\n        let index = event.keyCode === 40 || event.keyCode === 39 ? ++this.activeIndex : --this.activeIndex;\n        this.activeIndex = index = this.activeIndex === count ? 0 : this.activeIndex;\n        this.activeIndex = index = this.activeIndex < 0 ? count - 1 : this.activeIndex;\n        this.activeIndex = index = this.validLiElement(this.activeIndex, event.keyCode === 40 || event.keyCode === 39 ? false : true);\n        nextItem = isNullOrUndefined(this.timeCollections[index]) ? this.timeCollections[0] : this.timeCollections[index];\n      } else if (event.action === 'home') {\n        const index = this.validLiElement(0);\n        this.activeIndex = index;\n        nextItem = this.timeCollections[index];\n      } else if (event.action === 'end') {\n        const index = this.validLiElement(count - 1, true);\n        this.activeIndex = index;\n        nextItem = this.timeCollections[index];\n      }\n      this.selectedElement = this.liCollections[this.activeIndex];\n      this.elementValue(new Date(nextItem));\n    }\n    this.isNavigate = true;\n    this.setHover(this.selectedElement, NAVIGATION);\n    this.setActiveDescendant();\n    this.selectInputText();\n    if (this.isPopupOpen() && this.selectedElement !== null && (!event || event.type !== 'click')) {\n      this.setScrollPosition();\n    }\n  }\n  getCultureTimeObject(ld, c) {\n    return getValue('main.' + c + '.dates.calendars.gregorian.timeFormats.short', ld);\n  }\n  getCultureDateObject(ld, c) {\n    return getValue('main.' + c + '.dates.calendars.gregorian.dateFormats.short', ld);\n  }\n  wireListEvents() {\n    EventHandler.add(this.listWrapper, 'click', this.onMouseClick, this);\n    if (!Browser.isDevice) {\n      EventHandler.add(this.listWrapper, 'mouseover', this.onMouseOver, this);\n      EventHandler.add(this.listWrapper, 'mouseout', this.onMouseLeave, this);\n    }\n  }\n  unWireListEvents() {\n    if (this.listWrapper) {\n      EventHandler.remove(this.listWrapper, 'click', this.onMouseClick);\n      if (!Browser.isDevice) {\n        EventHandler.remove(this.listWrapper, 'mouseover', this.onMouseOver);\n        EventHandler.remove(this.listWrapper, 'mouseout', this.onMouseLeave);\n      }\n    }\n  }\n  valueProcess(event, value) {\n    const result = isNullOrUndefined(this.checkDateValue(value)) ? null : value;\n    if (+this.prevDate !== +result) {\n      this.initValue = result;\n      this.changeEvent(event);\n    }\n  }\n  changeEvent(e) {\n    this.addSelection();\n    this.updateInput(true, this.initValue);\n    const eventArgs = {\n      event: e || null,\n      value: this.value,\n      text: this.inputElement.value,\n      isInteracted: !isNullOrUndefined(e),\n      element: this.element\n    };\n    eventArgs.value = this.valueWithMinutes || this.getDateObject(this.inputElement.value);\n    this.prevDate = this.valueWithMinutes || this.getDateObject(this.inputElement.value);\n    if (this.isAngular && this.preventChange) {\n      this.preventChange = false;\n    } else {\n      this.trigger('change', eventArgs);\n    }\n    this.invalidValueString = null;\n    this.checkErrorState(this.value);\n  }\n  updateInput(isUpdate, date) {\n    if (isUpdate) {\n      this.prevValue = this.getValue(date);\n    }\n    this.prevDate = this.valueWithMinutes = date;\n    if (typeof date !== 'number' || (this.value && +new Date(+this.value).setMilliseconds(0)) !== +date) {\n      this.setProperties({\n        value: date\n      }, true);\n      if (this.enableMask) {\n        this.createMask();\n      }\n    }\n    if (!this.strictMode && isNullOrUndefined(this.value) && this.invalidValueString) {\n      this.checkErrorState(this.invalidValueString);\n      this.updateInputValue(this.invalidValueString);\n    }\n    this.clearIconState();\n  }\n  setActiveDescendant() {\n    if (!isNullOrUndefined(this.selectedElement)) {\n      attributes(this.inputElement, {\n        'aria-activedescendant': this.selectedElement.getAttribute('id')\n      });\n    } else {\n      attributes(this.inputElement, {\n        'aria-activedescendant': 'null'\n      });\n    }\n  }\n  removeSelection() {\n    this.removeHover(HOVER$1);\n    if (!isNullOrUndefined(this.popupWrapper)) {\n      const items = this.popupWrapper.querySelectorAll('.' + SELECTED$4);\n      if (items.length) {\n        removeClass(items, SELECTED$4);\n        items[0].removeAttribute('aria-selected');\n      }\n    }\n  }\n  removeHover(className) {\n    const hoveredItem = this.getHoverItem(className);\n    if (hoveredItem && hoveredItem.length) {\n      removeClass(hoveredItem, className);\n      if (className === NAVIGATION) {\n        hoveredItem[0].removeAttribute('aria-selected');\n      }\n    }\n  }\n  getHoverItem(className) {\n    let hoveredItem;\n    if (!isNullOrUndefined(this.popupWrapper)) {\n      hoveredItem = this.popupWrapper.querySelectorAll('.' + className);\n    }\n    return hoveredItem;\n  }\n  setActiveClass() {\n    if (!isNullOrUndefined(this.popupWrapper)) {\n      const items = this.popupWrapper.querySelectorAll('.' + LISTCLASS$1);\n      if (items.length) {\n        for (let i = 0; i < items.length; i++) {\n          if (this.timeCollections[i] === +this.getDateObject(this.valueWithMinutes)) {\n            items[i].setAttribute('aria-selected', 'true');\n            this.selectedElement = items[i];\n            this.activeIndex = i;\n            break;\n          }\n        }\n      }\n    }\n  }\n  addSelection() {\n    this.selectedElement = null;\n    this.removeSelection();\n    this.setActiveClass();\n    if (!isNullOrUndefined(this.selectedElement)) {\n      addClass([this.selectedElement], SELECTED$4);\n      this.selectedElement.setAttribute('aria-selected', 'true');\n    }\n  }\n  isValidLI(li) {\n    return li && li.classList.contains(LISTCLASS$1) && !li.classList.contains(DISABLED$3);\n  }\n  createDateObj(val) {\n    const formatStr = null;\n    let today = this.globalize.formatDate(new Date(), {\n      format: formatStr,\n      skeleton: 'short',\n      type: 'date'\n    });\n    let value = null;\n    if (typeof val === 'string') {\n      if (val.toUpperCase().indexOf('AM') > -1 || val.toUpperCase().indexOf('PM') > -1) {\n        today = this.defaultCulture.formatDate(new Date(), {\n          format: formatStr,\n          skeleton: 'short',\n          type: 'date'\n        });\n        value = isNaN(+new Date(today + ' ' + val)) ? null : new Date(new Date(today + ' ' + val).setMilliseconds(0));\n        if (isNullOrUndefined(value)) {\n          value = this.timeParse(today, val);\n        }\n      } else {\n        value = this.timeParse(today, val);\n      }\n    } else if (val instanceof Date) {\n      value = val;\n    }\n    return value;\n  }\n  timeParse(today, val) {\n    let value;\n    value = this.globalize.parseDate(today + ' ' + val, {\n      format: this.cldrDateFormat() + ' ' + this.cldrTimeFormat(),\n      type: 'datetime'\n    });\n    value = isNullOrUndefined(value) ? this.globalize.parseDate(today + ' ' + val, {\n      format: this.cldrDateFormat() + ' ' + this.dateToNumeric(),\n      type: 'datetime'\n    }) : value;\n    value = isNullOrUndefined(value) ? value : new Date(value.setMilliseconds(0));\n    return value;\n  }\n  createListItems() {\n    this.listWrapper = this.createElement('div', {\n      className: CONTENT$2,\n      attrs: {\n        'tabindex': '0'\n      }\n    });\n    let start;\n    const interval = this.step * 60000;\n    const listItems = [];\n    this.timeCollections = [];\n    this.disableItemCollection = [];\n    start = +this.getDateObject(this.initMin).setMilliseconds(0);\n    const end = +this.getDateObject(this.initMax).setMilliseconds(0);\n    while (end >= start) {\n      this.timeCollections.push(start);\n      listItems.push(this.globalize.formatDate(new Date(start), {\n        format: this.cldrTimeFormat(),\n        type: 'time'\n      }));\n      start += interval;\n    }\n    const listBaseOptions = {\n      itemCreated: args => {\n        const eventArgs = {\n          element: args.item,\n          text: args.text,\n          value: this.getDateObject(args.text),\n          isDisabled: false\n        };\n        this.trigger('itemRender', eventArgs, eventArgs => {\n          if (eventArgs.isDisabled) {\n            eventArgs.element.classList.add(DISABLED$3);\n          }\n          if (eventArgs.element.classList.contains(DISABLED$3)) {\n            this.disableItemCollection.push(eventArgs.element.getAttribute('data-value'));\n          }\n        });\n      }\n    };\n    this.listTag = ListBase.createList(this.createElement, listItems, listBaseOptions, true);\n    attributes(this.listTag, {\n      'role': 'listbox',\n      'aria-hidden': 'false',\n      'id': this.element.id + '_options'\n    });\n    append([this.listTag], this.listWrapper);\n  }\n  documentClickHandler(event) {\n    const target = event.target;\n    if (!isNullOrUndefined(this.popupObj) && (this.inputWrapper.container.contains(target) || this.popupObj.element && this.popupObj.element.contains(target)) && event.type !== 'touchstart') {\n      event.preventDefault();\n    }\n    if (!closest(target, '[id=\"' + this.popupObj.element.id + '\"]') && target !== this.inputElement && target !== (this.inputWrapper && this.inputWrapper.buttons[0]) && target !== (this.inputWrapper && this.inputWrapper.clearButton) && target !== (this.inputWrapper && this.inputWrapper.container)) {\n      if (this.isPopupOpen()) {\n        this.hide();\n        this.focusOut();\n      }\n    } else if (target !== this.inputElement) {\n      if (!Browser.isDevice) {\n        this.isPreventBlur = (Browser.isIE || Browser.info.name === 'edge') && document.activeElement === this.inputElement && target === this.popupWrapper;\n      }\n    }\n  }\n  setEnableRtl() {\n    Input.setEnableRtl(this.enableRtl, [this.inputWrapper.container]);\n    if (this.popupObj) {\n      this.popupObj.enableRtl = this.enableRtl;\n      this.popupObj.dataBind();\n    }\n  }\n  setEnable() {\n    Input.setEnabled(this.enabled, this.inputElement, this.floatLabelType);\n    if (this.enabled) {\n      removeClass([this.inputWrapper.container], DISABLED$3);\n      attributes(this.inputElement, {\n        'aria-disabled': 'false'\n      });\n      this.inputElement.setAttribute('tabindex', this.tabIndex);\n    } else {\n      this.hide();\n      addClass([this.inputWrapper.container], DISABLED$3);\n      attributes(this.inputElement, {\n        'aria-disabled': 'true'\n      });\n      this.inputElement.tabIndex = -1;\n    }\n  }\n  getProperty(date, val) {\n    if (val === 'min') {\n      this.initMin = this.checkDateValue(new Date(this.checkInValue(date.min)));\n      this.setProperties({\n        min: this.initMin\n      }, true);\n    } else {\n      this.initMax = this.checkDateValue(new Date(this.checkInValue(date.max)));\n      this.setProperties({\n        max: this.initMax\n      }, true);\n    }\n    if (this.inputElement.value === '') {\n      this.validateMinMax(this.value, this.min, this.max);\n    } else {\n      this.checkValue(this.inputElement.value);\n    }\n    this.checkValueChange(null, false);\n  }\n  inputBlurHandler(e) {\n    if (!this.enabled) {\n      return;\n    }\n    // IE popup closing issue when click over the scrollbar\n    if (this.isPreventBlur && this.isPopupOpen()) {\n      this.inputElement.focus();\n      return;\n    }\n    this.closePopup(0, e);\n    if (this.enableMask && this.maskedDateValue && this.placeholder && this.floatLabelType !== 'Always') {\n      if (this.inputElement.value == this.maskedDateValue && !this.value && (this.floatLabelType == 'Auto' || this.floatLabelType == 'Never' || this.placeholder)) {\n        this.updateInputValue('');\n      }\n    }\n    removeClass([this.inputWrapper.container], [FOCUS]);\n    const blurArguments = {\n      model: this\n    };\n    this.trigger('blur', blurArguments);\n    if (this.getText() !== this.inputElement.value) {\n      this.updateValue(this.inputElement.value, e);\n    } else if (this.inputElement.value.trim().length === 0) {\n      this.resetState();\n    }\n    this.cursorDetails = null;\n    this.isNavigate = false;\n    if (this.inputElement.value === '') {\n      this.invalidValueString = null;\n    }\n  }\n  /**\n   * Focuses out the TimePicker textbox element.\n   *\n   * @returns {void}\n   */\n  focusOut() {\n    if (document.activeElement === this.inputElement) {\n      this.inputElement.blur();\n      removeClass([this.inputWrapper.container], [FOCUS]);\n      const blurArguments = {\n        model: this\n      };\n      this.trigger('blur', blurArguments);\n    }\n  }\n  isPopupOpen() {\n    if (this.popupWrapper && this.popupWrapper.classList.contains('' + ROOT$3)) {\n      return true;\n    }\n    return false;\n  }\n  inputFocusHandler() {\n    if (!this.enabled) {\n      return;\n    }\n    const focusArguments = {\n      model: this\n    };\n    if (!this.readonly && !Browser.isDevice && !this.enableMask) {\n      this.selectInputText();\n    }\n    if (this.enableMask && !this.inputElement.value && this.placeholder) {\n      if (this.maskedDateValue && !this.value && (this.floatLabelType == 'Auto' || this.floatLabelType == 'Never' || this.placeholder)) {\n        this.updateInputValue(this.maskedDateValue);\n        this.inputElement.selectionStart = 0;\n        this.inputElement.selectionEnd = this.inputElement.value.length;\n      }\n    }\n    this.trigger('focus', focusArguments);\n    this.clearIconState();\n    if (this.openOnFocus) {\n      this.show();\n    }\n  }\n  /**\n   * Focused the TimePicker textbox element.\n   *\n   * @returns {void}\n   */\n  focusIn() {\n    if (document.activeElement !== this.inputElement && this.enabled) {\n      this.inputElement.focus();\n    }\n  }\n  /**\n   * Hides the TimePicker popup.\n   *\n   * @returns {void}\n   * @deprecated\n   */\n  hide() {\n    this.closePopup(100, null);\n    this.clearIconState();\n  }\n  /* eslint-disable valid-jsdoc, jsdoc/require-param */\n  /**\n   * Opens the popup to show the list items.\n   *\n   * @returns {void}\n   * @deprecated\n   */\n  show(event) {\n    if (this.enabled && this.readonly || !this.enabled || this.popupWrapper) {\n      return;\n    } else {\n      this.popupCreation();\n      if (Browser.isDevice && this.listWrapper) {\n        this.modal = this.createElement('div');\n        this.modal.className = '' + ROOT$3 + ' e-time-modal';\n        document.body.className += ' ' + OVERFLOW$2;\n        document.body.appendChild(this.modal);\n      }\n      if (Browser.isDevice) {\n        this.mobileTimePopupWrap = this.createElement('div', {\n          className: 'e-timepicker-mob-popup-wrap'\n        });\n        document.body.appendChild(this.mobileTimePopupWrap);\n      }\n      this.openPopupEventArgs = {\n        popup: this.popupObj || null,\n        cancel: false,\n        event: event || null,\n        name: 'open',\n        appendTo: Browser.isDevice ? this.mobileTimePopupWrap : document.body\n      };\n      const eventArgs = this.openPopupEventArgs;\n      this.trigger('open', eventArgs, eventArgs => {\n        this.openPopupEventArgs = eventArgs;\n        if (!this.openPopupEventArgs.cancel && !this.inputWrapper.buttons[0].classList.contains(DISABLED$3)) {\n          this.openPopupEventArgs.appendTo.appendChild(this.popupWrapper);\n          this.popupAlignment(this.openPopupEventArgs);\n          this.setScrollPosition();\n          if (!Browser.isDevice) {\n            this.inputElement.focus();\n          }\n          const openAnimation = {\n            name: 'FadeIn',\n            duration: ANIMATIONDURATION\n          };\n          this.popupObj.refreshPosition(this.anchor);\n          if (this.zIndex === 1000) {\n            this.popupObj.show(new Animation(openAnimation), this.element);\n          } else {\n            this.popupObj.show(new Animation(openAnimation), null);\n          }\n          this.setActiveDescendant();\n          attributes(this.inputElement, {\n            'aria-expanded': 'true'\n          });\n          addClass([this.inputWrapper.container], FOCUS);\n          EventHandler.add(document, 'mousedown touchstart', this.documentClickHandler, this);\n          this.setOverlayIndex(this.mobileTimePopupWrap, this.popupObj.element, this.modal, Browser.isDevice);\n        } else {\n          this.popupObj.destroy();\n          this.popupWrapper = this.listTag = undefined;\n          this.liCollections = this.timeCollections = this.disableItemCollection = [];\n          this.popupObj = null;\n        }\n      });\n    }\n  }\n  /* eslint-enable valid-jsdoc, jsdoc/require-param */\n  setOverlayIndex(popupWrapper, timePopupElement, modal, isDevice) {\n    if (isDevice && !isNullOrUndefined(timePopupElement) && !isNullOrUndefined(modal) && !isNullOrUndefined(popupWrapper)) {\n      const index = parseInt(timePopupElement.style.zIndex, 10) ? parseInt(timePopupElement.style.zIndex, 10) : 1000;\n      modal.style.zIndex = (index - 1).toString();\n      popupWrapper.style.zIndex = index.toString();\n    }\n  }\n  formatValues(type) {\n    let value;\n    if (typeof type === 'number') {\n      value = formatUnit(type);\n    } else if (typeof type === 'string') {\n      value = type.match(/px|%|em/) ? type : isNaN(parseInt(type, 10)) ? type : formatUnit(type);\n    }\n    return value;\n  }\n  popupAlignment(args) {\n    args.popup.position.X = this.formatValues(args.popup.position.X);\n    args.popup.position.Y = this.formatValues(args.popup.position.Y);\n    if (!isNaN(parseFloat(args.popup.position.X)) || !isNaN(parseFloat(args.popup.position.Y))) {\n      this.popupObj.relateTo = this.anchor = document.body;\n      this.popupObj.targetType = 'container';\n    }\n    if (!isNaN(parseFloat(args.popup.position.X))) {\n      this.popupObj.offsetX = parseFloat(args.popup.position.X);\n    }\n    if (!isNaN(parseFloat(args.popup.position.Y))) {\n      this.popupObj.offsetY = parseFloat(args.popup.position.Y);\n    }\n    if (!Browser.isDevice) {\n      switch (args.popup.position.X) {\n        case 'left':\n          break;\n        case 'right':\n          args.popup.offsetX = this.containerStyle.width;\n          break;\n        case 'center':\n          args.popup.offsetX = -(this.containerStyle.width / 2);\n          break;\n      }\n      switch (args.popup.position.Y) {\n        case 'top':\n          break;\n        case 'bottom':\n          break;\n        case 'center':\n          args.popup.offsetY = -(this.containerStyle.height / 2);\n          break;\n      }\n      if (args.popup.position.X === 'center' && args.popup.position.Y === 'center') {\n        this.popupObj.relateTo = this.inputWrapper.container;\n        this.anchor = this.inputElement;\n        this.popupObj.targetType = 'relative';\n      }\n    } else {\n      if (args.popup.position.X === 'center' && args.popup.position.Y === 'center') {\n        this.popupObj.relateTo = this.anchor = document.body;\n        this.popupObj.offsetY = 0;\n        this.popupObj.targetType = 'container';\n        this.popupObj.collision = {\n          X: 'fit',\n          Y: 'fit'\n        };\n      }\n    }\n  }\n  /* eslint-disable valid-jsdoc, jsdoc/require-returns-description */\n  /**\n   * Gets the properties to be maintained upon browser refresh.\n   *\n   * @returns {string}\n   */\n  getPersistData() {\n    const keyEntity = ['value'];\n    return this.addOnPersist(keyEntity);\n  }\n  /* eslint-enable valid-jsdoc, jsdoc/require-returns-description */\n  /**\n   * To get component name\n   *\n   * @returns {string} Returns the component name.\n   * @private\n   */\n  getModuleName() {\n    return 'timepicker';\n  }\n  /**\n   * Called internally if any of the property value changed.\n   *\n   * @param {TimePickerModel} newProp - Returns the dynamic property value of the component.\n   * @param {TimePickerModel} oldProp - Returns the previous property value of the component.\n   * @returns {void}\n   * @private\n   */\n  onPropertyChanged(newProp, oldProp) {\n    for (const prop of Object.keys(newProp)) {\n      switch (prop) {\n        case 'placeholder':\n          Input.setPlaceholder(newProp.placeholder, this.inputElement);\n          this.inputElement.setAttribute('aria-placeholder', newProp.placeholder);\n          break;\n        case 'readonly':\n          Input.setReadonly(this.readonly, this.inputElement, this.floatLabelType);\n          if (this.readonly) {\n            this.hide();\n          }\n          this.setTimeAllowEdit();\n          break;\n        case 'enabled':\n          this.setProperties({\n            enabled: newProp.enabled\n          }, true);\n          this.setEnable();\n          break;\n        case 'allowEdit':\n          this.setTimeAllowEdit();\n          break;\n        case 'enableRtl':\n          this.setProperties({\n            enableRtl: newProp.enableRtl\n          }, true);\n          this.setEnableRtl();\n          break;\n        case 'cssClass':\n          this.updateCssClass(newProp.cssClass, oldProp.cssClass);\n          break;\n        case 'zIndex':\n          this.setProperties({\n            zIndex: newProp.zIndex\n          }, true);\n          this.setZIndex();\n          break;\n        case 'htmlAttributes':\n          this.updateHtmlAttributeToElement();\n          this.updateHtmlAttributeToWrapper();\n          this.checkAttributes(true);\n          break;\n        case 'min':\n        case 'max':\n          this.getProperty(newProp, prop);\n          break;\n        case 'showClearButton':\n          Input.setClearButton(this.showClearButton, this.inputElement, this.inputWrapper);\n          this.bindClearEvent();\n          break;\n        case 'locale':\n          this.setProperties({\n            locale: newProp.locale\n          }, true);\n          this.globalize = new Internationalization(this.locale);\n          this.l10n.setLocale(this.locale);\n          this.updatePlaceHolder();\n          this.setValue(this.value);\n          if (this.enableMask) {\n            this.notify(\"createMask\", {\n              module: \"MaskedDateTime\"\n            });\n          }\n          break;\n        case 'width':\n          setStyleAttribute(this.inputWrapper.container, {\n            'width': this.setWidth(newProp.width)\n          });\n          this.containerStyle = this.inputWrapper.container.getBoundingClientRect();\n          break;\n        case 'format':\n          this.setProperties({\n            format: newProp.format\n          }, true);\n          this.checkTimeFormat();\n          this.setValue(this.value);\n          if (this.enableMask) {\n            this.createMask();\n            if (!this.value) {\n              this.updateInputValue(this.maskedDateValue);\n            }\n          }\n          break;\n        case 'value':\n          this.invalidValueString = null;\n          this.checkInvalidValue(newProp.value);\n          newProp.value = this.value;\n          if (!this.invalidValueString) {\n            if (typeof newProp.value === 'string') {\n              this.setProperties({\n                value: this.checkDateValue(new Date(newProp.value))\n              }, true);\n              newProp.value = this.value;\n            } else {\n              if ((newProp.value && +new Date(+newProp.value).setMilliseconds(0)) !== +this.value) {\n                newProp.value = this.checkDateValue(new Date('' + newProp.value));\n              }\n            }\n            this.initValue = newProp.value;\n            newProp.value = this.compareFormatChange(this.checkValue(newProp.value));\n          } else {\n            this.updateInputValue(this.invalidValueString);\n            this.checkErrorState(this.invalidValueString);\n          }\n          this.checkValueChange(null, false);\n          if (this.isPopupOpen()) {\n            this.setScrollPosition();\n          }\n          if (this.isAngular && this.preventChange) {\n            this.preventChange = false;\n          }\n          if (this.enableMask) {\n            this.notify(\"createMask\", {\n              module: \"MaskedDateTime\"\n            });\n          }\n          break;\n        case 'floatLabelType':\n          this.floatLabelType = newProp.floatLabelType;\n          Input.removeFloating(this.inputWrapper);\n          Input.addFloating(this.inputElement, this.floatLabelType, this.placeholder);\n          break;\n        case 'strictMode':\n          this.invalidValueString = null;\n          if (newProp.strictMode) {\n            this.checkErrorState(null);\n          }\n          this.setProperties({\n            strictMode: newProp.strictMode\n          }, true);\n          this.checkValue(this.inputElement.value);\n          this.checkValueChange(null, false);\n          break;\n        case 'scrollTo':\n          if (this.checkDateValue(new Date(this.checkInValue(newProp.scrollTo)))) {\n            if (this.popupWrapper) {\n              this.setScrollTo();\n            }\n            this.setProperties({\n              scrollTo: this.checkDateValue(new Date(this.checkInValue(newProp.scrollTo)))\n            }, true);\n          } else {\n            this.setProperties({\n              scrollTo: null\n            }, true);\n          }\n          break;\n        case 'enableMask':\n          if (this.enableMask) {\n            this.notify(\"createMask\", {\n              module: \"MaskedDateTime\"\n            });\n            this.updateInputValue(this.maskedDateValue);\n          } else {\n            if (this.inputElement.value === this.maskedDateValue) {\n              this.updateInputValue('');\n            }\n          }\n          break;\n      }\n    }\n  }\n  checkInValue(inValue) {\n    if (inValue instanceof Date) {\n      return inValue.toUTCString();\n    } else {\n      return '' + inValue;\n    }\n  }\n};\n__decorate$3([Property(null)], TimePicker.prototype, \"width\", void 0);\n__decorate$3([Property(null)], TimePicker.prototype, \"cssClass\", void 0);\n__decorate$3([Property(false)], TimePicker.prototype, \"strictMode\", void 0);\n__decorate$3([Property(null)], TimePicker.prototype, \"keyConfigs\", void 0);\n__decorate$3([Property(null)], TimePicker.prototype, \"format\", void 0);\n__decorate$3([Property(true)], TimePicker.prototype, \"enabled\", void 0);\n__decorate$3([Property(false)], TimePicker.prototype, \"readonly\", void 0);\n__decorate$3([Property({})], TimePicker.prototype, \"htmlAttributes\", void 0);\n__decorate$3([Property('Never')], TimePicker.prototype, \"floatLabelType\", void 0);\n__decorate$3([Property(null)], TimePicker.prototype, \"placeholder\", void 0);\n__decorate$3([Property(1000)], TimePicker.prototype, \"zIndex\", void 0);\n__decorate$3([Property(false)], TimePicker.prototype, \"enablePersistence\", void 0);\n__decorate$3([Property(true)], TimePicker.prototype, \"showClearButton\", void 0);\n__decorate$3([Property(30)], TimePicker.prototype, \"step\", void 0);\n__decorate$3([Property(null)], TimePicker.prototype, \"scrollTo\", void 0);\n__decorate$3([Property(null)], TimePicker.prototype, \"value\", void 0);\n__decorate$3([Property(null)], TimePicker.prototype, \"min\", void 0);\n__decorate$3([Property(null)], TimePicker.prototype, \"max\", void 0);\n__decorate$3([Property(true)], TimePicker.prototype, \"allowEdit\", void 0);\n__decorate$3([Property(false)], TimePicker.prototype, \"openOnFocus\", void 0);\n__decorate$3([Property(false)], TimePicker.prototype, \"enableMask\", void 0);\n__decorate$3([Property({\n  day: 'day',\n  month: 'month',\n  year: 'year',\n  hour: 'hour',\n  minute: 'minute',\n  second: 'second',\n  dayOfTheWeek: 'day of the week'\n})], TimePicker.prototype, \"maskPlaceholder\", void 0);\n__decorate$3([Event()], TimePicker.prototype, \"change\", void 0);\n__decorate$3([Event()], TimePicker.prototype, \"created\", void 0);\n__decorate$3([Event()], TimePicker.prototype, \"destroyed\", void 0);\n__decorate$3([Event()], TimePicker.prototype, \"open\", void 0);\n__decorate$3([Event()], TimePicker.prototype, \"itemRender\", void 0);\n__decorate$3([Event()], TimePicker.prototype, \"close\", void 0);\n__decorate$3([Event()], TimePicker.prototype, \"cleared\", void 0);\n__decorate$3([Event()], TimePicker.prototype, \"blur\", void 0);\n__decorate$3([Event()], TimePicker.prototype, \"focus\", void 0);\nTimePicker = __decorate$3([NotifyPropertyChanges], TimePicker);\n\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\n/**\n * TimePicker modules\n */\n\nvar __decorate$4 = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n// eslint-disable-next-line @typescript-eslint/triple-slash-reference\n///<reference path='../datepicker/datepicker-model.d.ts'/>\n//class constant defination\nconst DATEWRAPPER$1 = 'e-date-wrapper';\nconst DATEPICKERROOT = 'e-datepicker';\nconst DATETIMEWRAPPER = 'e-datetime-wrapper';\nconst DAY$1 = new Date().getDate();\nconst MONTH$3 = new Date().getMonth();\nconst YEAR$3 = new Date().getFullYear();\nconst HOUR = new Date().getHours();\nconst MINUTE = new Date().getMinutes();\nconst SECOND = new Date().getSeconds();\nconst MILLISECOND = new Date().getMilliseconds();\nconst ROOT$4 = 'e-datetimepicker';\nconst DATETIMEPOPUPWRAPPER = 'e-datetimepopup-wrapper';\nconst INPUTWRAPPER$1 = 'e-input-group-icon';\nconst POPUP$3 = 'e-popup';\nconst TIMEICON$1 = 'e-time-icon';\nconst INPUTFOCUS$2 = 'e-input-focus';\nconst POPUPDIMENSION$1 = '250px';\nconst ICONANIMATION$1 = 'e-icon-anim';\nconst DISABLED$4 = 'e-disabled';\nconst ERROR$3 = 'e-error';\nconst CONTENT$3 = 'e-content';\nconst NAVIGATION$1 = 'e-navigation';\nconst ACTIVE$2 = 'e-active';\nconst HOVER$2 = 'e-hover';\nconst ICONS$1 = 'e-icons';\nconst HALFPOSITION$1 = 2;\nconst LISTCLASS$2 = 'e-list-item';\nconst ANIMATIONDURATION$1 = 100;\nconst OVERFLOW$3 = 'e-time-overflow';\n/**\n * Represents the DateTimePicker component that allows user to select\n * or enter a date time value.\n * ```html\n * <input id=\"dateTimePicker\"/>\n * ```\n * ```typescript\n * <script>\n *   let dateTimePickerObject:DateTimePicker = new DateTimePicker({ value: new Date() });\n *   dateTimePickerObject.appendTo(\"#dateTimePicker\");\n * </script>\n * ```\n */\nlet DateTimePicker = class DateTimePicker extends DatePicker {\n  /**\n   * Constructor for creating the widget\n   *\n   * @param {DateTimePickerModel} options - Specifies the DateTimePicker model.\n   * @param {string | HTMLInputElement} element - Specifies the element to render as component.\n   * @private\n   */\n  constructor(options, element) {\n    super(options, element);\n    this.valueWithMinutes = null;\n    this.scrollInvoked = false;\n    this.moduleName = this.getModuleName();\n    this.dateTimeOptions = options;\n  }\n  focusHandler() {\n    if (!this.enabled) {\n      return;\n    }\n    addClass([this.inputWrapper.container], INPUTFOCUS$2);\n  }\n  /**\n   * Sets the focus to widget for interaction.\n   *\n   * @returns {void}\n   */\n  focusIn() {\n    super.focusIn();\n  }\n  /**\n   * Remove the focus from widget, if the widget is in focus state.\n   *\n   * @returns {void}\n   */\n  focusOut() {\n    if (document.activeElement === this.inputElement) {\n      this.inputElement.blur();\n      removeClass([this.inputWrapper.container], [INPUTFOCUS$2]);\n    }\n  }\n  blurHandler(e) {\n    if (!this.enabled) {\n      return;\n    }\n    // IE popup closing issue when click over the scrollbar\n    if (this.isTimePopupOpen() && this.isPreventBlur) {\n      this.inputElement.focus();\n      return;\n    }\n    removeClass([this.inputWrapper.container], INPUTFOCUS$2);\n    const blurArguments = {\n      model: this\n    };\n    if (this.isTimePopupOpen()) {\n      this.hide(e);\n    }\n    this.trigger('blur', blurArguments);\n  }\n  /**\n   * To destroy the widget.\n   *\n   * @returns {void}\n   */\n  destroy() {\n    if (this.popupObject && this.popupObject.element.classList.contains(POPUP$3)) {\n      this.popupObject.destroy();\n      detach(this.dateTimeWrapper);\n      this.dateTimeWrapper = undefined;\n      this.liCollections = this.timeCollections = [];\n      if (!isNullOrUndefined(this.rippleFn)) {\n        this.rippleFn();\n      }\n    }\n    const ariaAttribute = {\n      'aria-live': 'assertive',\n      'aria-atomic': 'true',\n      'aria-invalid': 'false',\n      'aria-haspopup': 'true',\n      'aria-activedescendant': 'null',\n      'autocorrect': 'off',\n      'autocapitalize': 'off',\n      'spellcheck': 'false',\n      'aria-owns': this.element.id + '_options',\n      'aria-expanded': 'false',\n      'role': 'combobox',\n      'autocomplete': 'off'\n    };\n    if (this.inputElement) {\n      Input.removeAttributes(ariaAttribute, this.inputElement);\n      this.inputElement.removeAttribute('aria-placeholder');\n    }\n    if (this.isCalendar()) {\n      if (this.popupWrapper) {\n        detach(this.popupWrapper);\n      }\n      this.popupObject = this.popupWrapper = null;\n      this.keyboardHandler.destroy();\n    }\n    this.unBindInputEvents();\n    super.destroy();\n  }\n  /**\n   * To Initialize the control rendering.\n   *\n   * @returns {void}\n   * @private\n   */\n  render() {\n    this.timekeyConfigure = {\n      enter: 'enter',\n      escape: 'escape',\n      end: 'end',\n      tab: 'tab',\n      home: 'home',\n      down: 'downarrow',\n      up: 'uparrow',\n      left: 'leftarrow',\n      right: 'rightarrow',\n      open: 'alt+downarrow',\n      close: 'alt+uparrow'\n    };\n    this.valueWithMinutes = null;\n    this.previousDateTime = null;\n    this.isPreventBlur = false;\n    this.cloneElement = this.element.cloneNode(true);\n    this.dateTimeFormat = this.cldrDateTimeFormat();\n    this.initValue = this.value;\n    super.updateHtmlAttributeToElement();\n    this.checkAttributes(false);\n    const localeText = {\n      placeholder: this.placeholder\n    };\n    this.l10n = new L10n('datetimepicker', localeText, this.locale);\n    this.setProperties({\n      placeholder: this.placeholder || this.l10n.getConstant('placeholder')\n    }, true);\n    super.render();\n    this.createInputElement();\n    super.updateHtmlAttributeToWrapper();\n    this.bindInputEvents();\n    if (this.enableMask) {\n      this.notify(\"createMask\", {\n        module: \"MaskedDateTime\"\n      });\n    }\n    this.setValue();\n    if (this.enableMask && !this.value && this.maskedDateValue && (this.floatLabelType == 'Always' || !this.floatLabelType || !this.placeholder)) {\n      Input.setValue(this.maskedDateValue, this.inputElement, this.floatLabelType, this.showClearButton);\n    }\n    this.setProperties({\n      scrollTo: this.checkDateValue(new Date(this.checkValue(this.scrollTo)))\n    }, true);\n    this.previousDateTime = this.value && new Date(+this.value);\n    if (this.element.tagName === 'EJS-DATETIMEPICKER') {\n      this.tabIndex = this.element.hasAttribute('tabindex') ? this.element.getAttribute('tabindex') : '0';\n      this.element.removeAttribute('tabindex');\n      if (!this.enabled) {\n        this.inputElement.tabIndex = -1;\n      }\n    }\n    this.renderComplete();\n  }\n  setValue() {\n    this.initValue = this.validateMinMaxRange(this.value);\n    if (!this.strictMode && this.isDateObject(this.initValue)) {\n      const value = this.validateMinMaxRange(this.initValue);\n      Input.setValue(this.getFormattedValue(value), this.inputElement, this.floatLabelType, this.showClearButton);\n      this.setProperties({\n        value: value\n      }, true);\n    } else {\n      if (isNullOrUndefined(this.value)) {\n        this.initValue = null;\n        this.setProperties({\n          value: null\n        }, true);\n      }\n    }\n    this.valueWithMinutes = this.value;\n    super.updateInput();\n  }\n  validateMinMaxRange(value) {\n    let result = value;\n    if (this.isDateObject(value)) {\n      result = this.validateValue(value);\n    } else {\n      if (+this.min > +this.max) {\n        this.disablePopupButton(true);\n      }\n    }\n    this.checkValidState(result);\n    return result;\n  }\n  checkValidState(value) {\n    this.isValidState = true;\n    if (!this.strictMode) {\n      if (+value > +this.max || +value < +this.min) {\n        this.isValidState = false;\n      }\n    }\n    this.checkErrorState();\n  }\n  checkErrorState() {\n    if (this.isValidState) {\n      removeClass([this.inputWrapper.container], ERROR$3);\n    } else {\n      addClass([this.inputWrapper.container], ERROR$3);\n    }\n    attributes(this.inputElement, {\n      'aria-invalid': this.isValidState ? 'false' : 'true'\n    });\n  }\n  validateValue(value) {\n    let dateVal = value;\n    if (this.strictMode) {\n      if (+this.min > +this.max) {\n        this.disablePopupButton(true);\n        dateVal = this.max;\n      } else if (+value < +this.min) {\n        dateVal = this.min;\n      } else if (+value > +this.max) {\n        dateVal = this.max;\n      }\n    } else {\n      if (+this.min > +this.max) {\n        this.disablePopupButton(true);\n        dateVal = value;\n      }\n    }\n    return dateVal;\n  }\n  disablePopupButton(isDisable) {\n    if (isDisable) {\n      addClass([this.inputWrapper.buttons[0], this.timeIcon], DISABLED$4);\n      this.hide();\n    } else {\n      removeClass([this.inputWrapper.buttons[0], this.timeIcon], DISABLED$4);\n    }\n  }\n  getFormattedValue(value) {\n    let dateOptions;\n    if (!isNullOrUndefined(value)) {\n      if (this.calendarMode === 'Gregorian') {\n        dateOptions = {\n          format: this.cldrDateTimeFormat(),\n          type: 'dateTime',\n          skeleton: 'yMd'\n        };\n      } else {\n        dateOptions = {\n          format: this.cldrDateTimeFormat(),\n          type: 'dateTime',\n          skeleton: 'yMd',\n          calendar: 'islamic'\n        };\n      }\n      return this.globalize.formatDate(value, dateOptions);\n    } else {\n      return null;\n    }\n  }\n  isDateObject(value) {\n    return !isNullOrUndefined(value) && !isNaN(+value) ? true : false;\n  }\n  createInputElement() {\n    removeClass([this.inputElement], DATEPICKERROOT);\n    removeClass([this.inputWrapper.container], DATEWRAPPER$1);\n    addClass([this.inputWrapper.container], DATETIMEWRAPPER);\n    addClass([this.inputElement], ROOT$4);\n    this.renderTimeIcon();\n  }\n  renderTimeIcon() {\n    this.timeIcon = Input.appendSpan(INPUTWRAPPER$1 + ' ' + TIMEICON$1 + ' ' + ICONS$1, this.inputWrapper.container);\n  }\n  bindInputEvents() {\n    EventHandler.add(this.timeIcon, 'mousedown', this.timeHandler, this);\n    EventHandler.add(this.inputWrapper.buttons[0], 'mousedown', this.dateHandler, this);\n    EventHandler.add(this.inputElement, 'blur', this.blurHandler, this);\n    EventHandler.add(this.inputElement, 'focus', this.focusHandler, this);\n    this.defaultKeyConfigs = extend(this.defaultKeyConfigs, this.keyConfigs);\n    this.keyboardHandler = new KeyboardEvents(this.inputElement, {\n      eventName: 'keydown',\n      keyAction: this.inputKeyAction.bind(this),\n      keyConfigs: this.defaultKeyConfigs\n    });\n  }\n  unBindInputEvents() {\n    EventHandler.remove(this.timeIcon, 'mousedown touchstart', this.timeHandler);\n    EventHandler.remove(this.inputWrapper.buttons[0], 'mousedown touchstart', this.dateHandler);\n    if (this.inputElement) {\n      EventHandler.remove(this.inputElement, 'blur', this.blurHandler);\n      EventHandler.remove(this.inputElement, 'focus', this.focusHandler);\n    }\n    if (this.keyboardHandler) {\n      this.keyboardHandler.destroy();\n    }\n  }\n  cldrTimeFormat() {\n    let cldrTime;\n    if (this.isNullOrEmpty(this.timeFormat)) {\n      if (this.locale === 'en' || this.locale === 'en-US') {\n        cldrTime = getValue('timeFormats.short', getDefaultDateObject());\n      } else {\n        cldrTime = this.getCultureTimeObject(cldrData, '' + this.locale);\n      }\n    } else {\n      cldrTime = this.timeFormat;\n    }\n    return cldrTime;\n  }\n  cldrDateTimeFormat() {\n    let cldrTime;\n    const culture = new Internationalization(this.locale);\n    const dateFormat = culture.getDatePattern({\n      skeleton: 'yMd'\n    });\n    if (this.isNullOrEmpty(this.formatString)) {\n      cldrTime = dateFormat + ' ' + this.getCldrFormat('time');\n    } else {\n      cldrTime = this.formatString;\n    }\n    return cldrTime;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  getCldrFormat(type) {\n    let cldrDateTime;\n    if (this.locale === 'en' || this.locale === 'en-US') {\n      cldrDateTime = getValue('timeFormats.short', getDefaultDateObject());\n    } else {\n      cldrDateTime = this.getCultureTimeObject(cldrData, '' + this.locale);\n    }\n    return cldrDateTime;\n  }\n  isNullOrEmpty(value) {\n    if (isNullOrUndefined(value) || typeof value === 'string' && value.trim() === '') {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  getCultureTimeObject(ld, c) {\n    if (this.calendarMode === 'Gregorian') {\n      return getValue('main.' + '' + this.locale + '.dates.calendars.gregorian.timeFormats.short', ld);\n    } else {\n      return getValue('main.' + '' + this.locale + '.dates.calendars.islamic.timeFormats.short', ld);\n    }\n  }\n  timeHandler(e) {\n    if (!this.enabled) {\n      return;\n    }\n    this.isIconClicked = true;\n    if (Browser.isDevice) {\n      this.inputElement.setAttribute('readonly', '');\n    }\n    if (e.currentTarget === this.timeIcon) {\n      e.preventDefault();\n    }\n    if (this.enabled && !this.readonly) {\n      if (this.isDatePopupOpen()) {\n        super.hide(e);\n      }\n      if (this.isTimePopupOpen()) {\n        this.closePopup(e);\n      } else {\n        this.inputElement.focus();\n        this.popupCreation('time', e);\n        addClass([this.inputWrapper.container], [INPUTFOCUS$2]);\n      }\n    }\n    this.isIconClicked = false;\n  }\n  dateHandler(e) {\n    if (!this.enabled) {\n      return;\n    }\n    if (e.currentTarget === this.inputWrapper.buttons[0]) {\n      e.preventDefault();\n    }\n    if (this.enabled && !this.readonly) {\n      if (this.isTimePopupOpen()) {\n        this.closePopup(e);\n      }\n      if (!isNullOrUndefined(this.popupWrapper)) {\n        this.popupCreation('date', e);\n      }\n    }\n  }\n  show(type, e) {\n    if (this.enabled && this.readonly || !this.enabled) {\n      return;\n    } else {\n      if (type === 'time' && !this.dateTimeWrapper) {\n        if (this.isDatePopupOpen()) {\n          this.hide(e);\n        }\n        this.popupCreation('time', e);\n      } else if (!this.popupObj) {\n        if (this.isTimePopupOpen()) {\n          this.hide(e);\n        }\n        super.show();\n        this.popupCreation('date', e);\n      }\n    }\n  }\n  toggle(e) {\n    if (this.isDatePopupOpen()) {\n      super.hide(e);\n      this.show('time', null);\n    } else if (this.isTimePopupOpen()) {\n      this.hide(e);\n      super.show(null, e);\n      this.popupCreation('date', null);\n    } else {\n      this.show(null, e);\n    }\n  }\n  listCreation() {\n    let dateObject;\n    if (this.calendarMode === 'Gregorian') {\n      dateObject = this.globalize.parseDate(this.inputElement.value, {\n        format: this.cldrDateTimeFormat(),\n        type: 'datetime'\n      });\n    } else {\n      dateObject = this.globalize.parseDate(this.inputElement.value, {\n        format: this.cldrDateTimeFormat(),\n        type: 'datetime',\n        calendar: 'islamic'\n      });\n    }\n    const value = isNullOrUndefined(this.value) ? this.inputElement.value !== '' ? dateObject : new Date() : this.value;\n    this.valueWithMinutes = value;\n    this.listWrapper = createElement('div', {\n      className: CONTENT$3,\n      attrs: {\n        'tabindex': '0'\n      }\n    });\n    const min = this.startTime(value);\n    const max = this.endTime(value);\n    const listDetails = TimePickerBase.createListItems(this.createElement, min, max, this.globalize, this.cldrTimeFormat(), this.step);\n    this.timeCollections = listDetails.collection;\n    this.listTag = listDetails.list;\n    attributes(this.listTag, {\n      'role': 'listbox',\n      'aria-hidden': 'false',\n      'id': this.element.id + '_options'\n    });\n    append([listDetails.list], this.listWrapper);\n    this.wireTimeListEvents();\n    const rippleModel = {\n      duration: 300,\n      selector: '.' + LISTCLASS$2\n    };\n    this.rippleFn = rippleEffect(this.listWrapper, rippleModel);\n    this.liCollections = this.listWrapper.querySelectorAll('.' + LISTCLASS$2);\n  }\n  popupCreation(type, e) {\n    if (Browser.isDevice) {\n      this.element.setAttribute('readonly', 'readonly');\n    }\n    if (type === 'date') {\n      if (!this.readonly && this.popupWrapper) {\n        addClass([this.popupWrapper], DATETIMEPOPUPWRAPPER);\n        attributes(this.popupWrapper, {\n          'id': this.element.id + '_datepopup'\n        });\n      }\n    } else {\n      if (!this.readonly) {\n        this.dateTimeWrapper = createElement('div', {\n          className: ROOT$4 + ' ' + POPUP$3,\n          attrs: {\n            'id': this.element.id + '_timepopup',\n            'style': 'visibility:hidden ; display:block'\n          }\n        });\n        if (!isNullOrUndefined(this.cssClass)) {\n          this.dateTimeWrapper.className += ' ' + this.cssClass;\n        }\n        if (!isNullOrUndefined(this.step) && this.step > 0) {\n          this.listCreation();\n          append([this.listWrapper], this.dateTimeWrapper);\n        }\n        document.body.appendChild(this.dateTimeWrapper);\n        this.addTimeSelection();\n        this.renderPopup();\n        this.setTimeScrollPosition();\n        this.openPopup(e);\n        this.popupObject.refreshPosition(this.inputElement);\n      }\n    }\n  }\n  openPopup(e) {\n    this.preventArgs = {\n      cancel: false,\n      popup: this.popupObject,\n      event: e || null\n    };\n    const eventArgs = this.preventArgs;\n    this.trigger('open', eventArgs, eventArgs => {\n      this.preventArgs = eventArgs;\n      if (!this.preventArgs.cancel && !this.readonly) {\n        const openAnimation = {\n          name: 'FadeIn',\n          duration: ANIMATIONDURATION$1\n        };\n        if (this.zIndex === 1000) {\n          this.popupObject.show(new Animation(openAnimation), this.element);\n        } else {\n          this.popupObject.show(new Animation(openAnimation), null);\n        }\n        addClass([this.inputWrapper.container], [ICONANIMATION$1]);\n        attributes(this.inputElement, {\n          'aria-expanded': 'true'\n        });\n        EventHandler.add(document, 'mousedown touchstart', this.documentClickHandler, this);\n      }\n    });\n  }\n  documentClickHandler(event) {\n    const target = event.target;\n    if (!isNullOrUndefined(this.popupObject) && (this.inputWrapper.container.contains(target) || this.popupObject.element && this.popupObject.element.contains(target)) && event.type !== 'touchstart') {\n      event.preventDefault();\n    }\n    if (!closest(target, '[id=\"' + (this.popupObject && this.popupObject.element.id + '\"]')) && target !== this.inputElement && target !== this.timeIcon && target !== this.inputWrapper.container) {\n      if (this.isTimePopupOpen()) {\n        this.hide(event);\n        this.focusOut();\n      }\n    } else if (target !== this.inputElement) {\n      if (!Browser.isDevice) {\n        this.isPreventBlur = document.activeElement === this.inputElement && (Browser.isIE || Browser.info.name === 'edge') && target === this.popupObject.element;\n      }\n    }\n  }\n  isTimePopupOpen() {\n    return this.dateTimeWrapper && this.dateTimeWrapper.classList.contains('' + ROOT$4) ? true : false;\n  }\n  isDatePopupOpen() {\n    return this.popupWrapper && this.popupWrapper.classList.contains('' + DATETIMEPOPUPWRAPPER) ? true : false;\n  }\n  renderPopup() {\n    this.containerStyle = this.inputWrapper.container.getBoundingClientRect();\n    if (Browser.isDevice) {\n      this.timeModal = createElement('div');\n      this.timeModal.className = '' + ROOT$4 + ' e-time-modal';\n      document.body.className += ' ' + OVERFLOW$3;\n      this.timeModal.style.display = 'block';\n      document.body.appendChild(this.timeModal);\n    }\n    const offset = 4;\n    this.popupObject = new Popup(this.dateTimeWrapper, {\n      width: this.setPopupWidth(),\n      zIndex: this.zIndex,\n      targetType: 'container',\n      collision: Browser.isDevice ? {\n        X: 'fit',\n        Y: 'fit'\n      } : {\n        X: 'flip',\n        Y: 'flip'\n      },\n      relateTo: Browser.isDevice ? document.body : this.inputWrapper.container,\n      position: Browser.isDevice ? {\n        X: 'center',\n        Y: 'center'\n      } : {\n        X: 'left',\n        Y: 'bottom'\n      },\n      enableRtl: this.enableRtl,\n      offsetY: offset,\n      open: () => {\n        this.dateTimeWrapper.style.visibility = 'visible';\n        addClass([this.timeIcon], ACTIVE$2);\n        if (!Browser.isDevice) {\n          this.timekeyConfigure = extend(this.timekeyConfigure, this.keyConfigs);\n          this.inputEvent = new KeyboardEvents(this.inputWrapper.container, {\n            keyAction: this.timeKeyActionHandle.bind(this),\n            keyConfigs: this.timekeyConfigure,\n            eventName: 'keydown'\n          });\n        }\n      },\n      close: () => {\n        removeClass([this.timeIcon], ACTIVE$2);\n        this.unWireTimeListEvents();\n        this.inputElement.setAttribute('aria-activedescendant', 'null');\n        remove(this.popupObject.element);\n        this.popupObject.destroy();\n        this.dateTimeWrapper.innerHTML = '';\n        this.listWrapper = this.dateTimeWrapper = undefined;\n        if (this.inputEvent) {\n          this.inputEvent.destroy();\n        }\n      },\n      targetExitViewport: () => {\n        if (!Browser.isDevice) {\n          this.hide();\n        }\n      }\n    });\n    this.popupObject.element.style.maxHeight = POPUPDIMENSION$1;\n  }\n  setDimension(width) {\n    if (typeof width === 'number') {\n      width = formatUnit(width);\n    } else if (typeof width === 'string') {\n      // eslint-disable-next-line no-self-assign\n      width = width;\n    } else {\n      width = '100%';\n    }\n    return width;\n  }\n  setPopupWidth() {\n    let width = this.setDimension(this.width);\n    if (width.indexOf('%') > -1) {\n      const inputWidth = this.containerStyle.width * parseFloat(width) / 100;\n      width = inputWidth.toString() + 'px';\n    }\n    return width;\n  }\n  wireTimeListEvents() {\n    EventHandler.add(this.listWrapper, 'click', this.onMouseClick, this);\n    if (!Browser.isDevice) {\n      EventHandler.add(this.listWrapper, 'mouseover', this.onMouseOver, this);\n      EventHandler.add(this.listWrapper, 'mouseout', this.onMouseLeave, this);\n    }\n  }\n  unWireTimeListEvents() {\n    if (this.listWrapper) {\n      EventHandler.remove(this.listWrapper, 'click', this.onMouseClick);\n      EventHandler.remove(document, 'mousedown touchstart', this.documentClickHandler);\n      if (!Browser.isDevice) {\n        EventHandler.add(this.listWrapper, 'mouseover', this.onMouseOver, this);\n        EventHandler.add(this.listWrapper, 'mouseout', this.onMouseLeave, this);\n      }\n    }\n  }\n  onMouseOver(event) {\n    const currentLi = closest(event.target, '.' + LISTCLASS$2);\n    this.setTimeHover(currentLi, HOVER$2);\n  }\n  onMouseLeave() {\n    this.removeTimeHover(HOVER$2);\n  }\n  setTimeHover(li, className) {\n    if (this.enabled && this.isValidLI(li) && !li.classList.contains(className)) {\n      this.removeTimeHover(className);\n      addClass([li], className);\n    }\n  }\n  getPopupHeight() {\n    const height = parseInt(POPUPDIMENSION$1, 10);\n    const popupHeight = this.dateTimeWrapper.getBoundingClientRect().height;\n    return popupHeight > height ? height : popupHeight;\n  }\n  changeEvent(e) {\n    if ((this.value && this.value.valueOf()) !== (this.previousDateTime && +this.previousDateTime.valueOf())) {\n      super.changeEvent(e);\n      this.valueWithMinutes = this.value;\n      this.setInputValue('date');\n      this.previousDateTime = this.value && new Date(+this.value);\n    }\n  }\n  updateValue(e) {\n    this.setInputValue('time');\n    if (+this.previousDateTime !== +this.value) {\n      this.changedArgs = {\n        value: this.value,\n        event: e || null,\n        isInteracted: !isNullOrUndefined(e),\n        element: this.element\n      };\n      this.addTimeSelection();\n      this.trigger('change', this.changedArgs);\n      this.previousDateTime = this.previousDate = this.value;\n    }\n  }\n  setTimeScrollPosition() {\n    const popupElement = this.selectedElement;\n    if (!isNullOrUndefined(popupElement)) {\n      this.findScrollTop(popupElement);\n    } else if (this.dateTimeWrapper && this.checkDateValue(this.scrollTo)) {\n      this.setScrollTo();\n    }\n  }\n  findScrollTop(element) {\n    const listHeight = this.getPopupHeight();\n    const nextElement = element.nextElementSibling;\n    const height = nextElement ? nextElement.offsetTop : element.offsetTop;\n    const lineHeight = element.getBoundingClientRect().height;\n    if (height + element.offsetTop > listHeight) {\n      this.dateTimeWrapper.scrollTop = nextElement ? height - (listHeight / HALFPOSITION$1 + lineHeight / HALFPOSITION$1) : height;\n    } else {\n      this.dateTimeWrapper.scrollTop = 0;\n    }\n  }\n  setScrollTo() {\n    let element;\n    const items = this.dateTimeWrapper.querySelectorAll('.' + LISTCLASS$2);\n    if (items.length >= 0) {\n      this.scrollInvoked = true;\n      const initialTime = this.timeCollections[0];\n      const scrollTime = this.getDateObject(this.checkDateValue(this.scrollTo)).getTime();\n      element = items[Math.round((scrollTime - initialTime) / (this.step * 60000))];\n    } else {\n      this.dateTimeWrapper.scrollTop = 0;\n    }\n    if (!isNullOrUndefined(element)) {\n      this.findScrollTop(element);\n    } else {\n      this.dateTimeWrapper.scrollTop = 0;\n    }\n  }\n  setInputValue(type) {\n    if (type === 'date') {\n      this.inputElement.value = this.previousElementValue = this.getFormattedValue(this.getFullDateTime());\n      this.setProperties({\n        value: this.getFullDateTime()\n      }, true);\n    } else {\n      const tempVal = this.getFormattedValue(new Date(this.timeCollections[this.activeIndex]));\n      Input.setValue(tempVal, this.inputElement, this.floatLabelType, this.showClearButton);\n      this.previousElementValue = this.inputElement.value;\n      this.setProperties({\n        value: new Date(this.timeCollections[this.activeIndex])\n      }, true);\n      if (this.enableMask) {\n        this.createMask();\n      }\n    }\n    this.updateIconState();\n  }\n  getFullDateTime() {\n    let value = null;\n    if (this.isDateObject(this.valueWithMinutes)) {\n      value = this.combineDateTime(this.valueWithMinutes);\n    } else {\n      value = this.previousDate;\n    }\n    return this.validateMinMaxRange(value);\n  }\n  createMask() {\n    this.notify(\"createMask\", {\n      module: \"MaskedDateTime\"\n    });\n  }\n  combineDateTime(value) {\n    if (this.isDateObject(value)) {\n      const day = this.previousDate.getDate();\n      const month = this.previousDate.getMonth();\n      const year = this.previousDate.getFullYear();\n      const hour = value.getHours();\n      const minutes = value.getMinutes();\n      const seconds = value.getSeconds();\n      return new Date(year, month, day, hour, minutes, seconds);\n    } else {\n      return this.previousDate;\n    }\n  }\n  onMouseClick(event) {\n    const target = event.target;\n    const li = this.selectedElement = closest(target, '.' + LISTCLASS$2);\n    if (li && li.classList.contains(LISTCLASS$2)) {\n      this.timeValue = li.getAttribute('data-value');\n      this.hide(event);\n    }\n    this.setSelection(li, event);\n  }\n  setSelection(li, event) {\n    if (this.isValidLI(li) && !li.classList.contains(ACTIVE$2)) {\n      this.selectedElement = li;\n      const index = Array.prototype.slice.call(this.liCollections).indexOf(li);\n      this.activeIndex = index;\n      this.valueWithMinutes = new Date(this.timeCollections[this.activeIndex]);\n      addClass([this.selectedElement], ACTIVE$2);\n      this.selectedElement.setAttribute('aria-selected', 'true');\n      this.updateValue(event);\n    }\n  }\n  setTimeActiveClass() {\n    const collections = isNullOrUndefined(this.dateTimeWrapper) ? this.listWrapper : this.dateTimeWrapper;\n    if (!isNullOrUndefined(collections)) {\n      const items = collections.querySelectorAll('.' + LISTCLASS$2);\n      if (items.length) {\n        for (let i = 0; i < items.length; i++) {\n          if (this.timeCollections[i] === +this.valueWithMinutes) {\n            items[i].setAttribute('aria-selected', 'true');\n            this.selectedElement = items[i];\n            this.activeIndex = i;\n            this.setTimeActiveDescendant();\n            break;\n          }\n        }\n      }\n    }\n  }\n  setTimeActiveDescendant() {\n    if (!isNullOrUndefined(this.selectedElement)) {\n      attributes(this.inputElement, {\n        'aria-activedescendant': this.selectedElement.getAttribute('id')\n      });\n    } else {\n      attributes(this.inputElement, {\n        'aria-activedescendant': 'null'\n      });\n    }\n  }\n  addTimeSelection() {\n    this.selectedElement = null;\n    this.removeTimeSelection();\n    this.setTimeActiveClass();\n    if (!isNullOrUndefined(this.selectedElement)) {\n      addClass([this.selectedElement], ACTIVE$2);\n      this.selectedElement.setAttribute('aria-selected', 'true');\n    }\n  }\n  removeTimeSelection() {\n    this.removeTimeHover(HOVER$2);\n    if (!isNullOrUndefined(this.dateTimeWrapper)) {\n      const items = this.dateTimeWrapper.querySelectorAll('.' + ACTIVE$2);\n      if (items.length) {\n        removeClass(items, ACTIVE$2);\n        items[0].removeAttribute('aria-selected');\n      }\n    }\n  }\n  removeTimeHover(className) {\n    const hoveredItem = this.getTimeHoverItem(className);\n    if (hoveredItem && hoveredItem.length) {\n      removeClass(hoveredItem, className);\n    }\n  }\n  getTimeHoverItem(className) {\n    const collections = isNullOrUndefined(this.dateTimeWrapper) ? this.listWrapper : this.dateTimeWrapper;\n    let hoveredItem;\n    if (!isNullOrUndefined(collections)) {\n      hoveredItem = collections.querySelectorAll('.' + className);\n    }\n    return hoveredItem;\n  }\n  isValidLI(li) {\n    return li && li.classList.contains(LISTCLASS$2) && !li.classList.contains(DISABLED$4);\n  }\n  calculateStartEnd(value, range, method) {\n    const day = value.getDate();\n    const month = value.getMonth();\n    const year = value.getFullYear();\n    const hours = value.getHours();\n    const minutes = value.getMinutes();\n    const seconds = value.getSeconds();\n    const milliseconds = value.getMilliseconds();\n    if (range) {\n      if (method === 'starttime') {\n        return new Date(year, month, day, 0, 0, 0);\n      } else {\n        return new Date(year, month, day, 23, 59, 59);\n      }\n    } else {\n      return new Date(year, month, day, hours, minutes, seconds, milliseconds);\n    }\n  }\n  startTime(date) {\n    let tempStartValue;\n    let start;\n    const tempMin = this.min;\n    const value = date === null ? new Date() : date;\n    if (+value.getDate() === +tempMin.getDate() && +value.getMonth() === +tempMin.getMonth() && +value.getFullYear() === +tempMin.getFullYear() || +new Date(value.getFullYear(), value.getMonth(), value.getDate()) <= +new Date(tempMin.getFullYear(), tempMin.getMonth(), tempMin.getDate())) {\n      start = false;\n      tempStartValue = this.min;\n    } else if (+value < +this.max && +value > +this.min) {\n      start = true;\n      tempStartValue = value;\n    } else if (+value >= +this.max) {\n      start = true;\n      tempStartValue = this.max;\n    }\n    return this.calculateStartEnd(tempStartValue, start, 'starttime');\n  }\n  endTime(date) {\n    let tempEndValue;\n    let end;\n    const tempMax = this.max;\n    const value = date === null ? new Date() : date;\n    if (+value.getDate() === +tempMax.getDate() && +value.getMonth() === +tempMax.getMonth() && +value.getFullYear() === +tempMax.getFullYear() || +new Date(value.getUTCFullYear(), value.getMonth(), value.getDate()) >= +new Date(tempMax.getFullYear(), tempMax.getMonth(), tempMax.getDate())) {\n      end = false;\n      tempEndValue = this.max;\n    } else if (+value < +this.max && +value > +this.min) {\n      end = true;\n      tempEndValue = value;\n    } else if (+value <= +this.min) {\n      end = true;\n      tempEndValue = this.min;\n    }\n    return this.calculateStartEnd(tempEndValue, end, 'endtime');\n  }\n  hide(e) {\n    if (this.popupObj || this.dateTimeWrapper) {\n      this.preventArgs = {\n        cancel: false,\n        popup: this.popupObj || this.popupObject,\n        event: e || null\n      };\n      const eventArgs = this.preventArgs;\n      if (isNullOrUndefined(this.popupObj)) {\n        this.trigger('close', eventArgs, eventArgs => {\n          this.dateTimeCloseEventCallback(e, eventArgs);\n        });\n      } else {\n        this.dateTimeCloseEventCallback(e, eventArgs);\n      }\n    } else {\n      if (Browser.isDevice && this.allowEdit && !this.readonly) {\n        this.inputElement.removeAttribute('readonly');\n      }\n      this.setAllowEdit();\n    }\n  }\n  dateTimeCloseEventCallback(e, eventArgs) {\n    this.preventArgs = eventArgs;\n    if (!this.preventArgs.cancel) {\n      if (this.isDatePopupOpen()) {\n        super.hide(e);\n      } else if (this.isTimePopupOpen()) {\n        this.closePopup(e);\n        removeClass([document.body], OVERFLOW$3);\n        if (Browser.isDevice && this.timeModal) {\n          this.timeModal.style.display = 'none';\n          this.timeModal.outerHTML = '';\n          this.timeModal = null;\n        }\n        this.setTimeActiveDescendant();\n      }\n    }\n    if (Browser.isDevice && this.allowEdit && !this.readonly) {\n      this.inputElement.removeAttribute('readonly');\n    }\n    this.setAllowEdit();\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  closePopup(e) {\n    if (this.isTimePopupOpen() && this.popupObject) {\n      const animModel = {\n        name: 'FadeOut',\n        duration: ANIMATIONDURATION$1,\n        delay: 0\n      };\n      this.popupObject.hide(new Animation(animModel));\n      this.inputWrapper.container.classList.remove(ICONANIMATION$1);\n      attributes(this.inputElement, {\n        'aria-expanded': 'false'\n      });\n      EventHandler.remove(document, 'mousedown touchstart', this.documentClickHandler);\n    }\n  }\n  preRender() {\n    this.checkFormat();\n    this.dateTimeFormat = this.cldrDateTimeFormat();\n    super.preRender();\n    removeClass([this.inputElementCopy], [ROOT$4]);\n  }\n  getProperty(date, val) {\n    if (val === 'min') {\n      this.setProperties({\n        min: this.validateValue(date.min)\n      }, true);\n    } else {\n      this.setProperties({\n        max: this.validateValue(date.max)\n      }, true);\n    }\n  }\n  checkAttributes(isDynamic) {\n    const attributes$$1 = isDynamic ? isNullOrUndefined(this.htmlAttributes) ? [] : Object.keys(this.htmlAttributes) : ['style', 'name', 'step', 'disabled', 'readonly', 'value', 'min', 'max', 'placeholder', 'type'];\n    let value;\n    for (const prop of attributes$$1) {\n      if (!isNullOrUndefined(this.inputElement.getAttribute(prop))) {\n        switch (prop) {\n          case 'name':\n            this.inputElement.setAttribute('name', this.inputElement.getAttribute(prop));\n            break;\n          case 'step':\n            this.step = parseInt(this.inputElement.getAttribute(prop), 10);\n            break;\n          case 'readonly':\n            if (isNullOrUndefined(this.dateTimeOptions) || this.dateTimeOptions['readonly'] === undefined || isDynamic) {\n              const readonly = this.inputElement.getAttribute(prop) === 'disabled' || this.inputElement.getAttribute(prop) === '' || this.inputElement.getAttribute(prop) === 'true' ? true : false;\n              this.setProperties({\n                readonly: readonly\n              }, !isDynamic);\n            }\n            break;\n          case 'placeholder':\n            if (isNullOrUndefined(this.dateTimeOptions) || this.dateTimeOptions['placeholder'] === undefined || isDynamic) {\n              this.setProperties({\n                placeholder: this.inputElement.getAttribute(prop)\n              }, !isDynamic);\n            }\n            break;\n          case 'min':\n            if (isNullOrUndefined(this.dateTimeOptions) || this.dateTimeOptions['min'] === undefined || isDynamic) {\n              value = new Date(this.inputElement.getAttribute(prop));\n              if (!this.isNullOrEmpty(value) && !isNaN(+value)) {\n                this.setProperties({\n                  min: value\n                }, !isDynamic);\n              }\n            }\n            break;\n          case 'disabled':\n            if (isNullOrUndefined(this.dateTimeOptions) || this.dateTimeOptions['enabled'] === undefined || isDynamic) {\n              const enabled = this.inputElement.getAttribute(prop) === 'disabled' || this.inputElement.getAttribute(prop) === 'true' || this.inputElement.getAttribute(prop) === '' ? false : true;\n              this.setProperties({\n                enabled: enabled\n              }, !isDynamic);\n            }\n            break;\n          case 'value':\n            if (isNullOrUndefined(this.dateTimeOptions) || this.dateTimeOptions['value'] === undefined || isDynamic) {\n              value = new Date(this.inputElement.getAttribute(prop));\n              if (!this.isNullOrEmpty(value) && !isNaN(+value)) {\n                this.setProperties({\n                  value: value\n                }, !isDynamic);\n              }\n            }\n            break;\n          case 'max':\n            if (isNullOrUndefined(this.dateTimeOptions) || this.dateTimeOptions['max'] === undefined || isDynamic) {\n              value = new Date(this.inputElement.getAttribute(prop));\n              if (!this.isNullOrEmpty(value) && !isNaN(+value)) {\n                this.setProperties({\n                  max: value\n                }, !isDynamic);\n              }\n            }\n            break;\n        }\n      }\n    }\n  }\n  requiredModules() {\n    const modules = [];\n    if (this) {\n      modules.push({\n        args: [this],\n        member: 'islamic'\n      });\n    }\n    if (this.enableMask) {\n      modules.push(this.maskedDateModule());\n    }\n    return modules;\n  }\n  maskedDateModule() {\n    let modules = {\n      args: [this],\n      member: 'MaskedDateTime'\n    };\n    return modules;\n  }\n  getTimeActiveElement() {\n    if (!isNullOrUndefined(this.dateTimeWrapper)) {\n      return this.dateTimeWrapper.querySelectorAll('.' + ACTIVE$2);\n    } else {\n      return null;\n    }\n  }\n  createDateObj(val) {\n    return val instanceof Date ? val : null;\n  }\n  getDateObject(text) {\n    if (!this.isNullOrEmpty(text)) {\n      const dateValue = this.createDateObj(text);\n      const value = this.valueWithMinutes;\n      const status = !isNullOrUndefined(value);\n      if (this.checkDateValue(dateValue)) {\n        const date = status ? value.getDate() : DAY$1;\n        const month = status ? value.getMonth() : MONTH$3;\n        const year = status ? value.getFullYear() : YEAR$3;\n        const hour = status ? value.getHours() : HOUR;\n        const minute = status ? value.getMinutes() : MINUTE;\n        const second = status ? value.getSeconds() : SECOND;\n        const millisecond = status ? value.getMilliseconds() : MILLISECOND;\n        if (!this.scrollInvoked) {\n          return new Date(year, month, date, hour, minute, second, millisecond);\n        } else {\n          this.scrollInvoked = false;\n          return new Date(year, month, date, dateValue.getHours(), dateValue.getMinutes(), dateValue.getSeconds(), dateValue.getMilliseconds());\n        }\n      }\n    }\n    return null;\n  }\n  findNextTimeElement(event) {\n    const textVal = this.inputElement.value;\n    const value = isNullOrUndefined(this.valueWithMinutes) ? this.createDateObj(textVal) : this.getDateObject(this.valueWithMinutes);\n    let dateTimeVal = null;\n    const listCount = this.liCollections.length;\n    if (!isNullOrUndefined(this.activeIndex) || !isNullOrUndefined(this.checkDateValue(value))) {\n      if (event.action === 'home') {\n        dateTimeVal = +this.createDateObj(new Date(this.timeCollections[0]));\n        this.activeIndex = 0;\n      } else if (event.action === 'end') {\n        dateTimeVal = +this.createDateObj(new Date(this.timeCollections[this.timeCollections.length - 1]));\n        this.activeIndex = this.timeCollections.length - 1;\n      } else {\n        if (event.action === 'down') {\n          for (let i = 0; i < listCount; i++) {\n            if (+value < this.timeCollections[i]) {\n              dateTimeVal = +this.createDateObj(new Date(this.timeCollections[i]));\n              this.activeIndex = i;\n              break;\n            }\n          }\n        } else {\n          for (let i = listCount - 1; i >= 0; i--) {\n            if (+value > this.timeCollections[i]) {\n              dateTimeVal = +this.createDateObj(new Date(this.timeCollections[i]));\n              this.activeIndex = i;\n              break;\n            }\n          }\n        }\n      }\n      this.selectedElement = this.liCollections[this.activeIndex];\n      this.timeElementValue(isNullOrUndefined(dateTimeVal) ? null : new Date(dateTimeVal));\n    }\n  }\n  setTimeValue(date, value) {\n    let dateString;\n    let time;\n    const val = this.validateMinMaxRange(value);\n    const newval = this.createDateObj(val);\n    if (this.getFormattedValue(newval) !== (!isNullOrUndefined(this.value) ? this.getFormattedValue(this.value) : null)) {\n      this.valueWithMinutes = isNullOrUndefined(newval) ? null : newval;\n      time = new Date(+this.valueWithMinutes);\n    } else {\n      if (this.strictMode) {\n        //for strict mode case, when value not present within a range. Reset the nearest range value.\n        date = newval;\n      }\n      this.valueWithMinutes = this.checkDateValue(date);\n      time = new Date(+this.valueWithMinutes);\n    }\n    if (this.calendarMode === 'Gregorian') {\n      dateString = this.globalize.formatDate(time, {\n        format: !isNullOrUndefined(this.formatString) ? this.formatString : this.cldrDateTimeFormat(),\n        type: 'dateTime',\n        skeleton: 'yMd'\n      });\n    } else {\n      dateString = this.globalize.formatDate(time, {\n        format: !isNullOrUndefined(this.formatString) ? this.formatString : this.cldrDateTimeFormat(),\n        type: 'dateTime',\n        skeleton: 'yMd',\n        calendar: 'islamic'\n      });\n    }\n    if (!this.strictMode && isNullOrUndefined(time)) {\n      Input.setValue(dateString, this.inputElement, this.floatLabelType, this.showClearButton);\n    } else {\n      Input.setValue(dateString, this.inputElement, this.floatLabelType, this.showClearButton);\n    }\n    return time;\n  }\n  timeElementValue(value) {\n    if (!isNullOrUndefined(this.checkDateValue(value)) && !this.isNullOrEmpty(value)) {\n      const date = value instanceof Date ? value : this.getDateObject(value);\n      return this.setTimeValue(date, value);\n    }\n    return null;\n  }\n  timeKeyHandler(event) {\n    if (isNullOrUndefined(this.step) || this.step <= 0) {\n      return;\n    }\n    const listCount = this.timeCollections.length;\n    if (isNullOrUndefined(this.getTimeActiveElement()) || this.getTimeActiveElement().length === 0) {\n      if (this.liCollections.length > 0) {\n        if (isNullOrUndefined(this.value) && isNullOrUndefined(this.activeIndex)) {\n          this.activeIndex = 0;\n          this.selectedElement = this.liCollections[0];\n          this.timeElementValue(new Date(this.timeCollections[0]));\n        } else {\n          this.findNextTimeElement(event);\n        }\n      }\n    } else {\n      let nextItemValue;\n      if (event.keyCode >= 37 && event.keyCode <= 40) {\n        let index = event.keyCode === 40 || event.keyCode === 39 ? ++this.activeIndex : --this.activeIndex;\n        this.activeIndex = index = this.activeIndex === listCount ? 0 : this.activeIndex;\n        this.activeIndex = index = this.activeIndex < 0 ? listCount - 1 : this.activeIndex;\n        nextItemValue = isNullOrUndefined(this.timeCollections[index]) ? this.timeCollections[0] : this.timeCollections[index];\n      } else if (event.action === 'home') {\n        this.activeIndex = 0;\n        nextItemValue = this.timeCollections[0];\n      } else if (event.action === 'end') {\n        this.activeIndex = listCount - 1;\n        nextItemValue = this.timeCollections[listCount - 1];\n      }\n      this.selectedElement = this.liCollections[this.activeIndex];\n      this.timeElementValue(new Date(nextItemValue));\n    }\n    this.isNavigate = true;\n    this.setTimeHover(this.selectedElement, NAVIGATION$1);\n    this.setTimeActiveDescendant();\n    if (this.isTimePopupOpen() && this.selectedElement !== null && (!event || event.type !== 'click')) {\n      this.setTimeScrollPosition();\n    }\n  }\n  timeKeyActionHandle(event) {\n    if (this.enabled) {\n      if (event.action !== 'right' && event.action !== 'left' && event.action !== 'tab') {\n        event.preventDefault();\n      }\n      switch (event.action) {\n        case 'up':\n        case 'down':\n        case 'home':\n        case 'end':\n          this.timeKeyHandler(event);\n          break;\n        case 'enter':\n          if (this.isNavigate) {\n            this.selectedElement = this.liCollections[this.activeIndex];\n            this.valueWithMinutes = new Date(this.timeCollections[this.activeIndex]);\n            this.setInputValue('time');\n            if (+this.previousDateTime !== +this.value) {\n              this.changedArgs.value = this.value;\n              this.addTimeSelection();\n              this.previousDateTime = this.value;\n            }\n          } else {\n            this.updateValue(event);\n          }\n          this.hide(event);\n          addClass([this.inputWrapper.container], INPUTFOCUS$2);\n          this.isNavigate = false;\n          event.stopPropagation();\n          break;\n        case 'escape':\n          this.hide(event);\n          break;\n        default:\n          this.isNavigate = false;\n          break;\n      }\n    }\n  }\n  inputKeyAction(event) {\n    switch (event.action) {\n      case 'altDownArrow':\n        this.strictModeUpdate();\n        this.updateInput();\n        this.toggle(event);\n        break;\n    }\n  }\n  /**\n   * Called internally if any of the property value changed.\n   *\n   * @param {DateTimePickerModel} newProp - Returns the dynamic property value of the component.\n   * @param {DateTimePickerModel} oldProp - Returns the previous property value of the component.\n   * @returns {void}\n   * @deprecated\n   */\n  onPropertyChanged(newProp, oldProp) {\n    for (const prop of Object.keys(newProp)) {\n      switch (prop) {\n        case 'value':\n          this.isDynamicValueChanged = true;\n          this.invalidValueString = null;\n          this.checkInvalidValue(newProp.value);\n          newProp.value = this.value;\n          newProp.value = this.validateValue(newProp.value);\n          Input.setValue(this.getFormattedValue(newProp.value), this.inputElement, this.floatLabelType, this.showClearButton);\n          this.valueWithMinutes = newProp.value;\n          this.setProperties({\n            value: newProp.value\n          }, true);\n          if (this.popupObj) {\n            this.popupUpdate();\n          }\n          this.previousDateTime = new Date(this.inputElement.value);\n          this.updateInput();\n          this.changeTrigger(null);\n          this.preventChange = this.isAngular && this.preventChange ? !this.preventChange : this.preventChange;\n          if (this.enableMask && this.value) {\n            this.notify(\"createMask\", {\n              module: \"MaskedDateTime\"\n            });\n          }\n          break;\n        case 'min':\n        case 'max':\n          this.getProperty(newProp, prop);\n          this.updateInput();\n          break;\n        case 'enableRtl':\n          Input.setEnableRtl(this.enableRtl, [this.inputWrapper.container]);\n          break;\n        case 'cssClass':\n          if (!isNullOrUndefined(oldProp.cssClass)) {\n            oldProp.cssClass = oldProp.cssClass.replace(/\\s+/g, ' ').trim();\n          }\n          if (!isNullOrUndefined(newProp.cssClass)) {\n            newProp.cssClass = newProp.cssClass.replace(/\\s+/g, ' ').trim();\n          }\n          Input.setCssClass(newProp.cssClass, [this.inputWrapper.container], oldProp.cssClass);\n          if (this.dateTimeWrapper) {\n            Input.setCssClass(newProp.cssClass, [this.dateTimeWrapper], oldProp.cssClass);\n          }\n          break;\n        case 'locale':\n          this.globalize = new Internationalization(this.locale);\n          this.l10n.setLocale(this.locale);\n          this.setProperties({\n            placeholder: this.l10n.getConstant('placeholder')\n          }, true);\n          Input.setPlaceholder(this.l10n.getConstant('placeholder'), this.inputElement);\n          this.dateTimeFormat = this.cldrDateTimeFormat();\n          super.updateInput();\n          break;\n        case 'htmlAttributes':\n          this.updateHtmlAttributeToElement();\n          this.updateHtmlAttributeToWrapper();\n          this.checkAttributes(true);\n          break;\n        case 'format':\n          this.setProperties({\n            format: newProp.format\n          }, true);\n          this.checkFormat();\n          this.dateTimeFormat = this.formatString;\n          this.setValue();\n          if (this.enableMask) {\n            this.notify(\"createMask\", {\n              module: \"MaskedDateTime\"\n            });\n            if (!this.value) {\n              Input.setValue(this.maskedDateValue, this.inputElement, this.floatLabelType, this.showClearButton);\n            }\n          }\n          break;\n        case 'placeholder':\n          Input.setPlaceholder(newProp.placeholder, this.inputElement);\n          this.inputElement.setAttribute('aria-placeholder', newProp.placeholder);\n          break;\n        case 'enabled':\n          Input.setEnabled(this.enabled, this.inputElement);\n          if (!this.enabled) {\n            this.inputElement.tabIndex = -1;\n          }\n          break;\n        case 'strictMode':\n          this.invalidValueString = null;\n          this.updateInput();\n          break;\n        case 'width':\n          this.setWidth(newProp.width);\n          break;\n        case 'readonly':\n          Input.setReadonly(this.readonly, this.inputElement);\n          break;\n        case 'floatLabelType':\n          this.floatLabelType = newProp.floatLabelType;\n          Input.removeFloating(this.inputWrapper);\n          Input.addFloating(this.inputElement, this.floatLabelType, this.placeholder);\n          break;\n        case 'scrollTo':\n          if (this.checkDateValue(new Date(this.checkValue(newProp.scrollTo)))) {\n            if (this.dateTimeWrapper) {\n              this.setScrollTo();\n            }\n            this.setProperties({\n              scrollTo: this.checkDateValue(new Date(this.checkValue(newProp.scrollTo)))\n            }, true);\n          } else {\n            this.setProperties({\n              scrollTo: null\n            }, true);\n          }\n          break;\n        case 'enableMask':\n          if (this.enableMask) {\n            this.notify(\"createMask\", {\n              module: \"MaskedDateTime\"\n            });\n            Input.setValue(this.maskedDateValue, this.inputElement, this.floatLabelType, this.showClearButton);\n          } else {\n            if (this.inputElement.value === this.maskedDateValue) {\n              this.maskedDateValue = '';\n              Input.setValue(this.maskedDateValue, this.inputElement, this.floatLabelType, this.showClearButton);\n            }\n          }\n          break;\n        default:\n          super.onPropertyChanged(newProp, oldProp);\n          break;\n      }\n      if (!this.isDynamicValueChanged) {\n        this.hide(null);\n      }\n      this.isDynamicValueChanged = false;\n    }\n  }\n  /**\n   * To get component name.\n   *\n   * @returns {string} Returns the component name.\n   * @private\n   */\n  getModuleName() {\n    return 'datetimepicker';\n  }\n  restoreValue() {\n    this.previousDateTime = this.previousDate;\n    this.currentDate = this.value ? this.value : new Date();\n    this.valueWithMinutes = this.value;\n    this.previousDate = this.value;\n    this.previousElementValue = this.previousElementValue = isNullOrUndefined(this.inputValueCopy) ? '' : this.getFormattedValue(this.inputValueCopy);\n  }\n};\n__decorate$4([Property(null)], DateTimePicker.prototype, \"timeFormat\", void 0);\n__decorate$4([Property(30)], DateTimePicker.prototype, \"step\", void 0);\n__decorate$4([Property(null)], DateTimePicker.prototype, \"scrollTo\", void 0);\n__decorate$4([Property(1000)], DateTimePicker.prototype, \"zIndex\", void 0);\n__decorate$4([Property(null)], DateTimePicker.prototype, \"value\", void 0);\n__decorate$4([Property(null)], DateTimePicker.prototype, \"keyConfigs\", void 0);\n__decorate$4([Property({})], DateTimePicker.prototype, \"htmlAttributes\", void 0);\n__decorate$4([Property(false)], DateTimePicker.prototype, \"enablePersistence\", void 0);\n__decorate$4([Property(true)], DateTimePicker.prototype, \"allowEdit\", void 0);\n__decorate$4([Property(false)], DateTimePicker.prototype, \"isMultiSelection\", void 0);\n__decorate$4([Property(null)], DateTimePicker.prototype, \"values\", void 0);\n__decorate$4([Property(true)], DateTimePicker.prototype, \"showClearButton\", void 0);\n__decorate$4([Property(null)], DateTimePicker.prototype, \"placeholder\", void 0);\n__decorate$4([Property(false)], DateTimePicker.prototype, \"strictMode\", void 0);\n__decorate$4([Property(null)], DateTimePicker.prototype, \"serverTimezoneOffset\", void 0);\n__decorate$4([Property(new Date(1900, 0, 1))], DateTimePicker.prototype, \"min\", void 0);\n__decorate$4([Property(new Date(2099, 11, 31))], DateTimePicker.prototype, \"max\", void 0);\n__decorate$4([Property(null)], DateTimePicker.prototype, \"firstDayOfWeek\", void 0);\n__decorate$4([Property('Gregorian')], DateTimePicker.prototype, \"calendarMode\", void 0);\n__decorate$4([Property('Month')], DateTimePicker.prototype, \"start\", void 0);\n__decorate$4([Property('Month')], DateTimePicker.prototype, \"depth\", void 0);\n__decorate$4([Property(false)], DateTimePicker.prototype, \"weekNumber\", void 0);\n__decorate$4([Property(true)], DateTimePicker.prototype, \"showTodayButton\", void 0);\n__decorate$4([Property('Short')], DateTimePicker.prototype, \"dayHeaderFormat\", void 0);\n__decorate$4([Property(false)], DateTimePicker.prototype, \"openOnFocus\", void 0);\n__decorate$4([Property(false)], DateTimePicker.prototype, \"enableMask\", void 0);\n__decorate$4([Property({\n  day: 'day',\n  month: 'month',\n  year: 'year',\n  hour: 'hour',\n  minute: 'minute',\n  second: 'second',\n  dayOfTheWeek: 'day of the week'\n})], DateTimePicker.prototype, \"maskPlaceholder\", void 0);\n__decorate$4([Event()], DateTimePicker.prototype, \"open\", void 0);\n__decorate$4([Event()], DateTimePicker.prototype, \"close\", void 0);\n__decorate$4([Event()], DateTimePicker.prototype, \"cleared\", void 0);\n__decorate$4([Event()], DateTimePicker.prototype, \"blur\", void 0);\n__decorate$4([Event()], DateTimePicker.prototype, \"focus\", void 0);\n__decorate$4([Event()], DateTimePicker.prototype, \"created\", void 0);\n__decorate$4([Event()], DateTimePicker.prototype, \"destroyed\", void 0);\nDateTimePicker = __decorate$4([NotifyPropertyChanges], DateTimePicker);\n\n/**\n * DateTimePicker modules\n */\n\nconst ARROWLEFT = 'ArrowLeft';\nconst ARROWRIGHT = 'ArrowRight';\nconst ARROWUP = 'ArrowUp';\nconst ARROWDOWN = 'ArrowDown';\nconst TAB = 'Tab';\nconst SHIFTTAB = 'shiftTab';\nconst END = 'End';\nconst HOME = 'Home';\nclass MaskedDateTime {\n  constructor(parent) {\n    this.mask = '';\n    this.defaultConstant = {\n      day: 'day',\n      month: 'month',\n      year: 'year',\n      hour: 'hour',\n      minute: 'minute',\n      second: 'second',\n      dayOfTheWeek: 'day of the week'\n    };\n    this.hiddenMask = '';\n    this.validCharacters = 'dMyhmHfasz';\n    this.isDayPart = false;\n    this.isMonthPart = false;\n    this.isYearPart = false;\n    this.isHourPart = false;\n    this.isMinutePart = false;\n    this.isSecondsPart = false;\n    this.isMilliSecondsPart = false;\n    this.monthCharacter = '';\n    this.periodCharacter = '';\n    this.isHiddenMask = false;\n    this.isComplete = false;\n    this.isNavigate = false;\n    this.formatRegex = /EEEEE|EEEE|EEE|EE|E|dddd|ddd|dd|d|MMMM|MMM|MM|M|yyyy|yy|y|HH|H|hh|h|mm|m|fff|ff|f|aa|a|ss|s|zzzz|zzz|zz|z|'[^']*'|'[^']*'/g;\n    this.isDeletion = false;\n    this.isShortYear = false;\n    this.isDeleteKey = false;\n    this.isDateZero = false;\n    this.isMonthZero = false;\n    this.isYearZero = false;\n    this.dayTypeCount = 0;\n    this.monthTypeCount = 0;\n    this.hourTypeCount = 0;\n    this.minuteTypeCount = 0;\n    this.secondTypeCount = 0;\n    this.parent = parent;\n    this.dateformat = this.getCulturedFormat();\n    this.maskDateValue = this.parent.value != null ? new Date(+this.parent.value) : new Date();\n    this.maskDateValue.setMonth(0);\n    this.maskDateValue.setHours(0);\n    this.maskDateValue.setMinutes(0);\n    this.maskDateValue.setSeconds(0);\n    this.previousDate = new Date(this.maskDateValue.getFullYear(), this.maskDateValue.getMonth(), this.maskDateValue.getDate(), this.maskDateValue.getHours(), this.maskDateValue.getMinutes(), this.maskDateValue.getSeconds());\n    this.removeEventListener();\n    this.addEventListener();\n  }\n  getModuleName() {\n    return 'MaskedDateTime';\n  }\n  addEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n    this.parent.on('createMask', this.createMask, this);\n    this.parent.on('setMaskSelection', this.validCharacterCheck, this);\n    this.parent.on('inputHandler', this.maskInputHandler, this);\n    this.parent.on('keyDownHandler', this.maskKeydownHandler, this);\n    this.parent.on('clearHandler', this.clearHandler, this);\n  }\n  removeEventListener() {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n    this.parent.off('createMask', this.createMask);\n    this.parent.off('setMaskSelection', this.validCharacterCheck);\n    this.parent.off('inputHandler', this.maskInputHandler);\n    this.parent.off('keyDownHandler', this.maskKeydownHandler);\n    this.parent.off('clearHandler', this.clearHandler);\n  }\n  createMask(dateformat) {\n    this.isDayPart = this.isMonthPart = this.isYearPart = this.isHourPart = this.isMinutePart = this.isSecondsPart = false;\n    this.dateformat = this.getCulturedFormat();\n    if (this.parent.maskPlaceholder.day) this.defaultConstant['day'] = this.parent.maskPlaceholder.day;\n    if (this.parent.maskPlaceholder.month) this.defaultConstant['month'] = this.parent.maskPlaceholder.month;\n    if (this.parent.maskPlaceholder.year) this.defaultConstant['year'] = this.parent.maskPlaceholder.year;\n    if (this.parent.maskPlaceholder.hour) this.defaultConstant['hour'] = this.parent.maskPlaceholder.hour;\n    if (this.parent.maskPlaceholder.minute) this.defaultConstant['minute'] = this.parent.maskPlaceholder.minute;\n    if (this.parent.maskPlaceholder.second) this.defaultConstant['second'] = this.parent.maskPlaceholder.second;\n    if (this.parent.maskPlaceholder.dayOfTheWeek) this.defaultConstant['dayOfTheWeek'] = this.parent.maskPlaceholder.dayOfTheWeek.toString();\n    this.getCUltureMaskFormat();\n    let inputValue = this.dateformat.replace(this.formatRegex, this.formatCheck());\n    this.isHiddenMask = true;\n    this.hiddenMask = this.dateformat.replace(this.formatRegex, this.formatCheck());\n    this.isHiddenMask = false;\n    this.previousHiddenMask = this.hiddenMask;\n    this.mask = this.previousValue = inputValue;\n    this.parent.maskedDateValue = this.mask;\n    if (this.parent.value) {\n      this.setDynamicValue();\n    }\n  }\n  getCUltureMaskFormat() {\n    this.l10n = new L10n(this.parent.moduleName, this.defaultConstant, this.parent.locale);\n    this.objectString = Object.keys(this.defaultConstant);\n    for (let i = 0; i < this.objectString.length; i++) {\n      this.defaultConstant[this.objectString[i].toString()] = this.l10n.getConstant(this.objectString[i].toString());\n    }\n  }\n  validCharacterCheck() {\n    let start = this.parent.inputElement.selectionStart;\n    for (let i = start, j = start - 1; i < this.hiddenMask.length || j >= 0; i++, j--) {\n      if (i < this.hiddenMask.length && this.validCharacters.indexOf(this.hiddenMask[i]) !== -1) {\n        this.setSelection(this.hiddenMask[i]);\n        return;\n      }\n      if (j >= 0 && this.validCharacters.indexOf(this.hiddenMask[j]) !== -1) {\n        this.setSelection(this.hiddenMask[j]);\n        return;\n      }\n    }\n  }\n  setDynamicValue() {\n    this.maskDateValue = this.parent.value;\n    this.isDayPart = this.isMonthPart = this.isYearPart = this.isHourPart = this.isMinutePart = this.isSecondsPart = true;\n    this.updateValue();\n    // this.parent.inputElement.selectionStart = start;\n    // this.validCharacterCheck();\n  }\n\n  setSelection(validChar) {\n    let start = -1;\n    let end = 0;\n    for (let i = 0; i < this.hiddenMask.length; i++) {\n      if (this.hiddenMask[i] === validChar) {\n        end = i + 1;\n        if (start === -1) {\n          start = i;\n        }\n      }\n    }\n    if (start < 0) {\n      start = 0;\n    }\n    this.parent.inputElement.setSelectionRange(start, end);\n  }\n  maskKeydownHandler(args) {\n    if (args.e.key === 'Delete') {\n      this.isDeleteKey = true;\n      return;\n    }\n    if (!args.e.altKey && !args.e.ctrlKey && (args.e.key === ARROWLEFT || args.e.key === ARROWRIGHT || args.e.key === SHIFTTAB || args.e.key === TAB || args.e.action === SHIFTTAB || args.e.key === END || args.e.key === HOME)) {\n      let start = this.parent.inputElement.selectionStart;\n      let end = this.parent.inputElement.selectionEnd;\n      let length = this.parent.inputElement.value.length;\n      if (start == 0 && end == length && (args.e.key === TAB || args.e.action === SHIFTTAB)) {\n        let index = args.e.action === SHIFTTAB ? end : 0;\n        this.parent.inputElement.selectionStart = this.parent.inputElement.selectionEnd = index;\n      }\n      if (args.e.key === END || args.e.key === HOME) {\n        let range = args.e.key === END ? length : 0;\n        this.parent.inputElement.selectionStart = this.parent.inputElement.selectionEnd = range;\n      }\n      this.navigateSelection(args.e.key === ARROWLEFT || args.e.action === SHIFTTAB || args.e.key === END ? true : false);\n    }\n    if (!args.e.altKey && !args.e.ctrlKey && (args.e.key === ARROWUP || args.e.key === ARROWDOWN)) {\n      let start = this.parent.inputElement.selectionStart;\n      this.dateAlteration(args.e.key === ARROWDOWN ? true : false);\n      let inputValue = this.dateformat.replace(this.formatRegex, this.formatCheck());\n      this.isHiddenMask = true;\n      this.hiddenMask = this.dateformat.replace(this.formatRegex, this.formatCheck());\n      this.isHiddenMask = false;\n      this.previousHiddenMask = this.hiddenMask;\n      this.previousValue = inputValue;\n      this.parent.inputElement.value = inputValue;\n      this.parent.inputElement.selectionStart = start;\n      this.validCharacterCheck();\n    }\n  }\n  differenceCheck() {\n    let start = this.parent.inputElement.selectionStart;\n    let inputValue = this.parent.inputElement.value;\n    let previousVal = this.previousValue.substring(0, start + this.previousValue.length - inputValue.length);\n    let newVal = inputValue.substring(0, start);\n    let newDateValue = new Date(+this.maskDateValue);\n    let maxDate = new Date(newDateValue.getFullYear(), newDateValue.getMonth() + 1, 0).getDate();\n    if (previousVal.indexOf(newVal) === 0 && (newVal.length === 0 || this.previousHiddenMask[newVal.length - 1] !== this.previousHiddenMask[newVal.length])) {\n      for (let i = newVal.length; i < previousVal.length; i++) {\n        if (this.previousHiddenMask[i] !== '' && this.validCharacters.indexOf(this.previousHiddenMask[i]) >= 0) {\n          this.isDeletion = this.handleDeletion(this.previousHiddenMask[i], false);\n        }\n      }\n      if (this.isDeletion) {\n        return;\n      }\n    }\n    switch (this.previousHiddenMask[start - 1]) {\n      case 'd':\n        let date = (this.isDayPart && newDateValue.getDate().toString().length < 2 ? newDateValue.getDate() * 10 : 0) + parseInt(newVal[start - 1], 10);\n        this.isDateZero = newVal[start - 1] == '0';\n        if (isNaN(date)) {\n          return;\n        }\n        for (let i = 0; date > maxDate; i++) {\n          date = parseInt(date.toString().slice(1), 10);\n        }\n        if (date >= 1) {\n          newDateValue.setDate(date);\n          this.isNavigate = date.toString().length === 2;\n          this.previousDate = new Date(newDateValue.getFullYear(), newDateValue.getMonth(), newDateValue.getDate());\n          if (newDateValue.getMonth() !== this.maskDateValue.getMonth()) {\n            return;\n          }\n          this.isDayPart = true;\n          this.dayTypeCount = this.dayTypeCount + 1;\n        } else {\n          this.isDayPart = false;\n          this.dayTypeCount = this.isDateZero ? this.dayTypeCount + 1 : this.dayTypeCount;\n        }\n        break;\n      case 'M':\n        let month;\n        if (newDateValue.getMonth().toString().length < 2) {\n          month = (this.isMonthPart ? (newDateValue.getMonth() + 1) * 10 : 0) + parseInt(newVal[start - 1], 10);\n        } else {\n          month = parseInt(newVal[start - 1], 10);\n        }\n        this.isMonthZero = newVal[start - 1] == '0';\n        if (!isNaN(month)) {\n          while (month > 12) {\n            month = parseInt(month.toString().slice(1), 10);\n          }\n          if (month >= 1) {\n            newDateValue.setMonth(month - 1);\n            this.isNavigate = month.toString().length === 2;\n            if (newDateValue.getMonth() !== month - 1) {\n              newDateValue.setDate(1);\n              newDateValue.setMonth(month - 1);\n            }\n            if (this.isDayPart) {\n              let previousMaxDate = new Date(this.previousDate.getFullYear(), this.previousDate.getMonth() + 1, 0).getDate();\n              let currentMaxDate = new Date(newDateValue.getFullYear(), newDateValue.getMonth() + 1, 0).getDate();\n              if (this.previousDate.getDate() == previousMaxDate && currentMaxDate <= previousMaxDate) {\n                newDateValue.setDate(currentMaxDate);\n              }\n            }\n            this.previousDate = new Date(newDateValue.getFullYear(), newDateValue.getMonth(), newDateValue.getDate());\n            this.isMonthPart = true;\n            this.monthTypeCount = this.monthTypeCount + 1;\n          } else {\n            newDateValue.setMonth(0);\n            this.isMonthPart = false;\n            this.monthTypeCount = this.isMonthZero ? this.monthTypeCount + 1 : this.monthTypeCount;\n          }\n        } else {\n          // let monthString: string[] = <string[]>(getValue('months[stand-alone].wide', getDefaultDateObject()));\n          let monthString = this.getCulturedValue('months[stand-alone].wide');\n          let monthValue = Object.keys(monthString);\n          this.monthCharacter += newVal[start - 1].toLowerCase();\n          while (this.monthCharacter.length > 0) {\n            let i = 1;\n            for (let months of monthValue) {\n              if (monthString[i].toLowerCase().indexOf(this.monthCharacter) === 0) {\n                newDateValue.setMonth(i - 1);\n                this.isMonthPart = true;\n                this.maskDateValue = newDateValue;\n                return;\n              }\n              i++;\n            }\n            this.monthCharacter = this.monthCharacter.substring(1, this.monthCharacter.length);\n          }\n        }\n        break;\n      case 'y':\n        let year = (this.isYearPart && newDateValue.getFullYear().toString().length < 4 && !this.isShortYear ? newDateValue.getFullYear() * 10 : 0) + parseInt(newVal[start - 1], 10);\n        this.isShortYear = false;\n        this.isYearZero = newVal[start - 1] == '0';\n        if (isNaN(year)) {\n          return;\n        }\n        while (year > 9999) {\n          year = parseInt(year.toString().slice(1), 10);\n        }\n        if (year < 1) {\n          this.isYearPart = false;\n        } else {\n          newDateValue.setFullYear(year);\n          if (year.toString().length === 4) {\n            this.isNavigate = true;\n          }\n          this.previousDate = new Date(newDateValue.getFullYear(), newDateValue.getMonth(), newDateValue.getDate());\n          this.isYearPart = true;\n        }\n        break;\n      case 'h':\n        this.hour = (this.isHourPart && (newDateValue.getHours() % 12 || 12).toString().length < 2 ? (newDateValue.getHours() % 12 || 12) * 10 : 0) + parseInt(newVal[start - 1], 10);\n        if (isNaN(this.hour)) {\n          return;\n        }\n        while (this.hour > 12) {\n          this.hour = parseInt(this.hour.toString().slice(1), 10);\n        }\n        newDateValue.setHours(Math.floor(newDateValue.getHours() / 12) * 12 + this.hour % 12);\n        this.isNavigate = this.hour.toString().length === 2;\n        this.isHourPart = true;\n        this.hourTypeCount = this.hourTypeCount + 1;\n        break;\n      case 'H':\n        this.hour = (this.isHourPart && newDateValue.getHours().toString().length < 2 ? newDateValue.getHours() * 10 : 0) + parseInt(newVal[start - 1], 10);\n        if (isNaN(this.hour)) {\n          return;\n        }\n        for (let i = 0; this.hour > 23; i++) {\n          this.hour = parseInt(this.hour.toString().slice(1), 10);\n        }\n        newDateValue.setHours(this.hour);\n        this.isNavigate = this.hour.toString().length === 2;\n        this.isHourPart = true;\n        this.hourTypeCount = this.hourTypeCount + 1;\n        break;\n      case 'm':\n        let minutes = (this.isMinutePart && newDateValue.getMinutes().toString().length < 2 ? newDateValue.getMinutes() * 10 : 0) + parseInt(newVal[start - 1], 10);\n        if (isNaN(minutes)) {\n          return;\n        }\n        for (let i = 0; minutes > 59; i++) {\n          minutes = parseInt(minutes.toString().slice(1), 10);\n        }\n        newDateValue.setMinutes(minutes);\n        this.isNavigate = minutes.toString().length === 2;\n        this.isMinutePart = true;\n        this.minuteTypeCount = this.minuteTypeCount + 1;\n        break;\n      case 's':\n        let seconds = (this.isSecondsPart && newDateValue.getSeconds().toString().length < 2 ? newDateValue.getSeconds() * 10 : 0) + parseInt(newVal[start - 1], 10);\n        if (isNaN(seconds)) {\n          return;\n        }\n        for (let i = 0; seconds > 59; i++) {\n          seconds = parseInt(seconds.toString().slice(1), 10);\n        }\n        newDateValue.setSeconds(seconds);\n        this.isNavigate = seconds.toString().length === 2;\n        this.isSecondsPart = true;\n        this.secondTypeCount = this.secondTypeCount + 1;\n        break;\n      case 'a':\n        this.periodCharacter += newVal[start - 1].toLowerCase();\n        // let periodString: string[] = <string[]>(getValue('dayPeriods.format.wide', getDefaultDateObject()));;\n        let periodString = this.getCulturedValue('dayPeriods.format.wide');\n        let periodkeys = Object.keys(periodString);\n        //periodString[periodkeys[0]] : periodString[periodkeys[1]] : periodString[periodkeys[0]];\n        for (let i = 0; this.periodCharacter.length > 0; i++) {\n          if (periodString[periodkeys[0]].toLowerCase().indexOf(this.periodCharacter) === 0 && newDateValue.getHours() >= 12 || periodString[periodkeys[1]].toLowerCase().indexOf(this.periodCharacter) === 0 && newDateValue.getHours() < 12) {\n            newDateValue.setHours((newDateValue.getHours() + 12) % 24);\n            this.maskDateValue = newDateValue;\n          }\n          this.periodCharacter = this.periodCharacter.substring(1, this.periodCharacter.length);\n          // Object.values()\n        }\n\n        break;\n      default:\n        break;\n    }\n    this.maskDateValue = newDateValue;\n  }\n  formatCheck() {\n    const proxy = this;\n    function formatValueSpecifier(formattext) {\n      let result;\n      let daysAbbreviated = proxy.getCulturedValue('days[stand-alone].abbreviated');\n      let dayKeyAbbreviated = Object.keys(daysAbbreviated);\n      let daysWide = proxy.getCulturedValue('days[stand-alone].wide');\n      let dayKeyWide = Object.keys(daysWide);\n      let daysNarrow = proxy.getCulturedValue('days[stand-alone].narrow');\n      let dayKeyNarrow = Object.keys(daysNarrow);\n      let monthAbbreviated = proxy.getCulturedValue('months[stand-alone].abbreviated');\n      let monthWide = proxy.getCulturedValue('months[stand-alone].wide');\n      let periodString = proxy.getCulturedValue('dayPeriods.format.wide');\n      let periodkeys = Object.keys(periodString);\n      let milliseconds;\n      let dateOptions;\n      switch (formattext) {\n        case 'ddd':\n        case 'dddd':\n        case 'd':\n          result = proxy.isDayPart ? proxy.maskDateValue.getDate().toString() : proxy.defaultConstant['day'].toString();\n          result = proxy.zeroCheck(proxy.isDateZero, proxy.isDayPart, result);\n          break;\n        case 'dd':\n          result = proxy.isDayPart ? proxy.roundOff(proxy.maskDateValue.getDate(), 2) : proxy.defaultConstant['day'].toString();\n          result = proxy.zeroCheck(proxy.isDateZero, proxy.isDayPart, result);\n          if (proxy.dayTypeCount == 2) {\n            proxy.isNavigate = true;\n            proxy.dayTypeCount = 0;\n          }\n          break;\n        case 'E':\n        case 'EE':\n        case 'EEE':\n          result = proxy.isDayPart && proxy.isMonthPart && proxy.isYearPart ? daysAbbreviated[dayKeyAbbreviated[proxy.maskDateValue.getDay()]].toString() : proxy.defaultConstant['dayOfTheWeek'].toString();\n          break;\n        case 'EEEE':\n          result = proxy.isDayPart && proxy.isMonthPart && proxy.isYearPart ? daysWide[dayKeyWide[proxy.maskDateValue.getDay()]].toString() : proxy.defaultConstant['dayOfTheWeek'].toString();\n          break;\n        case 'EEEEE':\n          result = proxy.isDayPart && proxy.isMonthPart && proxy.isYearPart ? daysNarrow[dayKeyNarrow[proxy.maskDateValue.getDay()]].toString() : proxy.defaultConstant['dayOfTheWeek'].toString();\n          break;\n        case 'M':\n          result = proxy.isMonthPart ? (proxy.maskDateValue.getMonth() + 1).toString() : proxy.defaultConstant['month'].toString();\n          result = proxy.zeroCheck(proxy.isMonthZero, proxy.isMonthPart, result);\n          break;\n        case 'MM':\n          result = proxy.isMonthPart ? proxy.roundOff(proxy.maskDateValue.getMonth() + 1, 2) : proxy.defaultConstant['month'].toString();\n          result = proxy.zeroCheck(proxy.isMonthZero, proxy.isMonthPart, result);\n          if (proxy.monthTypeCount == 2) {\n            proxy.isNavigate = true;\n            proxy.monthTypeCount = 0;\n          }\n          break;\n        case 'MMM':\n          result = proxy.isMonthPart ? monthAbbreviated[proxy.maskDateValue.getMonth() + 1] : proxy.defaultConstant['month'].toString();\n          break;\n        case 'MMMM':\n          result = proxy.isMonthPart ? monthWide[proxy.maskDateValue.getMonth() + 1] : proxy.defaultConstant['month'].toString();\n          break;\n        case 'yy':\n          result = proxy.isYearPart ? proxy.roundOff(proxy.maskDateValue.getFullYear() % 100, 2) : proxy.defaultConstant['year'].toString();\n          result = proxy.zeroCheck(proxy.isYearZero, proxy.isYearPart, result);\n          if (proxy.isYearPart) {\n            proxy.isNavigate = proxy.isShortYear = (proxy.maskDateValue.getFullYear() % 100).toString().length === 2;\n          }\n          break;\n        case 'y':\n        case 'yyyy':\n          result = proxy.isYearPart ? proxy.roundOff(proxy.maskDateValue.getFullYear(), 4) : proxy.defaultConstant['year'].toString();\n          result = proxy.zeroCheck(proxy.isYearZero, proxy.isYearPart, result);\n          break;\n        case 'h':\n          result = proxy.isHourPart ? (proxy.maskDateValue.getHours() % 12 || 12).toString() : proxy.defaultConstant['hour'].toString();\n          break;\n        case 'hh':\n          result = proxy.isHourPart ? proxy.roundOff(proxy.maskDateValue.getHours() % 12 || 12, 2) : proxy.defaultConstant['hour'].toString();\n          if (proxy.hourTypeCount == 2) {\n            proxy.isNavigate = true;\n            proxy.hourTypeCount = 0;\n          }\n          break;\n        case 'H':\n          result = proxy.isHourPart ? proxy.maskDateValue.getHours().toString() : proxy.defaultConstant['hour'].toString();\n          break;\n        case 'HH':\n          result = proxy.isHourPart ? proxy.roundOff(proxy.maskDateValue.getHours(), 2) : proxy.defaultConstant['hour'].toString();\n          if (proxy.hourTypeCount == 2) {\n            proxy.isNavigate = true;\n            proxy.hourTypeCount = 0;\n          }\n          break;\n        case 'm':\n          result = proxy.isMinutePart ? proxy.maskDateValue.getMinutes().toString() : proxy.defaultConstant['minute'].toString();\n          break;\n        case 'mm':\n          result = proxy.isMinutePart ? proxy.roundOff(proxy.maskDateValue.getMinutes(), 2) : proxy.defaultConstant['minute'].toString();\n          if (proxy.minuteTypeCount == 2) {\n            proxy.isNavigate = true;\n            proxy.minuteTypeCount = 0;\n          }\n          break;\n        case 's':\n          result = proxy.isSecondsPart ? proxy.maskDateValue.getSeconds().toString() : proxy.defaultConstant['second'].toString();\n          break;\n        case 'ss':\n          result = proxy.isSecondsPart ? proxy.roundOff(proxy.maskDateValue.getSeconds(), 2) : proxy.defaultConstant['second'].toString();\n          if (proxy.secondTypeCount == 2) {\n            proxy.isNavigate = true;\n            proxy.secondTypeCount = 0;\n          }\n          break;\n        case 'f':\n          result = Math.floor(proxy.maskDateValue.getMilliseconds() / 100).toString();\n          break;\n        case 'ff':\n          milliseconds = proxy.maskDateValue.getMilliseconds();\n          if (proxy.maskDateValue.getMilliseconds() > 99) {\n            milliseconds = Math.floor(proxy.maskDateValue.getMilliseconds() / 10);\n          }\n          result = proxy.roundOff(milliseconds, 2);\n          break;\n        case 'fff':\n          result = proxy.roundOff(proxy.maskDateValue.getMilliseconds(), 3);\n          break;\n        case 'a':\n        case 'aa':\n          result = proxy.maskDateValue.getHours() < 12 ? periodString[periodkeys[0]] : periodString[periodkeys[1]];\n          break;\n        case 'z':\n        case 'zz':\n        case 'zzz':\n        case 'zzzz':\n          dateOptions = {\n            format: formattext,\n            type: 'dateTime',\n            skeleton: 'yMd',\n            calendar: proxy.parent.calendarMode\n          };\n          result = proxy.parent.globalize.formatDate(proxy.maskDateValue, dateOptions);\n          break;\n      }\n      result = result !== undefined ? result : formattext.slice(1, formattext.length - 1);\n      if (proxy.isHiddenMask) {\n        let hiddenChar = '';\n        for (let i = 0; i < result.length; i++) {\n          hiddenChar += formattext[0];\n        }\n        return hiddenChar;\n      } else {\n        return result;\n      }\n    }\n    return formatValueSpecifier;\n  }\n  maskInputHandler() {\n    let start = this.parent.inputElement.selectionStart;\n    let selectionChar = this.previousHiddenMask[start - 1];\n    let inputValue;\n    this.differenceCheck();\n    inputValue = this.dateformat.replace(this.formatRegex, this.formatCheck());\n    this.isHiddenMask = true;\n    this.hiddenMask = this.dateformat.replace(this.formatRegex, this.formatCheck());\n    this.isDateZero = this.isMonthZero = this.isYearZero = false;\n    this.isHiddenMask = false;\n    this.previousHiddenMask = this.hiddenMask;\n    this.previousValue = inputValue;\n    this.parent.inputElement.value = inputValue;\n    this.parent.inputElement.selectionStart = start;\n    this.validCharacterCheck();\n    if ((this.isNavigate || this.isDeletion) && !this.isDeleteKey) {\n      let isbackward = this.isNavigate ? false : true;\n      this.isNavigate = this.isDeletion = false;\n      this.navigateSelection(isbackward);\n    }\n    this.isDeleteKey = false;\n    // this.setSelection(selectionChar);\n    // this.navigateSelection(inputValue);\n  }\n\n  navigateSelection(isbackward) {\n    let start = this.parent.inputElement.selectionStart;\n    let end = this.parent.inputElement.selectionEnd;\n    let formatIndex = isbackward ? start - 1 : end + 1;\n    while (formatIndex < this.hiddenMask.length && formatIndex >= 0) {\n      if (this.validCharacters.indexOf(this.hiddenMask[formatIndex]) >= 0) {\n        this.setSelection(this.hiddenMask[formatIndex]);\n        break;\n      }\n      formatIndex = formatIndex + (isbackward ? -1 : 1);\n    }\n  }\n  roundOff(val, count) {\n    let valueText = val.toString();\n    let length = count - valueText.length;\n    let result = '';\n    for (let i = 0; i < length; i++) {\n      result += '0';\n    }\n    return result + valueText;\n  }\n  zeroCheck(isZero, isDayPart, resultValue) {\n    let result = resultValue;\n    if (isZero && !isDayPart) {\n      result = '0';\n    }\n    return result;\n  }\n  handleDeletion(format, isSegment) {\n    switch (format) {\n      case 'd':\n        this.isDayPart = isSegment;\n        break;\n      case 'M':\n        this.isMonthPart = isSegment;\n        if (!isSegment) {\n          this.maskDateValue.setMonth(0);\n          this.monthCharacter = '';\n        }\n        break;\n      case 'y':\n        this.isYearPart = isSegment;\n        break;\n      case 'H':\n      case 'h':\n        this.isHourPart = isSegment;\n        if (!isSegment) {\n          this.periodCharacter = '';\n        }\n        break;\n      case 'm':\n        this.isMinutePart = isSegment;\n        break;\n      case 's':\n        this.isSecondsPart = isSegment;\n        break;\n      default:\n        return false;\n    }\n    return true;\n  }\n  dateAlteration(isDecrement) {\n    let start = this.parent.inputElement.selectionStart;\n    let formatText = '';\n    if (this.validCharacters.indexOf(this.hiddenMask[start]) !== -1) {\n      formatText = this.hiddenMask[start];\n    } else {\n      return;\n    }\n    let newDateValue = new Date(this.maskDateValue.getFullYear(), this.maskDateValue.getMonth(), this.maskDateValue.getDate(), this.maskDateValue.getHours(), this.maskDateValue.getMinutes(), this.maskDateValue.getSeconds());\n    this.previousDate = new Date(this.maskDateValue.getFullYear(), this.maskDateValue.getMonth(), this.maskDateValue.getDate(), this.maskDateValue.getHours(), this.maskDateValue.getMinutes(), this.maskDateValue.getSeconds());\n    let incrementValue = isDecrement ? -1 : 1;\n    switch (formatText) {\n      case 'd':\n        newDateValue.setDate(newDateValue.getDate() + incrementValue);\n        break;\n      case 'M':\n        let newMonth = newDateValue.getMonth() + incrementValue;\n        newDateValue.setDate(1);\n        newDateValue.setMonth(newMonth);\n        if (this.isDayPart) {\n          let previousMaxDate = new Date(this.previousDate.getFullYear(), this.previousDate.getMonth() + 1, 0).getDate();\n          let currentMaxDate = new Date(newDateValue.getFullYear(), newDateValue.getMonth() + 1, 0).getDate();\n          if (this.previousDate.getDate() == previousMaxDate && currentMaxDate <= previousMaxDate) {\n            newDateValue.setDate(currentMaxDate);\n          } else {\n            newDateValue.setDate(this.previousDate.getDate());\n          }\n        } else {\n          newDateValue.setDate(this.previousDate.getDate());\n        }\n        this.previousDate = new Date(newDateValue.getFullYear(), newDateValue.getMonth(), newDateValue.getDate());\n        break;\n      case 'y':\n        newDateValue.setFullYear(newDateValue.getFullYear() + incrementValue);\n        break;\n      case 'H':\n      case 'h':\n        newDateValue.setHours(newDateValue.getHours() + incrementValue);\n        break;\n      case 'm':\n        newDateValue.setMinutes(newDateValue.getMinutes() + incrementValue);\n        break;\n      case 's':\n        newDateValue.setSeconds(newDateValue.getSeconds() + incrementValue);\n        break;\n      case 'a':\n        newDateValue.setHours((newDateValue.getHours() + 12) % 24);\n        break;\n      default:\n        break;\n    }\n    this.maskDateValue = newDateValue.getFullYear() > 0 ? newDateValue : this.maskDateValue;\n    if (this.validCharacters.indexOf(this.hiddenMask[start]) !== -1) {\n      this.handleDeletion(this.hiddenMask[start], true);\n    }\n  }\n  getCulturedValue(format) {\n    let locale = this.parent.locale;\n    let result;\n    if (locale === 'en' || locale === 'en-US') {\n      result = getValue(format, getDefaultDateObject());\n    } else {\n      result = getValue('main.' + '' + locale + ('.dates.calendars.gregorian.' + format), cldrData);\n    }\n    return result;\n  }\n  getCulturedFormat() {\n    let formatString = this.getCulturedValue('dateTimeFormats[availableFormats].yMd').toString();\n    if (this.parent.moduleName == 'datepicker') {\n      formatString = this.getCulturedValue('dateTimeFormats[availableFormats].yMd').toString();\n      if (this.parent.format && this.parent.formatString) {\n        formatString = this.parent.formatString;\n      }\n    }\n    if (this.parent.moduleName == 'datetimepicker') {\n      formatString = this.getCulturedValue('dateTimeFormats[availableFormats].yMd').toString();\n      if (this.parent.dateTimeFormat) {\n        formatString = this.parent.dateTimeFormat;\n      }\n    }\n    if (this.parent.moduleName == 'timepicker') {\n      formatString = this.parent.cldrTimeFormat();\n    }\n    return formatString;\n  }\n  clearHandler() {\n    this.isDayPart = this.isMonthPart = this.isYearPart = this.isHourPart = this.isMinutePart = this.isSecondsPart = false;\n    this.updateValue();\n  }\n  updateValue() {\n    this.monthCharacter = this.periodCharacter = '';\n    let inputValue = this.dateformat.replace(this.formatRegex, this.formatCheck());\n    this.isHiddenMask = true;\n    this.hiddenMask = this.dateformat.replace(this.formatRegex, this.formatCheck());\n    this.isHiddenMask = false;\n    this.previousHiddenMask = this.hiddenMask;\n    this.previousValue = inputValue;\n    this.parent.updateInputValue(inputValue);\n    //this.parent.inputElement.value = inputValue;\n  }\n\n  destroy() {\n    this.removeEventListener();\n  }\n}\n\n/**\n * MaskedDateTime modules\n */\n\n/**\n * Calendar all modules\n */\n\nexport { CalendarBase, Calendar, Islamic, DatePicker, Presets, DateRangePicker, TimePickerBase, TimeMaskPlaceholder, TimePicker, DateTimePicker, MaskedDateTime };\n//# sourceMappingURL=ej2-calendars.es2015.js.map","map":null,"metadata":{},"sourceType":"module"}