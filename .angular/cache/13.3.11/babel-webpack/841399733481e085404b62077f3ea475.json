{"ast":null,"code":"import { Animation, Browser, ChildProperty, Collection, Complex, Component, Draggable, Event, EventHandler, HijriParser, Internationalization, KeyboardEvents, L10n, NotifyPropertyChanges, Property, SanitizeHtmlHelper, Touch, addClass, append, classList, cldrData, closest, compile, createElement, extend, formatUnit, getDefaultDateObject, getElement, getValue, isNullOrUndefined, prepend, print, remove, removeClass, setStyleAttribute } from '@syncfusion/ej2-base';\nimport { Dialog, Popup, Tooltip, createSpinner, hideSpinner, isCollide, showSpinner } from '@syncfusion/ej2-popups';\nimport { Toolbar, TreeView } from '@syncfusion/ej2-navigations';\nimport { Calendar, DatePicker, DateTimePicker } from '@syncfusion/ej2-calendars';\nimport { DataManager, Deferred, Predicate, Query } from '@syncfusion/ej2-data';\nimport { Button, CheckBox, RadioButton } from '@syncfusion/ej2-buttons';\nimport { FormValidator, Input, NumericTextBox } from '@syncfusion/ej2-inputs';\nimport { DropDownList, MultiSelect } from '@syncfusion/ej2-dropdowns';\nimport { ListBase } from '@syncfusion/ej2-lists';\nimport { Workbook } from '@syncfusion/ej2-excel-export';\n\n/**\n * Constants\n */\n/** @private */\nconst cellClick = 'cellClick';\n/** @private */\nconst cellDoubleClick = 'cellDoubleClick';\n/** @private */\nconst moreEventsClick = 'moreEventsClick';\n/** @private */\nconst select = 'select';\n/** @private */\nconst hover = 'hover';\n/** @private */\nconst actionBegin = 'actionBegin';\n/** @private */\nconst actionComplete = 'actionComplete';\n/** @private */\nconst actionFailure = 'actionFailure';\n/** @private */\nconst navigating = 'navigating';\n/** @private */\nconst renderCell = 'renderCell';\n/** @private */\nconst eventClick = 'eventClick';\n/** @private */\nconst eventRendered = 'eventRendered';\n/** @private */\nconst dataBinding = 'dataBinding';\n/** @private */\nconst dataBound = 'dataBound';\n/** @private */\nconst popupOpen = 'popupOpen';\n/** @private */\nconst popupClose = 'popupClose';\n/** @private */\nconst dragStart = 'dragStart';\n/** @private */\nconst drag = 'drag';\n/** @private */\nconst dragStop = 'dragStop';\n/** @private */\nconst resizeStart = 'resizeStart';\n/** @private */\nconst resizing = 'resizing';\n/** @private */\nconst resizeStop = 'resizeStop';\n/** @private */\nconst inlineClick = 'inlineClick';\n/**\n * Specifies schedule internal events\n */\n/** @private */\nconst initialLoad = 'initial-load';\n/** @private */\nconst initialEnd = 'initial-end';\n/** @private */\nconst print$1 = 'print';\n/** @private */\nconst dataReady = 'data-ready';\n/** @private */\nconst eventsLoaded = 'events-loaded';\n/** @private */\nconst contentReady = 'content-ready';\n/** @private */\nconst scroll = 'scroll';\n/** @private */\nconst virtualScroll = 'virtual-scroll';\n/** @private */\nconst scrollUiUpdate = 'scroll-ui-update';\n/** @private */\nconst uiUpdate = 'ui-update';\n/** @private */\nconst documentClick = 'document-click';\n/** @private */\nconst cellMouseDown = 'cell-mouse-down';\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Schedule common utilities\n */\nconst WEEK_LENGTH = 7;\nconst DEFAULT_WEEKS = 6;\nconst MS_PER_DAY = 86400000;\nconst MS_PER_MINUTE = 60000;\n/**\n * Method to get height from element\n *\n * @param {Element} container Accepts the DOM element\n * @param {string} elementClass Accepts the element class\n * @returns {number} Returns the height of the element\n */\nfunction getElementHeightFromClass(container, elementClass) {\n  let height = 0;\n  const el = createElement('div', {\n    className: elementClass\n  }).cloneNode();\n  el.style.visibility = 'hidden';\n  el.style.position = 'absolute';\n  container.appendChild(el);\n  height = el.getBoundingClientRect().height;\n  remove(el);\n  return height;\n}\n/**\n * Method to get translateY value\n *\n * @param {HTMLElement | Element} element Accepts the DOM element\n * @returns {number} Returns the translateY value of given element\n */\nfunction getTranslateY(element) {\n  const style = getComputedStyle(element);\n  return window.WebKitCSSMatrix ? new WebKitCSSMatrix(style.webkitTransform).m42 : 0;\n}\n/**\n * Method to get week first date\n *\n * @param {Date} date Accepts the date object\n * @param {number} firstDayOfWeek Accepts the first day of week number\n * @returns {Date} Returns the date object\n */\nfunction getWeekFirstDate(date, firstDayOfWeek) {\n  const date1 = new Date(date.getTime());\n  firstDayOfWeek = (firstDayOfWeek - date1.getDay() + 7 * -1) % 7;\n  return new Date(date1.setDate(date1.getDate() + firstDayOfWeek));\n}\n/**\n * Method to get week last date\n *\n * @param {Date} date Accepts the date object\n * @param {number} firstDayOfWeek Accepts the first day of week number\n * @returns {Date} Returns the date object\n */\nfunction getWeekLastDate(date, firstDayOfWeek) {\n  const weekFirst = getWeekFirstDate(date, firstDayOfWeek);\n  const weekLast = new Date(weekFirst.getFullYear(), weekFirst.getMonth(), weekFirst.getDate() + 6);\n  return new Date(weekLast.getTime());\n}\n/**\n * Method to get first date of month\n *\n * @param {Date} date Accepts the date object\n * @returns {Date} Returns the date object\n */\nfunction firstDateOfMonth(date) {\n  return new Date(date.getFullYear(), date.getMonth(), 1);\n}\n/**\n * Method to get last date of month\n *\n * @param {Date} date Accepts the date object\n * @returns {Date} Returns the date object\n */\nfunction lastDateOfMonth(date) {\n  return new Date(date.getFullYear(), date.getMonth() + 1, 0);\n}\n/**\n * Method to get week number\n *\n * @param {Date} date Accepts the date object\n * @returns {number} Returns the week number\n */\nfunction getWeekNumber(date) {\n  const date1 = new Date(date.getFullYear(), 0, 1).valueOf();\n  const currentDate = new Date(date.getFullYear(), date.getMonth(), date.getDate()).valueOf();\n  const dayOfYear = (currentDate - date1 + MS_PER_DAY) / MS_PER_DAY;\n  return Math.ceil(dayOfYear / 7);\n}\n/**\n * Method to get week middle date\n *\n * @param {Date} weekFirst Accepts the week first date object\n * @param {Date} weekLast Accepts the week last date object\n * @returns {Date} Returns the date object\n */\nfunction getWeekMiddleDate(weekFirst, weekLast) {\n  return new Date(weekLast.valueOf() - (weekLast.valueOf() - weekFirst.valueOf()) / 2);\n}\n/**\n * Method to set time to date object\n *\n * @param {Date} date Accepts the date object\n * @param {number} time Accepts the milliseconds\n * @returns {Date} Returns the date object\n */\nfunction setTime(date, time) {\n  const tzOffsetBefore = date.getTimezoneOffset();\n  const d = new Date(date.getTime() + time);\n  const tzOffsetDiff = d.getTimezoneOffset() - tzOffsetBefore;\n  date.setTime(d.getTime() + tzOffsetDiff * MS_PER_MINUTE);\n  return date;\n}\n/**\n * Method the reset hours in date object\n *\n * @param {Date} date Accepts the date object\n * @returns {Date} Returns the date object\n */\nfunction resetTime(date) {\n  return new Date(date.getFullYear(), date.getMonth(), date.getDate());\n}\n/**\n * Method to get milliseconds from date object\n *\n * @param {Date} date Accepts the date object\n * @returns {number} Returns the milliseconds from date object\n */\nfunction getDateInMs(date) {\n  const localOffset = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0).getTimezoneOffset();\n  const dateOffset = date.getTimezoneOffset();\n  const timezoneOffset = dateOffset - localOffset;\n  return date.getTime() - new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0).getTime() - timezoneOffset * 60 * 1000;\n}\n/**\n * Method to get date count between two dates\n *\n * @param {Date} startDate Accepts the date object\n * @param {Date} endDate Accepts the date object\n * @returns {number} Returns the date count\n */\nfunction getDateCount(startDate, endDate) {\n  return Math.ceil((endDate.getTime() - startDate.getTime()) / MS_PER_DAY);\n}\n/**\n * Method to add no of days in date object\n *\n * @param {Date} date Accepts the date object\n * @param {number} noOfDays Accepts the number of days count\n * @returns {Date} Returns the date object\n */\nfunction addDays(date, noOfDays) {\n  date = new Date('' + date);\n  return new Date(date.setDate(date.getDate() + noOfDays));\n}\n/**\n * Method to add no of months in date object\n *\n * @param {Date} date Accepts the date object\n * @param {number} noOfMonths Accepts the number of month count\n * @returns {Date} Returns the date object\n */\nfunction addMonths(date, noOfMonths) {\n  date = new Date('' + date);\n  const day = date.getDate();\n  date.setDate(1);\n  date.setMonth(date.getMonth() + noOfMonths);\n  date.setDate(Math.min(day, getMaxDays(date)));\n  return date;\n}\n/**\n * Method to add no of years in date object\n *\n * @param {Date} date Accepts the date object\n * @param {number} noOfYears Accepts the number of month count\n * @returns {Date} Returns the date object\n */\nfunction addYears(date, noOfYears) {\n  date = new Date('' + date);\n  const day = date.getDate();\n  date.setDate(1);\n  date.setFullYear(date.getFullYear() + noOfYears);\n  date.setDate(Math.min(day, getMaxDays(date)));\n  return date;\n}\n/**\n * Method to get start and end hours\n *\n * @param {Date} date Accepts the date object\n * @param {Date} startHour Accepts the start hour date object\n * @param {Date} endHour Accepts the end hour date object\n * @returns {Object} Returns the start and end hour date objects\n */\nfunction getStartEndHours(date, startHour, endHour) {\n  const date1 = new Date(date.getTime());\n  date1.setHours(startHour.getHours());\n  date1.setMinutes(startHour.getMinutes());\n  date1.setSeconds(startHour.getSeconds());\n  let date2 = new Date(date.getTime());\n  if (endHour.getHours() === 0) {\n    date2 = addDays(date2, 1);\n  } else {\n    date2.setHours(endHour.getHours());\n    date2.setMinutes(endHour.getMinutes());\n    date2.setSeconds(endHour.getSeconds());\n  }\n  return {\n    startHour: date1,\n    endHour: date2\n  };\n}\n/**\n * Method to get month last date\n *\n * @param {Date} date Accepts the date object\n * @returns {number} Returns the month last date\n */\nfunction getMaxDays(date) {\n  return lastDateOfMonth(date).getDate();\n}\n/**\n * Method to get days count between two dates\n *\n * @param {Date} startDate Accepts the date object\n * @param {Date} endDate Accepts the date object\n * @returns {number} Returns the days count\n */\nfunction getDaysCount(startDate, endDate) {\n  const strTime = resetTime(new Date(startDate));\n  const endTime = resetTime(new Date(endDate));\n  return Math.round((endTime.getTime() - strTime.getTime()) / MS_PER_DAY);\n}\n/**\n * Method to get date object from date string\n *\n * @param {string} date Accepts the date string\n * @returns {Date} Returns the date object\n */\nfunction getDateFromString(date) {\n  return date.indexOf('Date') !== -1 ? new Date(parseInt(date.match(/\\d+/g).toString(), 10)) : date.indexOf('T') !== -1 ? new Date(date) : new Date(date.replace(/-/g, '/'));\n}\n/** @private */\nlet scrollWidth = null;\n/**\n * Method to get scrollbar width\n *\n * @returns {number} Returns the scrollbar width\n * @private\n */\nfunction getScrollBarWidth() {\n  if (scrollWidth !== null) {\n    return scrollWidth;\n  }\n  const divNode = createElement('div');\n  let value = 0;\n  divNode.style.cssText = 'width:100px;height: 100px;overflow: scroll;position: absolute;top: -9999px;';\n  document.body.appendChild(divNode);\n  const ratio = devicePixelRatio ? devicePixelRatio.toFixed(2) === '1.10' || devicePixelRatio <= 1 ? Math.ceil(devicePixelRatio % 1) : Math.floor(devicePixelRatio % 1) : 0;\n  value = divNode.offsetWidth - divNode.clientWidth - ratio | 0;\n  document.body.removeChild(divNode);\n  return scrollWidth = value;\n}\n/**\n * Method to find the index from data collection\n *\n * @param {Object} data Accepts the data as object\n * @param {string} field Accepts the field name\n * @param {string} value Accepts the value name\n * @param {Object} event Accepts the data as object\n * @param {Object[]} resourceCollection Accepts the data collections\n * @returns {number} Returns the index number\n */\n// eslint-disable-next-line max-len\nfunction findIndexInData(data, field, value, event, resourceCollection) {\n  for (let i = 0, length = data.length; i < length; i++) {\n    if (data[i][field] === value) {\n      if (event) {\n        const field = resourceCollection.slice(-2)[0].field;\n        const res = event[field] instanceof Array ? event[field] : [event[field]];\n        const resData = res.join(',');\n        if (resData.includes(data[i][resourceCollection.slice(-1)[0].groupIDField])) {\n          return i;\n        }\n      } else {\n        return i;\n      }\n    }\n  }\n  return -1;\n}\n/**\n * Method to get element outer height\n *\n * @param {HTMLElement} element Accepts the DOM element\n * @returns {number} Returns the outer height of the given element\n */\nfunction getOuterHeight(element) {\n  const style = getComputedStyle(element);\n  return element.offsetHeight + (parseInt(style.marginTop, 10) || 0) + (parseInt(style.marginBottom, 10) || 0);\n}\n/**\n * Method to remove child elements\n *\n * @param {HTMLElement | Element} element Accepts the DOM element\n * @returns {void}\n */\nfunction removeChildren(element) {\n  const elementChildren = [].slice.call(element.children);\n  for (const elementChild of elementChildren) {\n    if (!elementChild.classList.contains('blazor-template')) {\n      element.removeChild(elementChild);\n    }\n  }\n}\n/**\n * Method to check DST is present or not in date object\n *\n * @param {Date} date Accepts the date object\n * @returns {boolean} Returns the boolean value for either DST is present or not\n */\nfunction isDaylightSavingTime(date) {\n  const jan = new Date(date.getFullYear(), 0, 1);\n  const jul = new Date(date.getFullYear(), 6, 1);\n  return date.getTimezoneOffset() < Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());\n}\n/**\n * Method to get UTC time value from date\n *\n * @param {Date} date Accepts the date\n * @returns {number} Returns the UTC time value\n */\nfunction getUniversalTime(date) {\n  const year = date.getFullYear();\n  const month = date.getMonth();\n  const day = date.getDate();\n  const hours = date.getHours();\n  const minutes = date.getMinutes();\n  const seconds = date.getSeconds();\n  const milliseconds = date.getMilliseconds();\n  return Date.UTC(year, month, day, hours, minutes, seconds, milliseconds);\n}\n/**\n * Method to check the device\n *\n * @returns {boolean} Returns the boolean value for either device is present or not.\n */\nfunction isMobile() {\n  return window.navigator.userAgent.toLowerCase().indexOf('mobi') > -1;\n}\n/**\n * Method to check the IPad device\n *\n * @returns {boolean} Returns the boolean value for either IPad device is present or not.\n */\nfunction isIPadDevice() {\n  return window.navigator.userAgent.toLowerCase().indexOf('ipad') > -1;\n}\n/**\n * Method to capitalize the first word in string\n *\n * @param {string} inputString Accepts the string value\n * @param {string} type Accepts the string type\n * @returns {string} Returns the output string\n */\nfunction capitalizeFirstWord(inputString, type) {\n  if (type === 'multiple') {\n    inputString = inputString.split(' ').map(e => e.charAt(0).toLocaleUpperCase() + e.substring(1)).join(' ');\n  } else if (type === 'single') {\n    if (inputString[0] >= '0' && inputString[0] <= '9') {\n      const array = inputString.match(/[a-zA-Z]/);\n      inputString = isNullOrUndefined(array) ? inputString : inputString.slice(0, array.index) + inputString[array.index].toLocaleUpperCase() + inputString.slice(array.index + 1);\n    }\n    inputString = inputString[0].toLocaleUpperCase() + inputString.slice(1);\n  }\n  return inputString;\n}\n\n/**\n * CSS Constants\n */\n/** @private */\nconst ROOT = 'e-schedule';\n/** @private */\nconst RTL = 'e-rtl';\n/** @private */\nconst DEVICE_CLASS = 'e-device';\n/** @private */\nconst MULTI_DRAG = 'e-multi-drag';\n/** @private */\nconst ICON = 'e-icons';\n/** @private */\nconst ENABLE_CLASS = 'e-enable';\n/** @private */\nconst DISABLE_CLASS = 'e-disable';\n/** @private */\nconst TABLE_CONTAINER_CLASS = 'e-table-container';\n/** @private */\nconst SCHEDULE_TABLE_CLASS = 'e-schedule-table';\n/** @private */\nconst ALLDAY_CELLS_CLASS = 'e-all-day-cells';\n/** @private */\nconst HEADER_POPUP_CLASS = 'e-header-popup';\n/** @private */\nconst HEADER_CALENDAR_CLASS = 'e-header-calendar';\n/** @private */\nconst ALLDAY_ROW_CLASS = 'e-all-day-row';\n/** @private */\nconst CONTENT_TABLE_CLASS = 'e-content-table';\n/** @private */\nconst WORK_CELLS_CLASS = 'e-work-cells';\n/** @private */\nconst WORK_HOURS_CLASS = 'e-work-hours';\n/** @private */\nconst POPUP_OPEN = 'e-popup-open';\n/** @private */\n\n/** @private */\nconst DATE_HEADER_WRAP_CLASS = 'e-date-header-wrap';\n/** @private */\nconst DATE_HEADER_CONTAINER_CLASS = 'e-date-header-container';\n/** @private */\nconst HEADER_CELLS_CLASS = 'e-header-cells';\n/** @private */\nconst HEADER_WEEK_CELLS_CLASS = 'e-header-week-cell';\n/** @private */\nconst HEADER_MONTH_CELLS_CLASS = 'e-header-month-cell';\n/** @private */\nconst HEADER_YEAR_CELLS_CLASS = 'e-header-year-cell';\n/** @private */\nconst WORKDAY_CLASS = 'e-work-days';\n/** @private */\nconst OTHERMONTH_CLASS = 'e-other-month';\n/** @private */\nconst CURRENT_DAY_CLASS = 'e-current-day';\n/** @private */\nconst CURRENTDATE_CLASS = 'e-current-date';\n/** @private */\nconst CURRENT_PANEL_CLASS = 'e-current-panel';\n/** @private */\nconst PREVIOUS_PANEL_CLASS = 'e-previous-panel';\n/** @private */\nconst NEXT_PANEL_CLASS = 'e-next-panel';\n/** @private */\nconst PREVIOUS_DATE_CLASS = 'e-prev';\n/** @private */\nconst NEXT_DATE_CLASS = 'e-next';\n/** @private */\nconst TRANSLATE_CLASS = 'e-translate';\n/** @private */\nconst LEFT_INDENT_CLASS = 'e-left-indent';\n/** @private */\nconst LEFT_INDENT_WRAP_CLASS = 'e-left-indent-wrap';\n/** @private */\nconst EVENT_TABLE_CLASS = 'e-event-table';\n/** @private */\nconst RESOURCE_LEFT_TD_CLASS = 'e-resource-left-td';\n/** @private */\nconst RESOURCE_GROUP_CELLS_CLASS = 'e-resource-group-cells';\n/** @private */\nconst RESOURCE_TEXT_CLASS = 'e-resource-text';\n/** @private */\nconst RESOURCE_COLUMN_WRAP_CLASS = 'e-resource-column-wrap';\n/** @private */\nconst RESOURCE_COLUMN_TABLE_CLASS = 'e-resource-column-table';\n/** @private */\nconst RESOURCE_CHILD_CLASS = 'e-child-node';\n/** @private */\nconst RESOURCE_PARENT_CLASS = 'e-parent-node';\n/** @private */\nconst RESOURCE_EXPAND_CLASS = 'e-resource-expand';\n/** @private */\nconst RESOURCE_COLLAPSE_CLASS = 'e-resource-collapse';\n/** @private */\nconst RESOURCE_TREE_ICON_CLASS = 'e-resource-tree-icon';\n/** @private */\nconst RESOURCE_CELLS_CLASS = 'e-resource-cells';\n/** @private */\nconst TIME_CELLS_WRAP_CLASS = 'e-time-cells-wrap';\n/** @private */\nconst TIME_CELLS_CLASS = 'e-time-cells';\n/** @private */\nconst TIME_SLOT_CLASS = 'e-time-slots';\n/** @private */\nconst ALTERNATE_CELLS_CLASS = 'e-alternate-cells';\n/** @private */\nconst CURRENT_TIME_CLASS = 'e-current-time';\n/** @private */\nconst CURRENT_TIMELINE_CLASS = 'e-current-timeline';\n/** @private */\nconst PREVIOUS_TIMELINE_CLASS = 'e-previous-timeline';\n/** @private */\nconst HIDE_CHILDS_CLASS = 'e-hide-childs';\n/** @private */\nconst SCROLL_CONTAINER_CLASS = 'e-scroll-container';\n/** @private */\n\n/** @private */\nconst TIMELINE_WRAPPER_CLASS = 'e-timeline-wrapper';\n/** @private */\nconst APPOINTMENT_WRAPPER_CLASS = 'e-appointment-wrapper';\n/** @private */\nconst DAY_WRAPPER_CLASS = 'e-day-wrapper';\n/** @private */\nconst TOOLBAR_CONTAINER = 'e-schedule-toolbar-container';\n/** @private */\nconst RESOURCE_TOOLBAR_CONTAINER = 'e-schedule-resource-toolbar-container';\n/** @private */\nconst HEADER_TOOLBAR = 'e-schedule-toolbar';\n/** @private */\nconst RESOURCE_HEADER_TOOLBAR = 'e-schedule-resource-toolbar';\n/** @private */\nconst SELECTED_CELL_CLASS = 'e-selected-cell';\n/** @private */\nconst WEEK_NUMBER_WRAPPER_CLASS = 'e-week-number-wrapper';\n/** @private */\nconst WEEK_NUMBER_CLASS = 'e-week-number';\n/** @private */\nconst APPOINTMENT_WRAP_CLASS = 'e-appointment-wrap';\n/** @private */\nconst WRAPPER_CONTAINER_CLASS = 'e-wrapper-container';\n/** @private */\nconst APPOINTMENT_CONTAINER_CLASS = 'e-appointment-container';\n/** @private */\nconst APPOINTMENT_CLASS = 'e-appointment';\n/** @private */\nconst BLOCK_APPOINTMENT_CLASS = 'e-block-appointment';\n/** @private */\nconst BLOCK_INDICATOR_CLASS = 'e-block-indicator';\n/** @private */\nconst APPOINTMENT_BORDER = 'e-appointment-border';\n/** @private */\nconst APPOINTMENT_DETAILS = 'e-appointment-details';\n/** @private */\nconst SUBJECT_WRAP = 'e-subject-wrap';\n/** @private */\nconst RESOURCE_NAME = 'e-resource-name';\n/** @private */\nconst APPOINTMENT_TIME = 'e-time';\n/** @private */\nconst TABLE_WRAP_CLASS = 'e-table-wrap';\n/** @private */\nconst OUTER_TABLE_CLASS = 'e-outer-table';\n/** @private */\nconst CONTENT_WRAP_CLASS = 'e-content-wrap';\n/** @private */\nconst VIRTUAL_TRACK_CLASS = 'e-virtual-track';\n/** @private */\nconst AGENDA_CELLS_CLASS = 'e-agenda-cells';\n/** @private */\nconst AGENDA_CURRENT_DAY_CLASS = 'e-current-day';\n/** @private */\nconst AGENDA_SELECTED_CELL = 'e-active-appointment-agenda';\n/** @private */\nconst MONTH_HEADER_CLASS = 'e-month-header';\n/** @private */\nconst AGENDA_HEADER_CLASS = 'e-day-date-header';\n/** @private */\nconst AGENDA_RESOURCE_CLASS = 'e-resource-column';\n/** @private */\nconst AGENDA_DATE_CLASS = 'e-date-column';\n/** @private */\nconst NAVIGATE_CLASS = 'e-navigate';\n/** @private */\nconst DATE_HEADER_CLASS = 'e-date-header';\n/** @private */\nconst AGENDA_DAY_BORDER_CLASS = 'e-day-border';\n/** @private */\nconst DATE_BORDER_CLASS = 'e-date-border';\n/** @private */\nconst AGENDA_DAY_PADDING_CLASS = 'e-day-padding';\n/** @private */\nconst DATE_TIME_CLASS = 'e-date-time';\n/** @private */\nconst DATE_TIME_WRAPPER_CLASS = 'e-date-time-wrapper';\n/** @private */\nconst AGENDA_EMPTY_EVENT_CLASS = 'e-empty-event';\n/** @private */\nconst AGENDA_NO_EVENT_CLASS = 'e-no-event';\n/** @private */\nconst APPOINTMENT_INDICATOR_CLASS = 'e-appointment-indicator';\n/** @private */\nconst EVENT_INDICATOR_CLASS = 'e-indicator';\n/** @private */\nconst EVENT_ICON_UP_CLASS = 'e-up-icon';\n/** @private */\nconst EVENT_ICON_DOWN_CLASS = 'e-down-icon';\n/** @private */\nconst EVENT_ICON_LEFT_CLASS = 'e-left-icon';\n/** @private */\nconst EVENT_ICON_RIGHT_CLASS = 'e-right-icon';\n/** @private */\nconst EVENT_ACTION_CLASS = 'e-event-action';\n/** @private */\nconst NEW_EVENT_CLASS = 'e-new-event';\n/** @private */\nconst CLONE_ELEMENT_CLASS = 'e-schedule-event-clone';\n/** @private */\nconst MONTH_CLONE_ELEMENT_CLASS = 'e-month-event';\n/** @private */\nconst CLONE_TIME_INDICATOR_CLASS = 'e-clone-time-indicator';\n/** @private */\nconst DRAG_CLONE_CLASS = 'e-drag-clone';\n/** @private */\nconst EVENT_RESIZE_CLASS = 'e-event-resize';\n/** @private */\nconst RESIZE_CLONE_CLASS = 'e-resize-clone';\n/** @private */\nconst LEFT_RESIZE_HANDLER = 'e-left-handler';\n/** @private */\nconst RIGHT_RESIZE_HANDLER = 'e-right-handler';\n/** @private */\nconst TOP_RESIZE_HANDLER = 'e-top-handler';\n/** @private */\nconst BOTTOM_RESIZE_HANDLER = 'e-bottom-handler';\n/** @private */\nconst EVENT_RECURRENCE_ICON_CLASS = 'e-recurrence-icon';\n/** @private */\nconst EVENT_RECURRENCE_EDIT_ICON_CLASS = 'e-recurrence-edit-icon';\n/** @private */\nconst HEADER_ROW_CLASS = 'e-header-row';\n/** @private */\nconst ALLDAY_APPOINTMENT_WRAPPER_CLASS = 'e-all-day-appointment-wrapper';\n/** @private */\nconst ALLDAY_APPOINTMENT_CLASS = 'e-all-day-appointment';\n/** @private */\nconst EVENT_COUNT_CLASS = 'e-appointment-hide';\n/** @private */\nconst ROW_COUNT_WRAPPER_CLASS = 'e-row-count-wrapper';\n/** @private */\nconst ALLDAY_APPOINTMENT_SECTION_CLASS = 'e-all-day-appointment-section';\n/** @private */\nconst APPOINTMENT_ROW_EXPAND_CLASS = 'e-appointment-expand';\n/** @private */\nconst APPOINTMENT_ROW_COLLAPSE_CLASS = 'e-appointment-collapse';\n/** @private */\nconst MORE_INDICATOR_CLASS = 'e-more-indicator';\n/** @private */\nconst CELL_POPUP_CLASS = 'e-cell-popup';\n/** @private */\nconst EVENT_POPUP_CLASS = 'e-event-popup';\n/** @private */\nconst MULTIPLE_EVENT_POPUP_CLASS = 'e-multiple-event-popup';\n/** @private */\nconst POPUP_HEADER_CLASS = 'e-popup-header';\n/** @private */\nconst POPUP_HEADER_ICON_WRAPPER = 'e-header-icon-wrapper';\n/** @private */\nconst POPUP_CONTENT_CLASS = 'e-popup-content';\n/** @private */\nconst POPUP_FOOTER_CLASS = 'e-popup-footer';\n/** @private */\nconst DATE_TIME_DETAILS_CLASS = 'e-date-time-details';\n/** @private */\nconst RECURRENCE_SUMMARY_CLASS = 'e-recurrence-summary';\n/** @private */\nconst QUICK_POPUP_EVENT_DETAILS_CLASS = 'e-event-details';\n/** @private */\nconst EVENT_CREATE_CLASS = 'e-event-create';\n/** @private */\nconst EDIT_EVENT_CLASS = 'e-event-edit';\n/** @private */\nconst DELETE_EVENT_CLASS = 'e-event-delete';\n/** @private */\nconst TEXT_ELLIPSIS = 'e-text-ellipsis';\n/** @private */\nconst MORE_POPUP_WRAPPER_CLASS = 'e-more-popup-wrapper';\n/** @private */\nconst MORE_EVENT_POPUP_CLASS = 'e-more-event-popup';\n/** @private */\nconst MORE_EVENT_HEADER_CLASS = 'e-more-event-header';\n/** @private */\nconst MORE_EVENT_DATE_HEADER_CLASS = 'e-more-event-date-header';\n/** @private */\nconst MORE_EVENT_HEADER_DAY_CLASS = 'e-header-day';\n/** @private */\nconst MORE_EVENT_HEADER_DATE_CLASS = 'e-header-date';\n/** @private */\nconst MORE_EVENT_CLOSE_CLASS = 'e-more-event-close';\n/** @private */\nconst MORE_EVENT_CONTENT_CLASS = 'e-more-event-content';\n/** @private */\nconst MORE_EVENT_WRAPPER_CLASS = 'e-more-appointment-wrapper';\n/** @private */\nconst QUICK_DIALOG_CLASS = 'e-quick-dialog';\n/** @private */\nconst QUICK_DIALOG_OCCURRENCE_CLASS = 'e-quick-dialog-occurrence-event';\n/** @private */\nconst QUICK_DIALOG_SERIES_CLASS = 'e-quick-dialog-series-event';\n/** @private */\nconst QUICK_DIALOG_FOLLOWING_EVENTS_CLASS = 'e-quick-dialog-following-events';\n/** @private */\nconst FOLLOWING_EVENTS_DIALOG = 'e-following-events-dialog';\n/** @private */\nconst QUICK_DIALOG_DELETE_CLASS = 'e-quick-dialog-delete';\n/** @private */\nconst QUICK_DIALOG_CANCEL_CLASS = 'e-quick-dialog-cancel';\n/** @private */\nconst QUICK_DIALOG_ALERT_OK = 'e-quick-alertok';\n/** @private */\nconst QUICK_DIALOG_ALERT_CANCEL = 'e-quick-alertcancel';\n/** @private */\nconst QUICK_DIALOG_ALERT_FOLLOWING = 'e-quick-alertfollowing';\n/** @private */\nconst QUICK_DIALOG_ALERT_BTN_CLASS = 'e-quick-dialog-alert-btn';\n/** @private */\nconst EVENT_WINDOW_DIALOG_CLASS = 'e-schedule-dialog';\n/** @private */\nconst FORM_CONTAINER_CLASS = 'e-form-container';\n/** @private */\nconst FORM_CLASS = 'e-schedule-form';\n/** @private */\nconst EVENT_WINDOW_ALLDAY_TZ_DIV_CLASS = 'e-all-day-time-zone-row';\n/** @private */\nconst EVENT_WINDOW_ALL_DAY_CLASS = 'e-all-day';\n/** @private */\nconst TIME_ZONE_CLASS = 'e-time-zone';\n/** @private */\nconst TIME_ZONE_ICON_CLASS = 'e-time-zone-icon';\n/** @private */\nconst TIME_ZONE_DETAILS_CLASS = 'e-time-zone-details';\n/** @private */\nconst EVENT_WINDOW_REPEAT_DIV_CLASS = 'e-repeat-parent-row';\n/** @private */\nconst EVENT_WINDOW_REPEAT_CLASS = 'e-repeat';\n/** @private */\nconst EVENT_WINDOW_TITLE_LOCATION_DIV_CLASS = 'e-title-location-row';\n/** @private */\nconst SUBJECT_CLASS = 'e-subject';\n/** @private */\nconst LOCATION_CLASS = 'e-location';\n/** @private */\nconst LOCATION_ICON_CLASS = 'e-location-icon';\n/** @private */\nconst LOCATION_DETAILS_CLASS = 'e-location-details';\n/** @private */\nconst EVENT_WINDOW_START_END_DIV_CLASS = 'e-start-end-row';\n/** @private */\nconst EVENT_WINDOW_START_CLASS = 'e-start';\n/** @private */\nconst EVENT_WINDOW_END_CLASS = 'e-end';\n/** @private */\nconst EVENT_WINDOW_RESOURCES_DIV_CLASS = 'e-resources-row';\n/** @private */\nconst DESCRIPTION_CLASS = 'e-description';\n/** @private */\nconst DESCRIPTION_ICON_CLASS = 'e-description-icon';\n/** @private */\nconst DESCRIPTION_DETAILS_CLASS = 'e-description-details';\n/** @private */\nconst EVENT_WINDOW_TIME_ZONE_DIV_CLASS = 'e-time-zone-row';\n/** @private */\nconst EVENT_WINDOW_START_TZ_CLASS = 'e-start-time-zone';\n/** @private */\nconst EVENT_WINDOW_END_TZ_CLASS = 'e-end-time-zone';\n/** @private */\nconst EVENT_WINDOW_BACK_ICON_CLASS = 'e-back-icon';\n/** @private */\nconst EVENT_WINDOW_SAVE_ICON_CLASS = 'e-save-icon';\n/** @private */\nconst EVENT_WINDOW_CANCEL_BUTTON_CLASS = 'e-event-cancel';\n/** @private */\nconst EVENT_WINDOW_SAVE_BUTTON_CLASS = 'e-event-save';\n/** @private */\nconst EVENT_WINDOW_DIALOG_PARENT_CLASS = 'e-dialog-parent';\n/** @private */\nconst EVENT_WINDOW_TITLE_TEXT_CLASS = 'e-title-text';\n/** @private */\nconst EVENT_WINDOW_ICON_DISABLE_CLASS = 'e-icon-disable';\n/** @private */\nconst EDIT_CLASS = 'e-edit';\n/** @private */\nconst EDIT_ICON_CLASS = 'e-edit-icon';\n/** @private */\nconst DELETE_CLASS = 'e-delete';\n/** @private */\nconst DELETE_ICON_CLASS = 'e-delete-icon';\n/** @private */\nconst CLOSE_CLASS = 'e-close';\n/** @private */\nconst CLOSE_ICON_CLASS = 'e-close-icon';\n/** @private */\nconst ERROR_VALIDATION_CLASS = 'e-schedule-error';\n/** @private */\nconst EVENT_TOOLTIP_ROOT_CLASS = 'e-schedule-event-tooltip';\n/** @private */\nconst ALLDAY_ROW_ANIMATE_CLASS = 'e-animate';\n/** @private */\nconst TIMESCALE_DISABLE = 'e-timescale-disable';\n/** @private */\nconst DISABLE_DATE = 'e-disable-date';\n/** @private */\nconst HIDDEN_CLASS = 'e-hidden';\n/** @private */\nconst DISABLE_DATES = 'e-disable-dates';\n/** @private */\nconst POPUP_WRAPPER_CLASS = 'e-quick-popup-wrapper';\n/** @private */\nconst POPUP_TABLE_CLASS = 'e-popup-table';\n/** @private */\nconst RESOURCE_MENU = 'e-resource-menu';\n/** @private */\nconst RESOURCE_MENU_ICON = 'e-icon-menu';\n/** @private */\nconst RESOURCE_LEVEL_TITLE = 'e-resource-level-title';\n/** @private */\nconst RESOURCE_TREE = 'e-resource-tree';\n/** @private */\nconst RESOURCE_TREE_POPUP_OVERLAY = 'e-resource-tree-popup-overlay';\n/** @private */\nconst RESOURCE_TREE_POPUP = 'e-resource-tree-popup';\n/** @private */\nconst RESOURCE_CLASS = 'e-resource';\n/** @private */\nconst RESOURCE_ICON_CLASS = 'e-resource-icon';\n/** @private */\nconst RESOURCE_DETAILS_CLASS = 'e-resource-details';\n/** @private */\nconst DATE_TIME_ICON_CLASS = 'e-date-time-icon';\n/** @private */\nconst VIRTUAL_SCROLL_CLASS = 'e-virtual-scroll';\n/** @private */\nconst ICON_DISABLE_CLASS = 'e-icon-disable';\n/** @private */\nconst AUTO_HEIGHT = 'e-auto-height';\n/** @private */\nconst IGNORE_WHITESPACE = 'e-ignore-whitespace';\n/** @private */\nconst EVENT_TEMPLATE = 'e-template';\n/** @private */\nconst READ_ONLY = 'e-read-only';\n/** @private */\nconst MONTH_HEADER_WRAPPER = 'e-month-header-wrapper';\n/** @private */\nconst INLINE_SUBJECT_CLASS = 'e-inline-subject';\n/** @private */\nconst INLINE_APPOINTMENT_CLASS = 'e-inline-appointment';\n/** @hidden */\nconst SCROLL_HIDDEN = 'e-scroll-hidden';\n/** @private */\nconst ALLDAY_APPOINTMENT_SCROLL = 'e-all-day-scroll';\n/** @private */\nconst ALLDAY_APPOINTMENT_AUTO = 'e-all-day-auto';\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Header module\n */\nclass HeaderRenderer {\n  constructor(parent) {\n    this.parent = parent;\n    this.l10n = this.parent.localeObj;\n    this.renderHeader();\n    this.addEventListener();\n  }\n  addEventListener() {\n    this.parent.on(documentClick, this.closeHeaderPopup, this);\n  }\n  removeEventListener() {\n    this.parent.off(documentClick, this.closeHeaderPopup);\n  }\n  closeHeaderPopup(e) {\n    const closestEle = closest(e.event.target, '.e-date-range,.e-header-popup,.e-day,.e-selected');\n    const closestPop = closest(e.event.target, '.e-hor-nav,.e-toolbar-pop');\n    const contentWrap = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS);\n    if (this.parent.isAdaptive) {\n      if (!isNullOrUndefined(closestPop) && (closestPop.classList.contains('e-toolbar-pop') || closestPop.classList.contains('e-hor-nav')) && !(closestPop.classList.contains('e-hor-nav') && this.element.querySelector('.e-toolbar-pop').classList.contains(POPUP_OPEN))) {\n        addClass([contentWrap], SCROLL_HIDDEN);\n      } else {\n        removeClass([contentWrap], SCROLL_HIDDEN);\n        const popupEle = this.element.querySelector('.e-toolbar-pop');\n        if (!isNullOrUndefined(popupEle)) {\n          const popupObj = popupEle.ej2_instances[0];\n          if (popupObj && !(!isNullOrUndefined(closestPop) && closestPop.classList.contains('e-hor-nav') && popupEle.classList.contains(POPUP_OPEN))) {\n            popupObj.hide();\n          }\n        }\n      }\n    }\n    if (!isNullOrUndefined(closestEle)) {\n      return;\n    }\n    this.hideHeaderPopup();\n  }\n  hideHeaderPopup() {\n    if (this.headerPopup) {\n      this.headerPopup.hide();\n    }\n  }\n  renderHeader() {\n    this.element = createElement('div', {\n      className: TOOLBAR_CONTAINER\n    });\n    const toolbarEle = createElement('div', {\n      className: HEADER_TOOLBAR\n    });\n    this.element.appendChild(toolbarEle);\n    this.parent.element.insertBefore(this.element, this.parent.element.firstElementChild);\n    this.renderToolbar();\n  }\n  renderToolbar() {\n    const items = this.getItems();\n    this.parent.trigger(actionBegin, {\n      requestType: 'toolbarItemRendering',\n      items: items\n    }, args => {\n      this.toolbarObj = new Toolbar({\n        items: args.items,\n        overflowMode: 'Popup',\n        clicked: this.toolbarClickHandler.bind(this),\n        enableRtl: this.parent.enableRtl,\n        locale: this.parent.locale\n      });\n      this.toolbarObj.appendTo(this.parent.element.querySelector('.' + HEADER_TOOLBAR));\n      const prevNavEle = this.toolbarObj.element.querySelector('.e-prev');\n      if (prevNavEle) {\n        prevNavEle.firstElementChild.setAttribute('title', this.l10n.getConstant('previous'));\n      }\n      const nextNavEle = this.toolbarObj.element.querySelector('.e-next');\n      if (nextNavEle) {\n        nextNavEle.firstElementChild.setAttribute('title', this.l10n.getConstant('next'));\n      }\n      this.updateAddIcon();\n      this.updateActiveView();\n      this.parent.trigger(actionComplete, {\n        requestType: 'toolBarItemRendered',\n        items: this.toolbarObj.items\n      });\n    });\n  }\n  updateItems() {\n    if (this.toolbarObj) {\n      const items = this.getItems();\n      this.parent.trigger(actionBegin, {\n        requestType: 'toolbarItemRendering',\n        items: items\n      }, args => {\n        this.toolbarObj.items = args.items;\n        this.toolbarObj.dataBind();\n        this.parent.trigger(actionComplete, {\n          requestType: 'toolBarItemRendered',\n          items: this.toolbarObj.items\n        });\n      });\n    }\n  }\n  getPopUpRelativeElement() {\n    if (this.parent.isAdaptive) {\n      return this.toolbarObj.element;\n    }\n    return this.element.querySelector('.e-date-range');\n  }\n  setDayOfWeek(index) {\n    if (this.headerCalendar) {\n      this.headerCalendar.firstDayOfWeek = index;\n      this.headerCalendar.dataBind();\n    }\n  }\n  setCalendarDate(date) {\n    if (this.headerCalendar) {\n      this.headerCalendar.value = date;\n      this.headerCalendar.dataBind();\n    }\n  }\n  setCalendarMinMaxDate() {\n    if (this.headerCalendar) {\n      this.headerCalendar.min = this.parent.minDate;\n      this.headerCalendar.max = this.parent.maxDate;\n      this.headerCalendar.dataBind();\n    }\n  }\n  getCalendarView() {\n    if (['Month', 'MonthAgenda', 'TimelineMonth'].indexOf(this.parent.currentView) > -1) {\n      return 'Year';\n    } else if (['Year', 'TimelineYear'].indexOf(this.parent.currentView) > -1) {\n      return 'Decade';\n    } else {\n      return 'Month';\n    }\n  }\n  setCalendarView() {\n    if (this.headerCalendar) {\n      const calendarView = this.getCalendarView();\n      this.headerCalendar.depth = calendarView;\n      this.headerCalendar.start = calendarView;\n      this.headerCalendar.refresh();\n    }\n  }\n  updateActiveView() {\n    const selEle = [].slice.call(this.toolbarObj.element.querySelectorAll('.e-views'));\n    removeClass(selEle, ['e-active-view']);\n    if (selEle.length > 0 && selEle[this.parent.viewIndex]) {\n      addClass([selEle[this.parent.viewIndex]], ['e-active-view']);\n    }\n  }\n  updateDateRange(text) {\n    const selEle = this.toolbarObj.element.querySelector('.e-date-range');\n    if (selEle) {\n      selEle.setAttribute('aria-label', text);\n      selEle.querySelector('.e-tbar-btn-text').innerHTML = text;\n      this.refresh();\n    }\n  }\n  refresh() {\n    if (this.toolbarObj) {\n      this.toolbarObj.refreshOverflow();\n    }\n  }\n  updateAddIcon() {\n    const addEle = this.toolbarObj.element.querySelector('.e-add');\n    if (addEle) {\n      if (!this.parent.eventSettings.allowAdding) {\n        addClass([addEle], HIDDEN_CLASS);\n      } else {\n        removeClass([addEle], HIDDEN_CLASS);\n      }\n    }\n  }\n  getDateRangeText() {\n    const dateString = this.parent.globalize.formatDate(this.parent.selectedDate, {\n      format: 'MMMM y',\n      calendar: this.parent.getCalendarMode()\n    });\n    return capitalizeFirstWord(dateString, 'single');\n  }\n  getItems() {\n    const items = [];\n    items.push({\n      align: 'Left',\n      prefixIcon: 'e-icon-prev',\n      tooltipText: 'Previous',\n      overflow: 'Show',\n      cssClass: 'e-prev',\n      htmlAttributes: {\n        'aria-label': 'previous period',\n        'role': 'navigation'\n      }\n    });\n    items.push({\n      align: 'Left',\n      prefixIcon: 'e-icon-next',\n      tooltipText: 'Next',\n      overflow: 'Show',\n      cssClass: 'e-next',\n      htmlAttributes: {\n        'aria-label': 'next period',\n        'role': 'navigation'\n      }\n    });\n    items.push({\n      align: 'Left',\n      text: this.getDateRangeText(),\n      suffixIcon: 'e-icon-down-arrow',\n      cssClass: 'e-date-range',\n      overflow: 'Show',\n      htmlAttributes: {\n        'aria-atomic': 'true',\n        'aria-live': 'assertive',\n        'aria-label': 'title',\n        'role': 'navigation'\n      }\n    });\n    if (this.parent.isAdaptive || this.parent.enableAdaptiveUI) {\n      items.push({\n        align: 'Right',\n        showAlwaysInPopup: this.parent.isAdaptive || this.parent.enableAdaptiveUI,\n        prefixIcon: 'e-icon-add',\n        text: this.l10n.getConstant('newEvent'),\n        cssClass: 'e-add',\n        overflow: 'Show'\n      });\n      items.push({\n        align: 'Right',\n        showAlwaysInPopup: this.parent.isAdaptive || this.parent.enableAdaptiveUI,\n        prefixIcon: 'e-icon-today',\n        text: this.l10n.getConstant('today'),\n        cssClass: 'e-today',\n        overflow: 'Show'\n      });\n    } else {\n      items.push({\n        align: 'Right',\n        showAlwaysInPopup: this.parent.isAdaptive || this.parent.enableAdaptiveUI,\n        prefixIcon: 'e-icon-day',\n        text: this.l10n.getConstant('today'),\n        cssClass: 'e-today',\n        overflow: 'Show'\n      });\n      if (this.parent.views.length > 1) {\n        items.push({\n          align: 'Right',\n          type: 'Separator',\n          cssClass: 'e-schedule-seperator'\n        });\n      }\n    }\n    if (this.parent.views.length > 1) {\n      for (const item of this.parent.views) {\n        items.push(this.getItemObject(item));\n      }\n    }\n    return items;\n  }\n  getItemObject(item) {\n    let viewName;\n    let displayName;\n    if (typeof item === 'string') {\n      viewName = item.toLowerCase();\n      displayName = null;\n    } else {\n      viewName = item.option.toLowerCase();\n      displayName = item.displayName;\n    }\n    let view;\n    let orientationClass;\n    const isItemInsidePopup = this.parent.isAdaptive || this.parent.enableAdaptiveUI;\n    switch (viewName) {\n      case 'day':\n        view = {\n          align: 'Right',\n          showAlwaysInPopup: isItemInsidePopup,\n          prefixIcon: 'e-icon-day',\n          text: displayName || this.l10n.getConstant('day'),\n          cssClass: 'e-views e-day'\n        };\n        break;\n      case 'week':\n        view = {\n          align: 'Right',\n          showAlwaysInPopup: isItemInsidePopup,\n          prefixIcon: 'e-icon-week',\n          text: displayName || this.l10n.getConstant('week'),\n          cssClass: 'e-views e-week'\n        };\n        break;\n      case 'workweek':\n        view = {\n          align: 'Right',\n          showAlwaysInPopup: isItemInsidePopup,\n          prefixIcon: 'e-icon-workweek',\n          text: displayName || this.l10n.getConstant('workWeek'),\n          cssClass: 'e-views e-work-week'\n        };\n        break;\n      case 'month':\n        view = {\n          align: 'Right',\n          showAlwaysInPopup: isItemInsidePopup,\n          prefixIcon: 'e-icon-month',\n          text: displayName || this.l10n.getConstant('month'),\n          cssClass: 'e-views e-month'\n        };\n        break;\n      case 'year':\n        view = {\n          align: 'Right',\n          showAlwaysInPopup: isItemInsidePopup,\n          prefixIcon: 'e-icon-year',\n          text: displayName || this.l10n.getConstant('year'),\n          cssClass: 'e-views e-year'\n        };\n        break;\n      case 'agenda':\n        view = {\n          align: 'Right',\n          showAlwaysInPopup: isItemInsidePopup,\n          prefixIcon: 'e-icon-agenda',\n          text: displayName || this.l10n.getConstant('agenda'),\n          cssClass: 'e-views e-agenda'\n        };\n        break;\n      case 'monthagenda':\n        view = {\n          align: 'Right',\n          showAlwaysInPopup: isItemInsidePopup,\n          prefixIcon: 'e-icon-month-agenda',\n          text: displayName || this.l10n.getConstant('monthAgenda'),\n          cssClass: 'e-views e-month-agenda'\n        };\n        break;\n      case 'timelineday':\n        view = {\n          align: 'Right',\n          showAlwaysInPopup: isItemInsidePopup,\n          prefixIcon: 'e-icon-timeline-day',\n          text: displayName || this.l10n.getConstant('timelineDay'),\n          cssClass: 'e-views e-timeline-day'\n        };\n        break;\n      case 'timelineweek':\n        view = {\n          align: 'Right',\n          showAlwaysInPopup: isItemInsidePopup,\n          prefixIcon: 'e-icon-timeline-week',\n          text: displayName || this.l10n.getConstant('timelineWeek'),\n          cssClass: 'e-views e-timeline-week'\n        };\n        break;\n      case 'timelineworkweek':\n        view = {\n          align: 'Right',\n          showAlwaysInPopup: isItemInsidePopup,\n          prefixIcon: 'e-icon-timeline-workweek',\n          text: displayName || this.l10n.getConstant('timelineWorkWeek'),\n          cssClass: 'e-views e-timeline-work-week'\n        };\n        break;\n      case 'timelinemonth':\n        view = {\n          align: 'Right',\n          showAlwaysInPopup: isItemInsidePopup,\n          prefixIcon: 'e-icon-timeline-month',\n          text: displayName || this.l10n.getConstant('timelineMonth'),\n          cssClass: 'e-views e-timeline-month'\n        };\n        break;\n      case 'timelineyear':\n        orientationClass = item.orientation === 'Vertical' ? 'vertical' : 'horizontal';\n        view = {\n          align: 'Right',\n          showAlwaysInPopup: isItemInsidePopup,\n          prefixIcon: 'e-icon-timeline-year-' + orientationClass,\n          text: displayName || this.l10n.getConstant('timelineYear'),\n          cssClass: 'e-views e-timeline-year'\n        };\n        break;\n    }\n    return view;\n  }\n  renderHeaderPopup() {\n    const headerPopupEle = createElement('div', {\n      className: HEADER_POPUP_CLASS\n    });\n    const headerCalendarEle = createElement('div', {\n      className: HEADER_CALENDAR_CLASS\n    });\n    headerPopupEle.appendChild(headerCalendarEle);\n    this.element.appendChild(headerPopupEle);\n    this.headerPopup = new Popup(headerPopupEle, {\n      actionOnScroll: 'hide',\n      targetType: 'relative',\n      relateTo: this.getPopUpRelativeElement(),\n      position: {\n        X: 'left',\n        Y: 'bottom'\n      },\n      enableRtl: this.parent.enableRtl\n    });\n    const calendarView = this.getCalendarView();\n    const isDisplayDate = this.parent.currentView === 'Month' && !isNullOrUndefined(this.parent.activeViewOptions.displayDate) && !this.hasSelectedDate();\n    this.headerCalendar = new Calendar({\n      value: isDisplayDate ? this.parent.activeViewOptions.displayDate : this.parent.selectedDate,\n      min: this.parent.minDate,\n      max: this.parent.maxDate,\n      firstDayOfWeek: this.parent.activeViewOptions.firstDayOfWeek,\n      enableRtl: this.parent.enableRtl,\n      locale: this.parent.locale,\n      depth: calendarView,\n      start: calendarView,\n      calendarMode: this.parent.calendarMode,\n      change: this.calendarChange.bind(this)\n    });\n    this.setCalendarTimezone();\n    this.headerCalendar.appendTo(headerCalendarEle);\n    this.headerPopup.hide();\n  }\n  calendarChange(args) {\n    if (args.value.getTime() !== this.parent.selectedDate.getTime()) {\n      const calendarDate = resetTime(new Date(args.value));\n      this.parent.changeDate(calendarDate);\n    }\n    this.headerPopup.hide();\n  }\n  setCalendarTimezone() {\n    if (this.headerCalendar) {\n      this.headerCalendar.timezone = this.parent.timezone || this.parent.tzModule.getLocalTimezoneName();\n    }\n  }\n  calculateViewIndex(args) {\n    const target = closest(args.originalEvent.target, '.e-views');\n    const views = [].slice.call(this.element.querySelectorAll('.e-views'));\n    return views.indexOf(target);\n  }\n  toolbarClickHandler(args) {\n    if (!args.item) {\n      return;\n    }\n    const strClass = args.item.cssClass.replace('e-views ', '');\n    let data;\n    let isSameTime;\n    let currentTime;\n    switch (strClass) {\n      case 'e-date-range':\n        if (!this.headerPopup) {\n          this.renderHeaderPopup();\n        }\n        if (this.headerPopup.element.classList.contains(POPUP_OPEN)) {\n          this.headerPopup.hide();\n        } else {\n          this.headerPopup.show();\n        }\n        break;\n      case 'e-day':\n        this.parent.changeView('Day', args.originalEvent, undefined, this.calculateViewIndex(args));\n        break;\n      case 'e-week':\n        this.parent.changeView('Week', args.originalEvent, undefined, this.calculateViewIndex(args));\n        break;\n      case 'e-work-week':\n        this.parent.changeView('WorkWeek', args.originalEvent, undefined, this.calculateViewIndex(args));\n        break;\n      case 'e-month':\n        this.parent.changeView('Month', args.originalEvent, undefined, this.calculateViewIndex(args));\n        break;\n      case 'e-year':\n        this.parent.changeView('Year', args.originalEvent, undefined, this.calculateViewIndex(args));\n        break;\n      case 'e-agenda':\n        this.parent.changeView('Agenda', args.originalEvent, undefined, this.calculateViewIndex(args));\n        break;\n      case 'e-month-agenda':\n        this.parent.changeView('MonthAgenda', args.originalEvent, undefined, this.calculateViewIndex(args));\n        break;\n      case 'e-timeline-day':\n        this.parent.changeView('TimelineDay', args.originalEvent, undefined, this.calculateViewIndex(args));\n        break;\n      case 'e-timeline-week':\n        this.parent.changeView('TimelineWeek', args.originalEvent, undefined, this.calculateViewIndex(args));\n        break;\n      case 'e-timeline-work-week':\n        this.parent.changeView('TimelineWorkWeek', args.originalEvent, undefined, this.calculateViewIndex(args));\n        break;\n      case 'e-timeline-month':\n        this.parent.changeView('TimelineMonth', args.originalEvent, undefined, this.calculateViewIndex(args));\n        break;\n      case 'e-timeline-year':\n        this.parent.changeView('TimelineYear', args.originalEvent, undefined, this.calculateViewIndex(args));\n        break;\n      case 'e-today':\n        currentTime = resetTime(this.parent.getCurrentTime());\n        if (this.parent.currentView === 'Agenda' || this.parent.currentView === 'MonthAgenda' || !this.parent.isSelectedDate(currentTime) || this.parent.currentView === 'Month' && this.parent.activeViewOptions.displayDate && !this.hasSelectedDate() && resetTime(this.parent.activeViewOptions.displayDate) !== currentTime || this.parent.currentView === 'Month' && this.parent.activeViewOptions.numberOfWeeks > 0 && !this.hasSelectedDate() && resetTime(firstDateOfMonth(this.parent.selectedDate)) !== currentTime) {\n          this.parent.changeDate(currentTime, args.originalEvent);\n        }\n        break;\n      case 'e-prev':\n        this.parent.changeDate(this.parent.activeView.getNextPreviousDate('previous'), args.originalEvent);\n        break;\n      case 'e-next':\n        this.parent.changeDate(this.parent.activeView.getNextPreviousDate('next'), args.originalEvent);\n        break;\n      case 'e-add':\n        isSameTime = this.parent.activeCellsData.startTime.getTime() === this.parent.activeCellsData.endTime.getTime();\n        if (this.parent.activeCellsData && !isSameTime) {\n          data = this.parent.activeCellsData;\n        } else {\n          const interval = this.parent.activeViewOptions.timeScale.interval;\n          const slotCount = this.parent.activeViewOptions.timeScale.slotCount;\n          const msInterval = interval * MS_PER_MINUTE / slotCount;\n          const startTime = new Date(this.parent.selectedDate.getTime());\n          const currentTime = this.parent.getCurrentTime();\n          startTime.setHours(currentTime.getHours(), Math.round(startTime.getMinutes() / msInterval) * msInterval, 0);\n          const endTime = new Date(new Date(startTime.getTime()).setMilliseconds(startTime.getMilliseconds() + msInterval));\n          data = {\n            startTime: startTime,\n            endTime: endTime,\n            isAllDay: false\n          };\n        }\n        this.parent.eventWindow.openEditor(extend(data, {\n          cancel: false,\n          event: args.originalEvent\n        }), 'Add');\n        break;\n    }\n    if (isNullOrUndefined(this.toolbarObj)) {\n      return;\n    }\n    const toolbarPopUp = this.toolbarObj.element.querySelector('.e-toolbar-pop');\n    if (toolbarPopUp && args.item.type !== 'Input') {\n      toolbarPopUp.ej2_instances[0].hide({\n        name: 'SlideUp',\n        duration: 100\n      });\n    }\n  }\n  hasSelectedDate() {\n    const selectedTime = resetTime(this.parent.selectedDate).getTime();\n    return selectedTime >= this.parent.activeView.getStartDate().getTime() && selectedTime <= this.parent.activeView.getEndDate().getTime();\n  }\n  getHeaderElement() {\n    return this.toolbarObj.element;\n  }\n  updateHeaderItems(classType) {\n    const prevNavEle = this.toolbarObj.element.querySelector('.e-prev');\n    const nextNavEle = this.toolbarObj.element.querySelector('.e-next');\n    const dateRangeEle = this.toolbarObj.element.querySelector('.e-date-range');\n    if (prevNavEle) {\n      if (classType === 'add') {\n        addClass([prevNavEle], HIDDEN_CLASS);\n      } else {\n        removeClass([prevNavEle], HIDDEN_CLASS);\n      }\n    }\n    if (nextNavEle) {\n      if (classType === 'add') {\n        addClass([nextNavEle], HIDDEN_CLASS);\n      } else {\n        removeClass([nextNavEle], HIDDEN_CLASS);\n      }\n    }\n    if (dateRangeEle) {\n      if (classType === 'add') {\n        addClass([dateRangeEle], TEXT_ELLIPSIS);\n      } else {\n        removeClass([dateRangeEle], TEXT_ELLIPSIS);\n      }\n    }\n  }\n  previousNextIconHandler() {\n    const dates = this.parent.currentView === 'Agenda' ? [this.parent.getCurrentViewDates()[0]] : this.parent.getCurrentViewDates();\n    const prevNavEle = this.toolbarObj.element.querySelector('.' + PREVIOUS_DATE_CLASS);\n    const nextNavEle = this.toolbarObj.element.querySelector('.' + NEXT_DATE_CLASS);\n    let firstDate = new Date(dates[0].getTime());\n    let lastDate = new Date(dates[dates.length - 1].getTime());\n    if (this.parent.currentView === 'WorkWeek' || this.parent.currentView === 'TimelineWorkWeek') {\n      firstDate = getWeekFirstDate(resetTime(this.parent.selectedDate), this.parent.firstDayOfWeek);\n      lastDate = addDays(firstDate, 7 * this.parent.activeViewOptions.interval);\n    }\n    if (this.parent.currentView === 'Month') {\n      const isCustomMonth = !isNullOrUndefined(this.parent.activeViewOptions.displayDate) || this.parent.activeViewOptions.numberOfWeeks > 0;\n      firstDate = isCustomMonth ? this.parent.activeView.getStartDate() : firstDateOfMonth(this.parent.selectedDate);\n      lastDate = isCustomMonth ? this.parent.activeView.getEndDate() : lastDateOfMonth(addMonths(firstDate, this.parent.activeViewOptions.interval - 1));\n    }\n    if (!isNullOrUndefined(prevNavEle)) {\n      this.toolbarObj.enableItems(prevNavEle, firstDate > this.parent.minDate);\n    }\n    if (!isNullOrUndefined(nextNavEle)) {\n      this.toolbarObj.enableItems(nextNavEle, lastDate < this.parent.maxDate);\n    }\n    this.setCalendarMinMaxDate();\n  }\n  getModuleName() {\n    return 'headerbar';\n  }\n  destroy() {\n    if (this.headerPopup && !this.headerPopup.isDestroyed) {\n      this.headerPopup.destroy();\n      this.headerPopup = null;\n    }\n    if (this.headerCalendar && !this.headerCalendar.isDestroyed) {\n      this.headerCalendar.destroy();\n      this.headerCalendar = null;\n    }\n    if (this.toolbarObj && !this.toolbarObj.isDestroyed) {\n      this.toolbarObj.destroy();\n      this.removeEventListener();\n      remove(this.element);\n      this.toolbarObj = null;\n    }\n    this.element = null;\n    this.parent = null;\n    this.l10n = null;\n  }\n}\n\n/**\n * `Scroll` module\n */\nclass Scroll {\n  /**\n   * Constructor for the scrolling.\n   *\n   * @param {Schedule} parent Accepts the Schedule instance\n   */\n  constructor(parent) {\n    this.parent = parent;\n    this.addEventListener();\n  }\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} Returns the module name.\n   * @private\n   */\n  getModuleName() {\n    return 'scroll';\n  }\n  /**\n   * Internal method to set the element width\n   *\n   * @returns {void}\n   * @private\n   */\n  setWidth() {\n    this.parent.element.style.width = formatUnit(this.parent.width);\n  }\n  /**\n   * Internal method to set the element height\n   *\n   * @returns {void}\n   * @private\n   */\n  setHeight() {\n    this.parent.element.style.height = formatUnit(this.parent.height);\n  }\n  /**\n   * Internal method to bind events\n   *\n   * @returns {void}\n   * @private\n   */\n  addEventListener() {\n    this.parent.on(contentReady, this.setDimensions, this);\n    this.parent.on(uiUpdate, this.onPropertyChanged, this);\n  }\n  /**\n   * Internal method to unbind events\n   *\n   * @returns {void}\n   * @private\n   */\n  removeEventListener() {\n    this.parent.off(contentReady, this.setDimensions);\n    this.parent.off(uiUpdate, this.onPropertyChanged);\n  }\n  /**\n   * Internal method to set the dimensions\n   *\n   * @returns {void}\n   * @private\n   */\n  setDimensions() {\n    this.setWidth();\n    this.setHeight();\n    const data = {\n      cssProperties: this.parent.getCssProperties(),\n      module: this.getModuleName()\n    };\n    this.parent.notify(scrollUiUpdate, data);\n  }\n  /**\n   * Internal method to set the dimensions dynamically\n   *\n   * @returns {void}\n   * @private\n   */\n  onPropertyChanged() {\n    this.setDimensions();\n  }\n  /**\n   * Destroy the scroll module\n   *\n   * @returns {void}\n   * @private\n   */\n  destroy() {\n    this.removeEventListener();\n  }\n}\n\n/**\n * `touch` module is used to handle touch interactions.\n */\nclass ScheduleTouch {\n  constructor(parent) {\n    this.parent = parent;\n    this.element = this.parent.element.querySelector('.' + TABLE_CONTAINER_CLASS);\n    this.touchObj = new Touch(this.element, {\n      scroll: this.scrollHandler.bind(this),\n      swipe: this.swipeHandler.bind(this),\n      tapHold: this.tapHoldHandler.bind(this),\n      swipeSettings: {\n        swipeThresholdDistance: 1\n      }\n    });\n    EventHandler.add(this.element, 'transitionend', this.onTransitionEnd, this);\n    this.touchLeftDirection = this.parent.enableRtl ? 'Right' : 'Left';\n    this.touchRightDirection = this.parent.enableRtl ? 'Left' : 'Right';\n  }\n  scrollHandler(e) {\n    if (this.parent.currentView === 'Agenda' || this.parent.uiStateValues.action || e.originalEvent && (e.originalEvent.target.classList.contains(APPOINTMENT_CLASS) || closest(e.originalEvent.target, '.' + APPOINTMENT_CLASS))) {\n      return;\n    }\n    if (!this.timeStampStart) {\n      this.timeStampStart = Date.now();\n    }\n    if (this.element.classList.contains(TRANSLATE_CLASS)) {\n      this.onTransitionEnd();\n    }\n    if (e.scrollDirection === 'Left' || e.scrollDirection === 'Right') {\n      const args = {\n        requestType: 'dateNavigate',\n        cancel: false,\n        event: e.originalEvent\n      };\n      this.parent.trigger(actionBegin, args);\n      if (args.cancel) {\n        return;\n      }\n      const scrollDiv = this.element.querySelector('.' + CONTENT_WRAP_CLASS);\n      if (scrollDiv && scrollDiv.scrollWidth > scrollDiv.clientWidth) {\n        return;\n      } else {\n        this.isScrollTriggered = true;\n        e.originalEvent.preventDefault();\n        e.originalEvent.stopPropagation();\n      }\n    }\n    if (e.scrollDirection === this.touchLeftDirection) {\n      if (!this.nextPanel) {\n        this.renderPanel(NEXT_PANEL_CLASS, 'next');\n        this.nextPanel = {\n          element: this.parent.activeView.getPanel(),\n          selectedDate: new Date(this.parent.selectedDate.getTime())\n        };\n        this.setDimensions(this.nextPanel.element);\n      }\n      const x = this.parent.enableRtl ? e.distanceX : -e.distanceX;\n      this.element.style.transform = 'translatex(' + (this.getTranslateX(this.element) + x) + 'px)';\n    } else if (e.scrollDirection === this.touchRightDirection) {\n      let prevWidth = 0;\n      if (!this.previousPanel) {\n        this.renderPanel(PREVIOUS_PANEL_CLASS, 'previous');\n        this.previousPanel = {\n          element: this.parent.activeView.getPanel(),\n          selectedDate: new Date(this.parent.selectedDate.getTime())\n        };\n        this.setDimensions(this.previousPanel.element);\n        prevWidth = this.previousPanel.element.offsetWidth;\n      }\n      const x = this.parent.enableRtl ? prevWidth - e.distanceX : -prevWidth + e.distanceX;\n      this.element.style.transform = 'translatex(' + (this.getTranslateX(this.element) + x) + 'px)';\n    }\n  }\n  swipeHandler(e) {\n    if (!this.isScrollTriggered || this.parent.uiStateValues.action) {\n      return;\n    }\n    this.isScrollTriggered = false;\n    const swipeDate = e.swipeDirection === 'Left' ? this.parent.activeView.renderDates[0] : this.parent.activeView.renderDates.slice(-1)[0];\n    if (e.swipeDirection === 'Left' && swipeDate < this.parent.maxDate || e.swipeDirection === 'Right' && swipeDate >= this.parent.minDate) {\n      const time = Date.now() - this.timeStampStart;\n      const offsetDist = e.distanceX * (Browser.isDevice ? 6 : 1.66);\n      if (offsetDist > time || e.distanceX > this.parent.element.offsetWidth / 2) {\n        this.swapPanels(e.swipeDirection);\n        if (offsetDist > time && e.distanceX > this.parent.element.offsetWidth / 2) {\n          this.element.style.transitionDuration = offsetDist / time / 10 + 's';\n        }\n        this.confirmSwipe(e.swipeDirection);\n      } else {\n        this.cancelSwipe();\n      }\n      const args = {\n        requestType: 'dateNavigate',\n        cancel: false,\n        event: e.originalEvent\n      };\n      this.parent.trigger(actionComplete, args);\n    } else {\n      this.cancelSwipe();\n    }\n    this.timeStampStart = null;\n  }\n  tapHoldHandler(e) {\n    const target = closest(e.originalEvent.target, '.' + APPOINTMENT_CLASS);\n    if (!isNullOrUndefined(target) && this.parent.isAdaptive) {\n      this.parent.quickPopup.tapHoldEventPopup(e.originalEvent);\n      return;\n    }\n  }\n  renderPanel(clsName, nextPrevType) {\n    if (!this.currentPanel) {\n      this.currentPanel = {\n        element: this.parent.activeView.getPanel(),\n        selectedDate: new Date(this.parent.selectedDate.getTime())\n      };\n      this.setDimensions(this.currentPanel.element);\n    } else {\n      this.parent.setProperties({\n        selectedDate: this.currentPanel.selectedDate\n      }, true);\n    }\n    this.parent.setProperties({\n      selectedDate: this.parent.activeView.getNextPreviousDate(nextPrevType)\n    }, true);\n    if (this.parent.headerModule) {\n      this.parent.headerModule.setCalendarDate(this.parent.selectedDate);\n    }\n    this.parent.activeView.getRenderDates();\n    this.parent.activeView.renderLayout(clsName);\n  }\n  swapPanels(direction) {\n    if (direction === this.touchLeftDirection) {\n      const temp = this.nextPanel;\n      this.nextPanel = this.currentPanel;\n      this.currentPanel = temp;\n    } else {\n      const temp = this.previousPanel;\n      this.previousPanel = this.currentPanel;\n      this.currentPanel = temp;\n    }\n  }\n  confirmSwipe(swipeDirection) {\n    const previousDate = swipeDirection === this.touchLeftDirection ? this.nextPanel.selectedDate : this.previousPanel.selectedDate;\n    const args = {\n      action: 'date',\n      cancel: false,\n      previousDate: previousDate,\n      currentDate: this.currentPanel.selectedDate\n    };\n    this.parent.trigger(navigating, args, navArgs => {\n      if (navArgs.cancel) {\n        this.swapPanels(swipeDirection);\n        this.cancelSwipe();\n      } else {\n        this.parent.activeView.setPanel(this.currentPanel.element);\n        this.parent.setProperties({\n          selectedDate: this.currentPanel.selectedDate\n        }, true);\n        let translateX;\n        if (this.parent.enableRtl) {\n          translateX = swipeDirection === this.touchLeftDirection ? this.previousPanel ? this.previousPanel.element.offsetLeft : this.currentPanel.element.offsetWidth : 0;\n        } else {\n          translateX = swipeDirection === this.touchLeftDirection ? -this.currentPanel.element.offsetLeft : 0;\n        }\n        addClass([this.element], TRANSLATE_CLASS);\n        this.element.style.transform = 'translatex(' + translateX + 'px)';\n        if (this.parent.headerModule) {\n          this.parent.headerModule.updateDateRange(this.parent.activeView.getDateRangeText());\n        }\n        this.parent.renderTemplates();\n        this.parent.crudModule.refreshDataManager();\n      }\n    });\n  }\n  cancelSwipe() {\n    this.parent.activeView.setPanel(this.currentPanel.element);\n    this.parent.setProperties({\n      selectedDate: this.currentPanel.selectedDate\n    }, true);\n    this.parent.activeView.getRenderDates();\n    this.parent.activeView.generateColumnLevels();\n    addClass([this.element], TRANSLATE_CLASS);\n    const prevWidth = this.previousPanel ? this.previousPanel.element.offsetWidth : 0;\n    this.element.style.transform = 'translatex(' + (this.parent.enableRtl ? prevWidth : -this.currentPanel.element.offsetLeft) + 'px)';\n  }\n  onTransitionEnd() {\n    removeClass([this.element], TRANSLATE_CLASS);\n    this.element.style.transitionDuration = '';\n    this.element.style.transform = '';\n    if (this.previousPanel) {\n      remove(this.previousPanel.element);\n      this.previousPanel = null;\n      removeClass([this.currentPanel.element], PREVIOUS_PANEL_CLASS);\n      addClass([this.currentPanel.element], CURRENT_PANEL_CLASS);\n    }\n    if (this.nextPanel) {\n      remove(this.nextPanel.element);\n      this.nextPanel = null;\n      removeClass([this.currentPanel.element], NEXT_PANEL_CLASS);\n      addClass([this.currentPanel.element], CURRENT_PANEL_CLASS);\n    }\n    this.currentPanel = null;\n    this.parent.activeView.getPanel().style.width = '';\n  }\n  getTranslateX(element) {\n    const style = window.getComputedStyle(element);\n    return new WebKitCSSMatrix(style.webkitTransform).m41;\n  }\n  setDimensions(element) {\n    element.style.width = this.parent.element.clientWidth + 'px';\n  }\n  resetValues() {\n    this.currentPanel = null;\n    this.previousPanel = null;\n    this.nextPanel = null;\n    this.timeStampStart = null;\n    this.element.style.transform = '';\n    removeChildren(this.element);\n    removeClass([this.element], TRANSLATE_CLASS);\n  }\n  destroy() {\n    if (this.touchObj) {\n      this.touchObj.destroy();\n      this.touchObj = null;\n    }\n    EventHandler.remove(this.element, 'transitionend', this.onTransitionEnd);\n    this.resetValues();\n  }\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Keyboard interaction\n */\nclass KeyboardInteraction {\n  constructor(parent) {\n    this.selectedCells = [];\n    this.keyConfigs = {\n      downArrow: 'downarrow',\n      upArrow: 'uparrow',\n      rightArrow: 'rightarrow',\n      leftArrow: 'leftarrow',\n      shiftDownArrow: 'shift+downarrow',\n      shiftUpArrow: 'shift+uparrow',\n      shiftRightArrow: 'shift+rightarrow',\n      shiftLeftArrow: 'shift+leftarrow',\n      ctrlLeftArrow: 'ctrl+leftarrow',\n      ctrlRightArrow: 'ctrl+rightarrow',\n      altOne: 'alt+1',\n      altTwo: 'alt+2',\n      altThree: 'alt+3',\n      altFour: 'alt+4',\n      altFive: 'alt+5',\n      altSix: 'alt+6',\n      altSeven: 'alt+7',\n      altEight: 'alt+8',\n      altNine: 'alt+9',\n      enter: 'enter',\n      escape: 'escape',\n      delete: 'delete',\n      home: 'home',\n      pageUp: 'pageup',\n      pageDown: 'pagedown',\n      tab: 'tab',\n      shiftTab: 'shift+tab',\n      ctrlShiftUpArrow: 'ctrl+shift+uparrow',\n      ctrlShiftDownArrow: 'ctrl+shift+downarrow',\n      ctrlShiftLeftArrow: 'ctrl+shift+leftarrow',\n      ctrlShiftRightArrow: 'ctrl+shift+rightarrow'\n    };\n    this.parent = parent;\n    this.parent.element.tabIndex = this.parent.element.tabIndex === -1 ? 0 : this.parent.element.tabIndex;\n    this.keyboardModule = new KeyboardEvents(this.parent.element, {\n      keyAction: this.keyActionHandler.bind(this),\n      keyConfigs: this.keyConfigs,\n      eventName: 'keydown'\n    });\n    this.addEventListener();\n  }\n  keyActionHandler(e) {\n    switch (e.action) {\n      case 'downArrow':\n      case 'shiftDownArrow':\n        this.processDown(e, e.shiftKey);\n        break;\n      case 'upArrow':\n      case 'shiftUpArrow':\n        this.processUp(e, e.shiftKey);\n        break;\n      case 'leftArrow':\n      case 'shiftLeftArrow':\n        this.processLeft(e, e.shiftKey);\n        break;\n      case 'rightArrow':\n      case 'shiftRightArrow':\n        this.processRight(e, e.shiftKey);\n        break;\n      case 'ctrlLeftArrow':\n        this.parent.changeDate(this.parent.activeView.getNextPreviousDate('previous'), e);\n        if (this.parent.headerModule) {\n          this.parent.headerModule.element.querySelector('.e-prev button').focus();\n        }\n        break;\n      case 'ctrlRightArrow':\n        this.parent.changeDate(this.parent.activeView.getNextPreviousDate('next'), e);\n        if (this.parent.headerModule) {\n          this.parent.headerModule.element.querySelector('.e-next button').focus();\n        }\n        break;\n      case 'altOne':\n      case 'altTwo':\n      case 'altThree':\n      case 'altFour':\n      case 'altFive':\n      case 'altSix':\n      case 'altSeven':\n      case 'altEight':\n      case 'altNine':\n        this.processViewNavigation(e);\n        break;\n      case 'enter':\n        this.processEnter(e);\n        break;\n      case 'home':\n        this.focusFirstCell();\n        break;\n      case 'tab':\n      case 'shiftTab':\n        this.processTab(e, e.shiftKey);\n        break;\n      case 'delete':\n        this.processDelete(e);\n        break;\n      case 'ctrlShiftUpArrow':\n      case 'ctrlShiftDownArrow':\n      case 'ctrlShiftLeftArrow':\n      case 'ctrlShiftRightArrow':\n        this.processCtrlShiftNavigationArrows(e);\n        break;\n      case 'escape':\n        this.processEscape(e);\n        break;\n      case 'fTwelve':\n        if (this.parent.allowInline && this.parent.inlineModule) {\n          e.preventDefault();\n          this.processFTwelve(e);\n        }\n        break;\n    }\n  }\n  processFTwelve(e) {\n    const target = e.target;\n    if (target.classList.contains(WORK_CELLS_CLASS) || target.classList.contains(ALLDAY_CELLS_CLASS)) {\n      this.parent.activeCellsData = this.getSelectedElements(target);\n      const args = extend(this.parent.activeCellsData, {\n        cancel: false,\n        event: e\n      });\n      const inlineArgs = {\n        element: args.element,\n        groupIndex: args.groupIndex,\n        type: 'Cell'\n      };\n      this.parent.notify(inlineClick, inlineArgs);\n    }\n    if (target.classList.contains(APPOINTMENT_CLASS)) {\n      target.click();\n      return;\n    }\n  }\n  addEventListener() {\n    this.parent.on(cellMouseDown, this.onCellMouseDown, this);\n  }\n  removeEventListener() {\n    this.parent.off(cellMouseDown, this.onCellMouseDown);\n  }\n  onCellMouseDown(e) {\n    if (e.event.shiftKey) {\n      return;\n    }\n    this.initialTarget = this.getClosestCell(e.event);\n    if (this.parent.activeViewOptions.readonly || this.parent.currentView === 'MonthAgenda' || !this.initialTarget) {\n      return;\n    }\n    if (e.event.target.classList.contains(WORK_CELLS_CLASS) && e.event.which !== 3) {\n      this.parent.removeSelectedClass();\n      EventHandler.add(this.parent.getContentTable(), 'mousemove', this.onMouseSelection, this);\n      EventHandler.add(this.parent.getContentTable(), 'mouseup', this.onMoveUp, this);\n    }\n    if (e.event.target.classList.contains(ALLDAY_CELLS_CLASS) && e.event.which !== 3) {\n      this.parent.removeSelectedClass();\n      const allDayRow = this.parent.getAllDayRow();\n      EventHandler.add(allDayRow, 'mousemove', this.onMouseSelection, this);\n      EventHandler.add(allDayRow, 'mouseup', this.onMoveUp, this);\n    }\n  }\n  onMouseSelection(e) {\n    const appointments = [].slice.call(this.parent.element.querySelectorAll('.' + APPOINTMENT_CLASS));\n    addClass(appointments, 'e-allow-select');\n    const selectionEdges = this.parent.boundaryValidation(e.pageY, e.pageX);\n    if (selectionEdges.bottom || selectionEdges.top || selectionEdges.left || selectionEdges.right) {\n      const parent = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS);\n      const yInBounds = parent.offsetHeight <= parent.scrollHeight && parent.scrollTop >= 0 && parent.scrollTop + parent.offsetHeight <= parent.scrollHeight;\n      const xInBounds = parent.offsetWidth <= parent.scrollWidth && parent.scrollLeft >= 0 && parent.scrollLeft + parent.offsetWidth <= parent.scrollWidth;\n      if (yInBounds && (selectionEdges.top || selectionEdges.bottom)) {\n        parent.scrollTop += selectionEdges.top ? -e.target.offsetHeight : e.target.offsetHeight;\n      }\n      if (xInBounds && (selectionEdges.left || selectionEdges.right)) {\n        parent.scrollLeft += selectionEdges.left ? -e.target.offsetWidth : e.target.offsetWidth;\n      }\n    }\n    const target = this.getClosestCell(e);\n    if (target) {\n      this.selectCells(true, target);\n    }\n  }\n  getClosestCell(e) {\n    return closest(e.target, '.' + WORK_CELLS_CLASS + ',.' + ALLDAY_CELLS_CLASS);\n  }\n  onMoveUp(e) {\n    const appointments = [].slice.call(this.parent.element.querySelectorAll('.' + APPOINTMENT_CLASS));\n    removeClass(appointments, 'e-allow-select');\n    if (e.target.classList.contains(WORK_CELLS_CLASS)) {\n      EventHandler.remove(this.parent.getContentTable(), 'mousemove', this.onMouseSelection);\n      EventHandler.remove(this.parent.getContentTable(), 'mouseup', this.onMoveUp);\n    }\n    if (e.target.classList.contains(ALLDAY_CELLS_CLASS)) {\n      const allDayRow = this.parent.getAllDayRow();\n      EventHandler.remove(allDayRow, 'mousemove', this.onMouseSelection);\n      EventHandler.remove(allDayRow, 'mouseup', this.onMoveUp);\n    }\n    if (this.isPreventAction(e)) {\n      return;\n    }\n    const queryStr = '.' + WORK_CELLS_CLASS + ',.' + ALLDAY_CELLS_CLASS + ',.' + HEADER_CELLS_CLASS;\n    const target = closest(e.target, queryStr);\n    if (this.parent.currentView === 'TimelineYear' && target.classList.contains(OTHERMONTH_CLASS)) {\n      return;\n    }\n    this.parent.activeCellsData = this.getSelectedElements(target);\n    const cellData = {};\n    if (this.parent.eventWindow) {\n      this.parent.eventWindow.convertToEventData(this.parent.activeCellsData, cellData);\n    }\n    const selectedCells = this.parent.getSelectedElements();\n    const args = {\n      data: cellData,\n      element: this.parent.activeCellsData.element,\n      event: e,\n      requestType: 'cellSelect',\n      showQuickPopup: false\n    };\n    this.parent.trigger(select, args, selectArgs => {\n      const isPopupShow = selectArgs.showQuickPopup || this.parent.quickInfoOnSelectionEnd;\n      if (isPopupShow && selectedCells.length > 1) {\n        const cellArgs = extend(this.parent.activeCellsData, {\n          cancel: false,\n          event: e,\n          name: 'cellClick'\n        });\n        this.parent.notify(cellClick, cellArgs);\n      }\n    });\n  }\n  processEnter(e) {\n    if (this.parent.activeViewOptions.readonly && !e.target.classList.contains(APPOINTMENT_CLASS) || this.isPreventAction(e)) {\n      return;\n    }\n    if (this.parent.currentView === 'TimelineYear' && e.target.classList.contains(OTHERMONTH_CLASS)) {\n      return;\n    }\n    const target = e.target;\n    if (closest(target, '.' + POPUP_WRAPPER_CLASS)) {\n      if (target.classList.contains(QUICK_POPUP_EVENT_DETAILS_CLASS) || target.classList.contains(EVENT_CREATE_CLASS) || target.classList.contains(EDIT_EVENT_CLASS) || target.classList.contains(DELETE_EVENT_CLASS) || target.classList.contains(CLOSE_CLASS)) {\n        target.click();\n        e.preventDefault();\n      } else if (target.classList.contains(SUBJECT_CLASS)) {\n        this.parent.element.querySelector('.' + EVENT_CREATE_CLASS).click();\n        e.preventDefault();\n      }\n      return;\n    }\n    if (target.classList.contains(RESOURCE_CELLS_CLASS) && target.classList.contains(RESOURCE_PARENT_CLASS)) {\n      const resourceIcon = target.querySelector('.' + RESOURCE_TREE_ICON_CLASS);\n      if (resourceIcon) {\n        resourceIcon.click();\n      }\n      return;\n    }\n    if (target.classList.contains(WORK_CELLS_CLASS) || target.classList.contains(ALLDAY_CELLS_CLASS)) {\n      this.parent.activeCellsData = this.getSelectedElements(target);\n      const args = extend(this.parent.activeCellsData, {\n        cancel: false,\n        event: e\n      });\n      if (this.parent.allowInline) {\n        const inlineArgs = {\n          element: args.element,\n          groupIndex: args.groupIndex,\n          type: 'Cell'\n        };\n        this.parent.notify(inlineClick, inlineArgs);\n      } else {\n        if (this.parent.currentView === 'Year') {\n          target.click();\n        } else {\n          this.parent.notify(cellClick, args);\n        }\n      }\n      return;\n    }\n    if (target.classList.contains(INLINE_SUBJECT_CLASS) && this.parent.inlineModule) {\n      this.parent.inlineModule.inlineCrudActions(target);\n      return;\n    }\n    if (target.classList.contains(APPOINTMENT_CLASS) || target.classList.contains(MORE_EVENT_CLOSE_CLASS) || target.classList.contains(ALLDAY_APPOINTMENT_SECTION_CLASS) || target.classList.contains(MORE_INDICATOR_CLASS)) {\n      target.click();\n      return;\n    }\n    if (target.classList.contains(MORE_EVENT_HEADER_DATE_CLASS)) {\n      this.parent.setProperties({\n        selectedDate: this.parent.getDateFromElement(target)\n      }, true);\n      this.parent.changeView(this.parent.getNavigateView(), e);\n      this.processEscape(e);\n      return;\n    }\n  }\n  getSelectedElements(target) {\n    let cellDetails;\n    if (this.selectedCells.length > 1 && target.classList.contains(SELECTED_CELL_CLASS)) {\n      const start = this.parent.getCellDetails(this.selectedCells[0]);\n      const end = this.parent.getCellDetails(this.selectedCells.slice(-1)[0]);\n      start.endTime = end.endTime;\n      start.element = target;\n      cellDetails = start;\n    } else {\n      cellDetails = this.parent.getCellDetails(target);\n    }\n    return cellDetails;\n  }\n  getCells(isInverseTable, start, end) {\n    const tableEle = this.parent.getContentTable();\n    const isTimelineYear = this.parent.currentView === 'TimelineYear';\n    const query = isTimelineYear && !isInverseTable ? '.' + WORK_CELLS_CLASS + ':not(.' + OTHERMONTH_CLASS + ')' : 'td';\n    let cells = [].slice.call(tableEle.querySelectorAll(query));\n    let maxRow = tableEle.rows.length;\n    let maxColumn = tableEle.rows[0].cells.length;\n    if (start && start.classList.contains(ALLDAY_CELLS_CLASS)) {\n      const allDayRow = this.parent.getAllDayRow();\n      cells = [].slice.call(allDayRow.cells);\n      maxRow = 1;\n      maxColumn = allDayRow.cells.length;\n    }\n    let startIndex = cells.indexOf(start);\n    let endIndex = cells.indexOf(end);\n    const inverseCells = [];\n    if (isInverseTable) {\n      for (let i = 0; i < maxColumn; i++) {\n        for (let j = 0; j < maxRow; j++) {\n          const cell = cells[maxColumn * j + i];\n          if (isTimelineYear && cell.classList.contains(OTHERMONTH_CLASS)) {\n            continue;\n          }\n          inverseCells.push(cell);\n        }\n      }\n      startIndex = inverseCells.indexOf(start);\n      endIndex = inverseCells.indexOf(end);\n    }\n    if (startIndex > endIndex) {\n      const temp = startIndex;\n      startIndex = endIndex;\n      endIndex = temp;\n    }\n    const sCells = isInverseTable ? inverseCells : cells;\n    return sCells.slice(startIndex, endIndex + 1);\n  }\n  focusFirstCell() {\n    if (this.parent.currentView === 'Agenda') {\n      const focusCell = this.parent.getContentTable().querySelector('.' + AGENDA_CELLS_CLASS);\n      focusCell.setAttribute('tabindex', '0');\n      focusCell.focus();\n      return;\n    }\n    this.parent.eventBase.removeSelectedAppointmentClass();\n    if (this.parent.activeView.isTimelineView() && this.parent.currentView !== 'TimelineYear') {\n      const cell = this.parent.element.querySelector('.' + CONTENT_TABLE_CLASS + ' tr:not(.' + HIDDEN_CLASS + ') .' + WORK_CELLS_CLASS + ':not(.' + RESOURCE_GROUP_CELLS_CLASS + ')');\n      this.selectCells(false, cell);\n    } else if (this.parent.currentView.indexOf('Year') > -1) {\n      let query = '.' + WORK_CELLS_CLASS + ':not(.' + OTHERMONTH_CLASS + ')' + ':not(.' + RESOURCE_GROUP_CELLS_CLASS + ')';\n      const isVerticalYear = this.parent.currentView === 'TimelineYear' && this.parent.activeViewOptions.orientation === 'Vertical';\n      query += isVerticalYear ? '[data-date=\"' + this.parent.activeView.startDate().getTime() + '\"]' : '';\n      this.selectCells(false, this.parent.element.querySelector(query));\n    } else {\n      this.selectCells(false, this.parent.getWorkCellElements()[0]);\n    }\n  }\n  isInverseTableSelect() {\n    return this.parent.activeView.isInverseTableSelect;\n  }\n  /**\n   * Internal method to select cells\n   *\n   * @param {boolean} isMultiple Accepts to select multiple cells or not\n   * @param {HTMLTableCellElement} targetCell Accepts the target cells\n   * @returns {void}\n   * @private\n   */\n  selectCells(isMultiple, targetCell) {\n    this.parent.removeSelectedClass();\n    let target = targetCell instanceof Array ? targetCell.slice(-1)[0] : targetCell;\n    if (isMultiple) {\n      let initialId;\n      const views = ['Day', 'Week', 'WorkWeek', 'TimelineDay', 'TimelineWeek', 'TimelineWorkWeek', 'TimelineMonth', 'TimelineYear'];\n      const args = {\n        element: targetCell,\n        requestType: 'mousemove',\n        allowMultipleRow: true\n      };\n      this.parent.inlineModule.removeInlineAppointmentElement();\n      this.parent.trigger(select, args, selectArgs => {\n        const allowMultipleRow = !selectArgs.allowMultipleRow || !this.parent.allowMultiRowSelection;\n        if (allowMultipleRow) {\n          const isTimelineYear = this.parent.currentView === 'TimelineYear';\n          if (isTimelineYear && this.parent.activeViewOptions.orientation === 'Horizontal' || this.parent.currentView === 'Month') {\n            const isGroupYear = isTimelineYear && this.parent.activeViewOptions.group.resources.length > 0;\n            target = isGroupYear ? this.initialTarget : this.initialTarget.parentElement.children[target.cellIndex];\n          } else if (views.indexOf(this.parent.currentView) > -1) {\n            target = target.parentElement.children[this.initialTarget.cellIndex];\n          }\n        }\n        let selectedCells = this.getCells(this.isInverseTableSelect(), this.initialTarget, target);\n        if (this.parent.activeViewOptions.group.resources.length > 0) {\n          initialId = this.initialTarget.getAttribute('data-group-index');\n          const resourceSelectedCells = [];\n          for (const cell of selectedCells) {\n            if (cell.getAttribute('data-group-index') === initialId) {\n              resourceSelectedCells.push(cell);\n            }\n          }\n          selectedCells = resourceSelectedCells;\n        }\n        if (!this.parent.allowMultiCellSelection) {\n          selectedCells = [this.initialTarget];\n        }\n        this.selectedCells = selectedCells;\n        if (selectedCells.length > 2 && !target.classList.contains(ALLDAY_CELLS_CLASS)) {\n          let allDayCells = this.getAllDayCells(selectedCells);\n          if (this.parent.activeViewOptions.group.resources.length > 0) {\n            const resourceAllDayCells = [];\n            for (const cell of allDayCells) {\n              if (cell.getAttribute('data-group-index') === initialId) {\n                resourceAllDayCells.push(cell);\n              }\n            }\n            allDayCells = resourceAllDayCells;\n          }\n          selectedCells = selectedCells.concat(allDayCells);\n        }\n        if (target.getAttribute('data-group-index') !== initialId && this.parent.activeViewOptions.group.resources.length > 0) {\n          target = this.selectedCells[this.selectedCells.length - 1];\n        }\n        this.parent.addSelectedClass(selectedCells, target);\n      });\n    } else {\n      this.initialTarget = target;\n      this.selectedCells = [target];\n      this.parent.addSelectedClass([target], target);\n    }\n  }\n  selectAppointment(isReverse, target) {\n    const appointments = this.getAppointmentElements();\n    if (appointments.length < 0) {\n      return;\n    }\n    this.parent.eventBase.removeSelectedAppointmentClass();\n    let nextAppEle;\n    if (target.classList.contains(APPOINTMENT_CLASS)) {\n      const targetIndex = appointments.indexOf(target);\n      nextAppEle = appointments[isReverse ? targetIndex - 1 : targetIndex + 1];\n    } else {\n      nextAppEle = isReverse ? appointments[appointments.length - 1] : appointments[0];\n    }\n    if (nextAppEle) {\n      this.parent.eventBase.addSelectedAppointments([nextAppEle]);\n      nextAppEle.focus();\n      addClass([nextAppEle], AGENDA_SELECTED_CELL);\n    }\n  }\n  selectAppointmentElementFromWorkCell(isReverse, target) {\n    this.parent.eventBase.removeSelectedAppointmentClass();\n    this.parent.removeSelectedClass();\n    if (target.classList.contains(WORK_CELLS_CLASS) || target.classList.contains(ALLDAY_CELLS_CLASS)) {\n      const appointmentElements = this.getUniqueAppointmentElements();\n      const filteredElements = [];\n      const selectedDate = this.parent.getDateFromElement(target).getTime();\n      const selectedSeriesEvents = this.parent.eventsProcessed.filter(eventObject => {\n        return !isReverse ? eventObject[this.parent.eventFields.startTime].getTime() >= selectedDate : eventObject[this.parent.eventFields.startTime].getTime() <= selectedDate;\n      });\n      selectedSeriesEvents.filter(event => {\n        appointmentElements.filter(element => {\n          if (JSON.stringify(event.Guid) === JSON.stringify(element.getAttribute('data-guid'))) {\n            filteredElements.push(element);\n          }\n        });\n      });\n      if (filteredElements.length > 0) {\n        const selectedElement = isReverse ? filteredElements[filteredElements.length - 1] : filteredElements[0];\n        const focusElements = this.getAppointmentElementsByGuid(selectedElement.getAttribute('data-guid'));\n        this.parent.eventBase.addSelectedAppointments(focusElements);\n        focusElements[focusElements.length - 1].focus();\n      }\n    }\n  }\n  getAllDayCells(cells) {\n    const allDayRow = this.parent.getAllDayRow();\n    if (!allDayRow) {\n      return [];\n    }\n    const startCell = cells[0];\n    const endCell = cells[cells.length - 1];\n    const start = this.parent.getCellDetails(startCell);\n    const end = this.parent.getCellDetails(endCell);\n    if (end.endTime.getTime() - start.startTime.getTime() >= MS_PER_DAY) {\n      const allDayCells = [].slice.call(allDayRow.cells);\n      return allDayCells.slice(startCell.cellIndex, endCell.cellIndex + 1);\n    }\n    return [];\n  }\n  getAppointmentElements() {\n    return [].slice.call(this.parent.element.querySelectorAll('.' + APPOINTMENT_CLASS));\n  }\n  getAppointmentElementsByGuid(guid) {\n    return [].slice.call(this.parent.element.querySelectorAll('div[data-guid=\"' + guid + '\"]'));\n  }\n  getUniqueAppointmentElements() {\n    const appointments = this.getAppointmentElements();\n    const appointmentElements = [];\n    appointments.map(value => value.getAttribute('data-guid')).filter((value, index, self) => {\n      if (self.indexOf(value) === index) {\n        appointmentElements.push(appointments[index]);\n      }\n    });\n    return appointmentElements;\n  }\n  getWorkCellFromAppointmentElement(target) {\n    const selectedObject = this.parent.eventBase.getEventByGuid(target.getAttribute('data-guid'));\n    return this.parent.eventBase.selectWorkCellByTime([selectedObject]);\n  }\n  processViewNavigation(e) {\n    const index = parseInt(e.key, 10) - 1;\n    if (index < this.parent.views.length) {\n      const view = this.parent.viewCollections[index].option;\n      this.parent.changeView(view, e, undefined, index);\n      if (this.parent.headerModule) {\n        this.parent.headerModule.element.querySelector('.e-active-view button').focus();\n      }\n    }\n  }\n  cancelUpDownAction(isTimelineYear) {\n    const isVerticalYear = isTimelineYear && this.parent.activeViewOptions.orientation === 'Vertical';\n    const isGroup = this.parent.activeViewOptions.group.resources.length > 0;\n    if (isVerticalYear && isGroup || isTimelineYear && this.initialTarget.classList.contains(OTHERMONTH_CLASS)) {\n      return true;\n    }\n    if (this.parent.activeView.isTimelineView() && !isTimelineYear || this.parent.currentView === 'MonthAgenda') {\n      return true;\n    }\n    return false;\n  }\n  processUp(e, isMultiple) {\n    const isTimelineYear = this.parent.currentView === 'TimelineYear';\n    if (isMultiple && this.cancelUpDownAction(isTimelineYear)) {\n      return;\n    }\n    let target = e.target;\n    const selectedElements = this.parent.getSelectedElements();\n    const selectedEventElements = this.parent.eventBase.getSelectedAppointments();\n    const moreEventWrapper = this.parent.element.querySelector('.' + MORE_POPUP_WRAPPER_CLASS);\n    const quickPopupWrapper = this.getQuickPopupElement();\n    if (selectedElements.length > 0 && !e.target.classList.contains(WORK_CELLS_CLASS)) {\n      target = selectedElements[selectedElements.length - 1];\n    }\n    if (selectedEventElements.length > 0 && !moreEventWrapper.classList.contains(POPUP_OPEN) && !quickPopupWrapper.classList.contains(POPUP_OPEN) && ['Day', 'Week', 'WorkWeek', 'Month'].indexOf(this.parent.currentView) !== -1) {\n      target = this.getWorkCellFromAppointmentElement(selectedEventElements[selectedEventElements.length - 1]);\n      this.parent.eventBase.removeSelectedAppointmentClass();\n    }\n    if (!target) {\n      return;\n    }\n    if (target.classList.contains(WORK_CELLS_CLASS) && !this.parent.element.querySelector('.' + POPUP_OPEN)) {\n      const tableRows = this.parent.getTableRows();\n      const curRowIndex = tableRows.indexOf(target.parentElement);\n      let targetCell;\n      if (isTimelineYear && isMultiple && this.parent.activeViewOptions.group.resources.length === 0) {\n        targetCell = this.isInverseTableSelect() ? this.getVerticalUpDownCell(tableRows, target, curRowIndex, true) : this.getHorizontalUpDownCell(tableRows, target, curRowIndex, true);\n      }\n      if ((curRowIndex > 0 || targetCell) && curRowIndex < tableRows.length) {\n        targetCell = targetCell ? targetCell : tableRows[curRowIndex - 1].cells[target.cellIndex];\n        if (this.parent.currentView === 'Year' && targetCell.classList.contains(OTHERMONTH_CLASS)) {\n          if (this.parent.activeView.getStartDate().getTime() < +targetCell.getAttribute('data-date')) {\n            targetCell = this.getYearUpDownCell(tableRows, curRowIndex - 1, target.cellIndex, true);\n          } else {\n            return;\n          }\n        }\n        this.selectCells(isMultiple, targetCell);\n      }\n    } else if (this.parent.currentView === 'Agenda' || this.parent.currentView === 'MonthAgenda') {\n      this.selectAppointment(true, target);\n    }\n  }\n  processDown(e, isMultiple) {\n    const isTimelineYear = this.parent.currentView === 'TimelineYear';\n    if (isMultiple && this.cancelUpDownAction(isTimelineYear)) {\n      return;\n    }\n    let target = e.target;\n    const selectedCells = this.parent.getSelectedElements();\n    const selectedElements = this.parent.eventBase.getSelectedAppointments();\n    const moreEventWrapper = this.parent.element.querySelector('.' + MORE_POPUP_WRAPPER_CLASS);\n    const quickPopupWrapper = this.getQuickPopupElement();\n    if (selectedCells.length > 0 && !e.target.classList.contains(WORK_CELLS_CLASS)) {\n      target = selectedCells[selectedCells.length - 1];\n    }\n    if (selectedElements.length > 0 && !moreEventWrapper.classList.contains(POPUP_OPEN) && !quickPopupWrapper.classList.contains(POPUP_OPEN) && ['Day', 'Week', 'WorkWeek', 'Month'].indexOf(this.parent.currentView) !== -1) {\n      target = this.getWorkCellFromAppointmentElement(selectedElements[selectedElements.length - 1]);\n      this.parent.eventBase.removeSelectedAppointmentClass();\n    }\n    const tableRows = this.parent.getTableRows();\n    if (!target) {\n      return;\n    }\n    if (target.classList.contains(WORK_CELLS_CLASS) && !this.parent.element.querySelector('.' + POPUP_OPEN)) {\n      const curRowIndex = tableRows.indexOf(target.parentElement);\n      let targetCell;\n      if (isTimelineYear && isMultiple && this.parent.activeViewOptions.group.resources.length === 0) {\n        targetCell = this.isInverseTableSelect() ? this.getVerticalUpDownCell(tableRows, target, curRowIndex, false) : this.getHorizontalUpDownCell(tableRows, target, curRowIndex, false);\n      }\n      if (curRowIndex >= 0 && (curRowIndex < tableRows.length - 1 || targetCell)) {\n        targetCell = targetCell ? targetCell : tableRows[curRowIndex + 1].cells[target.cellIndex];\n        if (this.parent.currentView === 'Year' && targetCell.classList.contains(OTHERMONTH_CLASS)) {\n          if (this.parent.activeView.getEndDate().getTime() > +targetCell.getAttribute('data-date')) {\n            targetCell = this.getYearUpDownCell(tableRows, curRowIndex + 1, target.cellIndex, false);\n          } else {\n            return;\n          }\n        }\n        this.selectCells(isMultiple, targetCell);\n      }\n    } else if (this.parent.currentView === 'Agenda' || this.parent.currentView === 'MonthAgenda') {\n      this.selectAppointment(false, target);\n    }\n  }\n  getYearUpDownCell(tableRows, rowIndex, cellIndex, isUp) {\n    while (tableRows[rowIndex] && tableRows[rowIndex].cells[cellIndex].classList.contains(OTHERMONTH_CLASS)) {\n      rowIndex = rowIndex + (isUp ? -1 : 1);\n    }\n    return tableRows[rowIndex].cells[cellIndex];\n  }\n  // eslint-disable-next-line max-len\n  getHorizontalUpDownCell(tableRows, target, curRowIndex, isUp) {\n    const row = tableRows[curRowIndex + (isUp ? -1 : 1)];\n    let cell = row ? row.cells[target.cellIndex] : target;\n    if (cell.classList.contains(OTHERMONTH_CLASS)) {\n      const workCell = row.querySelector('.' + WORK_CELLS_CLASS + ':not(.' + OTHERMONTH_CLASS + ')');\n      const date = new Date(+workCell.getAttribute('data-date'));\n      const query = '[data-date=\"' + new Date(date.getFullYear(), date.getMonth() + 1, 0).getTime() + '\"]';\n      cell = cell.cellIndex < workCell.cellIndex ? workCell : row.querySelector(query);\n    }\n    return cell;\n  }\n  // eslint-disable-next-line max-len\n  getVerticalUpDownCell(tableRows, target, curRowIndex, isUp) {\n    const hasRow = isUp && curRowIndex > 0 || !isUp && curRowIndex < tableRows.length - 1;\n    let targetCell = hasRow ? tableRows[curRowIndex + (isUp ? -1 : 1)].cells[target.cellIndex] : undefined;\n    if (!targetCell || targetCell.classList.contains(OTHERMONTH_CLASS)) {\n      const column = tableRows[curRowIndex].cells[target.cellIndex - (isUp ? 1 : -1)];\n      if (column) {\n        const dateAttr = +target.getAttribute('data-date') - (isUp ? MS_PER_DAY : -MS_PER_DAY);\n        return this.parent.getContentTable().querySelector('.' + WORK_CELLS_CLASS + '[data-date=\"' + dateAttr + '\"]');\n      }\n      targetCell = target;\n    }\n    return targetCell;\n  }\n  processLeftRight(target) {\n    const tableEle = this.parent.currentView === 'Year' ? target.closest('tbody') : this.parent.getContentTable();\n    const curRowIndex = target.parentNode.sectionRowIndex;\n    const key = {\n      element: tableEle,\n      rowIndex: curRowIndex,\n      columnIndex: target.cellIndex,\n      maxIndex: tableEle.rows[curRowIndex].cells.length\n    };\n    return key;\n  }\n  getQuickPopupElement() {\n    return (this.parent.isAdaptive ? document.body : this.parent.element).querySelector('.' + POPUP_WRAPPER_CLASS);\n  }\n  isCancelLeftRightAction(e, isMultiple, isTimelineYear) {\n    const prevent = this.parent.currentView === 'MonthAgenda' || isTimelineYear && this.initialTarget.classList.contains(OTHERMONTH_CLASS);\n    if (this.parent.currentView === 'Agenda' || isMultiple && prevent) {\n      return true;\n    }\n    if (this.isPreventAction(e) && isMultiple) {\n      return true;\n    }\n    const moreEventWrapper = this.parent.element.querySelector('.' + MORE_POPUP_WRAPPER_CLASS);\n    const quickPopupWrapper = this.getQuickPopupElement();\n    if (moreEventWrapper.classList.contains(POPUP_OPEN) || quickPopupWrapper.classList.contains(POPUP_OPEN)) {\n      return true;\n    }\n    return false;\n  }\n  processRight(e, isMultiple) {\n    const isTimelineYear = this.parent.currentView === 'TimelineYear';\n    if (this.isCancelLeftRightAction(e, isMultiple, isTimelineYear)) {\n      return;\n    }\n    const selectedCells = this.parent.getSelectedElements();\n    let targetCell;\n    const selectedAppointments = this.parent.eventBase.getSelectedAppointments();\n    let target = e.target;\n    if (selectedCells.length > 0 && !target.classList.contains(WORK_CELLS_CLASS) && !target.classList.contains(ALLDAY_CELLS_CLASS)) {\n      target = selectedCells[selectedCells.length - 1];\n    }\n    if (selectedAppointments.length > 0) {\n      target = this.getWorkCellFromAppointmentElement(selectedAppointments[selectedAppointments.length - 1]);\n      this.parent.eventBase.removeSelectedAppointmentClass();\n      if (!target) {\n        return;\n      }\n    }\n    if (target.classList.contains(WORK_CELLS_CLASS) && e.target.classList.contains(WORK_CELLS_CLASS)) {\n      const key = this.processLeftRight(target);\n      const targetDate = new Date(+target.getAttribute('data-date'));\n      const isMonthEnd = this.parent.currentView === 'Year' && targetDate.getTime() === lastDateOfMonth(targetDate).getTime();\n      if (key.columnIndex >= 0 && key.columnIndex < key.maxIndex - 1 && !isMonthEnd) {\n        targetCell = this.calculateNextPrevDate(target, key.element.rows[key.rowIndex].cells[target.cellIndex + 1], 'right');\n        if (isTimelineYear && isMultiple && targetCell.classList.contains(OTHERMONTH_CLASS)) {\n          targetCell = this.getTimelineYearTargetCell(key, target, true);\n        }\n        if (!isNullOrUndefined(targetCell)) {\n          this.selectCells(isMultiple, targetCell);\n        }\n      } else if (key.columnIndex === key.maxIndex - 1 || isMonthEnd) {\n        if (!this.isInverseTableSelect() && key.rowIndex < key.element.rows.length - 1 && !isMonthEnd) {\n          targetCell = this.calculateNextPrevDate(target, key.element.rows[key.rowIndex + 1].cells[0], 'right');\n          const changeTargetCell = isTimelineYear && isMultiple && targetCell.classList.contains(OTHERMONTH_CLASS);\n          targetCell = changeTargetCell ? this.getHorizontalLeftRightCell(key, target, true) : targetCell;\n          if (!isNullOrUndefined(targetCell)) {\n            this.selectCells(isMultiple, targetCell);\n          }\n        } else if (!isMultiple) {\n          if (isMonthEnd && targetDate.getTime() !== this.parent.activeView.getEndDate().getTime()) {\n            this.selectCells(isMultiple, this.parent.element.querySelector(':not(.' + OTHERMONTH_CLASS + ')[data-date=\"' + (targetDate.getTime() + MS_PER_DAY) + '\"]'));\n            return;\n          }\n          const rowIndex = this.isInverseTableSelect() ? key.rowIndex : 0;\n          this.parent.changeDate(this.parent.activeView.getNextPreviousDate('next'), e);\n          const tableEle = this.parent.getContentTable();\n          const cell = isMonthEnd ? tableEle.rows[rowIndex].querySelector('.' + WORK_CELLS_CLASS + ':not(.' + OTHERMONTH_CLASS + ')') : tableEle.rows[rowIndex].cells[0];\n          this.selectCells(false, cell);\n        }\n      }\n    } else if (target.classList.contains(ALLDAY_CELLS_CLASS)) {\n      const curColIndex = target.cellIndex;\n      const allDayRow = this.parent.getAllDayRow();\n      const maxColIndex = allDayRow.cells.length;\n      if (curColIndex >= 0 && curColIndex < maxColIndex - 1) {\n        this.selectCells(isMultiple, allDayRow.cells[curColIndex + 1]);\n      } else if (curColIndex === maxColIndex - 1 && !isMultiple) {\n        this.parent.changeDate(this.parent.activeView.getNextPreviousDate('next'), e);\n        const allDayRow = this.parent.getAllDayRow();\n        this.selectCells(false, allDayRow.cells[0]);\n      }\n    }\n  }\n  processLeft(e, isMultiple) {\n    const isTimelineYear = this.parent.currentView === 'TimelineYear';\n    if (this.isCancelLeftRightAction(e, isMultiple, isTimelineYear)) {\n      return;\n    }\n    let target = e.target;\n    const selectedCells = this.parent.getSelectedElements();\n    let targetCell;\n    if (selectedCells.length > 0 && !target.classList.contains(WORK_CELLS_CLASS) && !target.classList.contains(ALLDAY_CELLS_CLASS)) {\n      target = selectedCells[selectedCells.length - 1];\n    }\n    const selectedElements = this.parent.eventBase.getSelectedAppointments();\n    if (selectedElements.length > 0) {\n      target = this.getWorkCellFromAppointmentElement(selectedElements[selectedElements.length - 1]);\n      this.parent.eventBase.removeSelectedAppointmentClass();\n      if (!target) {\n        return;\n      }\n    }\n    if (e.target.classList.contains(WORK_CELLS_CLASS) && target.classList.contains(WORK_CELLS_CLASS)) {\n      const key = this.processLeftRight(target);\n      const targetDate = new Date(+target.getAttribute('data-date'));\n      const isMonthStart = this.parent.currentView === 'Year' && targetDate.getTime() === firstDateOfMonth(targetDate).getTime();\n      if (key.columnIndex > 0 && key.columnIndex < key.maxIndex && !isMonthStart) {\n        targetCell = this.calculateNextPrevDate(target, key.element.rows[key.rowIndex].cells[target.cellIndex - 1], 'left');\n        if (isTimelineYear && isMultiple && targetCell.classList.contains(OTHERMONTH_CLASS)) {\n          targetCell = this.getTimelineYearTargetCell(key, target, false);\n        }\n        if (!isNullOrUndefined(targetCell)) {\n          this.selectCells(isMultiple, targetCell);\n        }\n      } else if (key.columnIndex === 0 || isMonthStart) {\n        if (!this.isInverseTableSelect() && key.rowIndex > 0) {\n          targetCell = this.calculateNextPrevDate(target, key.element.rows[key.rowIndex - 1].cells[key.maxIndex - 1], 'left');\n          const otherMonthCell = isTimelineYear && isMultiple && targetCell.classList.contains(OTHERMONTH_CLASS);\n          targetCell = otherMonthCell ? this.getHorizontalLeftRightCell(key, target, false) : targetCell;\n          if (!isNullOrUndefined(targetCell)) {\n            this.selectCells(isMultiple, targetCell);\n          }\n        } else if (!isMultiple) {\n          if (isMonthStart && targetDate.getTime() !== this.parent.activeView.getStartDate().getTime()) {\n            this.selectCells(isMultiple, this.parent.element.querySelector('[data-date=\"' + (targetDate.getTime() - MS_PER_DAY) + '\"]'));\n            return;\n          }\n          this.parent.changeDate(this.parent.activeView.getNextPreviousDate('previous'), e);\n          const tableEle = this.parent.getContentTable();\n          const rowIndex = this.isInverseTableSelect() ? key.rowIndex : tableEle.rows.length - 1;\n          let cell = tableEle.rows[rowIndex].cells[key.maxIndex - 1];\n          if (isMonthStart) {\n            const tbody = this.parent.element.querySelectorAll('.' + CONTENT_TABLE_CLASS + ' tbody');\n            cell = tbody.item(tbody.length - 1).querySelector(':not(.' + OTHERMONTH_CLASS + ')[data-date=\"' + this.parent.activeView.getEndDate().getTime() + '\"]');\n          }\n          this.selectCells(false, cell);\n        }\n      }\n    } else if (target.classList.contains(ALLDAY_CELLS_CLASS)) {\n      const curColIndex = target.cellIndex;\n      const allDayRow = this.parent.getAllDayRow();\n      const maxColIndex = allDayRow.cells.length;\n      if (curColIndex > 0 && curColIndex < maxColIndex) {\n        this.selectCells(isMultiple, allDayRow.cells[curColIndex - 1]);\n      } else if (curColIndex === 0 && !isMultiple) {\n        this.parent.changeDate(this.parent.activeView.getNextPreviousDate('previous'), e);\n        const allDayRow = this.parent.getAllDayRow();\n        this.selectCells(false, allDayRow.cells[maxColIndex - 1]);\n      }\n    }\n  }\n  getTimelineYearTargetCell(key, target, isRight) {\n    return this.isInverseTableSelect() ? this.getVerticalLeftRightCell(target, isRight) : this.getHorizontalLeftRightCell(key, target, isRight);\n  }\n  getHorizontalLeftRightCell(key, target, isRight) {\n    const row = key.element.rows[target.parentNode.sectionRowIndex + (isRight ? 1 : -1)];\n    if (row) {\n      const query = isRight ? '.' + WORK_CELLS_CLASS + ':not(.' + OTHERMONTH_CLASS + ')' : '[data-date=\"' + (+target.getAttribute('data-date') - MS_PER_DAY) + '\"]';\n      return row.querySelector(query);\n    }\n    return target;\n  }\n  getVerticalLeftRightCell(target, isRight) {\n    const date = new Date(+target.getAttribute('data-date'));\n    const start = new Date(date.getFullYear(), date.getMonth() + (isRight ? 1 : -1), 1);\n    const tableEle = this.parent.getContentTable();\n    const targetCell = tableEle.querySelector('[data-date=\"' + start.getTime() + '\"]');\n    if (targetCell.parentNode.sectionRowIndex > target.parentNode.sectionRowIndex) {\n      return targetCell;\n    }\n    return tableEle.querySelector('[data-date=\"' + new Date(start.getFullYear(), start.getMonth() + 1, 0).getTime() + '\"]');\n  }\n  calculateNextPrevDate(currentCell, target, type) {\n    const initialId = this.initialTarget.getAttribute('data-group-index');\n    if (this.parent.activeViewOptions.group.resources.length > 0 && this.parent.currentView === 'Month') {\n      if (currentCell && target && target.getAttribute('data-group-index') !== initialId) {\n        const currentDate = this.parent.getDateFromElement(currentCell);\n        const nextPrevDate = type === 'right' ? new Date(currentDate.setDate(currentDate.getDate() + 1)) : new Date(currentDate.setDate(currentDate.getDate() - 1));\n        target = [].slice.call(this.parent.element.querySelectorAll('td[data-date=\"' + nextPrevDate.getTime().toString() + '\"]' + '[data-group-index=\"' + initialId + '\"]'))[0];\n      }\n    }\n    return target;\n  }\n  getFocusableElements(container) {\n    const queryString = 'a[href]:not([tabindex=\"-1\"]),input:not([disabled]):not([tabindex=\"-1\"]),' + 'textarea:not([disabled]):not([tabindex=\"-1\"]),button:not([disabled]):not([tabindex=\"-1\"]),' + 'select:not([disabled]):not([tabindex=\"-1\"]),[tabindex]:not([tabindex=\"-1\"]),[contentEditable=true]:not([tabindex=\"-1\"])';\n    return [].slice.call(container.querySelectorAll(queryString));\n  }\n  processTabOnPopup(e, popupElement) {\n    let focusableElements = this.getFocusableElements(popupElement);\n    focusableElements = focusableElements.filter(element => {\n      const footerEle = this.parent.element.querySelector('.' + POPUP_FOOTER_CLASS);\n      if (footerEle && footerEle.offsetParent) {\n        return !(element.classList.contains(EDIT_CLASS) || element.classList.contains(DELETE_CLASS));\n      } else {\n        return !(element.classList.contains(EDIT_EVENT_CLASS) || element.classList.contains(DELETE_EVENT_CLASS));\n      }\n    });\n    const firstEle = focusableElements[0];\n    const lastEle = focusableElements[focusableElements.length - 1];\n    if (!isNullOrUndefined(lastEle) && document.activeElement === lastEle && !e.shiftKey) {\n      e.preventDefault();\n      firstEle.focus();\n    }\n    if (!isNullOrUndefined(firstEle) && document.activeElement === firstEle && e.shiftKey) {\n      e.preventDefault();\n      lastEle.focus();\n    }\n  }\n  processTab(e, isReverse) {\n    let target = e.target;\n    if (target.classList.contains(INLINE_SUBJECT_CLASS) && this.parent.inlineModule) {\n      target = target.closest('.e-appointment');\n      this.parent.inlineModule.inlineCrudActions(e.target);\n    }\n    if (this.parent.currentView === 'TimelineYear' && target.classList.contains(OTHERMONTH_CLASS)) {\n      if (target.classList.contains(SELECTED_CELL_CLASS)) {\n        this.parent.removeSelectedClass();\n      }\n      return;\n    }\n    const popupWrapper = closest(target, '.' + POPUP_WRAPPER_CLASS + ',.' + MORE_POPUP_WRAPPER_CLASS);\n    if (popupWrapper && popupWrapper.classList.contains(POPUP_OPEN)) {\n      if (popupWrapper.classList.contains(MORE_POPUP_WRAPPER_CLASS)) {\n        this.parent.eventBase.removeSelectedAppointmentClass();\n      }\n      this.processTabOnPopup(e, popupWrapper);\n      return;\n    }\n    if (target.classList.contains(ROOT)) {\n      this.parent.eventBase.removeSelectedAppointmentClass();\n      return;\n    }\n    if (target.classList.contains(RESOURCE_CELLS_CLASS) && this.parent.activeView.isTimelineView() && this.parent.activeViewOptions.group.resources.length > 0) {\n      const index = parseInt(target.getAttribute('data-group-index'), 10);\n      const appSelector = `.${APPOINTMENT_CLASS}[data-group-index=\"${isReverse ? index - 1 : index}\"]`;\n      const appElements = [].slice.call(this.parent.element.querySelectorAll(appSelector));\n      if (appElements.length > 0) {\n        this.parent.eventBase.removeSelectedAppointmentClass();\n        const focusAppointment = isReverse ? appElements.slice(-1)[0] : appElements[0];\n        this.parent.eventBase.addSelectedAppointments([focusAppointment]);\n        focusAppointment.focus();\n        e.preventDefault();\n      } else if (index + 1 === this.parent.resourceBase.lastResourceLevel.length) {\n        this.parent.element.focus();\n        e.preventDefault();\n      } else if (this.parent.virtualScrollModule) {\n        const virtual = this.parent.element.querySelector('.' + VIRTUAL_TRACK_CLASS);\n        const averageRowHeight = Math.round(virtual.offsetHeight / this.parent.resourceBase.expandedResources.length);\n        this.parent.element.querySelector('.e-content-wrap').scrollTop = (isReverse ? index - 1 : index + 1) * averageRowHeight;\n        this.parent.virtualScrollModule.virtualScrolling();\n      } else {\n        this.setScrollPosition(index);\n      }\n      return;\n    }\n    if (target.classList.contains(APPOINTMENT_CLASS)) {\n      let appElements = [].slice.call(this.parent.element.querySelectorAll('.' + APPOINTMENT_CLASS));\n      const isTimelineYear = this.parent.currentView === 'TimelineYear';\n      const isTimeline = this.parent.activeView.isTimelineView() && !isTimelineYear;\n      if ((isTimeline || isTimelineYear && this.parent.activeViewOptions.orientation === 'Vertical') && this.parent.activeViewOptions.group.resources.length > 0) {\n        const index = parseInt(target.getAttribute('data-group-index'), 10);\n        appElements = [].slice.call(this.parent.element.querySelectorAll(`.${APPOINTMENT_CLASS}[data-group-index=\"${index}\"]`));\n        const resCellSelector = `.${RESOURCE_CELLS_CLASS}[data-group-index=\"${isReverse ? index : index + 1}\"]`;\n        const resourceCell = this.parent.element.querySelector(resCellSelector);\n        if (resourceCell && (isReverse && target.getAttribute('data-guid') === appElements[0].getAttribute('data-guid') || !isReverse && target.getAttribute('data-guid') === appElements.slice(-1)[0].getAttribute('data-guid'))) {\n          this.parent.eventBase.removeSelectedAppointmentClass();\n          if (this.parent.virtualScrollModule) {\n            resourceCell.focus({\n              preventScroll: true\n            });\n          } else {\n            resourceCell.focus();\n          }\n          if (this.parent.activeView.isTimelineView() && this.parent.activeViewOptions.group.resources.length > 0 && isNullOrUndefined(this.parent.virtualScrollModule)) {\n            this.setScrollPosition(index);\n          }\n          e.preventDefault();\n          return;\n        }\n      }\n      const selectedAppointments = this.parent.eventBase.getSelectedAppointments();\n      if (selectedAppointments.length > 0) {\n        target = selectedAppointments[selectedAppointments.length - 1];\n      }\n      this.parent.eventBase.removeSelectedAppointmentClass();\n      if (!isReverse && target.getAttribute('data-guid') === appElements[appElements.length - 1].getAttribute('data-guid') || isReverse && target.getAttribute('data-guid') === appElements[0].getAttribute('data-guid')) {\n        return;\n      }\n      if (this.parent.currentView === 'Agenda' || this.parent.currentView === 'MonthAgenda') {\n        this.selectAppointment(isReverse, target);\n        e.preventDefault();\n      }\n      return;\n    }\n    const selectedCells = this.parent.getSelectedElements();\n    if (selectedCells.length > 0 && !target.classList.contains(APPOINTMENT_CLASS)) {\n      target = selectedCells[selectedCells.length - 1];\n      this.selectAppointmentElementFromWorkCell(isReverse, target);\n      e.preventDefault();\n      return;\n    }\n    if (target && !target.classList.contains(RESOURCE_CELLS_CLASS) && this.parent.activeView.isTimelineView() && this.parent.activeViewOptions.group.resources.length > 0) {\n      this.processTabOnResourceCells(target, isReverse);\n    }\n  }\n  processDelete(e) {\n    let activeEle = document.activeElement;\n    if (this.parent.currentView === 'MonthAgenda') {\n      const selectedEle = this.parent.eventBase.getSelectedEvents().element;\n      activeEle = selectedEle && isNullOrUndefined(selectedEle.length) ? selectedEle : selectedEle[0];\n    }\n    if (activeEle && activeEle.classList.contains(APPOINTMENT_CLASS)) {\n      addClass([activeEle], APPOINTMENT_BORDER);\n      this.parent.activeEventData = this.parent.eventBase.getSelectedEvents();\n      if (this.parent.activeViewOptions.readonly || activeEle.classList.contains(READ_ONLY) || !this.parent.eventSettings.allowDeleting) {\n        return;\n      }\n      this.parent.quickPopup.deleteClick(e);\n    }\n  }\n  processCtrlShiftNavigationArrows(e) {\n    if (this.parent.activeViewOptions.group.resources.length > 0 && document.activeElement.classList.contains(APPOINTMENT_CLASS)) {\n      const groupIndex = parseInt(document.activeElement.getAttribute('data-group-index'), 10);\n      let index = e.action === 'ctrlShiftLeftArrow' || e.action === 'ctrlShiftUpArrow' ? groupIndex - 1 : groupIndex + 1;\n      index = index < 0 ? 0 : index > this.parent.resourceBase.lastResourceLevel.length ? this.parent.resourceBase.lastResourceLevel.length : index;\n      let eventEle = [];\n      while (eventEle.length === 0 && index >= 0 && index <= this.parent.resourceBase.lastResourceLevel.length) {\n        eventEle = [].slice.call(this.parent.element.querySelectorAll(`.${APPOINTMENT_CLASS}[data-group-index=\"${index}\"]`));\n        index = e.action === 'ctrlShiftLeftArrow' || e.action === 'ctrlShiftUpArrow' ? index - 1 : index + 1;\n      }\n      const nextAppEle = eventEle[0];\n      if (nextAppEle) {\n        this.parent.eventBase.removeSelectedAppointmentClass();\n        this.parent.eventBase.addSelectedAppointments([nextAppEle]);\n        nextAppEle.focus();\n      }\n    } else if (this.parent.activeViewOptions.group.resources.length > 0 && !document.activeElement.classList.contains(APPOINTMENT_CLASS)) {\n      const index = this.parent.resourceBase.renderedResources[0].groupIndex;\n      const appSelector = `.${APPOINTMENT_CLASS}[data-group-index=\"${index}\"]`;\n      const appElements = [].slice.call(this.parent.element.querySelectorAll(appSelector));\n      if (appElements.length > 0) {\n        this.parent.eventBase.removeSelectedAppointmentClass();\n        const focusAppointment = appElements[0];\n        this.parent.eventBase.addSelectedAppointments([focusAppointment]);\n        focusAppointment.focus();\n        e.preventDefault();\n      }\n    }\n  }\n  processEscape(event) {\n    this.parent.quickPopup.onClosePopup(event);\n    this.parent.quickPopup.morePopup.hide();\n    if (this.parent.headerModule) {\n      this.parent.headerModule.hideHeaderPopup();\n    }\n    if (this.parent.inlineModule) {\n      this.parent.inlineModule.removeInlineAppointmentElement();\n    }\n  }\n  isPreventAction(e) {\n    const target = closest(e.target, '.' + RESOURCE_GROUP_CELLS_CLASS);\n    if (this.parent.activeView.isTimelineView() && !isNullOrUndefined(target)) {\n      return true;\n    }\n    return false;\n  }\n  processTabOnResourceCells(target, isReverse) {\n    const tabElements = [].slice.call(this.parent.element.querySelectorAll('[tabIndex=\"0\"]'));\n    const currentTabIndex = tabElements.indexOf(target);\n    const nextTabElement = !isReverse ? tabElements[currentTabIndex + 1] : tabElements[currentTabIndex - 1];\n    if (nextTabElement && nextTabElement.classList.contains(RESOURCE_CELLS_CLASS)) {\n      const groupIndex = parseInt(nextTabElement.getAttribute('data-group-index'), 10);\n      if (this.parent.virtualScrollModule) {\n        const resColWrap = this.parent.element.querySelector('.' + RESOURCE_COLUMN_WRAP_CLASS);\n        const resCells = [].slice.call(this.parent.element.querySelectorAll('.' + RESOURCE_CELLS_CLASS));\n        resCells.forEach(element => {\n          if (element.getBoundingClientRect().top < resColWrap.getBoundingClientRect().top) {\n            element.setAttribute('tabindex', '-1');\n          }\n        });\n      } else {\n        this.setScrollPosition(groupIndex);\n      }\n    }\n  }\n  setScrollPosition(index) {\n    const workCell = this.parent.element.querySelector(`.${WORK_CELLS_CLASS}[data-group-index=\"${index}\"]`);\n    if (workCell) {\n      this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS).scrollTop = workCell.offsetTop;\n    }\n  }\n  /**\n   * Get module name.\n   *\n   * @returns {string} Returns the module name.\n   */\n  getModuleName() {\n    return 'keyboard';\n  }\n  /**\n   * To destroy the keyboard module.\n   *\n   * @returns {void}\n   * @private\n   */\n  destroy() {\n    this.removeEventListener();\n    this.keyboardModule.destroy();\n  }\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * data module is used to generate query and data source.\n *\n * @private\n */\nclass Data {\n  /**\n   * Constructor for data module\n   *\n   * @param {Object | DataManager} dataSource Accepts the datasource as JSON objects or DataManager\n   * @param {Query} query Accepts the query to process the data\n   * @private\n   */\n  constructor(dataSource, query) {\n    this.initDataManager(dataSource, query);\n  }\n  /**\n   * The function used to initialize dataManager and query\n   *\n   * @param {Object | DataManager} dataSource Accepts the datasource as JSON objects or DataManager\n   * @param {Query} query Accepts the query to process the data\n   * @returns {void}\n   * @private\n   */\n  initDataManager(dataSource, query) {\n    this.dataManager = dataSource instanceof DataManager ? dataSource : new DataManager(dataSource);\n    this.query = query instanceof Query ? query : new Query();\n  }\n  /**\n   * The function used to generate updated Query from schedule model\n   *\n   * @param {Date} startDate Accepts the start date\n   * @param {Date} endDate Accepts the end date\n   * @returns {void}\n   * @private\n   */\n  generateQuery(startDate, endDate) {\n    const query = this.query.clone();\n    if (startDate) {\n      query.addParams('StartDate', startDate.toISOString());\n    }\n    if (endDate) {\n      query.addParams('EndDate', endDate.toISOString());\n    }\n    return query;\n  }\n  /**\n   * The function used to get dataSource by executing given Query\n   *\n   * @param  {Query} query - A Query that specifies to generate dataSource\n   * @returns {void}\n   * @private\n   */\n  getData(query) {\n    return this.dataManager.executeQuery(query);\n  }\n  /**\n   * To destroy the crud module.\n   *\n   * @returns {void}\n   * @private\n   */\n  destroy() {\n    this.dataManager = null;\n    this.query = null;\n  }\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/** @private */\nclass Gregorian {\n  firstDateOfMonth(date) {\n    return new Date(date.getFullYear(), date.getMonth());\n  }\n  lastDateOfMonth(dt) {\n    return new Date(dt.getFullYear(), dt.getMonth() + 1, 0);\n  }\n  isMonthStart(date) {\n    return date.getDate() === 1;\n  }\n  getLeapYearDaysCount() {\n    return 366;\n  }\n  getYearDaysCount(date, interval) {\n    return (date.getFullYear() + interval) % 4 === 0 ? 366 : 365;\n  }\n  getDate(date) {\n    return date.getDate();\n  }\n  getMonth(date) {\n    return date.getMonth() + 1;\n  }\n  getFullYear(date) {\n    return date.getFullYear();\n  }\n  getYearLastDate(date, interval) {\n    return new Date(date.getFullYear() + interval, 0, 0);\n  }\n  getMonthDaysCount(date) {\n    return this.lastDateOfMonth(date).getDate();\n  }\n  getMonthStartDate(date) {\n    return new Date(date.getFullYear(), date.getMonth(), 1, date.getHours(), date.getMinutes());\n  }\n  getMonthEndDate(date) {\n    date.setDate(1);\n    return new Date(date.setMonth(date.getMonth() + 1));\n  }\n  getExpectedDays(date, days) {\n    return days;\n  }\n  setDate(dateObj, date) {\n    dateObj.setDate(date);\n  }\n  setValidDate(date, interval, startDate, monthValue, beginDate) {\n    if (!isNullOrUndefined(beginDate)) {\n      date.setMonth((beginDate ? monthValue : date.getMonth()) + interval);\n    } else {\n      date.setMonth(date.getMonth() + interval, startDate);\n    }\n  }\n  setMonth(date, interval, startDate) {\n    date.setFullYear(date.getFullYear());\n    date.setMonth(interval - 1);\n    date.setDate(startDate);\n  }\n  addYears(date, interval) {\n    date.setFullYear(date.getFullYear() + interval);\n  }\n  isSameMonth(date1, date2) {\n    return date1.getMonth() === date2.getMonth();\n  }\n  checkMonth(date, months) {\n    return months.indexOf(date.getMonth() + 1) === -1;\n  }\n  compareMonth(date1, date2) {\n    return date1.getMonth() > date2.getMonth();\n  }\n  isSameYear(date1, date2) {\n    return date1.getFullYear() === date2.getFullYear();\n  }\n  isLastMonth(date) {\n    return date.getMonth() === 11;\n  }\n  isLeapYear(year, interval) {\n    return (year + interval) % 4 === 0;\n  }\n}\n/** @private */\nclass Islamic {\n  firstDateOfMonth(date) {\n    const hDate = this.getHijriDate(date);\n    const gDate = HijriParser.toGregorian(hDate.year, hDate.month, 1);\n    return gDate;\n  }\n  lastDateOfMonth(date) {\n    const hDate = this.getHijriDate(date);\n    const daysInMonth = this.getDaysInMonth(hDate.month, hDate.year);\n    const gDate = HijriParser.toGregorian(hDate.year, hDate.month, daysInMonth);\n    let finalGDate = new Date(gDate.getTime());\n    finalGDate = new Date(finalGDate.setDate(finalGDate.getDate() + 1));\n    let finalHDate = this.getHijriDate(finalGDate);\n    if (hDate.month === finalHDate.month) {\n      return finalGDate;\n    }\n    finalHDate = this.getHijriDate(gDate);\n    if (hDate.month === finalHDate.month) {\n      return gDate;\n    }\n    return new Date(gDate.setDate(gDate.getDate() - 1));\n  }\n  isMonthStart(date) {\n    const hijriDate = this.getHijriDate(date);\n    return hijriDate.date === 1;\n  }\n  getLeapYearDaysCount() {\n    return 355;\n  }\n  getYearDaysCount(date, interval) {\n    const hDate = this.getHijriDate(date);\n    return this.isLeapYear(hDate.year, interval) ? 355 : 354;\n  }\n  getDate(date) {\n    const hijriDate = this.getHijriDate(date);\n    return hijriDate.date;\n  }\n  getMonth(date) {\n    const hDate = this.getHijriDate(date);\n    return hDate.month;\n  }\n  getFullYear(date) {\n    const hDate = this.getHijriDate(date);\n    return hDate.year;\n  }\n  getYearLastDate(date, interval) {\n    const hDate = this.getHijriDate(date);\n    const gDate = HijriParser.toGregorian(hDate.year + interval, 1, 0);\n    return gDate;\n  }\n  getMonthDaysCount(date) {\n    const maxDate = this.lastDateOfMonth(date);\n    const hijriDate = this.getHijriDate(maxDate);\n    return hijriDate.date;\n  }\n  getMonthStartDate(date) {\n    const firstDate = this.firstDateOfMonth(date);\n    return new Date(firstDate.getFullYear(), firstDate.getMonth(), firstDate.getDate(), date.getHours(), date.getMinutes());\n  }\n  getMonthEndDate(date) {\n    const lastDate = this.lastDateOfMonth(date);\n    lastDate.setDate(lastDate.getDate() + 1);\n    return new Date(lastDate.setMonth(lastDate.getMonth()));\n  }\n  getExpectedDays(date, days) {\n    const hDate = this.getHijriDate(date);\n    const day = [];\n    for (let i = 0; i < days.length; i++) {\n      const gDate = HijriParser.toGregorian(hDate.year, hDate.month, days[i]);\n      day.push(gDate.getDate());\n    }\n    return day;\n  }\n  setDate(dateObj, date) {\n    const hDate = this.getHijriDate(dateObj);\n    const gDate = HijriParser.toGregorian(hDate.year, hDate.month, date);\n    this.updateDateObj(dateObj, gDate);\n  }\n  setValidDate(date, interval, startDate, monthValue, beginDate) {\n    const firstDate = !isNullOrUndefined(beginDate) ? this.firstDateOfMonth(beginDate) : date;\n    const hDate = this.getHijriDate(firstDate);\n    const gDate = HijriParser.toGregorian(hDate.year, hDate.month + interval, startDate);\n    this.updateDateObj(date, gDate);\n  }\n  setMonth(date, interval, startDate) {\n    const hDate = this.getHijriDate(date);\n    const gDate = HijriParser.toGregorian(hDate.year, interval, startDate);\n    this.updateDateObj(date, gDate);\n  }\n  addYears(date, interval, monthValue) {\n    const hDate = this.getHijriDate(date);\n    const gDate = HijriParser.toGregorian(hDate.year + interval, monthValue, 1);\n    this.updateDateObj(date, gDate);\n  }\n  isSameMonth(date1, date2) {\n    const currentHijri = this.getHijriDate(date1);\n    const tempHijri = this.getHijriDate(date2);\n    return currentHijri.month === tempHijri.month;\n  }\n  checkMonth(date, months) {\n    const hDate = this.getHijriDate(date);\n    return months.indexOf(hDate.month) === -1;\n  }\n  compareMonth(date1, date2) {\n    const hDate = this.getHijriDate(date1);\n    const hDate1 = this.getHijriDate(date2);\n    return hDate.month > hDate1.month;\n  }\n  isSameYear(date1, date2) {\n    const hDate = this.getHijriDate(date1);\n    const hDate1 = this.getHijriDate(date2);\n    return hDate.year === hDate1.year;\n  }\n  isLastMonth(date) {\n    const hDate = this.getHijriDate(date);\n    return hDate.month === 12;\n  }\n  updateDateObj(date, gDate) {\n    date.setFullYear(gDate.getFullYear(), gDate.getMonth(), gDate.getDate());\n  }\n  isLeapYear(year, interval) {\n    return (14 + 11 * (year + interval)) % 30 < 11;\n  }\n  getDaysInMonth(month, year) {\n    let length = 0;\n    length = 29 + (month + 1) % 2;\n    if (month === 11 && this.isLeapYear(year, 0)) {\n      length++;\n    }\n    return length;\n  }\n  getHijriDate(date) {\n    return HijriParser.getHijriDate(date);\n  }\n}\n\n/**\n * Time zone\n */\nclass Timezone {\n  constructor() {\n    this.timezoneData = [];\n    this.timezoneData = this.getTimezoneData();\n  }\n  offset(date, timezone) {\n    const localOffset = date.getTimezoneOffset();\n    try {\n      const convertedDate = new Date(date.toLocaleString('en-US', {\n        timeZone: timezone\n      }));\n      if (!isNaN(convertedDate.getTime())) {\n        return (date.getTime() - convertedDate.getTime()) / 60000 + localOffset;\n      }\n      return 0;\n    } catch (error) {\n      return 0;\n    }\n  }\n  convert(date, fromOffset, toOffset) {\n    if (typeof fromOffset === 'string') {\n      fromOffset = this.offset(date, fromOffset);\n    }\n    if (typeof toOffset === 'string') {\n      toOffset = this.offset(date, toOffset);\n    }\n    const fromLocalOffset = date.getTimezoneOffset();\n    date = new Date(date.getTime() + (fromOffset - toOffset) * 60000);\n    const toLocalOffset = date.getTimezoneOffset();\n    return new Date(date.getTime() + (toLocalOffset - fromLocalOffset) * 60000);\n  }\n  add(date, timezone) {\n    return this.convert(date, date.getTimezoneOffset(), timezone);\n  }\n  remove(date, timezone) {\n    return this.convert(date, timezone, date.getTimezoneOffset());\n  }\n  removeLocalOffset(date) {\n    return new Date(date.getTime() - date.getTimezoneOffset() * 60000);\n  }\n  getLocalTimezoneName() {\n    return window.Intl ? Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC' : 'UTC';\n  }\n  getTimezoneData() {\n    return timezoneData;\n  }\n}\nconst timezoneData = [{\n  Value: 'Pacific/Niue',\n  Text: '(UTC-11:00) Niue'\n}, {\n  Value: 'Pacific/Pago_Pago',\n  Text: '(UTC-11:00) Pago Pago'\n}, {\n  Value: 'Pacific/Honolulu',\n  Text: '(UTC-10:00) Hawaii Time'\n}, {\n  Value: 'Pacific/Rarotonga',\n  Text: '(UTC-10:00) Rarotonga'\n}, {\n  Value: 'Pacific/Tahiti',\n  Text: '(UTC-10:00) Tahiti'\n}, {\n  Value: 'Pacific/Marquesas',\n  Text: '(UTC-09:30) Marquesas'\n}, {\n  Value: 'America/Anchorage',\n  Text: '(UTC-09:00) Alaska Time'\n}, {\n  Value: 'Pacific/Gambier',\n  Text: '(UTC-09:00) Gambier'\n}, {\n  Value: 'America/Los_Angeles',\n  Text: '(UTC-08:00) Pacific Time'\n}, {\n  Value: 'America/Tijuana',\n  Text: '(UTC-08:00) Pacific Time - Tijuana'\n}, {\n  Value: 'America/Vancouver',\n  Text: '(UTC-08:00) Pacific Time - Vancouver'\n}, {\n  Value: 'America/Whitehorse',\n  Text: '(UTC-08:00) Pacific Time - Whitehorse'\n}, {\n  Value: 'Pacific/Pitcairn',\n  Text: '(UTC-08:00) Pitcairn'\n}, {\n  Value: 'America/Denver',\n  Text: '(UTC-07:00) Mountain Time'\n}, {\n  Value: 'America/Phoenix',\n  Text: '(UTC-07:00) Mountain Time - Arizona'\n}, {\n  Value: 'America/Mazatlan',\n  Text: '(UTC-07:00) Mountain Time - Chihuahua, Mazatlan'\n}, {\n  Value: 'America/Dawson_Creek',\n  Text: '(UTC-07:00) Mountain Time - Dawson Creek'\n}, {\n  Value: 'America/Edmonton',\n  Text: '(UTC-07:00) Mountain Time - Edmonton'\n}, {\n  Value: 'America/Hermosillo',\n  Text: '(UTC-07:00) Mountain Time - Hermosillo'\n}, {\n  Value: 'America/Yellowknife',\n  Text: '(UTC-07:00) Mountain Time - Yellowknife'\n}, {\n  Value: 'America/Belize',\n  Text: '(UTC-06:00) Belize'\n}, {\n  Value: 'America/Chicago',\n  Text: '(UTC-06:00) Central Time'\n}, {\n  Value: 'America/Mexico_City',\n  Text: '(UTC-06:00) Central Time - Mexico City'\n}, {\n  Value: 'America/Regina',\n  Text: '(UTC-06:00) Central Time - Regina'\n}, {\n  Value: 'America/Tegucigalpa',\n  Text: '(UTC-06:00) Central Time - Tegucigalpa'\n}, {\n  Value: 'America/Winnipeg',\n  Text: '(UTC-06:00) Central Time - Winnipeg'\n}, {\n  Value: 'America/Costa_Rica',\n  Text: '(UTC-06:00) Costa Rica'\n}, {\n  Value: 'America/El_Salvador',\n  Text: '(UTC-06:00) El Salvador'\n}, {\n  Value: 'Pacific/Galapagos',\n  Text: '(UTC-06:00) Galapagos'\n}, {\n  Value: 'America/Guatemala',\n  Text: '(UTC-06:00) Guatemala'\n}, {\n  Value: 'America/Managua',\n  Text: '(UTC-06:00) Managua'\n}, {\n  Value: 'America/Cancun',\n  Text: '(UTC-05:00) America Cancun'\n}, {\n  Value: 'America/Bogota',\n  Text: '(UTC-05:00) Bogota'\n}, {\n  Value: 'Pacific/Easter',\n  Text: '(UTC-05:00) Easter Island'\n}, {\n  Value: 'America/New_York',\n  Text: '(UTC-05:00) Eastern Time'\n}, {\n  Value: 'America/Iqaluit',\n  Text: '(UTC-05:00) Eastern Time - Iqaluit'\n}, {\n  Value: 'America/Toronto',\n  Text: '(UTC-05:00) Eastern Time - Toronto'\n}, {\n  Value: 'America/Guayaquil',\n  Text: '(UTC-05:00) Guayaquil'\n}, {\n  Value: 'America/Havana',\n  Text: '(UTC-05:00) Havana'\n}, {\n  Value: 'America/Jamaica',\n  Text: '(UTC-05:00) Jamaica'\n}, {\n  Value: 'America/Lima',\n  Text: '(UTC-05:00) Lima'\n}, {\n  Value: 'America/Nassau',\n  Text: '(UTC-05:00) Nassau'\n}, {\n  Value: 'America/Panama',\n  Text: '(UTC-05:00) Panama'\n}, {\n  Value: 'America/Port-au-Prince',\n  Text: '(UTC-05:00) Port-au-Prince'\n}, {\n  Value: 'America/Rio_Branco',\n  Text: '(UTC-05:00) Rio Branco'\n}, {\n  Value: 'America/Halifax',\n  Text: '(UTC-04:00) Atlantic Time - Halifax'\n}, {\n  Value: 'America/Barbados',\n  Text: '(UTC-04:00) Barbados'\n}, {\n  Value: 'Atlantic/Bermuda',\n  Text: '(UTC-04:00) Bermuda'\n}, {\n  Value: 'America/Boa_Vista',\n  Text: '(UTC-04:00) Boa Vista'\n}, {\n  Value: 'America/Caracas',\n  Text: '(UTC-04:00) Caracas'\n}, {\n  Value: 'America/Curacao',\n  Text: '(UTC-04:00) Curacao'\n}, {\n  Value: 'America/Grand_Turk',\n  Text: '(UTC-04:00) Grand Turk'\n}, {\n  Value: 'America/Guyana',\n  Text: '(UTC-04:00) Guyana'\n}, {\n  Value: 'America/La_Paz',\n  Text: '(UTC-04:00) La Paz'\n}, {\n  Value: 'America/Manaus',\n  Text: '(UTC-04:00) Manaus'\n}, {\n  Value: 'America/Martinique',\n  Text: '(UTC-04:00) Martinique'\n}, {\n  Value: 'America/Port_of_Spain',\n  Text: '(UTC-04:00) Port of Spain'\n}, {\n  Value: 'America/Porto_Velho',\n  Text: '(UTC-04:00) Porto Velho'\n}, {\n  Value: 'America/Puerto_Rico',\n  Text: '(UTC-04:00) Puerto Rico'\n}, {\n  Value: 'America/Santo_Domingo',\n  Text: '(UTC-04:00) Santo Domingo'\n}, {\n  Value: 'America/Thule',\n  Text: '(UTC-04:00) Thule'\n}, {\n  Value: 'America/St_Johns',\n  Text: '(UTC-03:30) Newfoundland Time - St. Johns'\n}, {\n  Value: 'America/Araguaina',\n  Text: '(UTC-03:00) Araguaina'\n}, {\n  Value: 'America/Asuncion',\n  Text: '(UTC-03:00) Asuncion'\n}, {\n  Value: 'America/Belem',\n  Text: '(UTC-03:00) Belem'\n}, {\n  Value: 'America/Argentina/Buenos_Aires',\n  Text: '(UTC-03:00) Buenos Aires'\n}, {\n  Value: 'America/Campo_Grande',\n  Text: '(UTC-03:00) Campo Grande'\n}, {\n  Value: 'America/Cayenne',\n  Text: '(UTC-03:00) Cayenne'\n}, {\n  Value: 'America/Cuiaba',\n  Text: '(UTC-03:00) Cuiaba'\n}, {\n  Value: 'America/Fortaleza',\n  Text: '(UTC-03:00) Fortaleza'\n}, {\n  Value: 'America/Godthab',\n  Text: '(UTC-03:00) Godthab'\n}, {\n  Value: 'America/Maceio',\n  Text: '(UTC-03:00) Maceio'\n}, {\n  Value: 'America/Miquelon',\n  Text: '(UTC-03:00) Miquelon'\n}, {\n  Value: 'America/Montevideo',\n  Text: '(UTC-03:00) Montevideo'\n}, {\n  Value: 'Antarctica/Palmer',\n  Text: '(UTC-03:00) Palmer'\n}, {\n  Value: 'America/Paramaribo',\n  Text: '(UTC-03:00) Paramaribo'\n}, {\n  Value: 'America/Punta_Arenas',\n  Text: '(UTC-03:00) Punta Arenas'\n}, {\n  Value: 'America/Recife',\n  Text: '(UTC-03:00) Recife'\n}, {\n  Value: 'Antarctica/Rothera',\n  Text: '(UTC-03:00) Rothera'\n}, {\n  Value: 'America/Bahia',\n  Text: '(UTC-03:00) Salvador'\n}, {\n  Value: 'America/Santiago',\n  Text: '(UTC-03:00) Santiago'\n}, {\n  Value: 'Atlantic/Stanley',\n  Text: '(UTC-03:00) Stanley'\n}, {\n  Value: 'America/Noronha',\n  Text: '(UTC-02:00) Noronha'\n}, {\n  Value: 'America/Sao_Paulo',\n  Text: '(UTC-02:00) Sao Paulo'\n}, {\n  Value: 'Atlantic/South_Georgia',\n  Text: '(UTC-02:00) South Georgia'\n}, {\n  Value: 'Atlantic/Azores',\n  Text: '(UTC-01:00) Azores'\n}, {\n  Value: 'Atlantic/Cape_Verde',\n  Text: '(UTC-01:00) Cape Verde'\n}, {\n  Value: 'America/Scoresbysund',\n  Text: '(UTC-01:00) Scoresbysund'\n}, {\n  Value: 'Africa/Abidjan',\n  Text: '(UTC+00:00) Abidjan'\n}, {\n  Value: 'Africa/Accra',\n  Text: '(UTC+00:00) Accra'\n}, {\n  Value: 'Africa/Bissau',\n  Text: '(UTC+00:00) Bissau'\n}, {\n  Value: 'Atlantic/Canary',\n  Text: '(UTC+00:00) Canary Islands'\n}, {\n  Value: 'Africa/Casablanca',\n  Text: '(UTC+00:00) Casablanca'\n}, {\n  Value: 'America/Danmarkshavn',\n  Text: '(UTC+00:00) Danmarkshavn'\n}, {\n  Value: 'Europe/Dublin',\n  Text: '(UTC+00:00) Dublin'\n}, {\n  Value: 'Africa/El_Aaiun',\n  Text: '(UTC+00:00) El Aaiun'\n}, {\n  Value: 'Atlantic/Faroe',\n  Text: '(UTC+00:00) Faeroe'\n}, {\n  Value: 'Etc/UTC',\n  Text: '(UTC+00:00) UTC (no daylight saving)'\n}, {\n  Value: 'Europe/Lisbon',\n  Text: '(UTC+00:00) Lisbon'\n}, {\n  Value: 'Europe/London',\n  Text: '(UTC+00:00) London'\n}, {\n  Value: 'Africa/Monrovia',\n  Text: '(UTC+00:00) Monrovia'\n}, {\n  Value: 'Atlantic/Reykjavik',\n  Text: '(UTC+00:00) Reykjavik'\n}, {\n  Value: 'UTC',\n  Text: 'UTC'\n}, {\n  Value: 'Africa/Algiers',\n  Text: '(UTC+01:00) Algiers'\n}, {\n  Value: 'Europe/Amsterdam',\n  Text: '(UTC+01:00) Amsterdam'\n}, {\n  Value: 'Europe/Andorra',\n  Text: '(UTC+01:00) Andorra'\n}, {\n  Value: 'Europe/Berlin',\n  Text: '(UTC+01:00) Berlin'\n}, {\n  Value: 'Europe/Brussels',\n  Text: '(UTC+01:00) Brussels'\n}, {\n  Value: 'Europe/Budapest',\n  Text: '(UTC+01:00) Budapest'\n}, {\n  Value: 'Europe/Belgrade',\n  Text: '(UTC+01:00) Central European Time - Belgrade'\n}, {\n  Value: 'Europe/Prague',\n  Text: '(UTC+01:00) Central European Time - Prague'\n}, {\n  Value: 'Africa/Ceuta',\n  Text: '(UTC+01:00) Ceuta'\n}, {\n  Value: 'Europe/Copenhagen',\n  Text: '(UTC+01:00) Copenhagen'\n}, {\n  Value: 'Europe/Gibraltar',\n  Text: '(UTC+01:00) Gibraltar'\n}, {\n  Value: 'Africa/Lagos',\n  Text: '(UTC+01:00) Lagos'\n}, {\n  Value: 'Europe/Luxembourg',\n  Text: '(UTC+01:00) Luxembourg'\n}, {\n  Value: 'Europe/Madrid',\n  Text: '(UTC+01:00) Madrid'\n}, {\n  Value: 'Europe/Malta',\n  Text: '(UTC+01:00) Malta'\n}, {\n  Value: 'Europe/Monaco',\n  Text: '(UTC+01:00) Monaco'\n}, {\n  Value: 'Africa/Ndjamena',\n  Text: '(UTC+01:00) Ndjamena'\n}, {\n  Value: 'Europe/Oslo',\n  Text: '(UTC+01:00) Oslo'\n}, {\n  Value: 'Europe/Paris',\n  Text: '(UTC+01:00) Paris'\n}, {\n  Value: 'Europe/Rome',\n  Text: '(UTC+01:00) Rome'\n}, {\n  Value: 'Europe/Stockholm',\n  Text: '(UTC+01:00) Stockholm'\n}, {\n  Value: 'Europe/Tirane',\n  Text: '(UTC+01:00) Tirane'\n}, {\n  Value: 'Africa/Tunis',\n  Text: '(UTC+01:00) Tunis'\n}, {\n  Value: 'Europe/Vienna',\n  Text: '(UTC+01:00) Vienna'\n}, {\n  Value: 'Europe/Warsaw',\n  Text: '(UTC+01:00) Warsaw'\n}, {\n  Value: 'Europe/Zurich',\n  Text: '(UTC+01:00) Zurich'\n}, {\n  Value: 'Asia/Amman',\n  Text: '(UTC+02:00) Amman'\n}, {\n  Value: 'Europe/Athens',\n  Text: '(UTC+02:00) Athens'\n}, {\n  Value: 'Asia/Beirut',\n  Text: '(UTC+02:00) Beirut'\n}, {\n  Value: 'Europe/Bucharest',\n  Text: '(UTC+02:00) Bucharest'\n}, {\n  Value: 'Africa/Cairo',\n  Text: '(UTC+02:00) Cairo'\n}, {\n  Value: 'Europe/Chisinau',\n  Text: '(UTC+02:00) Chisinau'\n}, {\n  Value: 'Asia/Damascus',\n  Text: '(UTC+02:00) Damascus'\n}, {\n  Value: 'Asia/Gaza',\n  Text: '(UTC+02:00) Gaza'\n}, {\n  Value: 'Europe/Helsinki',\n  Text: '(UTC+02:00) Helsinki'\n}, {\n  Value: 'Asia/Jerusalem',\n  Text: '(UTC+02:00) Jerusalem'\n}, {\n  Value: 'Africa/Johannesburg',\n  Text: '(UTC+02:00) Johannesburg'\n}, {\n  Value: 'Africa/Khartoum',\n  Text: '(UTC+02:00) Khartoum'\n}, {\n  Value: 'Europe/Kiev',\n  Text: '(UTC+02:00) Kiev'\n}, {\n  Value: 'Africa/Maputo',\n  Text: '(UTC+02:00) Maputo'\n}, {\n  Value: 'Europe/Kaliningrad',\n  Text: '(UTC+02:00) Moscow-01 - Kaliningrad'\n}, {\n  Value: 'Asia/Nicosia',\n  Text: '(UTC+02:00) Nicosia'\n}, {\n  Value: 'Europe/Riga',\n  Text: '(UTC+02:00) Riga'\n}, {\n  Value: 'Europe/Sofia',\n  Text: '(UTC+02:00) Sofia'\n}, {\n  Value: 'Europe/Tallinn',\n  Text: '(UTC+02:00) Tallinn'\n}, {\n  Value: 'Africa/Tripoli',\n  Text: '(UTC+02:00) Tripoli'\n}, {\n  Value: 'Europe/Vilnius',\n  Text: '(UTC+02:00) Vilnius'\n}, {\n  Value: 'Africa/Windhoek',\n  Text: '(UTC+02:00) Windhoek'\n}, {\n  Value: 'Asia/Baghdad',\n  Text: '(UTC+03:00) Baghdad'\n}, {\n  Value: 'Europe/Istanbul',\n  Text: '(UTC+03:00) Istanbul'\n}, {\n  Value: 'Europe/Minsk',\n  Text: '(UTC+03:00) Minsk'\n}, {\n  Value: 'Europe/Moscow',\n  Text: '(UTC+03:00) Moscow+00 - Moscow'\n}, {\n  Value: 'Africa/Nairobi',\n  Text: '(UTC+03:00) Nairobi'\n}, {\n  Value: 'Asia/Qatar',\n  Text: '(UTC+03:00) Qatar'\n}, {\n  Value: 'Asia/Riyadh',\n  Text: '(UTC+03:00) Riyadh'\n}, {\n  Value: 'Antarctica/Syowa',\n  Text: '(UTC+03:00) Syowa'\n}, {\n  Value: 'Asia/Tehran',\n  Text: '(UTC+03:30) Tehran'\n}, {\n  Value: 'Asia/Baku',\n  Text: '(UTC+04:00) Baku'\n}, {\n  Value: 'Asia/Dubai',\n  Text: '(UTC+04:00) Dubai'\n}, {\n  Value: 'Indian/Mahe',\n  Text: '(UTC+04:00) Mahe'\n}, {\n  Value: 'Indian/Mauritius',\n  Text: '(UTC+04:00) Mauritius'\n}, {\n  Value: 'Europe/Samara',\n  Text: '(UTC+04:00) Moscow+01 - Samara'\n}, {\n  Value: 'Indian/Reunion',\n  Text: '(UTC+04:00) Reunion'\n}, {\n  Value: 'Asia/Tbilisi',\n  Text: '(UTC+04:00) Tbilisi'\n}, {\n  Value: 'Asia/Yerevan',\n  Text: '(UTC+04:00) Yerevan'\n}, {\n  Value: 'Asia/Kabul',\n  Text: '(UTC+04:30) Kabul'\n}, {\n  Value: 'Asia/Aqtau',\n  Text: '(UTC+05:00) Aqtau'\n}, {\n  Value: 'Asia/Aqtobe',\n  Text: '(UTC+05:00) Aqtobe'\n}, {\n  Value: 'Asia/Ashgabat',\n  Text: '(UTC+05:00) Ashgabat'\n}, {\n  Value: 'Asia/Dushanbe',\n  Text: '(UTC+05:00) Dushanbe'\n}, {\n  Value: 'Asia/Karachi',\n  Text: '(UTC+05:00) Karachi'\n}, {\n  Value: 'Indian/Kerguelen',\n  Text: '(UTC+05:00) Kerguelen'\n}, {\n  Value: 'Indian/Maldives',\n  Text: '(UTC+05:00) Maldives'\n}, {\n  Value: 'Antarctica/Mawson',\n  Text: '(UTC+05:00) Mawson'\n}, {\n  Value: 'Asia/Yekaterinburg',\n  Text: '(UTC+05:00) Moscow+02 - Yekaterinburg'\n}, {\n  Value: 'Asia/Tashkent',\n  Text: '(UTC+05:00) Tashkent'\n}, {\n  Value: 'Asia/Colombo',\n  Text: '(UTC+05:30) Colombo'\n}, {\n  Value: 'Asia/Kolkata',\n  Text: '(UTC+05:30) India Standard Time'\n}, {\n  Value: 'Asia/Katmandu',\n  Text: '(UTC+05:45) Katmandu'\n}, {\n  Value: 'Asia/Almaty',\n  Text: '(UTC+06:00) Almaty'\n}, {\n  Value: 'Asia/Bishkek',\n  Text: '(UTC+06:00) Bishkek'\n}, {\n  Value: 'Indian/Chagos',\n  Text: '(UTC+06:00) Chagos'\n}, {\n  Value: 'Asia/Dhaka',\n  Text: '(UTC+06:00) Dhaka'\n}, {\n  Value: 'Asia/Omsk',\n  Text: '(UTC+06:00) Moscow+03 - Omsk'\n}, {\n  Value: 'Asia/Thimphu',\n  Text: '(UTC+06:00) Thimphu'\n}, {\n  Value: 'Antarctica/Vostok',\n  Text: '(UTC+06:00) Vostok'\n}, {\n  Value: 'Indian/Cocos',\n  Text: '(UTC+06:30) Cocos'\n}, {\n  Value: 'Asia/Yangon',\n  Text: '(UTC+06:30) Rangoon'\n}, {\n  Value: 'Asia/Bangkok',\n  Text: '(UTC+07:00) Bangkok'\n}, {\n  Value: 'Indian/Christmas',\n  Text: '(UTC+07:00) Christmas'\n}, {\n  Value: 'Antarctica/Davis',\n  Text: '(UTC+07:00) Davis'\n}, {\n  Value: 'Asia/Saigon',\n  Text: '(UTC+07:00) Hanoi'\n}, {\n  Value: 'Asia/Hovd',\n  Text: '(UTC+07:00) Hovd'\n}, {\n  Value: 'Asia/Jakarta',\n  Text: '(UTC+07:00) Jakarta'\n}, {\n  Value: 'Asia/Krasnoyarsk',\n  Text: '(UTC+07:00) Moscow+04 - Krasnoyarsk'\n}, {\n  Value: 'Asia/Brunei',\n  Text: '(UTC+08:00) Brunei'\n}, {\n  Value: 'Asia/Shanghai',\n  Text: '(UTC+08:00) China Time - Beijing'\n}, {\n  Value: 'Asia/Choibalsan',\n  Text: '(UTC+08:00) Choibalsan'\n}, {\n  Value: 'Asia/Hong_Kong',\n  Text: '(UTC+08:00) Hong Kong'\n}, {\n  Value: 'Asia/Kuala_Lumpur',\n  Text: '(UTC+08:00) Kuala Lumpur'\n}, {\n  Value: 'Asia/Macau',\n  Text: '(UTC+08:00) Macau'\n}, {\n  Value: 'Asia/Makassar',\n  Text: '(UTC+08:00) Makassar'\n}, {\n  Value: 'Asia/Manila',\n  Text: '(UTC+08:00) Manila'\n}, {\n  Value: 'Asia/Irkutsk',\n  Text: '(UTC+08:00) Moscow+05 - Irkutsk'\n}, {\n  Value: 'Asia/Singapore',\n  Text: '(UTC+08:00) Singapore'\n}, {\n  Value: 'Asia/Taipei',\n  Text: '(UTC+08:00) Taipei'\n}, {\n  Value: 'Asia/Ulaanbaatar',\n  Text: '(UTC+08:00) Ulaanbaatar'\n}, {\n  Value: 'Australia/Perth',\n  Text: '(UTC+08:00) Western Time - Perth'\n}, {\n  Value: 'Asia/Pyongyang',\n  Text: '(UTC+08:30) Pyongyang'\n}, {\n  Value: 'Asia/Dili',\n  Text: '(UTC+09:00) Dili'\n}, {\n  Value: 'Asia/Jayapura',\n  Text: '(UTC+09:00) Jayapura'\n}, {\n  Value: 'Asia/Yakutsk',\n  Text: '(UTC+09:00) Moscow+06 - Yakutsk'\n}, {\n  Value: 'Pacific/Palau',\n  Text: '(UTC+09:00) Palau'\n}, {\n  Value: 'Asia/Seoul',\n  Text: '(UTC+09:00) Seoul'\n}, {\n  Value: 'Asia/Tokyo',\n  Text: '(UTC+09:00) Tokyo'\n}, {\n  Value: 'Australia/Darwin',\n  Text: '(UTC+09:30) Central Time - Darwin'\n}, {\n  Value: 'Antarctica/DumontDUrville',\n  Text: '(UTC+10:00) Dumont D\"Urville'\n}, {\n  Value: 'Australia/Brisbane',\n  Text: '(UTC+10:00) Eastern Time - Brisbane'\n}, {\n  Value: 'Pacific/Guam',\n  Text: '(UTC+10:00) Guam'\n}, {\n  Value: 'Asia/Vladivostok',\n  Text: '(UTC+10:00) Moscow+07 - Vladivostok'\n}, {\n  Value: 'Pacific/Port_Moresby',\n  Text: '(UTC+10:00) Port Moresby'\n}, {\n  Value: 'Pacific / Chuuk',\n  Text: '(UTC+10:00) Truk'\n}, {\n  Value: 'Australia/Adelaide',\n  Text: '(UTC+10:30) Central Time - Adelaide'\n}, {\n  Value: 'Antarctica/Casey',\n  Text: '(UTC+11:00) Casey'\n}, {\n  Value: 'Australia/Hobart',\n  Text: '(UTC+11:00) Eastern Time - Hobart'\n}, {\n  Value: 'Australia/Sydney',\n  Text: '(UTC+11:00) Eastern Time - Melbourne, Sydney'\n}, {\n  Value: 'Pacific/Efate',\n  Text: '(UTC+11:00) Efate'\n}, {\n  Value: 'Pacific/Guadalcanal',\n  Text: '(UTC+11:00) Guadalcanal'\n}, {\n  Value: 'Pacific/Kosrae',\n  Text: '(UTC+11:00) Kosrae'\n}, {\n  Value: 'Asia/Magadan',\n  Text: '(UTC+11:00) Moscow+08 - Magadan'\n}, {\n  Value: 'Pacific / Norfolk',\n  Text: '(UTC+11:00) Norfolk'\n}, {\n  Value: 'Pacific/Noumea',\n  Text: '(UTC+11:00) Noumea'\n}, {\n  Value: 'Pacific/Pohnpei',\n  Text: '(UTC+11:00) Ponape'\n}, {\n  Value: 'Pacific/Funafuti',\n  Text: '(UTC+12:00) Funafuti'\n}, {\n  Value: 'Pacific/Kwajalein',\n  Text: '(UTC+12:00) Kwajalein'\n}, {\n  Value: 'Pacific/Majuro',\n  Text: '(UTC+12:00) Majuro'\n}, {\n  Value: 'Asia/Kamchatka',\n  Text: '(UTC+12:00) Moscow+09 - Petropavlovsk - Kamchatskiy'\n}, {\n  Value: 'Pacific / Nauru',\n  Text: '(UTC+12:00) Nauru'\n}, {\n  Value: 'Pacific/Tarawa',\n  Text: '(UTC+12:00) Tarawa'\n}, {\n  Value: 'Pacific/Wake',\n  Text: '(UTC+12:00) Wake'\n}, {\n  Value: 'Pacific/Wallis',\n  Text: '(UTC+12:00) Wallis'\n}, {\n  Value: 'Pacific/Auckland',\n  Text: '(UTC+13:00) Auckland'\n}, {\n  Value: 'Pacific/Enderbury',\n  Text: '(UTC+13:00) Enderbury'\n}, {\n  Value: 'Pacific/Fakaofo',\n  Text: '(UTC+13:00) Fakaofo'\n}, {\n  Value: 'Pacific/Fiji',\n  Text: '(UTC+13:00) Fiji'\n}, {\n  Value: 'Pacific/Tongatapu',\n  Text: '(UTC+13:00) Tongatapu'\n}, {\n  Value: 'Pacific/Apia',\n  Text: '(UTC+14:00) Apia'\n}, {\n  Value: 'Pacific/Kiritimati',\n  Text: '(UTC+14:00) Kiritimati'\n}];\n\n/* eslint-disable max-len */\n/**\n * Date Generator from Recurrence Rule\n */\n/**\n * Generate Summary from Recurrence Rule\n *\n * @param {string} rule Accepts the Recurrence rule\n * @param {L10n} localeObject Accepts the locale object\n * @param {string} locale Accepts the locale name\n * @param {CalendarType} calendarType Accepts the calendar type\n * @returns {string} Returns the summary string from given recurrence rule\n */\nfunction generateSummary(rule, localeObject, locale, calendarType = 'Gregorian') {\n  const ruleObject = extractObjectFromRule(rule);\n  let summary = localeObject.getConstant(EVERY) + ' ';\n  let cldrObj;\n  let cldrObj1;\n  const calendarMode = calendarType.toLowerCase();\n  if (locale === 'en' || locale === 'en-US') {\n    const nameSpace1 = 'months.stand-alone.abbreviated';\n    const nameSpace = 'days.stand-alone.abbreviated';\n    cldrObj1 = getValue(nameSpace1, getDefaultDateObject(calendarMode));\n    cldrObj = getValue(nameSpace, getDefaultDateObject(calendarMode));\n  } else {\n    const nameSpace1 = 'main.' + locale + '.dates.calendars.' + calendarMode + '.months.stand-alone.abbreviated';\n    const nameSpace = 'main.' + locale + '.dates.calendars.' + calendarMode + '.days.stand-alone.abbreviated';\n    cldrObj1 = getValue(nameSpace1, cldrData);\n    cldrObj = getValue(nameSpace, cldrData);\n  }\n  if (ruleObject.interval > 1) {\n    summary += ruleObject.interval + ' ';\n  }\n  switch (ruleObject.freq) {\n    case 'DAILY':\n      summary += localeObject.getConstant(DAYS);\n      break;\n    case 'WEEKLY':\n      summary += localeObject.getConstant(WEEKS) + ' ' + localeObject.getConstant(ON) + ' ';\n      ruleObject.day.forEach((day, index) => {\n        summary += capitalizeFirstWord(getValue(DAYINDEXOBJECT[day], cldrObj), 'single');\n        summary += ruleObject.day.length - 1 === index ? '' : ', ';\n      });\n      break;\n    case 'MONTHLY':\n      summary += localeObject.getConstant(MONTHS) + ' ' + localeObject.getConstant(ON) + ' ';\n      summary += getMonthSummary(ruleObject, cldrObj, localeObject);\n      break;\n    case 'YEARLY':\n      summary += localeObject.getConstant(YEARS) + ' ' + localeObject.getConstant(ON) + ' ';\n      summary += capitalizeFirstWord(getValue(ruleObject.month[0].toString(), cldrObj1), 'single') + ' ';\n      summary += getMonthSummary(ruleObject, cldrObj, localeObject);\n      break;\n  }\n  if (ruleObject.count) {\n    summary += ', ' + ruleObject.count + ' ' + localeObject.getConstant(TIMES);\n  } else if (ruleObject.until) {\n    const tempDate = ruleObject.until;\n    summary += ', ' + localeObject.getConstant(UNTIL) + ' ' + tempDate.getDate() + ' ' + capitalizeFirstWord(getValue((tempDate.getMonth() + 1).toString(), cldrObj1), 'single') + ' ' + tempDate.getFullYear();\n  }\n  return summary;\n}\n/**\n * Generates Month summary\n *\n * @param {RecRule} ruleObject Accepts the recurrence rule object\n * @param {string[]} cldrObj Accepts the collections of month name from calendar\n * @param {L10n} localeObj Accepts the locale object\n * @returns {string} Returns the month summary string from given recurrence rule object\n * @private\n */\nfunction getMonthSummary(ruleObject, cldrObj, localeObj) {\n  let summary = '';\n  if (ruleObject.monthDay.length) {\n    summary += ruleObject.monthDay[0];\n  } else if (ruleObject.day) {\n    const pos = ruleObject.setPosition - 1;\n    summary += localeObj.getConstant(WEEKPOS[pos > -1 ? pos : WEEKPOS.length - 1]) + ' ' + capitalizeFirstWord(getValue(DAYINDEXOBJECT[ruleObject.day[0]], cldrObj), 'single');\n  }\n  return summary;\n}\n/**\n * Generates the date collections from the given recurrence rule\n *\n * @param {Date} startDate Accepts the rule start date\n * @param {string} rule Accepts the recurrence rule\n * @param {string} excludeDate Accepts the exception dates in string format\n * @param {number} startDayOfWeek Accepts the start day index of week\n * @param {number} maximumCount Accepts the maximum number count to generate date collections\n * @param {Date} viewDate Accepts the current date instead of start date\n * @param {CalendarType} calendarMode Accepts the calendar type\n * @param {string} oldTimezone Accepts the timezone name\n * @param {string} newTimezone Accepts the timezone name\n * @returns {number[]} Returns the collection of dates\n */\nfunction generate(startDate, rule, excludeDate, startDayOfWeek, maximumCount = MAXOCCURRENCE, viewDate = null, calendarMode = 'Gregorian', oldTimezone = null, newTimezone = null) {\n  const ruleObject = extractObjectFromRule(rule);\n  let cacheDate;\n  calendarUtil = getCalendarUtil(calendarMode);\n  const data = [];\n  const modifiedDate = new Date(startDate.getTime());\n  tempExcludeDate = [];\n  const tempDate = isNullOrUndefined(excludeDate) ? [] : excludeDate.split(',');\n  const tz = new Timezone();\n  tempDate.forEach(content => {\n    let parsedDate = getDateFromRecurrenceDateString(content);\n    if (oldTimezone && newTimezone) {\n      parsedDate = tz.convert(new Date(parsedDate.getTime()), oldTimezone, newTimezone);\n    }\n    tempExcludeDate.push(new Date(parsedDate.getTime()).setHours(0, 0, 0, 0));\n  });\n  ruleObject.recExceptionCount = !isNullOrUndefined(ruleObject.count) ? tempExcludeDate.length : 0;\n  if (viewDate && viewDate > startDate && !ruleObject.count) {\n    tempViewDate = new Date(new Date(viewDate.getTime()).setHours(0, 0, 0));\n  } else {\n    tempViewDate = null;\n  }\n  if (!ruleObject.until && tempViewDate) {\n    cacheDate = new Date(tempViewDate.getTime());\n    cacheDate.setDate(tempViewDate.getDate() + maximumCount * ruleObject.interval);\n    ruleObject.until = cacheDate;\n  }\n  if (ruleObject.until && startDate > ruleObject.until) {\n    return data;\n  }\n  maxOccurrence = maximumCount;\n  setFirstDayOfWeek(DAYINDEX[startDayOfWeek]);\n  switch (ruleObject.freq) {\n    case 'DAILY':\n      dailyType(modifiedDate, ruleObject.until, data, ruleObject);\n      break;\n    case 'WEEKLY':\n      weeklyType(modifiedDate, ruleObject.until, data, ruleObject);\n      break;\n    case 'MONTHLY':\n      monthlyType(modifiedDate, ruleObject.until, data, ruleObject);\n      break;\n    case 'YEARLY':\n      yearlyType(modifiedDate, ruleObject.until, data, ruleObject);\n  }\n  return data;\n}\n/**\n * Generate date object from given date string\n *\n * @param {string} recDateString Accepts the exception date as string\n * @returns {Date} Returns the date from exception date string\n */\nfunction getDateFromRecurrenceDateString(recDateString) {\n  return new Date(recDateString.substr(0, 4) + '-' + recDateString.substr(4, 2) + '-' + recDateString.substr(6, 5) + ':' + recDateString.substr(11, 2) + ':' + recDateString.substr(13));\n}\n/**\n * Internal method to handle exclude date\n *\n * @param {number[]} data Accepts the exception date collections\n * @param {number} date Accepts the new exclude date\n * @returns {void}\n * @private\n */\nfunction excludeDateHandler(data, date) {\n  const zeroIndex = new Date(date).setHours(0, 0, 0, 0);\n  if (tempExcludeDate.indexOf(zeroIndex) === -1 && (!tempViewDate || zeroIndex >= tempViewDate.getTime())) {\n    data.push(date);\n  }\n}\n/**\n * Internal method for get date count\n *\n * @param {Date} startDate Accepts the date\n * @param {RecRule} ruleObject Accepts the recurrence rule object\n * @returns {number} Returns the number of date count\n * @private\n */\nfunction getDateCount$1(startDate, ruleObject) {\n  let count = maxOccurrence;\n  if (ruleObject.count) {\n    count = ruleObject.count;\n  } else if (ruleObject.until) {\n    if (ruleObject.freq === 'DAILY' || ruleObject.freq === 'WEEKLY') {\n      count = Math.floor((ruleObject.until.getTime() - startDate.getTime()) / MS_PER_DAY) + 1;\n    } else if (ruleObject.freq === 'MONTHLY' || ruleObject.freq === 'YEARLY') {\n      count = Math.floor((ruleObject.until.getMonth() + 12 * ruleObject.until.getFullYear() - (startDate.getMonth() + 12 * startDate.getFullYear())) / ruleObject.interval) + (ruleObject.day.length > 1 ? Math.floor((ruleObject.until.getTime() - startDate.getTime()) / MS_PER_DAY) + 1 : 1);\n      if (ruleObject.freq === 'YEARLY') {\n        count = ruleObject.month.length > 1 ? count * ruleObject.month.length : count;\n      }\n    }\n  }\n  return count;\n}\n/**\n *  Internal method for daily type recurrence rule\n *\n * @param {Date} startDate Accepts the strat date\n * @param {Date} endDate Accepts the end date\n * @param {number[]} data Accepts the collection of dates\n * @param {RecRule} ruleObject Accepts the recurrence rule object\n * @returns {void}\n * @private\n */\nfunction dailyType(startDate, endDate, data, ruleObject) {\n  const tempDate = new Date(startDate.getTime());\n  const interval = ruleObject.interval;\n  const expectedCount = getDateCount$1(startDate, ruleObject);\n  let state;\n  const expectedDays = ruleObject.day;\n  while (compareDates(tempDate, endDate)) {\n    state = true;\n    state = validateRules(tempDate, ruleObject);\n    if (state && (expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1 || expectedDays.length === 0)) {\n      excludeDateHandler(data, tempDate.getTime());\n      if (expectedCount && data.length + ruleObject.recExceptionCount >= expectedCount) {\n        break;\n      }\n    }\n    tempDate.setDate(tempDate.getDate() + interval);\n  }\n}\n/**\n * Internal method for weekly type recurrence rule\n *\n * @param {Date} startDate Accepts the strat date\n * @param {Date} endDate Accepts the end date\n * @param {number[]} data Accepts the collection of dates\n * @param {RecRule} ruleObject Accepts the recurrence rule object\n * @returns {void}\n * @private\n */\nfunction weeklyType(startDate, endDate, data, ruleObject) {\n  let tempDate = new Date(startDate.getTime());\n  if (!ruleObject.day.length) {\n    ruleObject.day.push(DAYINDEX[startDate.getDay()]);\n  }\n  const interval = ruleObject.interval;\n  const expectedDays = ruleObject.day;\n  const expectedCount = getDateCount$1(startDate, ruleObject);\n  let weekState = true;\n  let wkstIndex;\n  let weekCollection = [];\n  if (expectedDays.length > 1) {\n    if (isNullOrUndefined(ruleObject.wkst) || ruleObject.wkst === '') {\n      ruleObject.wkst = dayIndex[0];\n    }\n    wkstIndex = DAYINDEX.indexOf(ruleObject.wkst);\n    while (compareDates(tempDate, endDate)) {\n      let startDateDiff = DAYINDEX.indexOf(DAYINDEX[tempDate.getDay()]) - wkstIndex;\n      startDateDiff = startDateDiff === -1 ? 6 : startDateDiff;\n      const weekstartDate = addDays(tempDate, -startDateDiff);\n      let weekendDate = addDays(weekstartDate, 6);\n      let compareTempDate = new Date(tempDate.getTime());\n      weekendDate = resetTime(weekendDate);\n      compareTempDate = resetTime(compareTempDate);\n      while (weekendDate >= compareTempDate) {\n        if (expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1) {\n          weekCollection.push([tempDate.getTime()]);\n        }\n        if (expectedCount && data.length + ruleObject.recExceptionCount >= expectedCount) {\n          break;\n        }\n        tempDate.setDate(tempDate.getDate() + 1);\n        compareTempDate = new Date(tempDate.getTime());\n        compareTempDate = resetTime(compareTempDate);\n      }\n      tempDate.setDate(tempDate.getDate() - 1);\n      if (expectedCount && data.length + ruleObject.recExceptionCount >= expectedCount) {\n        break;\n      }\n      tempDate.setDate(tempDate.getDate() + 1 + (interval - 1) * 7);\n      insertDataCollection(weekCollection, weekState, startDate, endDate, data, ruleObject);\n      weekCollection = [];\n    }\n  } else {\n    tempDate = getStartDateForWeek(startDate, ruleObject.day);\n    while (compareDates(tempDate, endDate)) {\n      weekState = validateRules(tempDate, ruleObject);\n      if (weekState && expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1) {\n        excludeDateHandler(data, tempDate.getTime());\n      }\n      if (expectedCount && data.length + ruleObject.recExceptionCount >= expectedCount) {\n        break;\n      }\n      tempDate.setDate(tempDate.getDate() + interval * 7);\n    }\n    insertDataCollection(weekCollection, weekState, startDate, endDate, data, ruleObject);\n    weekCollection = [];\n  }\n}\n/**\n *  Internal method for monthly type recurrence rule\n *\n * @param {Date} startDate Accepts the strat date\n * @param {Date} endDate Accepts the end date\n * @param {number[]} data Accepts the collection of dates\n * @param {RecRule} ruleObject Accepts the recurrence rule object\n * @returns {void}\n * @private\n */\nfunction monthlyType(startDate, endDate, data, ruleObject) {\n  // Set monthday value if BYDAY, BYMONTH and Month day property is not set based on start date\n  if (!ruleObject.month.length && !ruleObject.day.length && !ruleObject.monthDay.length) {\n    ruleObject.monthDay.push(startDate.getDate());\n    if (ruleObject.freq === 'YEARLY') {\n      ruleObject.month.push(startDate.getMonth() + 1);\n    }\n  } else if (ruleObject.month.length > 0 && !ruleObject.day.length && !ruleObject.monthDay.length) {\n    ruleObject.monthDay.push(startDate.getDate());\n  }\n  const ruleType = validateMonthlyRuleType(ruleObject);\n  switch (ruleType) {\n    case 'day':\n      switch (ruleObject.freq) {\n        case 'MONTHLY':\n          monthlyDayTypeProcessforMonthFreq(startDate, endDate, data, ruleObject);\n          break;\n        case 'YEARLY':\n          monthlyDayTypeProcess(startDate, endDate, data, ruleObject);\n          break;\n      }\n      break;\n    case 'both':\n    case 'date':\n      switch (ruleObject.freq) {\n        case 'MONTHLY':\n          monthlyDateTypeProcessforMonthFreq(startDate, endDate, data, ruleObject);\n          break;\n        case 'YEARLY':\n          monthlyDateTypeProcess(startDate, endDate, data, ruleObject);\n          break;\n      }\n      break;\n  }\n}\n/**\n * Internal method for yearly type recurrence rule\n *\n * @param {Date} startDate Accepts the strat date\n * @param {Date} endDate Accepts the end date\n * @param {number[]} data Accepts the collection of dates\n * @param {RecRule} ruleObject Accepts the recurrence rule object\n * @returns {void}\n * @private\n */\nfunction yearlyType(startDate, endDate, data, ruleObject) {\n  const typeValue = checkYearlyType(ruleObject);\n  switch (typeValue) {\n    case 'MONTH':\n      monthlyType(startDate, endDate, data, ruleObject);\n      break;\n    case 'WEEKNO':\n      processWeekNo(startDate, endDate, data, ruleObject);\n      break;\n    case 'YEARDAY':\n      processYearDay(startDate, endDate, data, ruleObject);\n      break;\n  }\n}\n/**\n * Internal method for process week no\n *\n * @param {Date} startDate Accepts the strat date\n * @param {Date} endDate Accepts the end date\n * @param {number[]} data Accepts the collection of dates\n * @param {RecRule} ruleObject Accepts the recurrence rule object\n * @returns {void}\n * @private\n */\nfunction processWeekNo(startDate, endDate, data, ruleObject) {\n  let stDate = calendarUtil.getYearLastDate(startDate, 0);\n  let tempDate;\n  const expectedCount = getDateCount$1(startDate, ruleObject);\n  let state;\n  let startDay;\n  let firstWeekSpan;\n  const weekNos = ruleObject.weekNo;\n  let weekNo;\n  let maxDate;\n  let minDate;\n  let weekCollection = [];\n  const expectedDays = ruleObject.day;\n  while (compareDates(stDate, endDate)) {\n    startDay = dayIndex.indexOf(DAYINDEX[stDate.getDay()]);\n    firstWeekSpan = 6 - startDay + 1;\n    for (let index = 0; index < weekNos.length; index++) {\n      weekNo = weekNos[index];\n      weekNo = weekNo > 0 ? weekNo : 53 + weekNo + 1;\n      maxDate = weekNo === 1 ? firstWeekSpan : firstWeekSpan + (weekNo - 1) * 7;\n      minDate = weekNo === 1 ? firstWeekSpan - 7 : firstWeekSpan + (weekNo - 2) * 7;\n      while (minDate < maxDate) {\n        tempDate = new Date(stDate.getTime() + MS_PER_DAY * minDate);\n        if (expectedDays.length === 0 || expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1) {\n          if (isNullOrUndefined(ruleObject.setPosition)) {\n            insertDateCollection(state, startDate, endDate, data, ruleObject, tempDate.getTime());\n          } else {\n            weekCollection.push([tempDate.getTime()]);\n          }\n        }\n        minDate++;\n      }\n    }\n    if (!isNullOrUndefined(ruleObject.setPosition)) {\n      insertDatasIntoExistingCollection(weekCollection, state, startDate, endDate, data, ruleObject);\n    }\n    if (expectedCount && data.length + ruleObject.recExceptionCount >= expectedCount) {\n      return;\n    }\n    stDate = calendarUtil.getYearLastDate(tempDate, ruleObject.interval);\n    weekCollection = [];\n  }\n}\n/**\n * Internal method for process year day\n *\n * @param {Date} startDate Accepts the strat date\n * @param {Date} endDate Accepts the end date\n * @param {number[]} data Accepts the collection of dates\n * @param {RecRule} ruleObject Accepts the recurrence rule object\n * @returns {void}\n * @private\n */\nfunction processYearDay(startDate, endDate, data, ruleObject) {\n  let stDate = calendarUtil.getYearLastDate(startDate, 0);\n  let tempDate;\n  const expectedCount = getDateCount$1(startDate, ruleObject);\n  let state;\n  let dateCollection = [];\n  let date;\n  const expectedDays = ruleObject.day;\n  while (compareDates(stDate, endDate)) {\n    for (let index = 0; index < ruleObject.yearDay.length; index++) {\n      date = ruleObject.yearDay[index];\n      tempDate = new Date(stDate.getTime());\n      if ((date === calendarUtil.getLeapYearDaysCount() || date === -calendarUtil.getLeapYearDaysCount()) && !calendarUtil.isLeapYear(calendarUtil.getFullYear(tempDate), 1)) {\n        tempDate.setDate(tempDate.getDate() + 1);\n        continue;\n      }\n      tempDate.setDate(tempDate.getDate() + (date < 0 ? calendarUtil.getYearDaysCount(tempDate, 1) + 1 + date : date));\n      if (expectedDays.length === 0 || expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1) {\n        if (ruleObject.setPosition == null) {\n          insertDateCollection(state, startDate, endDate, data, ruleObject, tempDate.getTime());\n        } else {\n          dateCollection.push([tempDate.getTime()]);\n        }\n      }\n    }\n    if (!isNullOrUndefined(ruleObject.setPosition)) {\n      insertDatasIntoExistingCollection(dateCollection, state, startDate, endDate, data, ruleObject);\n    }\n    if (expectedCount && data.length + ruleObject.recExceptionCount >= expectedCount) {\n      return;\n    }\n    stDate = calendarUtil.getYearLastDate(tempDate, ruleObject.interval);\n    dateCollection = [];\n  }\n}\n/**\n * Internal method to check yearly type\n *\n * @param {RecRule} ruleObject Accepts the recurrence rule object\n * @returns {YearRuleType} Returns the Yearly rule type object\n * @private\n */\nfunction checkYearlyType(ruleObject) {\n  if (ruleObject.yearDay.length) {\n    return 'YEARDAY';\n  } else if (ruleObject.weekNo.length) {\n    return 'WEEKNO';\n  }\n  return 'MONTH';\n}\n/**\n * Internal method to initialize recurrence rule variables\n *\n * @param {Date} startDate Accepts the start date\n * @param {RecRule} ruleObject Accepts the recurrence rule object\n * @returns {RuleData} Return the rule data object\n * @private\n */\nfunction initializeRecRuleVariables(startDate, ruleObject) {\n  const ruleData = {\n    monthCollection: [],\n    index: 0,\n    tempDate: new Date(startDate.getTime()),\n    mainDate: new Date(startDate.getTime()),\n    expectedCount: getDateCount$1(startDate, ruleObject),\n    monthInit: 0,\n    dateCollection: []\n  };\n  if (ruleObject.month.length) {\n    calendarUtil.setMonth(ruleData.tempDate, ruleObject.month[0], ruleData.tempDate.getDate());\n  }\n  return ruleData;\n}\n/**\n * Internal method for process monthly date type recurrence rule\n *\n * @param {Date} startDate Accepts the strat date\n * @param {Date} endDate Accepts the end date\n * @param {number[]} data Accepts the collection of dates\n * @param {RecRule} ruleObject Accepts the recurrence rule object\n * @returns {void}\n * @private\n */\nfunction monthlyDateTypeProcess(startDate, endDate, data, ruleObject) {\n  if (ruleObject.month.length) {\n    monthlyDateTypeProcessforMonthFreq(startDate, endDate, data, ruleObject);\n    return;\n  }\n  const ruleData = initializeRecRuleVariables(startDate, ruleObject);\n  let currentMonthDate;\n  ruleData.tempDate = ruleData.mainDate = calendarUtil.getMonthStartDate(ruleData.tempDate);\n  while (compareDates(ruleData.tempDate, endDate)) {\n    currentMonthDate = new Date(ruleData.tempDate.getTime());\n    while (calendarUtil.isSameYear(currentMonthDate, ruleData.tempDate) && ruleData.expectedCount && data.length + ruleObject.recExceptionCount <= ruleData.expectedCount) {\n      if (ruleObject.month.length === 0 || ruleObject.month.length > 0 && !calendarUtil.checkMonth(ruleData.tempDate, ruleObject.month)) {\n        processDateCollectionForByMonthDay(ruleObject, ruleData, endDate, false);\n        ruleData.beginDate = new Date(ruleData.tempDate.getTime());\n        ruleData.monthInit = setNextValidDate(ruleData.tempDate, ruleObject, ruleData.monthInit, ruleData.beginDate);\n      } else {\n        calendarUtil.setValidDate(ruleData.tempDate, 1, 1);\n        ruleData.tempDate = getStartDateForWeek(ruleData.tempDate, ruleObject.day);\n        break;\n      }\n    }\n    ruleData.tempDate.setFullYear(currentMonthDate.getFullYear(), currentMonthDate.getMonth(), currentMonthDate.getDate());\n    insertDataCollection(ruleData.dateCollection, ruleData.state, startDate, endDate, data, ruleObject);\n    if (calendarUtil.isLastMonth(ruleData.tempDate)) {\n      calendarUtil.setValidDate(ruleData.tempDate, 1, 1);\n      ruleData.tempDate = getStartDateForWeek(ruleData.tempDate, ruleObject.day);\n    }\n    if (ruleData.expectedCount && data.length + ruleObject.recExceptionCount >= ruleData.expectedCount) {\n      return;\n    }\n    ruleData.tempDate.setFullYear(ruleData.tempDate.getFullYear() + ruleObject.interval - 1);\n    ruleData.tempDate = getStartDateForWeek(ruleData.tempDate, ruleObject.day);\n    ruleData.monthInit = setNextValidDate(ruleData.tempDate, ruleObject, ruleData.monthInit, ruleData.beginDate);\n    ruleData.dateCollection = [];\n  }\n}\n/**\n * Internal method for process monthly date type with month frequency from recurrence rule\n *\n * @param {Date} startDate Accepts the strat date\n * @param {Date} endDate Accepts the end date\n * @param {number[]} data Accepts the collection of dates\n * @param {RecRule} ruleObject Accepts the recurrence rule object\n * @returns {void}\n * @private\n */\nfunction monthlyDateTypeProcessforMonthFreq(startDate, endDate, data, ruleObject) {\n  const ruleData = initializeRecRuleVariables(startDate, ruleObject);\n  ruleData.tempDate = ruleData.mainDate = calendarUtil.getMonthStartDate(ruleData.tempDate);\n  if ((ruleObject.freq === 'MONTHLY' && ruleObject.interval === 12 || ruleObject.freq === 'YEARLY') && calendarUtil.getMonthDaysCount(startDate) < ruleObject.monthDay[0]) {\n    return;\n  }\n  while (compareDates(ruleData.tempDate, endDate)) {\n    ruleData.beginDate = new Date(ruleData.tempDate.getTime());\n    processDateCollectionForByMonthDay(ruleObject, ruleData, endDate, true, startDate, data);\n    if (!isNullOrUndefined(ruleObject.setPosition)) {\n      insertDatasIntoExistingCollection(ruleData.dateCollection, ruleData.state, startDate, endDate, data, ruleObject);\n    }\n    if (ruleData.expectedCount && data.length + ruleObject.recExceptionCount >= ruleData.expectedCount) {\n      return;\n    }\n    ruleData.monthInit = setNextValidDate(ruleData.tempDate, ruleObject, ruleData.monthInit, ruleData.beginDate);\n    ruleData.dateCollection = [];\n  }\n}\n/**\n * To process date collection for Monthly & Yearly based on BYMONTH Day property\n *\n * @param {RecRule} ruleObject Accepts the recurrence rule object\n * @param {RuleData} recRuleVariables Accepts the rule data\n * @param {Date} endDate Accepts the end date\n * @param {boolean} isByMonth Accepts the boolean to validate either month or not\n * @param {Date} startDate Accepts the start date\n * @param {number[]} data Accepts the collection of dates\n * @returns {void}\n * @private\n */\nfunction processDateCollectionForByMonthDay(ruleObject, recRuleVariables, endDate, isByMonth, startDate, data) {\n  for (let index = 0; index < ruleObject.monthDay.length; index++) {\n    recRuleVariables.date = ruleObject.monthDay[index];\n    recRuleVariables.tempDate = calendarUtil.getMonthStartDate(recRuleVariables.tempDate);\n    const maxDate = calendarUtil.getMonthDaysCount(recRuleVariables.tempDate);\n    recRuleVariables.date = recRuleVariables.date > 0 ? recRuleVariables.date : maxDate + recRuleVariables.date + 1;\n    if (validateProperDate(recRuleVariables.tempDate, recRuleVariables.date, recRuleVariables.mainDate) && recRuleVariables.date > 0) {\n      calendarUtil.setDate(recRuleVariables.tempDate, recRuleVariables.date);\n      if (endDate && recRuleVariables.tempDate > endDate) {\n        return;\n      }\n      if (ruleObject.day.length === 0 || ruleObject.day.indexOf(DAYINDEX[recRuleVariables.tempDate.getDay()]) > -1) {\n        if (isByMonth && isNullOrUndefined(ruleObject.setPosition) && recRuleVariables.expectedCount && data.length + ruleObject.recExceptionCount < recRuleVariables.expectedCount) {\n          insertDateCollection(recRuleVariables.state, startDate, endDate, data, ruleObject, recRuleVariables.tempDate.getTime());\n        } else {\n          recRuleVariables.dateCollection.push([recRuleVariables.tempDate.getTime()]);\n        }\n      }\n    }\n  }\n}\n/**\n * Internal method to set next valid date\n *\n * @param {Date} tempDate Accepts the date\n * @param {RecRule} ruleObject Accepts the recurrence rule object\n * @param {number} monthInit Accepts the initial month\n * @param {Date} beginDate Accepts the initial date\n * @param {number} interval Accepts the interval duration\n * @returns {number} Returnx the next valid date\n * @private\n */\nfunction setNextValidDate(tempDate, ruleObject, monthInit, beginDate = null, interval) {\n  let monthData = beginDate ? beginDate.getMonth() : 0;\n  const startDate = calendarUtil.getMonthStartDate(tempDate);\n  interval = isNullOrUndefined(interval) ? ruleObject.interval : interval;\n  tempDate.setFullYear(startDate.getFullYear());\n  tempDate.setMonth(startDate.getMonth());\n  tempDate.setDate(startDate.getDate());\n  if (ruleObject.month.length) {\n    monthInit++;\n    monthInit = monthInit % ruleObject.month.length;\n    calendarUtil.setMonth(tempDate, ruleObject.month[monthInit], 1);\n    if (monthInit === 0) {\n      calendarUtil.addYears(tempDate, interval, ruleObject.month[0]);\n    }\n  } else {\n    if (beginDate && beginDate.getFullYear() < tempDate.getFullYear()) {\n      monthData = tempDate.getMonth() - 1;\n    }\n    calendarUtil.setValidDate(tempDate, interval, 1, monthData, beginDate);\n  }\n  return monthInit;\n}\n/**\n * To get month collection when BYDAY property having more than one value in list.\n *\n * @param {Date} startDate Accepts the strat date\n * @param {Date} endDate Accepts the end date\n * @param {number[]} data Accepts the collection of dates\n * @param {RecRule} ruleObject Accepts the recurrence rule object\n * @returns {void}\n * @private\n */\nfunction getMonthCollection(startDate, endDate, data, ruleObject) {\n  const expectedDays = ruleObject.day;\n  let tempDate = new Date(startDate.getTime());\n  tempDate = calendarUtil.getMonthStartDate(tempDate);\n  let monthCollection = [];\n  let dateCollection = [];\n  let dates = [];\n  let index;\n  let state;\n  const expectedCount = getDateCount$1(startDate, ruleObject);\n  let monthInit = 0;\n  let beginDate;\n  if (ruleObject.month.length) {\n    calendarUtil.setMonth(tempDate, ruleObject.month[0], 1);\n  }\n  tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n  while (compareDates(tempDate, endDate) && expectedCount && data.length + ruleObject.recExceptionCount < expectedCount) {\n    const currentMonthDate = new Date(tempDate.getTime());\n    const isHavingNumber = expectedDays.map(item => HASNUMBER.test(item));\n    if (isHavingNumber.indexOf(true) > -1) {\n      for (let j = 0; j <= expectedDays.length - 1; j++) {\n        const expectedDaysArray = expectedDays[j].match(SPLITNUMBERANDSTRING);\n        const position = parseInt(expectedDaysArray[0], 10);\n        tempDate = new Date(tempDate.getTime());\n        tempDate = calendarUtil.getMonthStartDate(tempDate);\n        tempDate = getStartDateForWeek(tempDate, expectedDays);\n        currentMonthDate.setFullYear(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate());\n        while (calendarUtil.isSameYear(currentMonthDate, tempDate) && calendarUtil.isSameMonth(currentMonthDate, tempDate)) {\n          if (expectedDaysArray[expectedDaysArray.length - 1] === DAYINDEX[currentMonthDate.getDay()]) {\n            monthCollection.push([currentMonthDate.getTime()]);\n          }\n          currentMonthDate.setDate(currentMonthDate.getDate() + 1);\n        }\n        currentMonthDate.setDate(currentMonthDate.getDate() - 1);\n        if (expectedDaysArray[0].indexOf('-') > -1) {\n          index = monthCollection.length - -1 * position;\n        } else {\n          index = position - 1;\n        }\n        index = isNaN(index) ? 0 : index;\n        if (monthCollection.length > 0) {\n          if (isNullOrUndefined(ruleObject.setPosition)) {\n            insertDatasIntoExistingCollection(monthCollection, state, startDate, endDate, data, ruleObject, index);\n          } else {\n            dateCollection = [filterDateCollectionByIndex(monthCollection, index, dates)];\n          }\n        }\n        if (expectedCount && data.length + ruleObject.recExceptionCount >= expectedCount) {\n          return;\n        }\n        monthCollection = [];\n      }\n      if (!isNullOrUndefined(ruleObject.setPosition)) {\n        insertDateCollectionBasedonBySetPos(dateCollection, state, startDate, endDate, data, ruleObject);\n        dates = [];\n      }\n      monthInit = setNextValidDate(tempDate, ruleObject, monthInit, beginDate);\n      tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n      monthCollection = [];\n    } else {\n      let weekCollection = [];\n      const dayCycleData = processWeekDays(expectedDays);\n      currentMonthDate.setFullYear(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate());\n      const initialDate = new Date(tempDate.getTime());\n      beginDate = new Date(tempDate.getTime());\n      while (calendarUtil.isSameMonth(initialDate, tempDate)) {\n        weekCollection.push(tempDate.getTime());\n        if (expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1) {\n          monthCollection.push(weekCollection);\n          weekCollection = [];\n        }\n        tempDate.setDate(tempDate.getDate() + dayCycleData[DAYINDEX[tempDate.getDay()]]);\n      }\n      index = ruleObject.setPosition < 1 ? monthCollection.length + ruleObject.setPosition : ruleObject.setPosition - 1;\n      if (isNullOrUndefined(ruleObject.setPosition)) {\n        index = 0;\n        const datas = [];\n        for (let week = 0; week < monthCollection.length; week++) {\n          for (let row = 0; row < monthCollection[week].length; row++) {\n            datas.push(monthCollection[week][row]);\n          }\n        }\n        monthCollection = [datas];\n      }\n      if (monthCollection.length > 0) {\n        insertDatasIntoExistingCollection(monthCollection, state, startDate, endDate, data, ruleObject, index);\n      }\n      if (expectedCount && data.length + ruleObject.recExceptionCount >= expectedCount) {\n        return;\n      }\n      monthInit = setNextValidDate(tempDate, ruleObject, monthInit, beginDate);\n      tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n      monthCollection = [];\n    }\n  }\n}\n/**\n * To process monday day type for FREQ=MONTHLY\n *\n * @param {Date} startDate Accepts the strat date\n * @param {Date} endDate Accepts the end date\n * @param {number[]} data Accepts the collection of dates\n * @param {RecRule} ruleObject Accepts the recurrence rule object\n * @returns {void}\n * @private\n */\nfunction monthlyDayTypeProcessforMonthFreq(startDate, endDate, data, ruleObject) {\n  const expectedDays = ruleObject.day;\n  // When BYDAY property having more than 1 value.\n  if (expectedDays.length > 1) {\n    getMonthCollection(startDate, endDate, data, ruleObject);\n    return;\n  }\n  let tempDate = new Date(startDate.getTime());\n  const expectedCount = getDateCount$1(startDate, ruleObject);\n  let monthCollection = [];\n  let beginDate;\n  let monthInit = 0;\n  tempDate = calendarUtil.getMonthStartDate(tempDate);\n  if (ruleObject.month.length) {\n    calendarUtil.setMonth(tempDate, ruleObject.month[0], 1);\n  }\n  tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n  while (compareDates(tempDate, endDate) && expectedCount && data.length + ruleObject.recExceptionCount < expectedCount) {\n    beginDate = new Date(tempDate.getTime());\n    const currentMonthDate = new Date(tempDate.getTime());\n    while (calendarUtil.isSameMonth(tempDate, currentMonthDate)) {\n      monthCollection.push([currentMonthDate.getTime()]);\n      currentMonthDate.setDate(currentMonthDate.getDate() + 7);\n    }\n    // To filter date collection based on BYDAY Index, then BYSETPOS and to insert datas into existing collection\n    insertDateCollectionBasedonIndex(monthCollection, startDate, endDate, data, ruleObject);\n    monthInit = setNextValidDate(tempDate, ruleObject, monthInit, beginDate);\n    tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n    monthCollection = [];\n  }\n}\n/**\n * To process monday day type for FREQ=YEARLY\n *\n * @param {Date} startDate Accepts the strat date\n * @param {Date} endDate Accepts the end date\n * @param {number[]} data Accepts the collection of dates\n * @param {RecRule} ruleObject Accepts the recurrence rule object\n * @returns {void}\n * @private\n */\nfunction monthlyDayTypeProcess(startDate, endDate, data, ruleObject) {\n  const expectedDays = ruleObject.day;\n  const isHavingNumber = expectedDays.map(item => HASNUMBER.test(item));\n  // If BYDAY property having more than 1 value in list\n  if (expectedDays.length > 1 && isHavingNumber.indexOf(true) > -1) {\n    processDateCollectionforByDayWithInteger(startDate, endDate, data, ruleObject);\n    return;\n  } else if (ruleObject.month.length && expectedDays.length === 1 && isHavingNumber.indexOf(true) > -1) {\n    monthlyDayTypeProcessforMonthFreq(startDate, endDate, data, ruleObject);\n    return;\n  }\n  let tempDate = new Date(startDate.getTime());\n  let currentMonthDate;\n  const expectedCount = getDateCount$1(startDate, ruleObject);\n  const interval = ruleObject.interval;\n  let monthCollection = [];\n  if (ruleObject.month.length) {\n    calendarUtil.setMonth(tempDate, ruleObject.month[0], tempDate.getDate());\n  }\n  // Set the date as start date of the yeear if yearly freq having ByDay property alone\n  if (isNullOrUndefined(ruleObject.setPosition) && ruleObject.month.length === 0 && ruleObject.weekNo.length === 0) {\n    tempDate.setFullYear(startDate.getFullYear(), 0, 1);\n  }\n  tempDate = calendarUtil.getMonthStartDate(tempDate);\n  tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n  while (compareDates(tempDate, endDate)) {\n    currentMonthDate = new Date(tempDate.getTime());\n    while (calendarUtil.isSameYear(currentMonthDate, tempDate) && expectedCount && data.length + ruleObject.recExceptionCount <= expectedCount) {\n      currentMonthDate = new Date(tempDate.getTime());\n      while (calendarUtil.isSameYear(currentMonthDate, tempDate)) {\n        if (ruleObject.month.length === 0 || ruleObject.month.length > 0 && !calendarUtil.checkMonth(tempDate, ruleObject.month)) {\n          if (expectedDays.length > 1) {\n            if (calendarUtil.compareMonth(currentMonthDate, tempDate)) {\n              calendarUtil.setValidDate(tempDate, 1, 1);\n              tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n              break;\n            }\n            if (expectedDays.indexOf(DAYINDEX[currentMonthDate.getDay()]) > -1) {\n              monthCollection.push([currentMonthDate.getTime()]);\n            }\n            currentMonthDate.setDate(currentMonthDate.getDate() + 1);\n          } else {\n            // If BYDAY property having 1 value in list\n            if (currentMonthDate.getFullYear() > tempDate.getFullYear()) {\n              calendarUtil.setValidDate(tempDate, 1, 1);\n              tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n              break;\n            }\n            const newstr = getDayString(expectedDays[0]);\n            if (DAYINDEX[currentMonthDate.getDay()] === newstr && new Date(currentMonthDate.getFullYear(), currentMonthDate.getMonth(), 0) > new Date(startDate.getFullYear())) {\n              monthCollection.push([currentMonthDate.getTime()]);\n            }\n            currentMonthDate.setDate(currentMonthDate.getDate() + 7);\n          }\n        } else {\n          calendarUtil.setValidDate(tempDate, 1, 1);\n          tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n          break;\n        }\n      }\n    }\n    tempDate.setFullYear(currentMonthDate.getFullYear(), currentMonthDate.getMonth(), currentMonthDate.getDate());\n    // To filter date collection based on BYDAY Index, then BYSETPOS and to insert datas into existing collection\n    insertDateCollectionBasedonIndex(monthCollection, startDate, endDate, data, ruleObject);\n    if (calendarUtil.isLastMonth(tempDate)) {\n      calendarUtil.setValidDate(tempDate, 1, 1);\n      tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n    }\n    tempDate.setFullYear(tempDate.getFullYear() + interval - 1);\n    if (expectedCount && data.length + ruleObject.recExceptionCount >= expectedCount) {\n      return;\n    }\n    tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n    monthCollection = [];\n  }\n}\n/**\n * To process the recurrence rule when BYDAY property having values with integer\n *\n * @param {Date} startDate Accepts the strat date\n * @param {Date} endDate Accepts the end date\n * @param {number[]} data Accepts the collection of dates\n * @param {RecRule} ruleObject Accepts the recurrence rule object\n * @returns {void}\n * @private\n */\nfunction processDateCollectionforByDayWithInteger(startDate, endDate, data, ruleObject) {\n  const expectedDays = ruleObject.day;\n  const expectedCount = getDateCount$1(startDate, ruleObject);\n  let tempDate = new Date(startDate.getTime());\n  const interval = ruleObject.interval;\n  let monthCollection = [];\n  let dateCollection = [];\n  let index;\n  let state;\n  let monthInit = 0;\n  let currentMonthDate;\n  let currentDate;\n  let beginDate;\n  tempDate = calendarUtil.getMonthStartDate(tempDate);\n  let datas = [];\n  if (ruleObject.month.length) {\n    calendarUtil.setMonth(tempDate, ruleObject.month[0], 1);\n  }\n  tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n  while (compareDates(tempDate, endDate)) {\n    currentMonthDate = new Date(tempDate.getTime());\n    for (let i = 0; i <= ruleObject.month.length; i++) {\n      for (let j = 0; j <= expectedDays.length - 1; j++) {\n        tempDate = calendarUtil.getMonthStartDate(tempDate);\n        tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n        monthCollection = [];\n        while (calendarUtil.isSameYear(currentMonthDate, tempDate) && expectedCount && data.length + ruleObject.recExceptionCount <= expectedCount) {\n          while (calendarUtil.isSameYear(currentMonthDate, tempDate)) {\n            currentMonthDate = new Date(tempDate.getTime());\n            if (ruleObject.month.length === 0 || ruleObject.month.length > 0 && ruleObject.month[i] === calendarUtil.getMonth(currentMonthDate)) {\n              const expectedDaysArray = expectedDays[j].match(SPLITNUMBERANDSTRING);\n              const position = parseInt(expectedDaysArray[0], 10);\n              currentDate = new Date(tempDate.getTime());\n              while (calendarUtil.isSameYear(currentDate, tempDate) && calendarUtil.isSameMonth(currentDate, tempDate)) {\n                if (expectedDaysArray[expectedDaysArray.length - 1] === DAYINDEX[currentDate.getDay()]) {\n                  monthCollection.push([currentDate.getTime()]);\n                }\n                currentDate.setDate(currentDate.getDate() + 1);\n              }\n              currentDate.setDate(currentDate.getDate() - 1);\n              if (expectedDaysArray[0].indexOf('-') > -1) {\n                index = monthCollection.length - -1 * position;\n              } else {\n                index = position - 1;\n              }\n              index = isNaN(index) ? 0 : index;\n            }\n            monthInit = setNextValidDate(tempDate, ruleObject, monthInit, beginDate, 1);\n            tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n          }\n        }\n        tempDate = j === 0 && currentDate ? new Date(currentDate.getTime()) : new Date(currentMonthDate.getTime());\n        if (monthCollection.length > 0) {\n          if (isNullOrUndefined(ruleObject.setPosition)) {\n            insertDatasIntoExistingCollection(monthCollection, state, startDate, endDate, data, ruleObject, index);\n          } else {\n            dateCollection = [filterDateCollectionByIndex(monthCollection, index, datas)];\n          }\n        }\n        if (expectedCount && data.length + ruleObject.recExceptionCount >= expectedCount) {\n          return;\n        }\n      }\n    }\n    if (!isNullOrUndefined(ruleObject.setPosition)) {\n      insertDateCollectionBasedonBySetPos(dateCollection, state, startDate, endDate, data, ruleObject);\n      datas = [];\n    }\n    if (calendarUtil.isLastMonth(tempDate)) {\n      calendarUtil.setValidDate(tempDate, 1, 1);\n      tempDate.setFullYear(tempDate.getFullYear() + interval - 1);\n    } else {\n      tempDate.setFullYear(tempDate.getFullYear() + interval);\n    }\n    tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n    if (ruleObject.month.length) {\n      calendarUtil.setMonth(tempDate, ruleObject.month[0], tempDate.getDate());\n    }\n  }\n}\n/**\n * To get recurrence collection if BYSETPOS is null\n *\n * @param {number[]} monthCollection Accepts the month collection dates\n * @param {string[]} expectedDays Accepts the exception dates\n * @returns {RuleData} Returns the rule data object\n * @private\n */\nfunction getRecurrenceCollection(monthCollection, expectedDays) {\n  let index;\n  const recurrenceCollectionObject = {\n    monthCollection: [],\n    index: 0\n  };\n  if (expectedDays.length === 1) {\n    // To split numeric value from BYDAY property value\n    const expectedDaysArrays = expectedDays[0].match(SPLITNUMBERANDSTRING);\n    let arrPosition;\n    if (expectedDaysArrays.length > 1) {\n      arrPosition = parseInt(expectedDaysArrays[0], 10);\n      index = arrPosition < 1 ? monthCollection.length + arrPosition : arrPosition - 1;\n    } else {\n      index = 0;\n      monthCollection = getDateCollectionforBySetPosNull(monthCollection);\n    }\n  } else {\n    index = 0;\n    monthCollection = getDateCollectionforBySetPosNull(monthCollection);\n  }\n  recurrenceCollectionObject.monthCollection = monthCollection;\n  recurrenceCollectionObject.index = index;\n  return recurrenceCollectionObject;\n}\n/**\n * Internal method to process the data collections\n *\n * @param {number[]} dateCollection Accepts the date collections\n * @param {boolean} state Accepts the state\n * @param {Date} startDate Accepts the start date\n * @param {Date} endDate Accepts the end date\n * @param {number[]} data Accepts the collection of numbers\n * @param {RecRule} ruleObject Accepts the recurrence rule object\n * @returns {void}\n * @private\n */\nfunction insertDataCollection(dateCollection, state, startDate, endDate, data, ruleObject) {\n  let index = ruleObject.setPosition < 1 ? dateCollection.length + ruleObject.setPosition : ruleObject.setPosition - 1;\n  if (isNullOrUndefined(ruleObject.setPosition)) {\n    index = 0;\n    dateCollection = getDateCollectionforBySetPosNull(dateCollection);\n  }\n  if (dateCollection.length > 0) {\n    insertDatasIntoExistingCollection(dateCollection, state, startDate, endDate, data, ruleObject, index);\n  }\n}\n/**\n * To process month collection if BYSETPOS is null\n *\n * @param {number[]} monthCollection Accepts the month date collections\n * @returns {number[]} Returns the month date collections\n * @private\n */\nfunction getDateCollectionforBySetPosNull(monthCollection) {\n  const datas = [];\n  for (let week = 0; week < monthCollection.length; week++) {\n    for (let row = 0; row < monthCollection[week].length; row++) {\n      datas.push(new Date(monthCollection[week][row]).getTime());\n    }\n  }\n  monthCollection = datas.length > 0 ? [datas] : [];\n  return monthCollection;\n}\n/**\n * To filter date collection based on BYDAY Index, then BYSETPOS and to insert datas into existing collection\n *\n * @param {number[]} monthCollection Accepts the month date collections\n * @param {Date} startDate Accepts the start date\n * @param {Date} endDate Accepts the end date\n * @param {number[]} data Accepts the date collections\n * @param {RecRule} ruleObject Accepts the recurrence rule object\n * @returns {void}\n * @private\n */\nfunction insertDateCollectionBasedonIndex(monthCollection, startDate, endDate, data, ruleObject) {\n  const expectedDays = ruleObject.day;\n  let state;\n  let datas = [];\n  let dateCollection = [];\n  const recurrenceCollections = getRecurrenceCollection(monthCollection, expectedDays);\n  monthCollection = recurrenceCollections.monthCollection;\n  const index = recurrenceCollections.index;\n  if (ruleObject.setPosition != null) {\n    dateCollection = [filterDateCollectionByIndex(monthCollection, index, datas)];\n    insertDateCollectionBasedonBySetPos(dateCollection, state, startDate, endDate, data, ruleObject);\n  } else {\n    if (monthCollection.length > 0) {\n      insertDatasIntoExistingCollection(monthCollection, state, startDate, endDate, data, ruleObject, index);\n    }\n  }\n  datas = [];\n}\n/**\n * To filter date collection when BYDAY property having values with number\n *\n * @param {number[]} monthCollection Accepts the date collections\n * @param {number} index Accepts the index of date collections\n * @param {number[]} datas Accepts the collection of dates\n * @returns {number[]} Returns the collection of dates\n * @private\n */\nfunction filterDateCollectionByIndex(monthCollection, index, datas) {\n  for (let week = 0; week < monthCollection[index].length; week++) {\n    datas.push(monthCollection[index][week]);\n  }\n  return datas;\n}\n/**\n * To insert processed date collection in final array element\n *\n * @param {boolean} state Accepts the state of the recurrence rule\n * @param {Date} startDate Accepts the start date\n * @param {Date} endDate Accepts the end date\n * @param {number[]} data Accepts the collection of date\n * @param {RecRule} ruleObject Accepts the recurrence rule object\n * @param {number} dayData Accepts the date index\n * @returns {void}\n * @private\n */\nfunction insertDateCollection(state, startDate, endDate, data, ruleObject, dayData) {\n  const expectedCount = getDateCount$1(startDate, ruleObject);\n  const chDate = new Date(dayData);\n  state = validateRules(chDate, ruleObject);\n  if (chDate >= startDate && compareDates(chDate, endDate) && state && expectedCount && data.length + ruleObject.recExceptionCount < expectedCount) {\n    excludeDateHandler(data, dayData);\n  }\n}\n/**\n * Return the last week number of given month and year.\n *\n * @param {number} year Accepts the Year in number format\n * @param {number} startDayOfWeek Accepts the start date\n * @param {number[]} monthCollection Accepts the collection of dates\n * @param {number} week Accepts the week in number format\n * @param {RecRule} ruleObject Accepts the recurrence rule object\n * @returns {number} returns week number\n * @private\n */\nfunction weekCount(year, startDayOfWeek, monthCollection, week, ruleObject) {\n  const firstDayOfWeek = startDayOfWeek || 0;\n  const firstOfMonth = new Date(year, ruleObject.month[0] - 1, 1);\n  const lastOfMonth = new Date(year, ruleObject.month[0] - 1, 0);\n  const numberOfDaysInMonth = lastOfMonth.getDate();\n  const firstWeekDay = (firstOfMonth.getDay() - firstDayOfWeek + 7) % 7;\n  const used = firstWeekDay + numberOfDaysInMonth;\n  const count = Math.ceil(used / 7) - 1;\n  const dayData = monthCollection[week][count];\n  const chDate = new Date(dayData);\n  const state = validateRules(chDate, ruleObject);\n  return state ? count : count - 1;\n}\n/**\n * To process date collection based on Byset position after process the collection based on BYDAY property value index: EX:BYDAY=1SUm-1SU\n *\n * @param {number[]} monthCollection Accepts the collection of dates\n * @param {boolean} state Accepts the state of the recurrence rule\n * @param {Date} startDate Accepts the start date\n * @param {Date} endDate Accepts the end date\n * @param {number[]} data Accepts the collection of date\n * @param {RecRule} ruleObject Accepts the recurrence rule object\n * @returns {void}\n * @private\n */\nfunction insertDateCollectionBasedonBySetPos(monthCollection, state, startDate, endDate, data, ruleObject) {\n  if (monthCollection.length > 0) {\n    for (let week = 0; week < monthCollection.length; week++) {\n      monthCollection[week].sort();\n      const expectedDays = ruleObject.day;\n      const isHavingNumber = expectedDays.map(item => HASNUMBER.test(item));\n      const weekIndex = ruleObject.freq === 'YEARLY' && ruleObject.validRules.indexOf('BYMONTH') > -1 && !(isHavingNumber.indexOf(true) > -1) ? weekCount(new Date(monthCollection[0][0]).getFullYear(), 0, monthCollection, week, ruleObject) : monthCollection[week].length + ruleObject.setPosition;\n      const index = ruleObject.setPosition < 1 ? weekIndex : ruleObject.setPosition - 1;\n      const dayData = monthCollection[week][index];\n      insertDateCollection(state, startDate, endDate, data, ruleObject, dayData);\n    }\n  }\n}\n/**\n * To insert datas into existing collection which is processed from previous loop.\n *\n * @param {number[]} monthCollection Accepts the collection of dates\n * @param {boolean} state Accepts the state of the recurrence rule\n * @param {Date} startDate Accepts the start date\n * @param {Date} endDate Accepts the end date\n * @param {number[]} data Accepts the collection of date\n * @param {RecRule} ruleObject Accepts the recurrence rule object\n * @param {number} index Accepts the index value\n * @returns {void}\n * @private\n */\nfunction insertDatasIntoExistingCollection(monthCollection, state, startDate, endDate, data, ruleObject, index) {\n  if (monthCollection.length > 0) {\n    index = !isNullOrUndefined(index) ? index : ruleObject.setPosition < 1 ? monthCollection.length + ruleObject.setPosition : ruleObject.setPosition - 1;\n    monthCollection[index].sort();\n    for (let week = 0; week < monthCollection[index].length; week++) {\n      const dayData = monthCollection[index][week];\n      insertDateCollection(state, startDate, endDate, data, ruleObject, dayData);\n    }\n  }\n}\n/**\n * Internal method to compare dates\n *\n * @param {Date} startDate Accepts the start date\n * @param {Date} endDate Accepts the end date\n * @returns {boolean} Returns the result of checking start and end dates\n * @private\n */\nfunction compareDates(startDate, endDate) {\n  return endDate ? startDate <= endDate : true;\n}\n/**\n * Internal method to get day string\n *\n * @param {string} expectedDays Accepts the exception date string\n * @returns {string} Returns the valid string\n * @private\n */\nfunction getDayString(expectedDays) {\n  // To get BYDAY value without numeric value\n  const newstr = expectedDays.replace(REMOVENUMBERINSTRING, '');\n  return newstr;\n}\n/**\n * Internal method to check day index\n *\n * @param {number} day Accepts the day index\n * @param {string[]} expectedDays Accepts the exception dates\n * @returns {boolean} Returns the index date\n * @private\n */\nfunction checkDayIndex(day, expectedDays) {\n  const sortedExpectedDays = [];\n  expectedDays.forEach(element => {\n    const expectedDaysNumberSplit = element.match(SPLITNUMBERANDSTRING);\n    if (expectedDaysNumberSplit.length === 2) {\n      sortedExpectedDays.push(expectedDaysNumberSplit[1]);\n    } else {\n      sortedExpectedDays.push(expectedDaysNumberSplit[0]);\n    }\n  });\n  return sortedExpectedDays.indexOf(DAYINDEX[day]) === -1;\n}\n/**\n * Internal method to get start date of week\n *\n * @param {Date} startDate Accepts the start date\n * @param {string[]} expectedDays Accepts the exception dates\n * @returns {Date} Return the week start date\n * @private\n */\nfunction getStartDateForWeek(startDate, expectedDays) {\n  const tempDate = new Date(startDate.getTime());\n  let newstr;\n  if (expectedDays.length > 0) {\n    const expectedDaysArr = [];\n    for (let i = 0; i <= expectedDays.length - 1; i++) {\n      newstr = getDayString(expectedDays[i]);\n      expectedDaysArr.push(newstr);\n    }\n    if (expectedDaysArr.indexOf(DAYINDEX[tempDate.getDay()]) === -1) {\n      do {\n        tempDate.setDate(tempDate.getDate() + 1);\n      } while (expectedDaysArr.indexOf(DAYINDEX[tempDate.getDay()]) === -1);\n    }\n  }\n  return tempDate;\n}\n/**\n * Method to generate recurrence rule object from given rule\n *\n * @param {string} rules Accepts the recurrence rule\n * @returns {RecRule} Returns the recurrence rule object\n */\nfunction extractObjectFromRule(rules) {\n  const ruleObject = {\n    freq: null,\n    interval: 1,\n    count: null,\n    until: null,\n    day: [],\n    wkst: null,\n    month: [],\n    weekNo: [],\n    monthDay: [],\n    yearDay: [],\n    setPosition: null,\n    validRules: []\n  };\n  const rulesList = rules.split(';');\n  let splitData = [];\n  let temp;\n  rulesList.forEach(data => {\n    splitData = data.split('=');\n    switch (splitData[0]) {\n      case 'UNTIL':\n        temp = splitData[1];\n        ruleObject.until = getDateFromRecurrenceDateString(temp);\n        break;\n      case 'BYDAY':\n        ruleObject.day = splitData[1].split(',');\n        ruleObject.validRules.push(splitData[0]);\n        break;\n      case 'BYMONTHDAY':\n        ruleObject.monthDay = splitData[1].split(',').map(Number);\n        ruleObject.validRules.push(splitData[0]);\n        break;\n      case 'BYMONTH':\n        ruleObject.month = splitData[1].split(',').map(Number);\n        ruleObject.validRules.push(splitData[0]);\n        break;\n      case 'BYYEARDAY':\n        ruleObject.yearDay = splitData[1].split(',').map(Number);\n        ruleObject.validRules.push(splitData[0]);\n        break;\n      case 'BYWEEKNO':\n        ruleObject.weekNo = splitData[1].split(',').map(Number);\n        ruleObject.validRules.push(splitData[0]);\n        break;\n      case 'INTERVAL':\n        ruleObject.interval = parseInt(splitData[1], 10);\n        break;\n      case 'COUNT':\n        ruleObject.count = parseInt(splitData[1], 10);\n        break;\n      case 'BYSETPOS':\n        ruleObject.setPosition = parseInt(splitData[1], 10) > 4 ? -1 : parseInt(splitData[1], 10);\n        break;\n      case 'FREQ':\n        ruleObject.freq = splitData[1];\n        break;\n      case 'WKST':\n        ruleObject.wkst = splitData[1];\n        break;\n    }\n  });\n  if (ruleObject.freq === 'MONTHLY' && ruleObject.monthDay.length === 0) {\n    const index = ruleObject.validRules.indexOf('BYDAY');\n    ruleObject.validRules.splice(index, 1);\n  }\n  return ruleObject;\n}\n/**\n * Internal method to validate proper date\n *\n * @param {Date} tempDate Accepts the date value\n * @param {number} data Accepts the data value\n * @param {Date} startDate Accepts the start date\n * @returns {boolean} Returns the result of date validate\n * @private\n */\nfunction validateProperDate(tempDate, data, startDate) {\n  const maxDate = calendarUtil.getMonthDaysCount(tempDate);\n  return data <= maxDate && tempDate >= startDate;\n}\n/**\n * Internal method to process week days\n *\n * @param {string[]} expectedDays Accepts the expection dates\n * @returns {Object} Returns the weekdays object\n * @private\n */\nfunction processWeekDays(expectedDays) {\n  const dayCycle = {};\n  expectedDays.forEach((element, index) => {\n    if (index === expectedDays.length - 1) {\n      const startIndex = dayIndex.indexOf(element);\n      let temp = startIndex;\n      while (temp % 7 !== dayIndex.indexOf(expectedDays[0])) {\n        temp++;\n      }\n      dayCycle[element] = temp - startIndex;\n    } else {\n      dayCycle[element] = dayIndex.indexOf(expectedDays[index + 1]) - dayIndex.indexOf(element);\n    }\n  });\n  return dayCycle;\n}\n/**\n * Internal method to check date\n *\n * @param {Date} tempDate Accepts the date value\n * @param {number[]} expectedDate Accepts the exception dates\n * @returns {boolean} Returns the boolean value\n * @private\n */\nfunction checkDate(tempDate, expectedDate) {\n  const temp = expectedDate.slice(0);\n  let data;\n  const maxDate = calendarUtil.getMonthDaysCount(tempDate);\n  data = temp.shift();\n  while (data) {\n    if (data < 0) {\n      data = data + maxDate + 1;\n    }\n    if (data === tempDate.getDate()) {\n      return false;\n    }\n    data = temp.shift();\n  }\n  return true;\n}\n/**\n * Internal method to check the year value\n *\n * @param {Date} tempDate Accepts the date value\n * @param {number[]} expectedyearDay Accepts the exception dates in year\n * @returns {boolean} Returns the boolean value\n * @private\n */\nfunction checkYear(tempDate, expectedyearDay) {\n  const temp = expectedyearDay.slice(0);\n  let data;\n  const yearDay = getYearDay(tempDate);\n  data = temp.shift();\n  while (data) {\n    if (data < 0) {\n      data = data + calendarUtil.getYearDaysCount(tempDate, 0) + 1;\n    }\n    if (data === yearDay) {\n      return false;\n    }\n    data = temp.shift();\n  }\n  return true;\n}\n/**\n * Internal method to get the year day\n *\n * @param {Date} currentDate Accepts the date value\n * @returns {number} Returns the boolean value\n * @private\n */\nfunction getYearDay(currentDate) {\n  if (!startDateCollection[calendarUtil.getFullYear(currentDate)]) {\n    startDateCollection[calendarUtil.getFullYear(currentDate)] = calendarUtil.getYearLastDate(currentDate, 0);\n  }\n  const tempDate = startDateCollection[calendarUtil.getFullYear(currentDate)];\n  const diff = currentDate.getTime() - tempDate.getTime();\n  return Math.ceil(diff / MS_PER_DAY);\n}\n/**\n * Internal method to validate monthly rule type\n *\n * @param {RecRule} ruleObject Accepts the recurrence rule object\n * @returns {MonthlyType} Returns the monthly type object\n * @private\n */\nfunction validateMonthlyRuleType(ruleObject) {\n  if (ruleObject.monthDay.length && !ruleObject.day.length) {\n    return 'date';\n  } else if (!ruleObject.monthDay.length && ruleObject.day.length) {\n    return 'day';\n  }\n  return 'both';\n}\n/**\n * Internal method to re-order the week days based on first day of week\n *\n * @param {string[]} days Accepts the week days value\n * @returns {void}\n * @private\n */\nfunction rotate(days) {\n  const data = days.shift();\n  days.push(data);\n}\n/**\n * Internal method to set first day of week\n *\n * @param {string} day Accepts the first day string\n * @returns {void}\n * @private\n */\nfunction setFirstDayOfWeek(day) {\n  while (dayIndex[0] !== day) {\n    rotate(dayIndex);\n  }\n}\n/**\n * Internal method to validate recurrence rule\n *\n * @param {Date} tempDate Accepts the date value\n * @param {RecRule} ruleObject Accepts the recurrence rule object\n * @returns {boolean} Returns the boolean value\n * @private\n */\nfunction validateRules(tempDate, ruleObject) {\n  let state = true;\n  const expectedDays = ruleObject.day;\n  const expectedMonth = ruleObject.month;\n  const expectedDate = calendarUtil.getExpectedDays(tempDate, ruleObject.monthDay);\n  const expectedyearDay = ruleObject.yearDay;\n  ruleObject.validRules.forEach(rule => {\n    switch (rule) {\n      case 'BYDAY':\n        if (checkDayIndex(tempDate.getDay(), expectedDays)) {\n          state = false;\n        }\n        break;\n      case 'BYMONTH':\n        if (calendarUtil.checkMonth(tempDate, expectedMonth)) {\n          state = false;\n        }\n        break;\n      case 'BYMONTHDAY':\n        if (checkDate(tempDate, expectedDate)) {\n          state = false;\n        }\n        break;\n      case 'BYYEARDAY':\n        if (checkYear(tempDate, expectedyearDay)) {\n          state = false;\n        }\n        break;\n    }\n  });\n  return state;\n}\n/**\n * Internal method to get calendar util\n *\n * @param {CalendarType} calendarMode Accepts the calendar type object\n * @returns {CalendarUtil} Returns the calendar util object\n * @private\n */\nfunction getCalendarUtil(calendarMode) {\n  if (calendarMode === 'Islamic') {\n    return new Islamic();\n  }\n  return new Gregorian();\n}\nconst startDateCollection = {};\nlet tempExcludeDate;\nconst dayIndex = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];\nlet maxOccurrence;\nlet tempViewDate;\nlet calendarUtil;\nconst DAYINDEX = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];\nconst MAXOCCURRENCE = 43;\nconst WEEKPOS = ['first', 'second', 'third', 'fourth', 'last'];\nconst TIMES = 'summaryTimes';\nconst ON = 'summaryOn';\nconst EVERY = 'every';\nconst UNTIL = 'summaryUntil';\nconst DAYS = 'summaryDay';\nconst WEEKS = 'summaryWeek';\nconst MONTHS = 'summaryMonth';\nconst YEARS = 'summaryYear';\nconst DAYINDEXOBJECT = {\n  SU: 'sun',\n  MO: 'mon',\n  TU: 'tue',\n  WE: 'wed',\n  TH: 'thu',\n  FR: 'fri',\n  SA: 'sat'\n};\n// To check string has number\nconst HASNUMBER = /\\d/;\n// To find the numbers in string\nconst REMOVENUMBERINSTRING = /[^A-Z]+/;\n// To split number and string\nconst SPLITNUMBERANDSTRING = /[a-z]+|[^a-z]+/gi;\n/**\n * Method to generate string from date\n *\n * @param {Date} date Accepts the date value\n * @returns {string} Returns the string value\n */\nfunction getRecurrenceStringFromDate(date) {\n  return [date.getUTCFullYear(), roundDateValues(date.getUTCMonth() + 1), roundDateValues(date.getUTCDate()), 'T', roundDateValues(date.getUTCHours()), roundDateValues(date.getUTCMinutes()), roundDateValues(date.getUTCSeconds()), 'Z'].join('');\n}\n/**\n * Internal method to round the date values\n *\n * @param {string | number} date Accepts the date value in either string or number format\n * @returns {string} Returns the date value in string format\n * @private\n */\nfunction roundDateValues(date) {\n  return ('0' + date).slice(-2);\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable max-len */\n/**\n * EventBase for appointment rendering\n */\nclass EventBase {\n  /**\n   * Constructor for EventBase\n   *\n   * @param {Schedule} parent Accepts the schedule instance\n   */\n  constructor(parent) {\n    this.slots = [];\n    this.isDoubleTapped = false;\n    this.parent = parent;\n  }\n  processData(events, timeZonePropChanged, oldTimezone) {\n    const start = this.parent.activeView.startDate();\n    const end = this.parent.activeView.endDate();\n    const fields = this.parent.eventFields;\n    let processed = [];\n    let temp = 1;\n    let generateID = false;\n    const resourceCollection = this.parent.resourceBase ? this.parent.resourceBase.resourceCollection : [];\n    if (events.length > 0 && isNullOrUndefined(events[0][fields.id])) {\n      generateID = true;\n    }\n    for (let event of events) {\n      if (generateID) {\n        event[fields.id] = temp++;\n      }\n      event = this.updateEventDateTime(event);\n      if (timeZonePropChanged) {\n        this.processTimezoneChange(event, oldTimezone);\n      } else if (!this.parent.isPrinting && !this.parent.uiStateValues.isResize) {\n        event = this.processTimezone(event);\n      }\n      for (let level = 0; level < resourceCollection.length; level++) {\n        if (event[resourceCollection[level].field] === null || event[resourceCollection[level].field] === 0) {\n          event[resourceCollection[level].field] = undefined;\n        }\n      }\n      if (!isNullOrUndefined(event[fields.recurrenceRule]) && event[fields.recurrenceRule] === '') {\n        event[fields.recurrenceRule] = null;\n      }\n      if (!isNullOrUndefined(event[fields.recurrenceRule]) && isNullOrUndefined(event[fields.recurrenceID]) && !(this.parent.crudModule && this.parent.crudModule.crudObj.isCrudAction)) {\n        processed = processed.concat(this.generateOccurrence(event, null, oldTimezone, true));\n      } else {\n        if (this.parent.crudModule && this.parent.crudModule.crudObj.isCrudAction) {\n          if (!isNullOrUndefined(event[fields.recurrenceRule]) && isNullOrUndefined(event[fields.recurrenceID])) {\n            const recurrenceEvent = this.generateOccurrence(event, null, oldTimezone, true);\n            for (const occurrence of recurrenceEvent) {\n              const app = this.parent.eventsProcessed.filter(data => data[fields.startTime].getTime() - occurrence[fields.startTime].getTime() === 0 && data[fields.id] === occurrence[fields.id]);\n              occurrence.Guid = app.length > 0 ? app[0].Guid : this.generateGuid();\n              processed.push(occurrence);\n            }\n          } else {\n            const app = this.parent.eventsProcessed.filter(data => data[this.parent.eventFields.id] === event[this.parent.eventFields.id]);\n            event.Guid = app.length > 0 ? app[0].Guid : this.generateGuid();\n            processed.push(event);\n          }\n        } else {\n          event.Guid = this.generateGuid();\n          processed.push(event);\n        }\n      }\n    }\n    this.parent.eventsProcessed = [];\n    const eventData = processed.filter(data => !data[this.parent.eventFields.isBlock]);\n    this.parent.eventsProcessed = this.filterEvents(start, end, eventData);\n    const blockData = processed.filter(data => data[this.parent.eventFields.isBlock]);\n    for (const eventObj of blockData) {\n      if (eventObj[fields.isAllDay]) {\n        const isDifferentDate = resetTime(new Date(eventObj[fields.startTime].getTime())) < resetTime(new Date(eventObj[fields.endTime].getTime()));\n        if (!isDifferentDate) {\n          eventObj[fields.startTime] = resetTime(eventObj[fields.startTime]);\n          eventObj[fields.endTime] = addDays(resetTime(eventObj[fields.endTime]), 1);\n        }\n      }\n    }\n    this.parent.blockProcessed = blockData;\n    return eventData;\n  }\n  updateEventDateTime(eventData) {\n    if (typeof eventData[this.parent.eventFields.startTime] === 'string') {\n      eventData[this.parent.eventFields.startTime] = getDateFromString(eventData[this.parent.eventFields.startTime]);\n    }\n    if (typeof eventData[this.parent.eventFields.endTime] === 'string') {\n      eventData[this.parent.eventFields.endTime] = getDateFromString(eventData[this.parent.eventFields.endTime]);\n    }\n    return eventData;\n  }\n  getProcessedEvents(eventCollection = this.parent.eventsData) {\n    let processed = [];\n    for (const event of eventCollection) {\n      if (!isNullOrUndefined(event[this.parent.eventFields.recurrenceRule]) && isNullOrUndefined(event[this.parent.eventFields.recurrenceID])) {\n        processed = processed.concat(this.generateOccurrence(event));\n      } else {\n        processed.push(event);\n      }\n    }\n    return processed;\n  }\n  timezonePropertyChange(oldTimezone) {\n    const data = this.parent.eventsData.concat(this.parent.blockData);\n    const processed = this.processData(data, true, oldTimezone);\n    this.parent.notify(dataReady, {\n      processedData: processed\n    });\n  }\n  timezoneConvert(eventData) {\n    const fields = this.parent.eventFields;\n    eventData[fields.startTimezone] = eventData[fields.startTimezone] || eventData[fields.endTimezone];\n    eventData[fields.endTimezone] = eventData[fields.endTimezone] || eventData[fields.startTimezone];\n    if (this.parent.timezone) {\n      const startTz = eventData[fields.startTimezone];\n      const endTz = eventData[fields.endTimezone];\n      eventData[fields.startTime] = this.parent.tzModule.convert(eventData[fields.startTime], this.parent.timezone, startTz);\n      eventData[fields.endTime] = this.parent.tzModule.convert(eventData[fields.endTime], this.parent.timezone, endTz);\n    }\n  }\n  processTimezoneChange(event, oldTimezone) {\n    const fields = this.parent.eventFields;\n    if (event[fields.isAllDay]) {\n      return;\n    }\n    if (oldTimezone && this.parent.timezone) {\n      event[fields.startTime] = this.parent.tzModule.convert(event[fields.startTime], oldTimezone, this.parent.timezone);\n      event[fields.endTime] = this.parent.tzModule.convert(event[fields.endTime], oldTimezone, this.parent.timezone);\n    } else if (!oldTimezone && this.parent.timezone) {\n      event[fields.startTime] = this.parent.tzModule.add(event[fields.startTime], this.parent.timezone);\n      event[fields.endTime] = this.parent.tzModule.add(event[fields.endTime], this.parent.timezone);\n    } else if (oldTimezone && !this.parent.timezone) {\n      event[fields.startTime] = this.parent.tzModule.remove(event[fields.startTime], oldTimezone);\n      event[fields.endTime] = this.parent.tzModule.remove(event[fields.endTime], oldTimezone);\n    }\n  }\n  processTimezone(event, isReverse = false) {\n    const fields = this.parent.eventFields;\n    if (event[fields.startTimezone] || event[fields.endTimezone]) {\n      const startTimezone = event[fields.startTimezone] || event[fields.endTimezone];\n      const endTimezone = event[fields.endTimezone] || event[fields.startTimezone];\n      if (isReverse) {\n        if (this.parent.timezone) {\n          event[fields.startTime] = this.parent.tzModule.convert(event[fields.startTime], startTimezone, this.parent.timezone);\n          event[fields.endTime] = this.parent.tzModule.convert(event[fields.endTime], endTimezone, this.parent.timezone);\n          event[fields.startTime] = this.parent.tzModule.remove(event[fields.startTime], this.parent.timezone);\n          event[fields.endTime] = this.parent.tzModule.remove(event[fields.endTime], this.parent.timezone);\n        } else {\n          event[fields.startTime] = this.parent.tzModule.remove(event[fields.startTime], startTimezone);\n          event[fields.endTime] = this.parent.tzModule.remove(event[fields.endTime], endTimezone);\n        }\n      } else {\n        event[fields.startTime] = this.parent.tzModule.add(event[fields.startTime], startTimezone);\n        event[fields.endTime] = this.parent.tzModule.add(event[fields.endTime], endTimezone);\n        if (this.parent.timezone) {\n          event[fields.startTime] = this.parent.tzModule.convert(event[fields.startTime], startTimezone, this.parent.timezone);\n          event[fields.endTime] = this.parent.tzModule.convert(event[fields.endTime], endTimezone, this.parent.timezone);\n        }\n      }\n    } else if (this.parent.timezone) {\n      if (isReverse) {\n        event[fields.startTime] = this.parent.tzModule.remove(event[fields.startTime], this.parent.timezone);\n        event[fields.endTime] = this.parent.tzModule.remove(event[fields.endTime], this.parent.timezone);\n      } else {\n        event[fields.startTime] = this.parent.tzModule.add(event[fields.startTime], this.parent.timezone);\n        event[fields.endTime] = this.parent.tzModule.add(event[fields.endTime], this.parent.timezone);\n      }\n    }\n    return event;\n  }\n  filterBlockEvents(eventObj) {\n    const fields = this.parent.eventFields;\n    const eStart = eventObj[fields.startTime];\n    const eEnd = eventObj[fields.endTime];\n    let resourceData;\n    if (this.parent.activeViewOptions.group.resources.length > 0) {\n      const data = this.getGroupIndexFromEvent(eventObj);\n      resourceData = this.parent.resourceBase.lastResourceLevel[data];\n    }\n    const blockEvents = extend([], this.parent.blockProcessed, null, true);\n    for (const eventObj of blockEvents) {\n      if (eventObj[fields.isAllDay]) {\n        const isDifferentTime = eventObj[fields.endTime].getTime() > resetTime(new Date(eventObj[fields.endTime].getTime())).getTime();\n        if (isDifferentTime) {\n          eventObj[fields.startTime] = resetTime(eventObj[fields.startTime]);\n          eventObj[fields.endTime] = addDays(resetTime(eventObj[fields.endTime]), 1);\n        }\n      }\n    }\n    return this.filterEvents(eStart, eEnd, blockEvents, resourceData);\n  }\n  filterEvents(startDate, endDate, appointments = this.parent.eventsProcessed, resourceTdData) {\n    const fieldMapping = this.parent.eventFields;\n    const predicate = new Predicate(fieldMapping.startTime, 'greaterthanorequal', startDate).and(new Predicate(fieldMapping.endTime, 'greaterthanorequal', startDate)).and(new Predicate(fieldMapping.startTime, 'lessthan', endDate)).or(new Predicate(fieldMapping.startTime, 'lessthanorequal', startDate).and(new Predicate(fieldMapping.endTime, 'greaterthan', startDate)));\n    let filter = new DataManager({\n      json: appointments\n    }).executeLocal(new Query().where(predicate));\n    if (resourceTdData) {\n      filter = this.filterEventsByResource(resourceTdData, filter);\n    }\n    return this.sortByTime(filter);\n  }\n  filterEventsByRange(eventCollection, startDate, endDate) {\n    let filteredEvents = [];\n    if (startDate && endDate) {\n      filteredEvents = this.filterEvents(startDate, endDate, eventCollection);\n    } else if (startDate && !endDate) {\n      filteredEvents = eventCollection.filter(e => e[this.parent.eventFields.startTime] >= startDate);\n    } else if (!startDate && endDate) {\n      filteredEvents = eventCollection.filter(e => e[this.parent.eventFields.endTime] <= endDate);\n    } else {\n      filteredEvents = eventCollection;\n    }\n    return this.sortByTime(filteredEvents);\n  }\n  filterEventsByResource(resourceTdData, appointments = this.parent.eventsProcessed) {\n    const predicate = {};\n    const resourceCollection = this.parent.resourceBase.resourceCollection;\n    for (let level = 0; level < resourceCollection.length; level++) {\n      predicate[resourceCollection[level].field] = resourceTdData.groupOrder[level];\n    }\n    const keys = Object.keys(predicate);\n    const filteredCollection = appointments.filter(eventObj => keys.every(key => {\n      if (eventObj[key] instanceof Array) {\n        return eventObj[key].indexOf(predicate[key]) > -1;\n      } else {\n        return eventObj[key] === predicate[key];\n      }\n    }));\n    return filteredCollection;\n  }\n  sortByTime(appointmentsCollection) {\n    if (this.parent.eventSettings.sortComparer) {\n      appointmentsCollection = this.parent.eventSettings.sortComparer.call(this.parent, appointmentsCollection);\n    } else {\n      const fieldMappings = this.parent.eventFields;\n      appointmentsCollection.sort((a, b) => {\n        const d1 = a[fieldMappings.startTime];\n        const d2 = b[fieldMappings.startTime];\n        return d1.getTime() - d2.getTime();\n      });\n    }\n    return appointmentsCollection;\n  }\n  sortByDateTime(appointments) {\n    if (this.parent.eventSettings.sortComparer) {\n      appointments = this.parent.eventSettings.sortComparer.call(this.parent, appointments);\n    } else {\n      const fieldMapping = this.parent.eventFields;\n      appointments.sort((object1, object2) => {\n        const d3 = object1[fieldMapping.startTime];\n        const d4 = object2[fieldMapping.startTime];\n        const d5 = object1[fieldMapping.endTime];\n        const d6 = object2[fieldMapping.endTime];\n        const d1 = d5.getTime() - d3.getTime();\n        const d2 = d6.getTime() - d4.getTime();\n        return d3.getTime() - d4.getTime() || d2 - d1;\n      });\n    }\n    return appointments;\n  }\n  getSmallestMissingNumber(array) {\n    const large = Math.max(...array);\n    for (let i = 0; i < large; i++) {\n      if (array.indexOf(i) === -1) {\n        return i;\n      }\n    }\n    return large + 1;\n  }\n  splitEventByDay(event) {\n    const eventFields = this.parent.eventFields;\n    const data = [];\n    const eventStartTime = event[eventFields.startTime];\n    const eventEndTime = event[eventFields.endTime];\n    const isDifferentDate = resetTime(new Date(eventStartTime.getTime())) < resetTime(new Date(eventEndTime.getTime()));\n    if (isDifferentDate) {\n      let start = new Date(eventStartTime.getTime());\n      let end = addDays(resetTime(new Date(eventStartTime.getTime())), 1);\n      const endDate = eventEndTime.getHours() === 0 && eventEndTime.getMinutes() === 0 ? eventEndTime : addDays(eventEndTime, 1);\n      let index = 1;\n      const eventLength = getDaysCount(eventStartTime.getTime(), endDate.getTime());\n      while (end <= eventEndTime && start.getTime() !== end.getTime()) {\n        const app = extend({}, event);\n        app[eventFields.startTime] = start;\n        app[eventFields.endTime] = end;\n        app.data = {\n          index: index,\n          count: eventLength\n        };\n        app.Guid = this.generateGuid();\n        app.isSpanned = true;\n        data.push(app);\n        start = end;\n        if (resetTime(new Date(start.getTime())).getTime() === resetTime(new Date(eventEndTime.getTime())).getTime() && !(end.getTime() === eventEndTime.getTime())) {\n          end = new Date(start.getTime());\n          end = new Date(end.setHours(eventEndTime.getHours(), eventEndTime.getMinutes(), eventEndTime.getSeconds()));\n        } else {\n          end = addDays(resetTime(new Date(start.getTime())), 1);\n        }\n        index++;\n      }\n    } else {\n      data.push(event);\n    }\n    return data;\n  }\n  splitEvent(event, dateRender) {\n    const fields = this.parent.eventFields;\n    let start = resetTime(event[fields.startTime]).getTime();\n    let end = resetTime(event[fields.endTime]).getTime();\n    if (getDateInMs(event[fields.endTime]) <= 0) {\n      const temp = addDays(resetTime(event[fields.endTime]), -1).getTime();\n      end = start > temp ? start : temp;\n    }\n    const orgStart = start;\n    const orgEnd = end;\n    const ranges = [];\n    if (start !== end) {\n      if (start < dateRender[0].getTime()) {\n        start = dateRender[0].getTime();\n      }\n      if (end > dateRender[dateRender.length - 1].getTime()) {\n        end = dateRender[dateRender.length - 1].getTime();\n      }\n      let cStart = start;\n      for (let level = 0; level < this.slots.length; level++) {\n        let slot = this.slots[level];\n        if (this.parent.currentView === 'WorkWeek' || this.parent.currentView === 'TimelineWorkWeek' || this.parent.activeViewOptions.group.byDate || this.parent.activeViewOptions.showWeekend) {\n          const slotDates = [];\n          for (const s of slot) {\n            slotDates.push(new Date(s));\n          }\n          const renderedDates = this.getRenderedDates(slotDates);\n          if (!isNullOrUndefined(renderedDates) && renderedDates.length > 0) {\n            slot = [];\n            for (const date of renderedDates) {\n              slot.push(date.getTime());\n            }\n          }\n        }\n        if (typeof slot === 'number') {\n          const temp = slot;\n          slot = [];\n          slot.push(temp);\n        }\n        const firstSlot = slot[0];\n        cStart = cStart <= firstSlot && end >= firstSlot ? firstSlot : cStart;\n        if (cStart > end || firstSlot > end) {\n          break;\n        }\n        if (!this.parent.activeViewOptions.group.byDate && this.parent.activeViewOptions.showWeekend && this.parent.currentView !== 'WorkWeek' && this.parent.currentView !== 'TimelineWorkWeek') {\n          const startIndex = slot.indexOf(cStart);\n          if (startIndex !== -1) {\n            let endIndex = slot.indexOf(end);\n            const hasBreak = endIndex !== -1;\n            endIndex = hasBreak ? endIndex : slot.length - 1;\n            const count = endIndex - startIndex + 1;\n            const isLeft = slot[startIndex] !== orgStart;\n            const isRight = slot[endIndex] !== orgEnd;\n            ranges.push(this.cloneEventObject(event, slot[startIndex], slot[endIndex], count, isLeft, isRight));\n            if (hasBreak) {\n              break;\n            }\n          }\n        } else {\n          if (this.dateInRange(cStart, slot[0], slot[slot.length - 1])) {\n            const availSlot = [];\n            for (let i = 0; i < slot.length; i++) {\n              if (this.dateInRange(slot[i], orgStart, orgEnd)) {\n                availSlot.push(slot[i]);\n              }\n            }\n            if (availSlot.length > 0) {\n              if (!this.parent.activeViewOptions.group.byDate) {\n                const isLeft = availSlot[0] !== orgStart;\n                const isRight = availSlot[availSlot.length - 1] !== orgEnd;\n                ranges.push(this.cloneEventObject(event, availSlot[0], availSlot[availSlot.length - 1], availSlot.length, isLeft, isRight));\n              } else {\n                for (const slot of availSlot) {\n                  ranges.push(this.cloneEventObject(event, slot, slot, 1, slot !== orgStart, slot !== orgEnd));\n                }\n              }\n            }\n          }\n        }\n      }\n    } else {\n      ranges.push(this.cloneEventObject(event, start, end, 1, false, false));\n    }\n    return ranges;\n  }\n  cloneEventObject(event, start, end, count, isLeft, isRight) {\n    const fields = this.parent.eventFields;\n    const e = extend({}, event, null, true);\n    const data = {\n      count: count,\n      isLeft: isLeft,\n      isRight: isRight\n    };\n    data[fields.startTime] = event[fields.startTime];\n    data[fields.endTime] = event[fields.endTime];\n    e.data = data;\n    e[fields.startTime] = new Date(start);\n    e[fields.endTime] = new Date(end);\n    return e;\n  }\n  dateInRange(date, start, end) {\n    return start <= date && date <= end;\n  }\n  getSelectedEventElements(target) {\n    this.removeSelectedAppointmentClass();\n    if (this.parent.selectedElements.length <= 0) {\n      this.parent.selectedElements.push(target);\n    } else {\n      const isAlreadySelected = this.parent.selectedElements.filter(element => element.getAttribute('data-guid') === target.getAttribute('data-guid'));\n      if (isAlreadySelected.length <= 0) {\n        const elementSelector = 'div[data-guid=\"' + target.getAttribute('data-guid') + '\"]';\n        const focusElements = [].slice.call(this.parent.element.querySelectorAll(elementSelector));\n        for (const element of focusElements) {\n          this.parent.selectedElements.push(element);\n        }\n      } else {\n        const selectedElements = this.parent.selectedElements.filter(element => element.getAttribute('data-guid') !== target.getAttribute('data-guid'));\n        this.parent.selectedElements = selectedElements;\n      }\n    }\n    if (target && this.parent.selectedElements.length > 0) {\n      this.addSelectedAppointments(this.parent.selectedElements);\n    }\n    return this.parent.selectedElements;\n  }\n  getSelectedEvents() {\n    const eventSelect = [];\n    const elementSelect = [];\n    const selectAppointments = [].slice.call(this.parent.element.querySelectorAll('.' + APPOINTMENT_BORDER));\n    selectAppointments.filter(element => {\n      const isAlreadyAdded = eventSelect.filter(event => {\n        return event.Guid === element.getAttribute('data-guid');\n      });\n      if (isAlreadyAdded.length === 0) {\n        eventSelect.push(this.getEventByGuid(element.getAttribute('data-guid')));\n      }\n      elementSelect.push(element);\n    });\n    return {\n      event: eventSelect.length > 1 ? eventSelect : eventSelect[0],\n      element: elementSelect.length > 1 ? elementSelect : elementSelect[0]\n    };\n  }\n  removeSelectedAppointmentClass() {\n    const selectedAppointments = this.getSelectedAppointments();\n    for (const appointment of selectedAppointments) {\n      appointment.setAttribute('aria-selected', 'false');\n    }\n    removeClass(selectedAppointments, APPOINTMENT_BORDER);\n    if (this.parent.currentView === 'Agenda' || this.parent.currentView === 'MonthAgenda') {\n      removeClass(selectedAppointments, AGENDA_SELECTED_CELL);\n    }\n  }\n  addSelectedAppointments(cells) {\n    for (const cell of cells) {\n      cell.setAttribute('aria-selected', 'true');\n    }\n    if (this.parent.currentView !== 'MonthAgenda') {\n      this.parent.removeSelectedClass();\n    }\n    addClass(cells, APPOINTMENT_BORDER);\n  }\n  getSelectedAppointments() {\n    return [].slice.call(this.parent.element.querySelectorAll('.' + APPOINTMENT_BORDER + ',.' + APPOINTMENT_CLASS + ':focus'));\n  }\n  focusElement(isFocused) {\n    if (this.parent.eventWindow.dialogObject && this.parent.eventWindow.dialogObject.visible) {\n      return;\n    }\n    const activeEle = document.activeElement;\n    const selectedCell = this.parent.getSelectedElements();\n    if (selectedCell.length > 0 && (activeEle && (this.parent.element.contains(activeEle) || selectedCell.indexOf(activeEle) !== -1) || isFocused)) {\n      if (this.parent.keyboardInteractionModule) {\n        const target = !isNullOrUndefined(this.parent.activeCellsData) && this.parent.activeCellsData.element || selectedCell[selectedCell.length - 1];\n        this.parent.keyboardInteractionModule.selectCells(target instanceof Array, target);\n      }\n      return;\n    }\n    const selectedAppointments = this.getSelectedAppointments();\n    if (selectedAppointments.length > 0) {\n      selectedAppointments[selectedAppointments.length - 1].focus();\n      return;\n    }\n  }\n  selectWorkCellByTime(eventsData) {\n    let target;\n    if (this.parent.currentView === 'Agenda' || this.parent.currentView === 'MonthAgenda') {\n      return target;\n    }\n    if (eventsData.length > 0) {\n      const selectedObject = eventsData[eventsData.length - 1];\n      const eventStartTime = selectedObject[this.parent.eventFields.startTime];\n      let nearestTime = new Date(+eventStartTime).setMinutes(0, 0, 0);\n      const isAllDay = this.isAllDayAppointment(selectedObject);\n      if (this.parent.currentView === 'Month' || isAllDay) {\n        nearestTime = new Date(+eventStartTime).setHours(0, 0, 0, 0);\n      }\n      let targetArea;\n      if (isAllDay && ['Day', 'Week', 'WorkWeek'].indexOf(this.parent.currentView) !== -1) {\n        targetArea = this.parent.getAllDayRow();\n      } else {\n        targetArea = this.parent.getContentTable();\n      }\n      let queryString = '[data-date=\"' + new Date(nearestTime).getTime() + '\"]';\n      if (this.parent.activeViewOptions.group.resources.length > 0) {\n        queryString += '[data-group-index=\"' + this.getGroupIndexFromEvent(selectedObject) + '\"]';\n      }\n      target = targetArea.querySelector(queryString);\n      if (target) {\n        this.parent.activeCellsData = this.parent.getCellDetails(target);\n        if (this.parent.keyboardInteractionModule) {\n          this.parent.keyboardInteractionModule.selectCells(false, target);\n        }\n        return target;\n      }\n    }\n    return target;\n  }\n  getGroupIndexFromEvent(eventData) {\n    let levelIndex;\n    let resource;\n    let levelName;\n    let idField;\n    for (let i = this.parent.resourceBase.resourceCollection.length - 1; i >= 0; i--) {\n      const resourceData = eventData[this.parent.resourceBase.resourceCollection[i].field];\n      if (!isNullOrUndefined(resourceData)) {\n        resource = this.parent.resourceBase.resourceCollection[i];\n        levelIndex = i;\n        levelName = resource.name;\n        idField = resource.field;\n        break;\n      }\n    }\n    if (isNullOrUndefined(levelName) && isNullOrUndefined(levelIndex)) {\n      levelName = this.parent.resourceCollection.slice(-1)[0].name;\n      levelIndex = this.parent.resourceCollection.length - 1;\n      idField = this.parent.resourceCollection.slice(-1)[0].field;\n      resource = this.parent.resourceCollection.filter((e, index) => {\n        if (e.name === levelName) {\n          levelIndex = index;\n          return e;\n        }\n        return null;\n      })[0];\n    }\n    const id = eventData[idField] instanceof Array ? eventData[idField][0] : eventData[idField];\n    if (levelIndex > 0) {\n      const parentField = this.parent.resourceCollection[levelIndex - 1].field;\n      return this.parent.resourceBase.getIndexFromResourceId(id, levelName, resource, eventData, parentField);\n    } else {\n      return this.parent.resourceBase.getIndexFromResourceId(id, levelName, resource);\n    }\n  }\n  isAllDayAppointment(event) {\n    const fieldMapping = this.parent.eventFields;\n    const isAllDay = event[fieldMapping.isAllDay];\n    const isFullDay = (event[fieldMapping.endTime].getTime() - event[fieldMapping.startTime].getTime()) / MS_PER_DAY >= 1;\n    return isAllDay || this.parent.eventSettings.spannedEventPlacement !== 'TimeSlot' && isFullDay ? true : false;\n  }\n  addEventListener() {\n    this.parent.on(documentClick, this.appointmentBorderRemove, this);\n  }\n  removeEventListener() {\n    this.parent.off(documentClick, this.appointmentBorderRemove);\n  }\n  appointmentBorderRemove(event) {\n    const element = event.event.target;\n    if (closest(element, '.' + APPOINTMENT_CLASS)) {\n      if (this.parent.currentView !== 'MonthAgenda') {\n        this.parent.removeSelectedClass();\n      }\n    } else if (!closest(element, '.' + POPUP_OPEN)) {\n      this.removeSelectedAppointmentClass();\n    }\n  }\n  wireAppointmentEvents(element, event, isPreventCrud = false) {\n    const isReadOnly = !isNullOrUndefined(event) ? event[this.parent.eventFields.isReadonly] : false;\n    EventHandler.add(element, 'click', this.eventClick, this);\n    if (!this.parent.isAdaptive && !this.parent.activeViewOptions.readonly && !isReadOnly) {\n      EventHandler.add(element, 'touchstart', this.eventTouchClick, this);\n      EventHandler.add(element, 'dblclick', this.eventDoubleClick, this);\n    }\n    if (!this.parent.activeViewOptions.readonly && !isReadOnly && !isPreventCrud) {\n      if (this.parent.resizeModule) {\n        this.parent.resizeModule.wireResizeEvent(element);\n      }\n      if (this.parent.dragAndDropModule) {\n        this.parent.dragAndDropModule.wireDragEvent(element);\n      }\n    }\n  }\n  eventTouchClick(e) {\n    setTimeout(() => this.isDoubleTapped = false, 250);\n    e.preventDefault();\n    if (this.isDoubleTapped) {\n      this.eventDoubleClick(e);\n    } else if (!this.isDoubleTapped) {\n      this.isDoubleTapped = true;\n      this.eventClick(e);\n    }\n  }\n  renderResizeHandler(element, spanEvent, isReadOnly) {\n    if (!this.parent.resizeModule || !this.parent.allowResizing || this.parent.activeViewOptions.readonly || isReadOnly) {\n      return;\n    }\n    for (const resizeEdge of Object.keys(spanEvent)) {\n      const resizeHandler = createElement('div', {\n        className: EVENT_RESIZE_CLASS\n      });\n      switch (resizeEdge) {\n        case 'isLeft':\n          if (!spanEvent.isLeft) {\n            resizeHandler.appendChild(createElement('div', {\n              className: 'e-left-right-resize'\n            }));\n            addClass([resizeHandler], this.parent.enableRtl ? RIGHT_RESIZE_HANDLER : LEFT_RESIZE_HANDLER);\n            prepend([resizeHandler], element);\n          }\n          break;\n        case 'isRight':\n          if (!spanEvent.isRight) {\n            resizeHandler.appendChild(createElement('div', {\n              className: 'e-left-right-resize'\n            }));\n            addClass([resizeHandler], this.parent.enableRtl ? LEFT_RESIZE_HANDLER : RIGHT_RESIZE_HANDLER);\n            append([resizeHandler], element);\n          }\n          break;\n        case 'isTop':\n          if (!spanEvent.isTop) {\n            resizeHandler.appendChild(createElement('div', {\n              className: 'e-top-bottom-resize'\n            }));\n            addClass([resizeHandler], TOP_RESIZE_HANDLER);\n            prepend([resizeHandler], element);\n          }\n          break;\n        case 'isBottom':\n          if (!spanEvent.isBottom) {\n            resizeHandler.appendChild(createElement('div', {\n              className: 'e-top-bottom-resize'\n            }));\n            addClass([resizeHandler], BOTTOM_RESIZE_HANDLER);\n            append([resizeHandler], element);\n          }\n          break;\n      }\n    }\n  }\n  eventClick(eventData) {\n    const target = eventData.target;\n    if (target.classList.contains(DRAG_CLONE_CLASS) || target.classList.contains(RESIZE_CLONE_CLASS) || target.classList.contains(INLINE_SUBJECT_CLASS)) {\n      return;\n    }\n    if ((eventData.ctrlKey || eventData.metaKey) && eventData.which === 1 && this.parent.keyboardInteractionModule) {\n      this.parent.quickPopup.quickPopup.hide();\n      this.parent.selectedElements = [].slice.call(this.parent.element.querySelectorAll('.' + APPOINTMENT_BORDER));\n      const target = closest(eventData.target, '.' + APPOINTMENT_CLASS);\n      this.getSelectedEventElements(target);\n      this.activeEventData(eventData, false);\n      const selectArgs = {\n        data: this.parent.activeEventData.event,\n        element: this.parent.activeEventData.element,\n        event: eventData,\n        requestType: 'eventSelect'\n      };\n      this.parent.trigger(select, selectArgs);\n      const args = extend(this.parent.activeEventData, {\n        cancel: false,\n        originalEvent: eventData\n      });\n      this.parent.trigger(eventClick, args);\n    } else {\n      this.removeSelectedAppointmentClass();\n      this.activeEventData(eventData, true);\n      const selectEventArgs = {\n        data: this.parent.activeEventData.event,\n        element: this.parent.activeEventData.element,\n        event: eventData,\n        requestType: 'eventSelect'\n      };\n      this.parent.trigger(select, selectEventArgs);\n      const args = extend(this.parent.activeEventData, {\n        cancel: false,\n        originalEvent: eventData\n      });\n      this.parent.trigger(eventClick, args, eventClickArgs => {\n        if (eventClickArgs.cancel) {\n          this.removeSelectedAppointmentClass();\n          if (this.parent.quickPopup) {\n            this.parent.quickPopup.quickPopupHide();\n          }\n        } else {\n          if (this.parent.currentView === 'Agenda' || this.parent.currentView === 'MonthAgenda') {\n            addClass([this.parent.activeEventData.element], AGENDA_SELECTED_CELL);\n          }\n          if (this.parent.allowInline) {\n            const inlineArgs = {\n              data: eventClickArgs.event,\n              element: eventClickArgs.element,\n              type: 'Event'\n            };\n            this.parent.notify(inlineClick, inlineArgs);\n          } else {\n            this.parent.notify(eventClick, eventClickArgs);\n          }\n        }\n      });\n    }\n  }\n  eventDoubleClick(e) {\n    if (this.parent.quickPopup) {\n      this.parent.quickPopup.quickPopupHide(true);\n    }\n    if (e.type === 'touchstart') {\n      this.activeEventData(e, true);\n    }\n    this.removeSelectedAppointmentClass();\n    if (this.parent.activeEventData.element.classList.contains(INLINE_APPOINTMENT_CLASS) || this.parent.activeEventData.element.querySelector('.' + INLINE_SUBJECT_CLASS)) {\n      return;\n    }\n    if (!isNullOrUndefined(this.parent.activeEventData.event) && isNullOrUndefined(this.parent.activeEventData.event[this.parent.eventFields.recurrenceID])) {\n      this.parent.eventWindow.openEditor(this.parent.activeEventData.event, 'Save');\n    } else {\n      this.parent.currentAction = 'EditOccurrence';\n      this.parent.quickPopup.openRecurrenceAlert();\n    }\n  }\n  getEventByGuid(guid) {\n    return this.parent.eventsProcessed.filter(data => data.Guid === guid)[0];\n  }\n  getEventById(id) {\n    return this.parent.eventsData.filter(data => data[this.parent.eventFields.id] === id)[0];\n  }\n  generateGuid() {\n    return 'xyxxxxyx-xxxy-yxxx-xyxx-xxyxxxxyyxxx'.replace(/[xy]/g, c => {\n      const r = Math.random() * 16 | 0;\n      const v = c === 'x' ? r : r & 0x3 | 0x8;\n      return v.toString(16);\n    });\n  }\n  getEventIDType() {\n    if (this.parent.eventsData.length !== 0) {\n      return typeof this.parent.eventsData[0][this.parent.eventFields.id];\n    }\n    if (this.parent.blockData.length !== 0) {\n      return typeof this.parent.blockData[0][this.parent.eventFields.id];\n    }\n    return 'string';\n  }\n  getEventMaxID(resourceId) {\n    if (this.parent.eventsData.length < 1 && this.parent.blockData.length < 1) {\n      return 1;\n    }\n    let eventId;\n    const idType = this.getEventIDType();\n    if (idType === 'string') {\n      eventId = this.generateGuid();\n    }\n    if (idType === 'number') {\n      const datas = this.parent.eventsData.concat(this.parent.blockData);\n      let maxId = Math.max(...datas.map(event => event[this.parent.eventFields.id]));\n      maxId = isNullOrUndefined(resourceId) ? maxId : maxId + resourceId;\n      eventId = maxId + 1;\n    }\n    return eventId;\n  }\n  activeEventData(eventData, isMultiple) {\n    const target = closest(eventData.target, '.' + APPOINTMENT_CLASS);\n    const guid = target.getAttribute('data-guid');\n    if (isMultiple) {\n      this.addSelectedAppointments([].slice.call(this.parent.element.querySelectorAll('div[data-guid=\"' + guid + '\"]')));\n      target.focus();\n    }\n    let eventObject = this.getEventByGuid(guid);\n    if (eventObject && eventObject.isSpanned) {\n      eventObject = this.parent.eventsData.filter(obj => obj[this.parent.eventFields.id] === eventObject[this.parent.eventFields.id])[0];\n    }\n    this.parent.activeEventData = {\n      event: eventObject,\n      element: target\n    };\n  }\n  generateOccurrence(event, viewDate, oldTimezone, isMaxCount) {\n    const startDate = event[this.parent.eventFields.startTime];\n    const endDate = event[this.parent.eventFields.endTime];\n    const eventRule = event[this.parent.eventFields.recurrenceRule];\n    const duration = endDate.getTime() - startDate.getTime();\n    viewDate = new Date((viewDate || this.parent.activeView.startDate()).getTime() - duration);\n    const exception = event[this.parent.eventFields.recurrenceException];\n    let maxCount;\n    if (this.parent.currentView !== 'Agenda' && isMaxCount) {\n      maxCount = getDateCount(this.parent.activeView.startDate(), this.parent.activeView.endDate()) + 1;\n    }\n    const newTimezone = this.parent.timezone || this.parent.tzModule.getLocalTimezoneName();\n    const firstDay = this.parent.activeViewOptions.firstDayOfWeek;\n    const calendarMode = this.parent.calendarMode;\n    const dates = generate(startDate, eventRule, exception, firstDay, maxCount, viewDate, calendarMode, oldTimezone, newTimezone);\n    if (this.parent.currentView === 'Agenda' && eventRule.indexOf('COUNT') === -1 && eventRule.indexOf('UNTIL') === -1) {\n      if (isNullOrUndefined(event.generatedDates)) {\n        event.generatedDates = {\n          start: new Date(dates[0]),\n          end: new Date(dates[dates.length - 1])\n        };\n      } else {\n        if (dates[0] < event.generatedDates.start.getTime()) {\n          event.generatedDates.start = new Date(dates[0]);\n        }\n        if (dates[dates.length - 1] > event.generatedDates.end.getTime()) {\n          event.generatedDates.end = new Date(dates[dates.length - 1]);\n        }\n      }\n    }\n    const occurrenceCollection = [];\n    for (const date of dates) {\n      const clonedObject = extend({}, event, null, true);\n      clonedObject[this.parent.eventFields.startTime] = new Date(date);\n      clonedObject[this.parent.eventFields.endTime] = new Date(new Date(date).setMilliseconds(duration));\n      clonedObject[this.parent.eventFields.recurrenceID] = clonedObject[this.parent.eventFields.id];\n      delete clonedObject[this.parent.eventFields.recurrenceException];\n      delete clonedObject[this.parent.eventFields.followingID];\n      clonedObject.Guid = this.generateGuid();\n      occurrenceCollection.push(clonedObject);\n    }\n    return occurrenceCollection;\n  }\n  getParentEvent(eventObj, isParent = false) {\n    let parentEvent;\n    do {\n      eventObj = this.getFollowingEvent(eventObj);\n      if (eventObj) {\n        parentEvent = extend({}, eventObj, null, true);\n      }\n    } while (eventObj && isParent);\n    if (isParent && parentEvent) {\n      const collection = this.getEventCollections(parentEvent);\n      let followObj = collection.follow.slice(-1)[0];\n      if (collection.occurrence.length > 0 && !parentEvent[this.parent.eventFields.recurrenceException]) {\n        followObj = collection.occurrence.slice(-1)[0];\n      }\n      if (followObj) {\n        parentEvent[this.parent.eventFields.recurrenceRule] = followObj[this.parent.eventFields.recurrenceRule];\n      }\n    }\n    return parentEvent;\n  }\n  getEventCollections(parentObj, childObj) {\n    const followingCollection = [];\n    let occurrenceCollection = [];\n    let followingEvent = parentObj;\n    do {\n      followingEvent = this.getFollowingEvent(followingEvent, true);\n      if (followingEvent) {\n        followingCollection.push(followingEvent);\n      }\n      occurrenceCollection = occurrenceCollection.concat(this.getOccurrenceEvent(followingEvent || parentObj));\n    } while (followingEvent);\n    let collections = {};\n    if (childObj) {\n      const fields = this.parent.eventFields;\n      collections = {\n        follow: followingCollection.filter(eventData => eventData[fields.startTime] >= childObj[fields.startTime]),\n        occurrence: occurrenceCollection.filter(eventData => eventData[fields.startTime] >= childObj[fields.startTime])\n      };\n    } else {\n      collections = {\n        follow: followingCollection,\n        occurrence: occurrenceCollection\n      };\n    }\n    return collections;\n  }\n  getFollowingEvent(parentObj, isReverse) {\n    const fields = this.parent.eventFields;\n    let fieldValue;\n    if (isReverse) {\n      fieldValue = parentObj[fields.id];\n    } else {\n      fieldValue = parentObj[fields.recurrenceID] || parentObj[fields.followingID];\n    }\n    const parentApp = this.parent.eventsData.filter(data => data[isReverse ? fields.followingID : fields.id] === fieldValue);\n    return parentApp.shift();\n  }\n  isFollowingEvent(parentObj, childObj) {\n    const parentStart = parentObj[this.parent.eventFields.startTime];\n    const childStart = childObj[this.parent.eventFields.startTime];\n    return parentStart.getHours() === childStart.getHours() && parentStart.getMinutes() === childStart.getMinutes() && parentStart.getSeconds() === childStart.getSeconds();\n  }\n  getOccurrenceEvent(eventObj, isGuid = false, isFollowing = false) {\n    const idField = isGuid ? 'Guid' : isFollowing ? this.parent.eventFields.followingID : this.parent.eventFields.recurrenceID;\n    const fieldKey = isGuid ? 'Guid' : this.parent.eventFields.id;\n    const dataSource = isGuid ? this.parent.eventsProcessed : this.parent.eventsData;\n    return dataSource.filter(data => data[idField] === eventObj[fieldKey]);\n  }\n  getOccurrencesByID(id) {\n    const fields = this.parent.eventFields;\n    let occurrenceCollection = [];\n    const parentObject = this.parent.eventsData.filter(obj => obj[fields.id] === id);\n    for (const event of parentObject) {\n      if (!isNullOrUndefined(event[fields.recurrenceRule])) {\n        occurrenceCollection = occurrenceCollection.concat(this.generateOccurrence(event));\n      }\n    }\n    return occurrenceCollection;\n  }\n  getOccurrencesByRange(startTime, endTime) {\n    const fields = this.parent.eventFields;\n    let occurrenceCollection = [];\n    for (const event of this.parent.eventsData) {\n      if (!isNullOrUndefined(event[fields.recurrenceRule])) {\n        occurrenceCollection = occurrenceCollection.concat(this.generateOccurrence(event));\n      }\n    }\n    const filter = occurrenceCollection.filter(obj => obj[fields.startTime] >= startTime && obj[fields.endTime] <= endTime && !isNullOrUndefined(obj[fields.recurrenceID]));\n    return filter;\n  }\n  getDeletedOccurrences(recurrenceData) {\n    const fields = this.parent.eventFields;\n    let parentObject;\n    const deletedOccurrences = [];\n    if (typeof recurrenceData === 'string' || typeof recurrenceData === 'number') {\n      parentObject = this.parent.eventsData.filter(obj => obj[fields.id] === recurrenceData)[0];\n    } else {\n      parentObject = extend({}, recurrenceData, null, true);\n    }\n    if (parentObject[fields.recurrenceException]) {\n      const exDateString = parentObject[fields.recurrenceException].split(',');\n      for (let i = 0, len = exDateString.length; i < len; i++) {\n        const edited = this.parent.eventsData.filter(eventObj => eventObj[fields.recurrenceID] === parentObject[fields.id] && eventObj[fields.recurrenceException] === exDateString[i]);\n        if (edited.length === 0) {\n          const exDate = getDateFromRecurrenceDateString(exDateString[i]);\n          const childObject = extend({}, recurrenceData, null, true);\n          childObject[fields.recurrenceID] = parentObject[fields.id];\n          delete childObject[fields.followingID];\n          childObject[fields.recurrenceException] = exDateString[i];\n          const startDate = new Date(exDate.getTime());\n          const time = parentObject[fields.endTime].getTime() - parentObject[fields.startTime].getTime();\n          const endDate = new Date(startDate.getTime());\n          endDate.setMilliseconds(time);\n          childObject[fields.startTime] = new Date(startDate.getTime());\n          childObject[fields.endTime] = new Date(endDate.getTime());\n          deletedOccurrences.push(childObject);\n        }\n      }\n    }\n    return deletedOccurrences;\n  }\n  applyResourceColor(element, data, type, index, alpha) {\n    if (!this.parent.resourceBase) {\n      return;\n    }\n    const alphaColor = (color, alpha) => {\n      color = color.replace('#', '');\n      const r = parseInt(color.substring(0, color.length / 3), 16);\n      const g = parseInt(color.substring(color.length / 3, 2 * color.length / 3), 16);\n      const b = parseInt(color.substring(2 * color.length / 3, 3 * color.length / 3), 16);\n      return `rgba(${r}, ${g}, ${b}, ${alpha})`;\n    };\n    // index refers groupOrder\n    const color = this.parent.resourceBase.getResourceColor(data, index);\n    if (color) {\n      element.style[type] = !isNullOrUndefined(alpha) ? alphaColor(color, alpha) : color;\n    }\n  }\n  createBlockAppointmentElement(record, resIndex) {\n    const eventSubject = record[this.parent.eventFields.subject] || this.parent.eventSettings.fields.subject.default;\n    const appointmentWrapper = createElement('div', {\n      className: BLOCK_APPOINTMENT_CLASS,\n      attrs: {\n        'data-id': 'Appointment_' + record[this.parent.eventFields.id],\n        'aria-readonly': 'true',\n        'aria-selected': 'false'\n      }\n    });\n    let templateElement;\n    if (!isNullOrUndefined(this.parent.activeViewOptions.eventTemplate)) {\n      const scheduleId = this.parent.element.id + '_';\n      const viewName = this.parent.activeViewOptions.eventTemplateName;\n      const templateId = scheduleId + viewName + 'eventTemplate';\n      const templateName = 'eventTemplate' + (this.parent.activeViewOptions.group.resources.length > 0 && this.parent.currentView.indexOf('Year') === -1 ? '_' + resIndex : '');\n      templateElement = this.parent.getAppointmentTemplate()(record, this.parent, templateName, templateId, false);\n    } else {\n      const appointmentSubject = createElement('div', {\n        className: SUBJECT_CLASS,\n        innerHTML: eventSubject\n      });\n      templateElement = [appointmentSubject];\n    }\n    append(templateElement, appointmentWrapper);\n    this.setWrapperAttributes(appointmentWrapper, resIndex);\n    return appointmentWrapper;\n  }\n  setWrapperAttributes(appointmentWrapper, resIndex) {\n    if (!isNullOrUndefined(this.cssClass)) {\n      addClass([appointmentWrapper], this.cssClass);\n    }\n    if (this.parent.activeViewOptions.group.resources.length > 0) {\n      appointmentWrapper.setAttribute('data-group-index', resIndex.toString());\n    }\n  }\n  getReadonlyAttribute(event) {\n    return (event[this.parent.eventFields.isReadonly] || this.parent.readonly).toString();\n  }\n  isBlockRange(eventData) {\n    const eventCollection = eventData instanceof Array ? eventData : [eventData];\n    let isBlockAlert = false;\n    const fields = this.parent.eventFields;\n    for (const event of eventCollection) {\n      let dataCol = [];\n      if (!isNullOrUndefined(event[fields.recurrenceRule]) && (isNullOrUndefined(event[fields.recurrenceID]) || event[fields.id] === event[fields.recurrenceID])) {\n        dataCol = this.generateOccurrence(event);\n      } else {\n        dataCol.push(event);\n      }\n      for (const data of dataCol) {\n        const filterBlockEvents = this.filterBlockEvents(data);\n        if (filterBlockEvents.length > 0) {\n          isBlockAlert = true;\n          break;\n        }\n      }\n    }\n    this.parent.uiStateValues.isBlock = isBlockAlert;\n    return isBlockAlert;\n  }\n  getFilterEventsList(dataSource, query) {\n    return new DataManager(dataSource).executeLocal(new Query().where(query));\n  }\n  getSeriesEvents(parentEvent, startTime) {\n    const fields = this.parent.eventFields;\n    startTime = isNullOrUndefined(startTime) ? parentEvent[fields.startTime] : startTime;\n    let deleteFutureEditEvents;\n    let futureEvents;\n    const deleteFutureEditEventList = [];\n    let delId = parentEvent[fields.id];\n    let followingId = parentEvent[fields.followingID];\n    let deleteFutureEvent;\n    const startTimeQuery = this.parent.currentAction === 'EditSeries' ? 'greaterthan' : 'greaterthanorequal';\n    do {\n      deleteFutureEvent = new Predicate(fields.followingID, 'equal', delId).and(new Predicate(fields.startTime, startTimeQuery, startTime));\n      futureEvents = this.getFilterEventsList(this.parent.eventsData, deleteFutureEvent);\n      deleteFutureEditEvents = futureEvents.slice(-1)[0];\n      if (!isNullOrUndefined(deleteFutureEditEvents) && deleteFutureEditEvents[fields.id] !== followingId) {\n        deleteFutureEditEventList.push(deleteFutureEditEvents);\n        delId = deleteFutureEditEvents[fields.id];\n        followingId = deleteFutureEditEvents[fields.followingID];\n      } else {\n        followingId = null;\n      }\n    } while (futureEvents.length === 1 && !isNullOrUndefined(deleteFutureEditEvents[fields.followingID]));\n    return deleteFutureEditEventList;\n  }\n  getEditedOccurrences(deleteFutureEditEventList, startTime) {\n    const fields = this.parent.eventFields;\n    let deleteRecurrenceEventList = [];\n    let delEditedEvents;\n    for (const event of deleteFutureEditEventList) {\n      let delEventQuery = new Predicate(fields.recurrenceID, 'equal', event[fields.id]).or(new Predicate(fields.recurrenceID, 'equal', event[fields.followingID]).and(new Predicate(fields.recurrenceID, 'notequal', undefined)).and(new Predicate(fields.recurrenceID, 'notequal', null)));\n      if (this.parent.currentAction === 'EditFollowingEvents' || this.parent.currentAction === 'DeleteFollowingEvents') {\n        delEventQuery = delEventQuery.and(new Predicate(fields.startTime, 'greaterthanorequal', startTime));\n      }\n      delEditedEvents = this.getFilterEventsList(this.parent.eventsData, delEventQuery);\n      deleteRecurrenceEventList = deleteRecurrenceEventList.concat(delEditedEvents);\n    }\n    return deleteRecurrenceEventList;\n  }\n  getRenderedDates(dateRender) {\n    let firstDate = 0;\n    let lastDate = dateRender.length;\n    let filteredDates;\n    if (dateRender[0] < this.parent.minDate && dateRender[dateRender.length - 1] > this.parent.maxDate) {\n      for (let i = 0; i < dateRender.length; i++) {\n        if (resetTime(dateRender[i]).getTime() === resetTime(new Date(this.parent.minDate)).getTime()) {\n          firstDate = i;\n        }\n        if (resetTime(dateRender[i]).getTime() === resetTime(new Date(this.parent.maxDate)).getTime()) {\n          lastDate = i;\n        }\n      }\n      filteredDates = dateRender.filter(date => date >= dateRender[firstDate] && date <= dateRender[lastDate]);\n    }\n    return filteredDates;\n  }\n  isValidEvent(eventObj, start, end, schedule) {\n    const isHourRange = end.getTime() > schedule.startHour.getTime() && start.getTime() < schedule.endHour.getTime();\n    const isSameRange = schedule.startHour.getTime() <= start.getTime() && eventObj[this.parent.eventFields.startTime].getTime() >= schedule.startHour.getTime() && eventObj[this.parent.eventFields.endTime].getTime() < schedule.endHour.getTime() && start.getTime() === end.getTime();\n    return isHourRange || isSameRange;\n  }\n  allDayExpandScroll(dateHeader) {\n    let indentHeight = 0;\n    const headerRows = [].slice.call(this.parent.element.querySelectorAll('.' + HEADER_ROW_CLASS));\n    headerRows.forEach(element => {\n      const tdEle = [].slice.call(element.children);\n      tdEle.forEach(ele => {\n        ele.style.top = indentHeight + 'px';\n      });\n      indentHeight += element.offsetHeight;\n    });\n    indentHeight = dateHeader.offsetHeight - indentHeight;\n    this.parent.element.querySelector('.' + ALLDAY_CELLS_CLASS).style.height = indentHeight / 12 + 'em';\n    if (this.parent.uiStateValues.expand) {\n      addClass([dateHeader], ALLDAY_APPOINTMENT_SCROLL);\n    } else {\n      removeClass([dateHeader], ALLDAY_APPOINTMENT_SCROLL);\n    }\n  }\n  updateEventMinimumDuration(startEndHours, startTime, endTime) {\n    const eventDuration = (getUniversalTime(endTime) - getUniversalTime(startTime)) / MS_PER_MINUTE;\n    if (eventDuration < this.parent.eventSettings.minimumEventDuration) {\n      const tempEnd = new Date(startTime);\n      tempEnd.setMinutes(tempEnd.getMinutes() + this.parent.eventSettings.minimumEventDuration);\n      endTime = tempEnd;\n      if (endTime.getTime() > startEndHours.endHour.getTime()) {\n        const tempStart = new Date(startEndHours.endHour.getTime());\n        tempStart.setMinutes(tempStart.getMinutes() - this.parent.eventSettings.minimumEventDuration);\n        startTime = tempStart;\n        endTime = startEndHours.endHour;\n      }\n    }\n    return {\n      startDate: startTime,\n      endDate: endTime\n    };\n  }\n  unWireEvents() {\n    const appElements = [].slice.call(this.parent.element.querySelectorAll('.' + APPOINTMENT_CLASS));\n    for (const element of appElements) {\n      EventHandler.clearEvents(element);\n    }\n  }\n  destroy() {\n    this.unWireEvents();\n    this.parent = null;\n  }\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Vertical view appointment rendering\n */\nclass VerticalEvent extends EventBase {\n  constructor(parent) {\n    super(parent);\n    this.dateRender = [];\n    this.renderedEvents = [];\n    this.renderedAllDayEvents = [];\n    this.overlapEvents = [];\n    this.moreEvents = [];\n    this.overlapList = [];\n    this.allDayEvents = [];\n    this.slotCount = this.parent.activeViewOptions.timeScale.slotCount;\n    this.interval = this.parent.activeViewOptions.timeScale.interval;\n    this.allDayLevel = 0;\n    this.startHour = this.parent.activeView.getStartHour();\n    this.endHour = this.parent.activeView.getEndHour();\n    this.element = this.parent.activeView.getPanel();\n    this.fields = this.parent.eventFields;\n    this.animation = new Animation({\n      progress: this.animationUiUpdate.bind(this)\n    });\n    this.addEventListener();\n  }\n  renderAppointments() {\n    if (isNullOrUndefined(this.parent)) {\n      return;\n    }\n    if (this.parent.dragAndDropModule) {\n      this.parent.dragAndDropModule.setDragArea();\n    }\n    const wrapperElements = [].slice.call(this.parent.element.querySelectorAll('.' + BLOCK_APPOINTMENT_CLASS + ',.' + APPOINTMENT_CLASS + ',.' + ROW_COUNT_WRAPPER_CLASS));\n    const isDragging = this.parent.crudModule && this.parent.crudModule.crudObj.isCrudAction ? true : false;\n    for (const wrapper of wrapperElements) {\n      if (isDragging && !(wrapper.classList.contains(ALLDAY_APPOINTMENT_CLASS) || wrapper.classList.contains(ROW_COUNT_WRAPPER_CLASS))) {\n        const groupIndex = parseInt(wrapper.getAttribute('data-group-index'), 10);\n        for (let j = 0, len = this.parent.crudModule.crudObj.sourceEvent.length; j < len; j++) {\n          if (groupIndex === this.parent.crudModule.crudObj.sourceEvent[j].groupIndex || groupIndex === this.parent.crudModule.crudObj.targetEvent[j].groupIndex) {\n            remove(wrapper);\n          }\n        }\n      } else {\n        remove(wrapper);\n      }\n    }\n    if (!this.element.querySelector('.' + WORK_CELLS_CLASS)) {\n      return;\n    }\n    this.allDayElement = [].slice.call(this.element.querySelectorAll('.' + ALLDAY_CELLS_CLASS));\n    this.setAllDayRowHeight(0);\n    if (this.parent.eventsProcessed.length === 0 && this.parent.blockProcessed.length === 0) {\n      return;\n    }\n    const expandCollapse = this.element.querySelector('.' + ALLDAY_APPOINTMENT_SECTION_CLASS);\n    EventHandler.remove(expandCollapse, 'click', this.rowExpandCollapse);\n    EventHandler.add(expandCollapse, 'click', this.rowExpandCollapse, this);\n    this.renderedEvents = [];\n    this.renderedAllDayEvents = [];\n    this.initializeValues();\n    this.processBlockEvents();\n    this.renderEvents('normalEvents');\n    if (this.allDayEvents.length > 0) {\n      this.allDayEvents = this.allDayEvents.filter((item, index, arr) => index === arr.map(item => item.Guid).indexOf(item.Guid));\n      removeClass(this.allDayElement, ALLDAY_ROW_ANIMATE_CLASS);\n      this.slots.push(this.parent.activeView.renderDates.map(date => +date));\n      this.renderEvents('allDayEvents');\n    }\n    this.parent.notify(contentReady, {});\n    addClass(this.allDayElement, ALLDAY_ROW_ANIMATE_CLASS);\n    if (isDragging) {\n      this.parent.crudModule.crudObj.isCrudAction = false;\n    }\n    this.parent.renderTemplates();\n  }\n  initializeValues() {\n    this.resources = this.parent.activeViewOptions.group.resources.length > 0 ? this.parent.uiStateValues.isGroupAdaptive ? [this.parent.resourceBase.lastResourceLevel[this.parent.uiStateValues.groupIndex]] : this.parent.resourceBase.lastResourceLevel : [];\n    this.cellHeight = parseFloat(this.parent.element.querySelector('.e-content-wrap tbody tr').getBoundingClientRect().height.toFixed(2));\n    this.dateRender[0] = this.parent.activeView.renderDates;\n    if (this.parent.activeViewOptions.group.resources.length > 0) {\n      for (let i = 0, len = this.resources.length; i < len; i++) {\n        this.dateRender[i] = this.resources[i].renderDates;\n      }\n    }\n  }\n  getHeight(start, end) {\n    let appHeight = (getUniversalTime(end) - getUniversalTime(start)) / MS_PER_MINUTE * (this.cellHeight * this.slotCount) / this.interval;\n    appHeight = appHeight <= 0 ? this.cellHeight : appHeight;\n    return appHeight;\n  }\n  appendEvent(eventObj, appointmentElement, index, appLeft) {\n    const appointmentWrap = [].slice.call(this.element.querySelectorAll('.' + APPOINTMENT_WRAPPER_CLASS));\n    if (this.parent.enableRtl) {\n      setStyleAttribute(appointmentElement, {\n        'right': appLeft\n      });\n    } else {\n      setStyleAttribute(appointmentElement, {\n        'left': appLeft\n      });\n    }\n    const eventType = appointmentElement.classList.contains(BLOCK_APPOINTMENT_CLASS) ? 'blockEvent' : 'event';\n    const args = {\n      data: extend({}, eventObj, null, true),\n      element: appointmentElement,\n      cancel: false,\n      type: eventType\n    };\n    this.parent.trigger(eventRendered, args, eventArgs => {\n      if (!eventArgs.cancel) {\n        appointmentWrap[index].appendChild(appointmentElement);\n      }\n    });\n  }\n  processBlockEvents() {\n    const resources = this.getResourceList();\n    let dateCount = 0;\n    for (const resource of resources) {\n      const renderDates = this.dateRender[resource];\n      for (let day = 0, length = renderDates.length; day < length; day++) {\n        const startDate = new Date(renderDates[day].getTime());\n        const endDate = addDays(renderDates[day], 1);\n        const filterEvents = this.filterEvents(startDate, endDate, this.parent.blockProcessed, this.resources[resource]);\n        for (const event of filterEvents) {\n          if (this.parent.resourceBase) {\n            this.setValues(event, resource);\n          }\n          this.renderBlockEvents(event, day, resource, dateCount);\n          this.cssClass = null;\n          this.groupOrder = null;\n        }\n        dateCount += 1;\n      }\n    }\n  }\n  renderBlockEvents(eventObj, dayIndex, resource, dayCount) {\n    const spannedData = this.isSpannedEvent(eventObj, dayIndex, resource);\n    const eStart = spannedData[this.fields.startTime];\n    const eEnd = spannedData[this.fields.endTime];\n    const currentDate = resetTime(new Date(this.dateRender[resource][dayIndex].getTime()));\n    const schedule = getStartEndHours(currentDate, this.startHour, this.endHour);\n    if (eStart <= eEnd && this.isValidEvent(eventObj, eStart, eEnd, schedule)) {\n      let blockTop;\n      let blockHeight;\n      if (spannedData[this.fields.isAllDay]) {\n        const contentWrap = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS + ' table');\n        blockHeight = formatUnit(contentWrap.offsetHeight);\n        blockTop = formatUnit(0);\n      } else {\n        blockHeight = formatUnit(this.getHeight(eStart, eEnd));\n        blockTop = formatUnit(this.getTopValue(eStart, dayIndex, resource));\n      }\n      const appointmentElement = this.createBlockAppointmentElement(eventObj, resource);\n      setStyleAttribute(appointmentElement, {\n        'width': '100%',\n        'height': blockHeight,\n        'top': blockTop\n      });\n      const index = this.parent.activeViewOptions.group.byDate ? this.resources.length * dayIndex + resource : dayCount;\n      this.appendEvent(eventObj, appointmentElement, index, '0px');\n    }\n  }\n  renderEvents(eventType) {\n    removeClass(this.allDayElement, ALLDAY_ROW_ANIMATE_CLASS);\n    const eventCollection = eventType === 'allDayEvents' ? this.sortByDateTime(this.allDayEvents) : undefined;\n    const resources = this.getResourceList();\n    let dateCount = 0;\n    let isRender;\n    for (const resource of resources) {\n      isRender = true;\n      if (this.parent.crudModule && this.parent.crudModule.crudObj.isCrudAction && eventType !== 'allDayEvents' && !this.parent.uiStateValues.isGroupAdaptive) {\n        if (this.parent.crudModule.crudObj.sourceEvent.filter(data => data.groupIndex === resource).length === 0 && this.parent.crudModule.crudObj.targetEvent.filter(data => data.groupIndex === resource).length === 0) {\n          isRender = false;\n        }\n      }\n      this.slots = [];\n      const renderDates = this.dateRender[resource];\n      const renderedDate = this.getRenderedDates(renderDates) || renderDates;\n      this.slots.push(renderDates.map(date => {\n        return +date;\n      }));\n      for (let day = 0, length = renderDates.length; day < length && renderDates[day] <= renderedDate[renderedDate.length - 1]; day++) {\n        this.renderedEvents = [];\n        const startDate = new Date(renderDates[day].getTime());\n        const endDate = addDays(renderDates[day], 1);\n        const filterEvents = this.filterEvents(startDate, endDate, eventCollection, this.resources[resource]);\n        if (isRender) {\n          for (const event of filterEvents) {\n            if (this.parent.resourceBase) {\n              this.setValues(event, resource);\n            }\n            if (eventType === 'allDayEvents') {\n              this.renderAllDayEvents(event, day, resource, dateCount);\n            } else {\n              if (this.isAllDayAppointment(event)) {\n                this.allDayEvents.push(extend({}, event, null, true));\n              } else {\n                if (this.parent.eventSettings.enableMaxHeight) {\n                  if (this.getOverlapIndex(event, day, false, resource) > 0) {\n                    continue;\n                  }\n                }\n                this.renderNormalEvents(event, day, resource, dateCount);\n              }\n            }\n            this.cssClass = null;\n            this.groupOrder = null;\n          }\n        } else {\n          for (const event of filterEvents) {\n            if (this.isAllDayAppointment(event)) {\n              this.allDayEvents.push(extend({}, event, null, true));\n            }\n          }\n        }\n        dateCount += 1;\n      }\n    }\n  }\n  setValues(event, resourceIndex) {\n    if (this.parent.activeViewOptions.group.resources.length > 0) {\n      this.cssClass = this.resources[resourceIndex].cssClass;\n      this.groupOrder = this.resources[resourceIndex].groupOrder;\n    } else {\n      this.cssClass = this.parent.resourceBase.getCssClass(event);\n    }\n  }\n  getResourceList() {\n    // eslint-disable-next-line prefer-spread\n    const resources = Array.apply(null, {\n      length: this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive ? this.resources.length : 1\n    }).map((value, index) => {\n      return index;\n    });\n    return resources;\n  }\n  // eslint-disable-next-line max-len\n  createAppointmentElement(record, isAllDay, data, resource) {\n    const fieldMapping = this.parent.eventFields;\n    const recordSubject = record[fieldMapping.subject] || this.parent.eventSettings.fields.subject.default || this.parent.localeObj.getConstant('addTitle');\n    const appointmentWrapper = createElement('div', {\n      className: APPOINTMENT_CLASS,\n      attrs: {\n        'data-id': 'Appointment_' + record[fieldMapping.id],\n        'data-guid': record.Guid,\n        'role': 'button',\n        'tabindex': '0',\n        'aria-readonly': this.parent.eventBase.getReadonlyAttribute(record),\n        'aria-selected': 'false',\n        'aria-grabbed': 'true',\n        'aria-label': this.parent.getAnnouncementString(record)\n      }\n    });\n    if (record[this.fields.isReadonly]) {\n      addClass([appointmentWrapper], 'e-read-only');\n    }\n    const appointmentDetails = createElement('div', {\n      className: APPOINTMENT_DETAILS\n    });\n    appointmentWrapper.appendChild(appointmentDetails);\n    if (this.parent.activeViewOptions.group.resources.length > 0) {\n      const resourceIndex = this.parent.uiStateValues.isGroupAdaptive ? this.parent.uiStateValues.groupIndex : resource;\n      appointmentWrapper.setAttribute('data-group-index', resourceIndex.toString());\n    }\n    let templateElement;\n    const eventData = data;\n    if (!isNullOrUndefined(this.parent.activeViewOptions.eventTemplate)) {\n      const elementId = this.parent.element.id + '_';\n      const viewName = this.parent.activeViewOptions.eventTemplateName;\n      const templateId = elementId + viewName + 'eventTemplate';\n      const resIndex = this.parent.uiStateValues.isGroupAdaptive ? this.parent.uiStateValues.groupIndex : resource;\n      const templateName = 'eventTemplate' + (this.parent.activeViewOptions.group.resources.length > 0 ? '_' + resIndex : '');\n      templateElement = this.parent.getAppointmentTemplate()(record, this.parent, templateName, templateId, false);\n    } else {\n      const appointmentSubject = createElement('div', {\n        className: SUBJECT_CLASS,\n        innerHTML: recordSubject\n      });\n      if (isAllDay) {\n        if (record[fieldMapping.isAllDay]) {\n          templateElement = [appointmentSubject];\n        } else {\n          templateElement = [];\n          const appointmentStartTime = createElement('div', {\n            className: APPOINTMENT_TIME + (this.parent.isAdaptive ? ' ' + DISABLE_CLASS : ''),\n            innerHTML: this.parent.getTimeString(record[fieldMapping.startTime])\n          });\n          const appointmentEndTime = createElement('div', {\n            className: APPOINTMENT_TIME + (this.parent.isAdaptive ? ' ' + DISABLE_CLASS : ''),\n            innerHTML: this.parent.getTimeString(record[fieldMapping.endTime])\n          });\n          addClass([appointmentSubject], 'e-text-center');\n          if (!eventData.isLeft) {\n            templateElement.push(appointmentStartTime);\n          }\n          templateElement.push(appointmentSubject);\n          if (!eventData.isRight) {\n            templateElement.push(appointmentEndTime);\n          }\n        }\n      } else {\n        const timeStr = this.parent.getTimeString(record[fieldMapping.startTime]) + ' - ' + this.parent.getTimeString(record[fieldMapping.endTime]);\n        const appointmentTime = createElement('div', {\n          className: APPOINTMENT_TIME + (this.parent.isAdaptive ? ' ' + DISABLE_CLASS : ''),\n          innerHTML: timeStr\n        });\n        const appointmentLocation = createElement('div', {\n          className: LOCATION_CLASS,\n          innerHTML: record[fieldMapping.location] || this.parent.eventSettings.fields.location.default || ''\n        });\n        templateElement = [appointmentSubject, appointmentTime, appointmentLocation];\n      }\n    }\n    append(templateElement, appointmentDetails);\n    if (!this.parent.isAdaptive && (!isNullOrUndefined(record[fieldMapping.recurrenceRule]) || !isNullOrUndefined(record[fieldMapping.recurrenceID]))) {\n      const iconClass = record[fieldMapping.id] === record[fieldMapping.recurrenceID] ? EVENT_RECURRENCE_ICON_CLASS : EVENT_RECURRENCE_EDIT_ICON_CLASS;\n      const recurrenceIcon = createElement('div', {\n        className: ICON + ' ' + iconClass\n      });\n      if (isAllDay) {\n        appointmentDetails.appendChild(recurrenceIcon);\n      } else {\n        appointmentWrapper.appendChild(recurrenceIcon);\n      }\n    }\n    this.renderSpannedIcon(isAllDay ? appointmentDetails : appointmentWrapper, eventData);\n    if (!isNullOrUndefined(this.cssClass)) {\n      addClass([appointmentWrapper], this.cssClass);\n    }\n    this.applyResourceColor(appointmentWrapper, record, 'backgroundColor', this.groupOrder);\n    this.renderResizeHandler(appointmentWrapper, eventData, record[this.fields.isReadonly]);\n    return appointmentWrapper;\n  }\n  createMoreIndicator(allDayRow, count, currentDay) {\n    const index = currentDay + count;\n    const countWrapper = allDayRow[index];\n    if (countWrapper.childElementCount <= 0) {\n      const innerCountWrap = createElement('div', {\n        className: ROW_COUNT_WRAPPER_CLASS,\n        id: ROW_COUNT_WRAPPER_CLASS + '-' + index.toString()\n      });\n      const moreIndicatorElement = createElement('div', {\n        className: MORE_INDICATOR_CLASS,\n        attrs: {\n          'tabindex': '0',\n          'role': 'list',\n          'data-index': index.toString(),\n          'data-count': '1'\n        },\n        innerHTML: '+1&nbsp;' + (this.parent.isAdaptive ? '' : this.parent.localeObj.getConstant('more'))\n      });\n      innerCountWrap.appendChild(moreIndicatorElement);\n      countWrapper.appendChild(innerCountWrap);\n      EventHandler.add(moreIndicatorElement, 'click', this.rowExpandCollapse, this);\n    } else {\n      const countCell = countWrapper.querySelector('.' + MORE_INDICATOR_CLASS);\n      const moreCount = parseInt(countCell.getAttribute('data-count'), 10) + 1;\n      countCell.setAttribute('data-count', moreCount.toString());\n      countCell.innerHTML = '+' + this.parent.globalize.formatNumber(moreCount) + '&nbsp;' + (this.parent.isAdaptive ? '' : this.parent.localeObj.getConstant('more'));\n    }\n  }\n  renderSpannedIcon(element, spanEvent) {\n    const iconElement = createElement('div', {\n      className: EVENT_INDICATOR_CLASS + ' ' + ICON\n    });\n    if (spanEvent.isLeft) {\n      const iconLeft = iconElement.cloneNode();\n      addClass([iconLeft], EVENT_ICON_LEFT_CLASS);\n      prepend([iconLeft], element);\n    }\n    if (spanEvent.isRight) {\n      const iconRight = iconElement.cloneNode();\n      addClass([iconRight], EVENT_ICON_RIGHT_CLASS);\n      append([iconRight], element);\n    }\n    if (spanEvent.isTop) {\n      const iconTop = iconElement.cloneNode();\n      addClass([iconTop], EVENT_ICON_UP_CLASS);\n      prepend([iconTop], element);\n    }\n    if (spanEvent.isBottom) {\n      const iconBottom = iconElement.cloneNode();\n      addClass([iconBottom], EVENT_ICON_DOWN_CLASS);\n      append([iconBottom], element);\n    }\n  }\n  isSpannedEvent(record, day, resource) {\n    let currentDate = resetTime(this.dateRender[resource][day]);\n    const renderedDate = this.getRenderedDates(this.dateRender[resource]) || [currentDate];\n    const currentDay = renderedDate.filter(date => date.getDay() === day);\n    if (currentDay.length === 0) {\n      currentDate = resetTime(renderedDate[0]);\n    }\n    const field = this.parent.eventFields;\n    const schedule = getStartEndHours(currentDate, this.startHour, this.endHour);\n    const event = extend({}, record, null, true);\n    event.isSpanned = {\n      isBottom: false,\n      isTop: false\n    };\n    if (record[field.startTime].getTime() < schedule.startHour.getTime()) {\n      event[field.startTime] = schedule.startHour;\n      event.isSpanned.isTop = true;\n    }\n    if (record[field.endTime].getTime() > schedule.endHour.getTime()) {\n      event[field.endTime] = schedule.endHour;\n      event.isSpanned.isBottom = true;\n    }\n    const eventDates = this.updateEventMinimumDuration(schedule, event[field.startTime], event[field.endTime]);\n    event[field.startTime] = eventDates.startDate;\n    event[field.endTime] = eventDates.endDate;\n    return event;\n  }\n  renderAllDayEvents(eventObj, dayIndex, resource, dayCount, inline) {\n    let currentDates = this.getRenderedDates(this.dateRender[resource]) || this.dateRender[resource];\n    if (this.parent.activeViewOptions.group.byDate) {\n      this.slots[0] = [this.dateRender[resource][dayIndex].getTime()];\n      currentDates = [this.dateRender[resource][dayIndex]];\n    }\n    const record = this.splitEvent(eventObj, currentDates)[0];\n    const allDayRowCell = this.element.querySelector('.' + ALLDAY_CELLS_CLASS + ':first-child');\n    const cellTop = allDayRowCell.offsetTop;\n    const eStart = new Date(record[this.parent.eventFields.startTime].getTime());\n    const eEnd = new Date(record[this.parent.eventFields.endTime].getTime());\n    let appWidth = 0;\n    let topValue = 1;\n    const isDateRange = currentDates[0].getTime() <= eStart.getTime() && addDays(currentDates.slice(-1)[0], 1).getTime() >= eStart.getTime();\n    if (eStart <= eEnd && isDateRange) {\n      let isAlreadyRendered = [];\n      if (this.renderedAllDayEvents[resource]) {\n        isAlreadyRendered = this.renderedAllDayEvents[resource].filter(event => event.Guid === eventObj.Guid);\n        if (this.parent.activeViewOptions.group.byDate) {\n          isAlreadyRendered = isAlreadyRendered.filter(event => event[this.parent.eventFields.startTime] >= currentDates[dayIndex] && event[this.parent.eventFields.endTime] <= addDays(new Date(+currentDates[dayIndex]), 1));\n        }\n      }\n      if (isAlreadyRendered.length === 0) {\n        const allDayDifference = record.data.count;\n        const allDayIndex = this.getOverlapIndex(record, dayIndex, true, resource);\n        record.Index = allDayIndex;\n        this.allDayLevel = this.allDayLevel < allDayIndex ? allDayIndex : this.allDayLevel;\n        const widthAdjustment = record.data.isRight ? 0 : this.parent.currentView === 'Day' ? 4 : 7;\n        if (allDayDifference >= 0) {\n          appWidth = allDayDifference * 100 - widthAdjustment;\n        }\n        if (isNullOrUndefined(this.renderedAllDayEvents[resource])) {\n          this.renderedAllDayEvents[resource] = [];\n        }\n        this.renderedAllDayEvents[resource].push(extend({}, record, null, true));\n        const allDayRow = [].slice.call(this.element.querySelector('.' + ALLDAY_ROW_CLASS).children);\n        const wIndex = this.parent.activeViewOptions.group.byDate ? this.resources.length * dayIndex + resource : dayCount;\n        const eventWrapper = this.element.querySelector('.' + ALLDAY_APPOINTMENT_WRAPPER_CLASS + ':nth-child(' + (wIndex + 1) + ')');\n        let appointmentElement;\n        if (inline) {\n          appointmentElement = this.parent.inlineModule.createInlineAppointmentElement(eventObj);\n        } else {\n          appointmentElement = this.createAppointmentElement(eventObj, true, record.data, resource);\n        }\n        addClass([appointmentElement], ALLDAY_APPOINTMENT_CLASS);\n        const eventData = extend({}, record.data, null, true);\n        eventObj.data = eventData;\n        const args = {\n          data: eventObj,\n          element: appointmentElement,\n          cancel: false\n        };\n        this.parent.trigger(eventRendered, args, eventArgs => {\n          if (!eventArgs.cancel) {\n            eventWrapper.appendChild(appointmentElement);\n            const appHeight = appointmentElement.offsetHeight;\n            topValue += (allDayIndex === 0 ? cellTop : cellTop + allDayIndex * appHeight) + 1;\n            setStyleAttribute(appointmentElement, {\n              'width': appWidth + '%',\n              'top': formatUnit(topValue)\n            });\n            if (allDayIndex > 1) {\n              this.moreEvents.push(appointmentElement);\n              for (let count = 0, length = allDayDifference; count < length; count++) {\n                this.createMoreIndicator(allDayRow, count, wIndex);\n              }\n            }\n            allDayRowCell.setAttribute('data-count', this.allDayLevel.toString());\n            const allDayRowHeight = (!this.parent.uiStateValues.expand && this.allDayLevel > 2 ? 3 * appHeight : (this.allDayLevel + 1) * appHeight) + 4;\n            this.setAllDayRowHeight(allDayRowHeight);\n            this.addOrRemoveClass();\n            this.wireAppointmentEvents(appointmentElement, eventObj);\n          }\n        });\n      }\n    }\n  }\n  renderNormalEvents(eventObj, dayIndex, resource, dayCount, inline) {\n    const record = this.isSpannedEvent(eventObj, dayIndex, resource);\n    const eStart = record[this.fields.startTime];\n    const eEnd = record[this.fields.endTime];\n    let appWidth = '0%';\n    const appLeft = '0%';\n    let topValue = 0;\n    const currentDate = resetTime(new Date(this.dateRender[resource][dayIndex].getTime()));\n    const schedule = getStartEndHours(currentDate, this.startHour, this.endHour);\n    const isValidEvent = this.isValidEvent(eventObj, eStart, eEnd, schedule);\n    if (eStart <= eEnd && isValidEvent) {\n      const appHeight = this.getHeight(eStart, eEnd);\n      if (eStart.getTime() > schedule.startHour.getTime()) {\n        topValue = this.getTopValue(eStart, dayIndex, resource);\n      }\n      const appIndex = this.getOverlapIndex(record, dayIndex, false, resource);\n      record.Index = appIndex;\n      this.overlapList.push(record);\n      if (this.overlapList.length > 1) {\n        if (isNullOrUndefined(this.overlapEvents[appIndex])) {\n          this.overlapEvents[appIndex] = [];\n        }\n        this.overlapEvents[appIndex].push(record);\n      } else {\n        this.overlapEvents = [];\n        this.overlapEvents.push([record]);\n      }\n      appWidth = this.getEventWidth();\n      const argsData = {\n        index: appIndex,\n        left: appLeft,\n        width: appWidth,\n        day: dayIndex,\n        dayIndex: dayCount,\n        record: record,\n        resource: resource\n      };\n      const tempData = this.adjustOverlapElements(argsData);\n      appWidth = tempData.appWidth;\n      if (isNullOrUndefined(this.renderedEvents[resource])) {\n        this.renderedEvents[resource] = [];\n      }\n      this.renderedEvents[resource].push(extend({}, record, null, true));\n      let appointmentElement;\n      if (inline) {\n        appointmentElement = this.parent.inlineModule.createInlineAppointmentElement(eventObj);\n      } else {\n        appointmentElement = this.createAppointmentElement(eventObj, false, record.isSpanned, resource);\n      }\n      setStyleAttribute(appointmentElement, {\n        'width': this.parent.eventSettings.enableMaxHeight ? '100%' : tempData.appWidth,\n        'height': appHeight + 'px',\n        'top': topValue + 'px'\n      });\n      const iconHeight = appointmentElement.querySelectorAll('.' + EVENT_INDICATOR_CLASS).length * 15;\n      const maxHeight = appHeight - 40 - iconHeight;\n      const subjectElement = appointmentElement.querySelector('.' + SUBJECT_CLASS);\n      if (!this.parent.isAdaptive && subjectElement) {\n        subjectElement.style.maxHeight = formatUnit(maxHeight);\n      }\n      const index = this.parent.activeViewOptions.group.byDate ? this.resources.length * dayIndex + resource : dayCount;\n      const eventData = {};\n      eventData[this.fields.startTime] = eventObj[this.fields.startTime];\n      eventData[this.fields.endTime] = eventObj[this.fields.endTime];\n      record.data = eventData;\n      this.appendEvent(record, appointmentElement, index, tempData.appLeft);\n      this.wireAppointmentEvents(appointmentElement, eventObj);\n      if (appHeight < this.cellHeight) {\n        const resizeHandlers = [].slice.call(appointmentElement.querySelectorAll('.' + EVENT_RESIZE_CLASS));\n        resizeHandlers.forEach(resizeHandler => {\n          resizeHandler.style.height = Math.ceil(appHeight / resizeHandler.offsetHeight) + 'px';\n        });\n      }\n    }\n  }\n  getEventWidth() {\n    const width = this.parent.currentView === 'Day' ? 97 : 94;\n    const tempWidth = (width - this.overlapEvents.length) / this.overlapEvents.length;\n    return (tempWidth < 0 ? 0 : tempWidth) + '%';\n  }\n  getEventLeft(appWidth, index) {\n    const tempLeft = (parseFloat(appWidth) + 1) * index;\n    return (tempLeft > 99 ? 99 : tempLeft) + '%';\n  }\n  getTopValue(date, day, resource) {\n    const startEndHours = getStartEndHours(resetTime(this.dateRender[resource][day]), this.startHour, this.endHour);\n    const startHour = startEndHours.startHour;\n    const diffInMinutes = (date.getHours() - startHour.getHours()) * 60 + (date.getMinutes() - startHour.getMinutes());\n    return this.parent.activeViewOptions.timeScale.enable ? diffInMinutes * this.cellHeight * this.slotCount / this.interval : 0;\n  }\n  getOverlapIndex(record, day, isAllDay, resource) {\n    const fieldMapping = this.parent.eventFields;\n    let eventsList = [];\n    let appIndex = -1;\n    this.overlapEvents = [];\n    if (isAllDay) {\n      if (!isNullOrUndefined(this.renderedAllDayEvents[resource])) {\n        const date = resetTime(new Date(this.dateRender[resource][day].getTime()));\n        eventsList = this.renderedAllDayEvents[resource].filter(app => resetTime(app[fieldMapping.startTime]).getTime() <= date.getTime() && resetTime(app[fieldMapping.endTime]).getTime() >= date.getTime());\n        if (this.parent.activeViewOptions.group.resources.length > 0) {\n          eventsList = this.filterEventsByResource(this.resources[resource], eventsList);\n        }\n      }\n    } else {\n      const appointmentList = !isNullOrUndefined(this.renderedEvents[resource]) ? this.renderedEvents[resource] : [];\n      let appointment = [];\n      const recordStart = record[fieldMapping.startTime];\n      const recordEnd = record[fieldMapping.endTime];\n      this.overlapList = appointmentList.filter(data => data[fieldMapping.endTime] > recordStart && data[fieldMapping.startTime] <= recordEnd || data[fieldMapping.startTime] >= recordEnd && data[fieldMapping.endTime] <= recordStart || data[fieldMapping.endTime].getTime() === data[fieldMapping.startTime].getTime() && data[fieldMapping.startTime].getTime() === recordStart.getTime() && data[fieldMapping.endTime] < recordEnd);\n      if (this.parent.activeViewOptions.group.resources.length > 0) {\n        this.overlapList = this.filterEventsByResource(this.resources[resource], this.overlapList);\n      }\n      this.overlapList.forEach(obj => {\n        let filterList = appointmentList.filter(data => data[fieldMapping.endTime] > obj[fieldMapping.startTime] && data[fieldMapping.startTime] <= obj[fieldMapping.endTime]);\n        if (this.parent.activeViewOptions.group.resources.length > 0) {\n          filterList = this.filterEventsByResource(this.resources[resource], filterList);\n        }\n        const collection = filterList.filter(val => this.overlapList.indexOf(val) === -1);\n        if (collection.length > 0) {\n          appointment = appointment.concat(collection);\n        }\n      });\n      for (let i = 0; i < appointment.length - 1; i++) {\n        for (let j = i + 1; j < appointment.length; j++) {\n          if (appointment[i][fieldMapping.id] === appointment[j][fieldMapping.id]) {\n            appointment.splice(j, 1);\n            j--;\n          }\n        }\n      }\n      this.overlapList = this.overlapList.concat(appointment);\n      eventsList = this.overlapList;\n      for (const event of eventsList) {\n        const record = event;\n        const index = record.Index;\n        if (isNullOrUndefined(this.overlapEvents[index])) {\n          this.overlapEvents[index] = [event];\n        } else {\n          this.overlapEvents[index].push(event);\n        }\n      }\n    }\n    if (!isAllDay) {\n      eventsList = eventsList.filter(obj => obj[fieldMapping.startTime] === record[fieldMapping.startTime] && obj[fieldMapping.endTime] > record[fieldMapping.endTime] || obj[fieldMapping.endTime] > record[fieldMapping.startTime] && obj[fieldMapping.startTime] < record[fieldMapping.endTime] || obj[fieldMapping.endTime] === record[fieldMapping.startTime] && obj[fieldMapping.startTime] === record[fieldMapping.endTime] || obj[fieldMapping.startTime].getTime() === record[fieldMapping.startTime].getTime() && obj[fieldMapping.endTime].getTime() === record[fieldMapping.endTime].getTime() || obj[fieldMapping.startTime].getTime() === record[fieldMapping.startTime].getTime() && obj[fieldMapping.endTime].getTime() < record[fieldMapping.endTime].getTime() || obj[fieldMapping.endTime].getTime() > record[fieldMapping.endTime].getTime());\n    }\n    if (eventsList.length > 0) {\n      const appLevel = eventsList.map(obj => obj.Index);\n      appIndex = appLevel.length > 0 ? this.getSmallestMissingNumber(appLevel) : 0;\n    }\n    return appIndex === -1 ? 0 : appIndex;\n  }\n  adjustOverlapElements(args) {\n    const data = {\n      appWidth: args.width,\n      appLeft: args.left\n    };\n    for (let i = 0, length1 = this.overlapEvents.length; i < length1; i++) {\n      if (!isNullOrUndefined(this.overlapEvents[i])) {\n        for (let j = 0, length2 = this.overlapEvents[i].length; j < length2; j++) {\n          const dayCount = this.parent.activeViewOptions.group.byDate ? this.resources.length * args.day + args.resource : args.dayIndex;\n          const element = this.element.querySelector('#e-appointment-wrapper-' + dayCount);\n          if (element.childElementCount > 0) {\n            const eleGuid = this.overlapEvents[i][j].Guid;\n            if (element.querySelectorAll('div[data-guid=\"' + eleGuid + '\"]').length > 0 && eleGuid !== args.record.Guid) {\n              const apps = element.querySelector('div[data-guid=\"' + eleGuid + '\"]');\n              if (parseFloat(args.width) <= parseFloat(apps.style.width)) {\n                if (this.parent.enableRtl) {\n                  apps.style.right = this.getEventLeft(args.width, i);\n                } else {\n                  apps.style.left = this.getEventLeft(args.width, i);\n                }\n                apps.style.width = parseFloat(args.width) + '%';\n                data.appWidth = apps.style.width;\n              } else {\n                data.appWidth = apps.style.width;\n              }\n            } else {\n              let appWidth = args.width;\n              if (isNullOrUndefined(this.overlapEvents[i - 1])) {\n                appWidth = this.getEventWidth();\n              }\n              data.appWidth = appWidth;\n              data.appLeft = this.getEventLeft(appWidth, args.index);\n            }\n          }\n        }\n      }\n    }\n    return data;\n  }\n  setAllDayRowHeight(height) {\n    const dateHeader = this.parent.element.querySelector('.' + DATE_HEADER_WRAP_CLASS);\n    if (this.parent.height === 'auto' || !this.parent.enableAllDayScroll) {\n      addClass([dateHeader], ALLDAY_APPOINTMENT_AUTO);\n    }\n    const allDayRow = this.parent.element.querySelector('.' + ALLDAY_ROW_CLASS);\n    allDayRow.style.height = '';\n    if (this.parent.uiStateValues.expand && this.parent.height !== 'auto' && this.parent.enableAllDayScroll) {\n      allDayRow.style.height = height / 12 + 'em';\n      this.parent.eventBase.allDayExpandScroll(dateHeader);\n    } else {\n      dateHeader.scrollTop = 0;\n      for (const element of this.allDayElement) {\n        element.style.height = height / 12 + 'em';\n      }\n      removeClass([dateHeader], ALLDAY_APPOINTMENT_SCROLL);\n    }\n    this.animation.animate(this.allDayElement[0]);\n  }\n  addOrRemoveClass() {\n    this.moreEvents.filter(element => {\n      if (!this.parent.uiStateValues.expand && this.allDayLevel > 2) {\n        addClass([element], EVENT_COUNT_CLASS);\n        element.setAttribute('tabindex', '-1');\n      } else {\n        removeClass([element], EVENT_COUNT_CLASS);\n        element.setAttribute('tabindex', '0');\n      }\n    });\n    const moreEventCount = this.element.querySelector('.' + ALLDAY_APPOINTMENT_SECTION_CLASS);\n    if (this.parent.uiStateValues.expand) {\n      removeClass([moreEventCount], APPOINTMENT_ROW_EXPAND_CLASS);\n      addClass([moreEventCount], APPOINTMENT_ROW_COLLAPSE_CLASS);\n    } else {\n      removeClass([moreEventCount], APPOINTMENT_ROW_COLLAPSE_CLASS);\n      addClass([moreEventCount], APPOINTMENT_ROW_EXPAND_CLASS);\n    }\n    if (this.allDayLevel > 2) {\n      removeClass([moreEventCount], DISABLE_CLASS);\n    } else {\n      addClass([moreEventCount], DISABLE_CLASS);\n    }\n    const countCell = [].slice.call(this.element.querySelectorAll('.' + ROW_COUNT_WRAPPER_CLASS));\n    countCell.forEach(element => {\n      if (!this.parent.uiStateValues.expand && this.allDayLevel > 2) {\n        removeClass([element], DISABLE_CLASS);\n      } else {\n        addClass([element], DISABLE_CLASS);\n      }\n    });\n  }\n  getEventHeight() {\n    const eventElement = createElement('div', {\n      className: APPOINTMENT_CLASS,\n      styles: 'visibility:hidden'\n    });\n    const eventWrapper = this.element.querySelector('.' + ALLDAY_APPOINTMENT_WRAPPER_CLASS + ':first-child');\n    eventWrapper.appendChild(eventElement);\n    const height = eventElement.offsetHeight;\n    remove(eventElement);\n    return height;\n  }\n  rowExpandCollapse() {\n    const target = this.element.querySelector('.' + ALLDAY_APPOINTMENT_SECTION_CLASS);\n    this.parent.uiStateValues.expand = target.classList.contains(APPOINTMENT_ROW_EXPAND_CLASS);\n    let rowHeight;\n    if (this.parent.uiStateValues.expand) {\n      target.setAttribute('title', this.parent.localeObj.getConstant('collapseAllDaySection'));\n      target.setAttribute('aria-label', 'Collapse section');\n      rowHeight = (this.allDayLevel + 1) * this.getEventHeight() + 4;\n    } else {\n      target.setAttribute('title', this.parent.localeObj.getConstant('expandAllDaySection'));\n      target.setAttribute('aria-label', 'Expand section');\n      rowHeight = 3 * this.getEventHeight() + 4;\n    }\n    this.setAllDayRowHeight(rowHeight);\n    this.addOrRemoveClass();\n    this.animation.animate(target);\n  }\n  animationUiUpdate() {\n    this.parent.notify(contentReady, {});\n  }\n  destroy() {\n    if (!this.parent || this.parent && this.parent.isDestroyed) {\n      return;\n    }\n    this.removeEventListener();\n    this.allDayElement = null;\n    this.renderedAllDayEvents = null;\n    this.renderedEvents = null;\n    this.slotCount = null;\n    this.interval = null;\n    this.startHour = null;\n    this.endHour = null;\n    this.element = null;\n    this.fields = null;\n    this.animation = null;\n    super.destroy();\n  }\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst EVENT_GAP = 0;\n/**\n * Month view events render\n */\nclass MonthEvent extends EventBase {\n  constructor(parent) {\n    super(parent);\n    this.renderedEvents = [];\n    this.monthHeaderHeight = 0;\n    this.moreIndicatorHeight = 19;\n    this.renderType = 'day';\n    this.element = this.parent.activeView.getPanel();\n    this.fields = this.parent.eventFields;\n    this.maxHeight = this.parent.eventSettings.enableMaxHeight && !this.parent.eventSettings.enableIndicator && !this.parent.rowAutoHeight;\n    this.withIndicator = this.parent.eventSettings.enableMaxHeight && this.parent.eventSettings.enableIndicator && !this.parent.rowAutoHeight;\n    this.maxOrIndicator = this.maxHeight || this.withIndicator;\n    this.moreIndicatorHeight = this.parent.rowAutoHeight && this.parent.eventSettings.ignoreWhitespace ? 0 : this.moreIndicatorHeight;\n    this.addEventListener();\n  }\n  removeEventWrapper(appElement) {\n    if (appElement.length > 0) {\n      appElement = this.parent.currentView === 'Month' ? appElement : [appElement[0]];\n      for (const wrap of appElement) {\n        if (!wrap.classList.contains('e-more-indicator') && wrap.parentElement && wrap.parentElement.parentNode) {\n          remove(wrap.parentElement);\n        }\n      }\n    }\n  }\n  renderAppointments() {\n    if (this.parent.dragAndDropModule) {\n      this.parent.dragAndDropModule.setDragArea();\n    }\n    const conWrap = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS);\n    if (this.parent.rowAutoHeight) {\n      this.parent.uiStateValues.top = conWrap.scrollTop;\n      this.parent.uiStateValues.left = conWrap.scrollLeft;\n    }\n    const appointmentWrapper = [].slice.call(this.element.querySelectorAll('.' + APPOINTMENT_WRAPPER_CLASS));\n    if (this.parent.crudModule && this.parent.crudModule.crudObj.isCrudAction) {\n      for (let i = 0, len = this.parent.crudModule.crudObj.sourceEvent.length; i < len; i++) {\n        const appElement = [].slice.call(this.element.querySelectorAll('.e-appointment-wrapper ' + '[data-group-index=\"' + this.parent.crudModule.crudObj.sourceEvent[i].groupIndex + '\"]'));\n        this.removeEventWrapper(appElement);\n        if (this.parent.crudModule.crudObj.targetEvent[i] && this.parent.crudModule.crudObj.sourceEvent[i].groupIndex !== this.parent.crudModule.crudObj.targetEvent[i].groupIndex) {\n          const ele = [].slice.call(this.element.querySelectorAll('.e-appointment-wrapper ' + '[data-group-index=\"' + this.parent.crudModule.crudObj.targetEvent[i].groupIndex + '\"]'));\n          this.removeEventWrapper(ele);\n        }\n      }\n    } else {\n      for (const wrap of appointmentWrapper) {\n        remove(wrap);\n      }\n    }\n    this.removeHeightProperty(CONTENT_TABLE_CLASS);\n    if (!this.element.querySelector('.' + WORK_CELLS_CLASS)) {\n      return;\n    }\n    if (this.parent.currentView === 'Month') {\n      const wrapper = createElement('div', {\n        className: APPOINTMENT_WRAPPER_CLASS\n      });\n      const cellTd = this.parent.element.querySelector('.' + WORK_CELLS_CLASS);\n      cellTd.appendChild(wrapper);\n      this.monthHeaderHeight = wrapper.offsetTop - cellTd.offsetTop;\n      cellTd.removeChild(wrapper);\n    }\n    this.eventHeight = getElementHeightFromClass(this.element, APPOINTMENT_CLASS);\n    const scrollTop = conWrap.scrollTop;\n    if (this.parent.rowAutoHeight && this.parent.virtualScrollModule && !isNullOrUndefined(this.parent.currentAction)) {\n      conWrap.scrollTop = conWrap.scrollTop - 1;\n    }\n    if (this.parent.activeViewOptions.group.resources.length > 0) {\n      this.renderResourceEvents();\n      if (this.parent.virtualScrollModule) {\n        this.parent.virtualScrollModule.updateFocusedWorkCell();\n      }\n    } else {\n      this.renderEventsHandler(this.parent.activeView.renderDates, this.parent.activeViewOptions.workDays);\n    }\n    if (this.parent.rowAutoHeight) {\n      this.updateBlockElements();\n      const data = {\n        cssProperties: this.parent.getCssProperties(),\n        module: this.parent.getModuleName(),\n        isPreventScrollUpdate: true,\n        scrollPosition: {\n          left: this.parent.uiStateValues.left,\n          top: this.parent.uiStateValues.top\n        }\n      };\n      if (this.parent.virtualScrollModule) {\n        if (this.parent.currentAction) {\n          conWrap.scrollTop = scrollTop;\n          this.parent.currentAction = null;\n        } else {\n          this.parent.virtualScrollModule.updateVirtualScrollHeight();\n        }\n      }\n      if (!this.parent.enablePersistence) {\n        this.parent.notify(contentReady, {});\n      }\n      this.parent.notify(scrollUiUpdate, data);\n      if (this.parent.currentView === 'Month' && this.parent.showWeekNumber) {\n        const totalCells = [].slice.call(this.parent.element.querySelectorAll('.e-content-wrap table tr td:first-child'));\n        const weekNumberCells = [].slice.call(this.parent.element.querySelectorAll('.' + WEEK_NUMBER_CLASS));\n        weekNumberCells.forEach((cell, i) => {\n          const height = totalCells[i].offsetHeight;\n          setStyleAttribute(cell, {\n            'height': height + 'px'\n          });\n        });\n        this.parent.element.querySelector('.' + WEEK_NUMBER_WRAPPER_CLASS).scrollTop = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS).scrollTop;\n      }\n    }\n    this.parent.renderTemplates();\n  }\n  renderEventsHandler(dateRender, workDays, resData) {\n    this.renderedEvents = [];\n    let eventsList;\n    let blockList;\n    let resIndex = 0;\n    if (resData) {\n      resIndex = resData.groupIndex;\n      this.cssClass = resData.cssClass;\n      this.groupOrder = resData.groupOrder;\n      eventsList = this.parent.eventBase.filterEventsByResource(resData, this.parent.eventsProcessed);\n      blockList = this.parent.eventBase.filterEventsByResource(resData, this.parent.blockProcessed);\n      this.workCells = [].slice.call(this.element.querySelectorAll('.' + WORK_CELLS_CLASS + '[data-group-index=\"' + resIndex + '\"]'));\n    } else {\n      eventsList = this.parent.eventsProcessed;\n      blockList = this.parent.blockProcessed;\n      this.workCells = [].slice.call(this.element.querySelectorAll('.' + WORK_CELLS_CLASS));\n    }\n    this.sortByDateTime(eventsList);\n    this.sortByDateTime(blockList);\n    if (this.parent.currentView === 'Month' && this.parent.rowAutoHeight && this.parent.activeViewOptions.group.resources.length === 0) {\n      const totalCells = [].slice.call(this.parent.element.querySelectorAll('.e-content-wrap table tr td:first-child'));\n      const height = this.parent.height === 'auto' ? (this.parent.element.querySelector('.e-content-wrap').clientHeight + this.parent.element.querySelector('.e-date-header-wrap').clientHeight) / totalCells.length : this.parent.element.querySelector('.e-schedule-table').clientHeight / totalCells.length;\n      totalCells.forEach(cell => {\n        setStyleAttribute(cell, {\n          'height': height + 'px'\n        });\n      });\n    }\n    const cellDetail = this.workCells[this.parent.activeView.isTimelineView() ? 0 : this.workCells.length - 1].getBoundingClientRect();\n    this.cellWidth = cellDetail.width;\n    this.cellHeight = cellDetail.height;\n    this.dateRender = dateRender;\n    const filteredDates = this.getRenderedDates(dateRender);\n    this.getSlotDates(workDays || this.parent.activeViewOptions.workDays);\n    this.processBlockEvents(blockList, resIndex, resData);\n    for (const event of eventsList) {\n      if (this.parent.resourceBase && !resData) {\n        this.cssClass = this.parent.resourceBase.getCssClass(event);\n      }\n      const spannedEvents = this.splitEvent(event, filteredDates || this.dateRender);\n      for (const event of spannedEvents) {\n        if (this.maxHeight) {\n          const sDate = this.parent.currentView === 'Month' ? event[this.fields.startTime] : this.getStartTime(event, event.data);\n          if (this.getIndex(sDate) > 0) {\n            continue;\n          }\n        }\n        this.updateIndicatorIcon(event);\n        this.renderEvents(event, resIndex, eventsList);\n      }\n    }\n    this.cssClass = null;\n    this.groupOrder = null;\n  }\n  processBlockEvents(blockEvents, resIndex, resData) {\n    for (const event of blockEvents) {\n      if (this.parent.resourceBase && !resData) {\n        this.cssClass = this.parent.resourceBase.getCssClass(event);\n      }\n      const blockSpannedList = [];\n      if (this.renderType === 'day' && !event[this.fields.isAllDay]) {\n        const temp = extend({}, event, null, true);\n        let isSameDate = this.isSameDate(temp[this.fields.startTime], temp[this.fields.endTime]);\n        temp.isBlockIcon = isSameDate;\n        if (!isSameDate && getDateInMs(temp[this.fields.startTime]) > 0) {\n          const e = extend({}, event, null, true);\n          e[this.fields.endTime] = addDays(resetTime(new Date(event[this.fields.startTime] + '')), 1);\n          e.isBlockIcon = true;\n          temp[this.fields.startTime] = e[this.fields.endTime];\n          blockSpannedList.push(e);\n        }\n        isSameDate = this.isSameDate(temp[this.fields.startTime], temp[this.fields.endTime]);\n        if (!isSameDate && getDateInMs(temp[this.fields.endTime]) > 0) {\n          const e = extend({}, event, null, true);\n          e[this.fields.startTime] = resetTime(new Date(event[this.fields.endTime] + ''));\n          e.isBlockIcon = true;\n          blockSpannedList.push(e);\n          temp[this.fields.endTime] = e[this.fields.startTime];\n        }\n        blockSpannedList.push(temp);\n      } else {\n        blockSpannedList.push(event);\n      }\n      for (const blockEvent of blockSpannedList) {\n        const spannedEvents = this.splitEvent(blockEvent, this.dateRender);\n        for (const event of spannedEvents) {\n          this.renderBlockEvents(event, resIndex, !!blockEvent.isBlockIcon);\n        }\n      }\n    }\n  }\n  isSameDate(start, end) {\n    return new Date(+start).setHours(0, 0, 0, 0) === new Date(+end).setHours(0, 0, 0, 0);\n  }\n  renderBlockEvents(event, resIndex, isIcon) {\n    const eventData = event.data;\n    const startTime = this.getStartTime(event, eventData);\n    const endTime = this.getEndTime(event, eventData);\n    const day = this.parent.getIndexOfDate(this.dateRender, resetTime(new Date(startTime.getTime())));\n    if (day < 0 || startTime > endTime) {\n      return;\n    }\n    const cellTd = this.getCellTd(day);\n    const position = this.getPosition(startTime, endTime, event[this.fields.isAllDay], day);\n    if (!isIcon) {\n      const diffInDays = eventData.count;\n      let appWidth = this.getEventWidth(startTime, endTime, event[this.fields.isAllDay], diffInDays);\n      appWidth = appWidth <= 0 ? this.cellWidth : appWidth;\n      const appLeft = this.parent.enableRtl ? 0 : position;\n      const appRight = this.parent.enableRtl ? position : 0;\n      const appHeight = this.cellHeight - this.monthHeaderHeight;\n      const appTop = this.getRowTop(resIndex);\n      const blockElement = this.createBlockAppointmentElement(event, resIndex);\n      setStyleAttribute(blockElement, {\n        'width': appWidth + 'px',\n        'height': appHeight + 'px',\n        'left': appLeft + 'px',\n        'right': appRight + 'px',\n        'top': appTop + 'px'\n      });\n      this.renderEventElement(event, blockElement, cellTd);\n    } else {\n      this.renderBlockIndicator(cellTd, position, resIndex);\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  renderBlockIndicator(cellTd, position, resIndex) {\n    const blockIndicator = createElement('div', {\n      className: 'e-icons ' + BLOCK_INDICATOR_CLASS\n    });\n    if (isNullOrUndefined(cellTd.querySelector('.' + BLOCK_INDICATOR_CLASS))) {\n      cellTd.appendChild(blockIndicator);\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  getStartTime(event, eventData) {\n    return event[this.fields.startTime];\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  getEndTime(event, eventData) {\n    return event[this.fields.endTime];\n  }\n  getCellTd(day) {\n    return this.workCells[day];\n  }\n  getEventWidth(startDate, endDate, isAllDay, count) {\n    return count * this.cellWidth - 1;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  getPosition(startTime, endTime, isAllDay, day) {\n    return 0;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  getRowTop(resIndex) {\n    return 0;\n  }\n  updateIndicatorIcon(event) {\n    if (this.parent.currentView.indexOf('Timeline') === -1 || this.parent.currentView === 'TimelineMonth' || event[this.fields.isAllDay]) {\n      return;\n    }\n    const cloneData = event.data;\n    const start = this.parent.activeView.getStartHour();\n    const end = this.parent.activeView.getEndHour();\n    const startHour = getStartEndHours(event[this.fields.startTime], start, end);\n    const endHour = getStartEndHours(event[this.fields.endTime], start, end);\n    const actualStartTime = cloneData[this.fields.startTime];\n    const actualEndTime = cloneData[this.fields.endTime];\n    cloneData.isLeft = cloneData.isLeft || actualStartTime.getTime() < startHour.startHour.getTime();\n    cloneData.isRight = cloneData.isRight || actualEndTime.getTime() > endHour.endHour.getTime();\n    if (resetTime(actualStartTime).getTime() !== resetTime(actualEndTime).getTime()) {\n      const actualStartHour = startHour.startHour;\n      const actualEndHour = endHour.endHour;\n      const startTime = new Date(resetTime(actualStartTime));\n      startTime.setHours(actualEndHour.getHours(), actualEndHour.getMinutes(), actualEndHour.getSeconds());\n      cloneData.isLeft = cloneData.isLeft || actualStartTime.getTime() >= (actualStartHour.getDate() === startHour.endHour.getDate() ? startTime.getTime() : addDays(startTime, 1).getTime());\n      if (actualEndTime.getTime() !== resetTime(actualEndTime).getTime()) {\n        const endTime = new Date(resetTime(actualEndTime));\n        cloneData.isRight = cloneData.isRight || actualEndTime.getTime() <= endTime.setHours(actualStartHour.getHours(), actualStartHour.getMinutes(), actualStartHour.getSeconds());\n      }\n    }\n  }\n  renderResourceEvents() {\n    const resources = this.parent.uiStateValues.isGroupAdaptive ? [this.parent.resourceBase.lastResourceLevel[this.parent.uiStateValues.groupIndex]] : this.parent.resourceBase.lastResourceLevel;\n    if (this.parent.crudModule && this.parent.crudModule.crudObj.isCrudAction) {\n      for (let i = 0, len = this.parent.crudModule.crudObj.sourceEvent.length; i < len; i++) {\n        const sourceRes = this.parent.crudModule.crudObj.sourceEvent[i];\n        this.renderEventsHandler(sourceRes.renderDates, sourceRes.workDays, sourceRes);\n        if (this.parent.crudModule.crudObj.sourceEvent[i].groupIndex !== this.parent.crudModule.crudObj.targetEvent[i].groupIndex) {\n          const target = this.parent.crudModule.crudObj.targetEvent[i];\n          this.renderEventsHandler(target.renderDates, target.workDays, target);\n        }\n      }\n      this.parent.crudModule.crudObj.isCrudAction = false;\n    } else {\n      for (const slotData of resources) {\n        this.renderEventsHandler(slotData.renderDates, slotData.workDays, slotData);\n      }\n    }\n  }\n  getSlotDates(workDays) {\n    this.slots = [];\n    const dates = this.dateRender.map(date => {\n      return +date;\n    });\n    const noOfDays = this.parent.activeViewOptions.showWeekend ? WEEK_LENGTH : workDays.length;\n    while (dates.length > 0) {\n      this.slots.push(dates.splice(0, noOfDays));\n    }\n  }\n  createAppointmentElement(record, resIndex, isCloneElement = false) {\n    const eventSubject = record[this.fields.subject] || this.parent.eventSettings.fields.subject.default || this.parent.localeObj.getConstant('addTitle');\n    const newRecord = extend({}, record, record.data, true);\n    const attrs = {\n      'data-id': 'Appointment_' + record[this.fields.id],\n      'role': 'button',\n      'tabindex': '0',\n      'aria-readonly': this.parent.eventBase.getReadonlyAttribute(record),\n      'aria-selected': 'false',\n      'aria-grabbed': 'true',\n      'aria-label': this.parent.getAnnouncementString(newRecord, eventSubject)\n    };\n    if (!isCloneElement) {\n      attrs['data-guid'] = record.Guid;\n    }\n    if (this.parent.activeViewOptions.group.resources.length > 0) {\n      attrs['data-group-index'] = resIndex.toString();\n    }\n    const appointmentWrapper = createElement('div', {\n      className: APPOINTMENT_CLASS,\n      attrs: attrs\n    });\n    if (!isNullOrUndefined(this.cssClass)) {\n      addClass([appointmentWrapper], this.cssClass);\n    }\n    if (record[this.fields.isReadonly]) {\n      addClass([appointmentWrapper], 'e-read-only');\n    }\n    const appointmentDetails = createElement('div', {\n      className: APPOINTMENT_DETAILS\n    });\n    appointmentWrapper.appendChild(appointmentDetails);\n    let templateElement;\n    const eventData = record.data;\n    const eventObj = this.getEventData(record);\n    if (!isNullOrUndefined(this.parent.activeViewOptions.eventTemplate)) {\n      const scheduleId = this.parent.element.id + '_';\n      const viewName = this.parent.activeViewOptions.eventTemplateName;\n      const templateId = scheduleId + viewName + 'eventTemplate';\n      const eventTemplate = 'eventTemplate' + (this.parent.activeViewOptions.group.resources.length > 0 ? '_' + resIndex : '');\n      templateElement = this.parent.getAppointmentTemplate()(eventObj, this.parent, eventTemplate, templateId, false);\n    } else {\n      const eventLocation = record[this.fields.location] || this.parent.eventSettings.fields.location.default || '';\n      const appointmentSubject = createElement('div', {\n        className: SUBJECT_CLASS,\n        innerHTML: eventSubject + (eventLocation ? ';&nbsp' + eventLocation : '')\n      });\n      const appointmentStartTime = createElement('div', {\n        className: APPOINTMENT_TIME + (this.parent.isAdaptive ? ' ' + DISABLE_CLASS : ''),\n        innerHTML: this.parent.getTimeString(eventData[this.fields.startTime])\n      });\n      const appointmentEndTime = createElement('div', {\n        className: APPOINTMENT_TIME + (this.parent.isAdaptive ? ' ' + DISABLE_CLASS : ''),\n        innerHTML: this.parent.getTimeString(eventData[this.fields.endTime])\n      });\n      if (this.parent.currentView === 'Month') {\n        if (record[this.fields.isAllDay]) {\n          templateElement = [appointmentSubject];\n          addClass([appointmentSubject], 'e-text-center');\n        } else if (eventData.count <= 1 && !eventData.isLeft && !eventData.isRight) {\n          templateElement = [appointmentStartTime, appointmentSubject];\n        } else {\n          templateElement = [];\n          addClass([appointmentSubject], 'e-text-center');\n          if (!eventData.isLeft) {\n            templateElement.push(appointmentStartTime);\n          }\n          templateElement.push(appointmentSubject);\n          if (!eventData.isRight) {\n            templateElement.push(appointmentEndTime);\n          }\n        }\n      } else {\n        let innerElement;\n        if (record[this.fields.isAllDay]) {\n          const allDayString = createElement('div', {\n            className: APPOINTMENT_TIME,\n            innerHTML: this.parent.localeObj.getConstant('allDay')\n          });\n          innerElement = [appointmentSubject, allDayString];\n        } else {\n          const timeString = this.parent.getTimeString(eventData[this.fields.startTime]) + ' - ' + this.parent.getTimeString(eventData[this.fields.endTime]);\n          const appTime = createElement('div', {\n            className: APPOINTMENT_TIME + (this.parent.isAdaptive ? ' ' + DISABLE_CLASS : ''),\n            innerHTML: timeString\n          });\n          const appLocation = createElement('div', {\n            className: LOCATION_CLASS,\n            innerHTML: eventLocation\n          });\n          innerElement = [appointmentSubject, appTime, appLocation];\n        }\n        const wrap = createElement('div', {\n          className: 'e-inner-wrap'\n        });\n        append(innerElement, wrap);\n        templateElement = [wrap];\n      }\n    }\n    append(templateElement, appointmentDetails);\n    this.appendEventIcons(record, appointmentDetails);\n    this.renderResizeHandler(appointmentWrapper, record.data, record[this.fields.isReadonly]);\n    return appointmentWrapper;\n  }\n  appendEventIcons(record, appointmentDetails) {\n    const eventData = record.data;\n    if (!isNullOrUndefined(record[this.fields.recurrenceRule]) || !isNullOrUndefined(record[this.fields.recurrenceID])) {\n      const iconClass = record[this.fields.id] === record[this.fields.recurrenceID] ? EVENT_RECURRENCE_ICON_CLASS : EVENT_RECURRENCE_EDIT_ICON_CLASS;\n      appointmentDetails.appendChild(createElement('div', {\n        className: ICON + ' ' + iconClass + (this.parent.isAdaptive ? ' ' + DISABLE_CLASS : '')\n      }));\n    }\n    if (eventData.isLeft) {\n      const iconLeft = createElement('div', {\n        className: EVENT_INDICATOR_CLASS + ' ' + ICON + ' ' + EVENT_ICON_LEFT_CLASS\n      });\n      prepend([iconLeft], appointmentDetails);\n    }\n    if (eventData.isRight) {\n      const iconRight = createElement('div', {\n        className: EVENT_INDICATOR_CLASS + ' ' + ICON + ' ' + EVENT_ICON_RIGHT_CLASS\n      });\n      append([iconRight], appointmentDetails);\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  renderEvents(event, resIndex, eventsList) {\n    const startTime = event[this.fields.startTime];\n    const endTime = event[this.fields.endTime];\n    const day = this.parent.getIndexOfDate(this.dateRender, resetTime(startTime));\n    if (day < 0) {\n      return;\n    }\n    if (startTime.getTime() < this.parent.minDate.getTime() || endTime.getTime() > this.parent.maxDate.getTime()) {\n      return;\n    }\n    const overlapCount = this.getIndex(startTime);\n    event.Index = overlapCount;\n    let appHeight = this.eventHeight;\n    this.renderedEvents.push(extend({}, event, null, true));\n    const diffInDays = event.data.count;\n    if (startTime.getTime() <= endTime.getTime()) {\n      const appWidth = diffInDays * this.cellWidth - 5;\n      const cellTd = this.workCells[day];\n      const appTop = overlapCount * (appHeight + EVENT_GAP);\n      const height = this.monthHeaderHeight + (overlapCount + 1) * (appHeight + EVENT_GAP) + this.moreIndicatorHeight;\n      const enableAppRender = this.maxOrIndicator ? overlapCount < 1 ? true : false : this.cellHeight > height;\n      if (this.parent.rowAutoHeight || enableAppRender) {\n        let appointmentElement;\n        if (this.inlineValue) {\n          appointmentElement = this.parent.inlineModule.createInlineAppointmentElement();\n        } else {\n          appointmentElement = this.createAppointmentElement(event, resIndex);\n        }\n        this.applyResourceColor(appointmentElement, event, 'backgroundColor', this.groupOrder);\n        this.wireAppointmentEvents(appointmentElement, event);\n        setStyleAttribute(appointmentElement, {\n          'width': appWidth + 'px',\n          'top': appTop + 'px'\n        });\n        this.renderEventElement(event, appointmentElement, cellTd);\n        if (this.parent.rowAutoHeight) {\n          const firstChild = cellTd.parentElement.firstElementChild;\n          this.updateCellHeight(firstChild, height);\n        }\n      } else {\n        for (let i = 0; i < diffInDays; i++) {\n          const cellTd = this.workCells[day + i];\n          if (cellTd && isNullOrUndefined(cellTd.querySelector('.' + MORE_INDICATOR_CLASS))) {\n            const startDate = new Date(this.dateRender[day + i].getTime());\n            const endDate = addDays(this.dateRender[day + i], 1);\n            const groupIndex = cellTd.getAttribute('data-group-index');\n            const filterEvents = this.getFilteredEvents(startDate, endDate, groupIndex);\n            const appArea = this.cellHeight - this.monthHeaderHeight - this.moreIndicatorHeight;\n            appHeight = this.withIndicator ? appArea : appHeight;\n            const renderedAppCount = Math.floor(appArea / (appHeight + EVENT_GAP));\n            const count = filterEvents.length - renderedAppCount <= 0 ? 1 : filterEvents.length - renderedAppCount;\n            const moreIndicatorElement = this.getMoreIndicatorElement(count, startDate, endDate);\n            if (!isNullOrUndefined(groupIndex)) {\n              moreIndicatorElement.setAttribute('data-group-index', groupIndex);\n            }\n            moreIndicatorElement.style.top = appArea + 'px';\n            moreIndicatorElement.style.width = this.cellWidth - 2 + 'px';\n            this.renderElement(cellTd, moreIndicatorElement);\n            EventHandler.add(moreIndicatorElement, 'click', this.moreIndicatorClick, this);\n          }\n        }\n      }\n    }\n  }\n  updateCellHeight(cell, height) {\n    if (height > cell.offsetHeight) {\n      setStyleAttribute(cell, {\n        'height': height + 'px'\n      });\n    }\n  }\n  updateBlockElements() {\n    const blockElement = [].slice.call(this.element.querySelectorAll('.' + BLOCK_APPOINTMENT_CLASS));\n    for (const element of blockElement) {\n      const target = closest(element, 'tr');\n      this.monthHeaderHeight = element.offsetParent.offsetTop - target.offsetTop;\n      element.style.height = target.offsetHeight - 1 - this.monthHeaderHeight + 'px';\n      const firstChild = target.firstElementChild;\n      const width = Math.round(element.offsetWidth / firstChild.offsetWidth);\n      element.style.width = firstChild.offsetWidth * width + 'px';\n    }\n  }\n  // eslint-disable-next-line max-len\n  getFilteredEvents(startDate, endDate, groupIndex, eventsList) {\n    let filteredEvents;\n    if (isNullOrUndefined(groupIndex)) {\n      filteredEvents = this.filterEvents(startDate, endDate);\n    } else {\n      const data = this.parent.resourceBase.lastResourceLevel[parseInt(groupIndex, 10)];\n      filteredEvents = this.filterEvents(startDate, endDate, isNullOrUndefined(eventsList) ? undefined : eventsList, data);\n    }\n    return filteredEvents;\n  }\n  getOverlapEvents(date, appointments) {\n    const appointmentsList = [];\n    for (const app of appointments) {\n      const dateTime = resetTime(date).getTime();\n      if (resetTime(app[this.fields.startTime]).getTime() <= dateTime && resetTime(app[this.fields.endTime]).getTime() >= dateTime) {\n        appointmentsList.push(app);\n      }\n    }\n    return appointmentsList;\n  }\n  getIndex(date) {\n    let appIndex = -1;\n    const appointments = this.renderedEvents;\n    if (appointments.length > 0) {\n      const appointmentsList = this.getOverlapEvents(date, appointments);\n      const appLevel = appointmentsList.map(obj => obj.Index);\n      appIndex = appLevel.length > 0 ? this.getSmallestMissingNumber(appLevel) : 0;\n    }\n    return appIndex === -1 ? 0 : appIndex;\n  }\n  moreIndicatorClick(event) {\n    const target = closest(event.target, '.' + MORE_INDICATOR_CLASS);\n    const startDate = new Date(parseInt(target.getAttribute('data-start-date'), 10));\n    const endDate = new Date(parseInt(target.getAttribute('data-end-date'), 10));\n    const groupIndex = target.getAttribute('data-group-index');\n    const moreArgs = {\n      cancel: false,\n      event: event,\n      element: target,\n      isPopupOpen: true,\n      startTime: startDate,\n      endTime: endDate,\n      viewName: this.parent.getNavigateView()\n    };\n    if (groupIndex) {\n      moreArgs.groupIndex = parseInt(groupIndex, 10);\n    }\n    this.parent.trigger(moreEventsClick, moreArgs, clickArgs => {\n      if (!clickArgs.cancel) {\n        if (clickArgs.isPopupOpen) {\n          const filteredEvents = this.getFilteredEvents(startDate, endDate, groupIndex);\n          const moreArgs = {\n            date: startDate,\n            event: filteredEvents,\n            element: event.target\n          };\n          this.parent.quickPopup.moreEventClick(moreArgs, endDate, groupIndex);\n        } else {\n          this.parent.setProperties({\n            selectedDate: startDate\n          }, true);\n          this.parent.changeView(clickArgs.viewName, event);\n        }\n      }\n    });\n  }\n  renderEventElement(event, appointmentElement, cellTd) {\n    const eventType = appointmentElement.classList.contains(BLOCK_APPOINTMENT_CLASS) ? 'blockEvent' : 'event';\n    const isAppointment = appointmentElement.classList.contains(APPOINTMENT_CLASS);\n    const eventObj = this.getEventData(event);\n    const args = {\n      data: eventObj,\n      element: appointmentElement,\n      cancel: false,\n      type: eventType\n    };\n    this.parent.trigger(eventRendered, args, eventArgs => {\n      if (eventArgs.cancel) {\n        this.renderedEvents.pop();\n      } else {\n        this.renderElement(cellTd, appointmentElement, isAppointment);\n      }\n    });\n  }\n  getEventData(event) {\n    const eventObj = extend({}, event, null, true);\n    eventObj[this.fields.startTime] = event.data[this.fields.startTime];\n    eventObj[this.fields.endTime] = event.data[this.fields.endTime];\n    return eventObj;\n  }\n  renderElement(cellTd, element, isAppointment = false) {\n    if (this.maxOrIndicator && isAppointment) {\n      this.setMaxEventHeight(element, cellTd);\n    }\n    const wrapperEle = cellTd.querySelector('.' + APPOINTMENT_WRAPPER_CLASS);\n    if (wrapperEle) {\n      wrapperEle.appendChild(element);\n    } else {\n      const wrapper = createElement('div', {\n        className: APPOINTMENT_WRAPPER_CLASS\n      });\n      wrapper.appendChild(element);\n      cellTd.appendChild(wrapper);\n    }\n  }\n  getMoreIndicatorElement(count, startDate, endDate) {\n    const moreIndicatorElement = createElement('div', {\n      className: MORE_INDICATOR_CLASS,\n      innerHTML: '+' + this.parent.globalize.formatNumber(count) + '&nbsp;' + (this.parent.isAdaptive ? '' : this.parent.localeObj.getConstant('more')),\n      attrs: {\n        'tabindex': '0',\n        'data-start-date': startDate.getTime().toString(),\n        'data-end-date': endDate.getTime().toString(),\n        'role': 'list'\n      }\n    });\n    return moreIndicatorElement;\n  }\n  removeHeightProperty(selector) {\n    const rows = [].slice.call(this.element.querySelectorAll('.' + selector + ' tbody tr'));\n    for (const row of rows) {\n      row.firstElementChild.style.height = '';\n    }\n  }\n  setMaxEventHeight(event, cell) {\n    const headerHeight = getOuterHeight(cell.querySelector('.' + DATE_HEADER_CLASS));\n    const height = cell.offsetHeight - headerHeight - (this.maxHeight ? 0 : this.moreIndicatorHeight);\n    setStyleAttribute(event, {\n      'height': height + 'px',\n      'align-items': 'center'\n    });\n  }\n  destroy() {\n    this.element = null;\n    this.fields = null;\n    this.maxHeight = null;\n    this.withIndicator = null;\n    this.maxOrIndicator = null;\n    this.moreIndicatorHeight = null;\n    this.removeEventListener();\n    super.destroy();\n  }\n}\n\n/* eslint-disable max-len */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst EVENT_GAP$1 = 2;\nconst BLOCK_INDICATOR_WIDTH = 22;\nconst BLOCK_INDICATOR_HEIGHT = 18;\n/**\n * Timeline view events render\n */\nclass TimelineEvent extends MonthEvent {\n  constructor(parent, type) {\n    super(parent);\n    this.startHour = this.parent.activeView.getStartHour();\n    this.endHour = this.parent.activeView.getEndHour();\n    this.slotCount = this.parent.activeViewOptions.timeScale.slotCount;\n    this.interval = this.parent.activeViewOptions.timeScale.interval;\n    this.day = 0;\n    this.rowIndex = 0;\n    this.cellTops = [];\n    this.renderType = type;\n    this.eventContainers = [].slice.call(this.element.querySelectorAll('.' + APPOINTMENT_CONTAINER_CLASS));\n    const tr = [].slice.call(this.element.querySelectorAll('.' + CONTENT_TABLE_CLASS + ' tbody tr'));\n    this.dayLength = tr.length === 0 ? 0 : tr[0].children.length;\n    this.content = this.parent.element.querySelector('.' + CONTENT_TABLE_CLASS);\n  }\n  getSlotDates() {\n    this.slots = [];\n    this.slots.push(this.parent.activeView.renderDates.map(date => {\n      return +date;\n    }));\n    if (this.parent.activeViewOptions.headerRows.length > 0 && this.parent.activeViewOptions.headerRows.slice(-1)[0].option !== 'Hour') {\n      this.renderType = 'day';\n      this.cellWidth = this.content.offsetWidth / this.dateRender.length;\n      this.slotsPerDay = 1;\n    } else {\n      this.slotsPerDay = this.dayLength / this.dateRender.length;\n    }\n  }\n  getOverlapEvents(date, appointments) {\n    const appointmentsList = [];\n    if (this.renderType === 'day') {\n      for (const app of appointments) {\n        if (resetTime(app[this.fields.startTime]).getTime() <= resetTime(new Date(date.getTime())).getTime() && resetTime(app[this.fields.endTime]).getTime() >= resetTime(new Date(date.getTime())).getTime()) {\n          appointmentsList.push(app);\n        }\n      }\n    } else {\n      for (const app of appointments) {\n        const eventData = app.data;\n        if (eventData.trimStartTime.getTime() <= date.getTime() && eventData.trimEndTime.getTime() > date.getTime()) {\n          appointmentsList.push(app);\n        }\n      }\n    }\n    return appointmentsList;\n  }\n  getSortComparerIndex(startDate, endDate) {\n    let appIndex = -1;\n    const appointments = this.renderedEvents;\n    if (appointments.length > 0) {\n      const appointmentsList = this.getOverlapSortComparerEvents(startDate, endDate, appointments);\n      const appLevel = appointmentsList.map(obj => obj.Index);\n      appIndex = appLevel.length > 0 ? this.getSmallestMissingNumber(appLevel) : 0;\n    }\n    return appIndex === -1 ? 0 : appIndex;\n  }\n  getOverlapSortComparerEvents(startDate, endDate, appointmentsCollection) {\n    const appointments = [];\n    for (const app of appointmentsCollection) {\n      if (this.renderType === 'day') {\n        if (resetTime(app[this.fields.startTime]).getTime() <= resetTime(new Date(startDate.getTime())).getTime() && resetTime(app[this.fields.endTime]).getTime() >= resetTime(new Date(startDate.getTime())).getTime()) {\n          appointments.push(app);\n        }\n      } else {\n        const eventData = app.data;\n        if (eventData.trimStartTime.getTime() <= startDate.getTime() && startDate.getTime() < eventData.trimEndTime.getTime() || startDate.getTime() <= eventData.trimStartTime.getTime() && eventData.trimStartTime.getTime() < endDate.getTime()) {\n          appointments.push(app);\n        }\n      }\n    }\n    return appointments;\n  }\n  renderResourceEvents() {\n    this.removeHeightProperty(RESOURCE_COLUMN_TABLE_CLASS);\n    const resources = this.parent.uiStateValues.isGroupAdaptive ? [this.parent.resourceBase.lastResourceLevel[this.parent.uiStateValues.groupIndex]] : this.parent.resourceBase.renderedResources;\n    if (this.parent.crudModule && this.parent.crudModule.crudObj.isCrudAction) {\n      for (let i = 0, len = this.parent.crudModule.crudObj.sourceEvent.length; i < len; i++) {\n        const source = this.parent.crudModule.crudObj.sourceEvent[i];\n        this.rowIndex = source.groupIndex;\n        this.renderEventsHandler(this.parent.activeView.renderDates, this.parent.activeViewOptions.workDays, source);\n        if (this.parent.crudModule.crudObj.targetEvent[i] && this.parent.crudModule.crudObj.sourceEvent[i].groupIndex !== this.parent.crudModule.crudObj.targetEvent[i].groupIndex) {\n          const target = this.parent.crudModule.crudObj.targetEvent[i];\n          this.rowIndex = target.groupIndex;\n          this.renderEventsHandler(this.parent.activeView.renderDates, this.parent.activeViewOptions.workDays, target);\n        }\n      }\n      this.parent.crudModule.crudObj.isCrudAction = false;\n    } else {\n      for (let i = 0; i < resources.length; i++) {\n        this.rowIndex = i;\n        this.renderEventsHandler(this.parent.activeView.renderDates, this.parent.activeViewOptions.workDays, resources[i]);\n      }\n    }\n  }\n  renderEvents(event, resIndex, appointmentsList) {\n    let startTime = event[this.fields.startTime];\n    let endTime = event[this.fields.endTime];\n    if (startTime.getTime() < this.parent.minDate.getTime() || endTime.getTime() > this.parent.maxDate.getTime()) {\n      return;\n    }\n    const eventData = event.data;\n    startTime = this.getStartTime(event, eventData);\n    endTime = this.getEndTime(event, eventData);\n    const startEndHours = getStartEndHours(event[this.fields.startTime], this.startHour, this.endHour);\n    const eventDates = this.updateEventMinimumDuration(startEndHours, startTime, endTime);\n    startTime = eventDates.startDate;\n    endTime = eventDates.endDate;\n    this.day = this.parent.getIndexOfDate(this.dateRender, resetTime(new Date(startTime.getTime())));\n    if (this.day < 0) {\n      return;\n    }\n    const cellTd = this.getCellTd();\n    const overlapCount = isNullOrUndefined(this.parent.eventSettings.sortComparer) ? this.getIndex(startTime) : this.getSortComparerIndex(startTime, endTime);\n    event.Index = overlapCount;\n    const appHeight = this.eventHeight;\n    const diffInDays = eventData.count;\n    const eventObj = extend({}, event, null, true);\n    eventObj[this.fields.startTime] = eventData[this.fields.startTime];\n    eventObj[this.fields.endTime] = eventData[this.fields.endTime];\n    const currentDate = resetTime(new Date(this.dateRender[this.day].getTime()));\n    const schedule = getStartEndHours(currentDate, this.startHour, this.endHour);\n    const isValidEvent = this.isValidEvent(eventObj, startTime, endTime, schedule);\n    if (startTime <= endTime && isValidEvent) {\n      let appWidth = this.getEventWidth(startTime, endTime, event[this.fields.isAllDay], diffInDays);\n      appWidth = this.renderType === 'day' ? appWidth - 2 : appWidth;\n      let appLeft = 0;\n      let appRight = 0;\n      const position = this.getPosition(startTime, endTime, event[this.fields.isAllDay], this.day);\n      appWidth = appWidth <= 0 ? this.cellWidth : appWidth; // appWidth 0 when start and end time as same\n      this.renderedEvents.push(extend({}, event, null, true));\n      if (isNullOrUndefined(this.cellTops[resIndex])) {\n        this.cellTops[resIndex] = this.getRowTop(resIndex);\n      }\n      const top = this.cellTops[resIndex];\n      const appTop = top + (this.maxHeight ? 0 : EVENT_GAP$1) + overlapCount * (appHeight + EVENT_GAP$1);\n      appLeft = this.parent.enableRtl ? 0 : position;\n      appRight = this.parent.enableRtl ? position : 0;\n      const height = (overlapCount + 1) * (appHeight + EVENT_GAP$1) + this.moreIndicatorHeight;\n      const renderApp = this.maxOrIndicator ? overlapCount < 1 ? true : false : this.cellHeight > height;\n      if (this.parent.rowAutoHeight || renderApp) {\n        let appointmentElement;\n        if (isNullOrUndefined(this.inlineValue)) {\n          appointmentElement = this.createAppointmentElement(event, resIndex);\n        } else {\n          appointmentElement = this.parent.inlineModule.createInlineAppointmentElement();\n        }\n        this.applyResourceColor(appointmentElement, event, 'backgroundColor', this.groupOrder);\n        setStyleAttribute(appointmentElement, {\n          'width': appWidth + 'px',\n          'left': appLeft + 'px',\n          'right': appRight + 'px',\n          'top': appTop + 'px'\n        });\n        this.wireAppointmentEvents(appointmentElement, event);\n        this.renderEventElement(event, appointmentElement, cellTd);\n        if (this.parent.rowAutoHeight) {\n          const firstChild = this.getFirstChild(resIndex);\n          this.updateCellHeight(firstChild, height);\n        }\n        if (this.parent.activeViewOptions.option !== 'TimelineMonth' && this.parent.activeViewOptions.timeScale.enable && appWidth < this.cellWidth) {\n          const resizeHandlers = [].slice.call(appointmentElement.querySelectorAll('.' + EVENT_RESIZE_CLASS));\n          resizeHandlers.forEach(resizeHandler => {\n            resizeHandler.style.width = Math.ceil(appWidth / resizeHandler.getBoundingClientRect().width) + 'px';\n          });\n        }\n      } else {\n        for (let i = 0; i < diffInDays; i++) {\n          const moreIndicator = cellTd.querySelector('.' + MORE_INDICATOR_CLASS);\n          let appPos = this.parent.enableRtl ? appRight : appLeft;\n          appPos = Math.floor(appPos / this.cellWidth) * this.cellWidth;\n          const interval = this.interval / this.slotCount;\n          let startDate = this.parent.activeViewOptions.option === 'TimelineMonth' || this.renderType === 'day' || i !== 0 ? new Date(this.dateRender[this.day + i].getTime()) : new Date(startTime);\n          let endDate = addDays(this.dateRender[this.day + i], 1);\n          if (this.parent.activeViewOptions.option === 'TimelineMonth' || this.renderType === 'day') {\n            const position = this.getPosition(startDate, endDate, event[this.fields.isAllDay], this.day + i);\n            this.renderTimelineMoreIndicator(startTime, startDate, endDate, appHeight, interval, resIndex, appointmentsList, top, appLeft, appRight, cellTd, moreIndicator, appPos, position);\n          } else {\n            const slotCount = (getUniversalTime(endTime) - getUniversalTime(startTime)) / MS_PER_MINUTE * this.slotCount / this.interval;\n            for (let k = 0; k < slotCount; k++) {\n              startDate = k === 0 ? new Date(startDate.getTime()) : new Date(startDate.getTime() + 60000 * interval);\n              endDate = new Date(startDate.getTime() + 60000 * interval);\n              if (endDate.getTime() > endTime.getTime()) {\n                break;\n              }\n              const position = this.getPosition(startDate, endDate, false, this.day + i);\n              if (appPos > position) {\n                break;\n              }\n              appPos = position;\n              this.renderTimelineMoreIndicator(startTime, startDate, endDate, appHeight, interval, resIndex, appointmentsList, top, appLeft, appRight, cellTd, moreIndicator, appPos, position);\n            }\n          }\n        }\n      }\n    }\n    this.parent.renderTemplates();\n  }\n  renderTimelineMoreIndicator(startTime, startDate, endDate, appHeight, interval, resIndex, appointmentsList, top, appLeft, appRight, cellTd, moreIndicator, appPos, position) {\n    appLeft = this.parent.enableRtl ? appRight = position : position;\n    appPos = this.parent.enableRtl ? appRight : appLeft;\n    appPos = Math.floor(appPos / this.cellWidth) * this.cellWidth;\n    if (cellTd && isNullOrUndefined(moreIndicator) || !this.isAlreadyAvail(appPos, cellTd)) {\n      const startDateTime = this.parent.activeViewOptions.option === 'TimelineMonth' || this.renderType === 'day' ? new Date(+startTime) : startDate;\n      const slotStartTime = new Date(startDateTime.setMinutes(Math.floor(startDateTime.getMinutes() / interval) * interval));\n      const slotEndTime = new Date(slotStartTime.getTime() + 60000 * interval);\n      let groupIndex;\n      if (this.parent.activeViewOptions.group.resources.length > 0 && !isNullOrUndefined(resIndex)) {\n        groupIndex = resIndex.toString();\n      }\n      const filterEvents = this.getFilterEvents(startDate, endDate, slotStartTime, slotEndTime, groupIndex, appointmentsList);\n      const appArea = this.cellHeight - this.moreIndicatorHeight;\n      appHeight = this.withIndicator ? appArea - EVENT_GAP$1 : appHeight;\n      const renderedAppCount = Math.floor(appArea / (appHeight + EVENT_GAP$1));\n      const count = filterEvents.length - renderedAppCount <= 0 ? 1 : filterEvents.length - renderedAppCount;\n      let moreIndicatorElement;\n      if (this.renderType === 'day') {\n        moreIndicatorElement = this.getMoreIndicatorElement(count, startDate, endDate);\n      } else {\n        moreIndicatorElement = this.getMoreIndicatorElement(count, slotStartTime, slotEndTime);\n      }\n      if (!isNullOrUndefined(groupIndex)) {\n        moreIndicatorElement.setAttribute('data-group-index', groupIndex);\n      }\n      moreIndicatorElement.style.top = top + appArea + 'px';\n      moreIndicatorElement.style.width = this.cellWidth + 'px';\n      moreIndicatorElement.style.left = Math.floor(appLeft / this.cellWidth) * this.cellWidth + 'px';\n      moreIndicatorElement.style.right = Math.floor(appRight / this.cellWidth) * this.cellWidth + 'px';\n      this.renderElement(cellTd, moreIndicatorElement);\n      EventHandler.add(moreIndicatorElement, 'click', this.moreIndicatorClick, this);\n    }\n  }\n  updateCellHeight(cell, height) {\n    if (height > this.cellHeight) {\n      setStyleAttribute(cell, {\n        'height': height + 'px'\n      });\n      if (this.parent.activeViewOptions.group.resources.length > 0) {\n        const resourceCell = this.parent.element.querySelector('.' + RESOURCE_COLUMN_TABLE_CLASS + ' ' + 'tbody td[data-group-index=\"' + cell.getAttribute('data-group-index') + '\"]');\n        if (resourceCell) {\n          setStyleAttribute(resourceCell, {\n            'height': height + 'px'\n          });\n        }\n      }\n      const monthHeader = this.parent.element.querySelector('.e-month-header-wrapper table tr:nth-child(' + (cell.parentElement.rowIndex + 1) + ') td');\n      if (monthHeader) {\n        setStyleAttribute(monthHeader, {\n          'height': height + 'px'\n        });\n      }\n    }\n  }\n  getFirstChild(index) {\n    const query = '.' + CONTENT_TABLE_CLASS + ' tbody td';\n    let groupIndex = '';\n    if (this.parent.activeViewOptions.group.resources.length > 0) {\n      groupIndex = '[data-group-index=\"' + index.toString() + '\"]';\n    }\n    const td = this.parent.element.querySelector(query + groupIndex);\n    return td;\n  }\n  updateBlockElements() {\n    const blockElement = [].slice.call(this.element.querySelectorAll('.' + BLOCK_APPOINTMENT_CLASS));\n    for (const element of blockElement) {\n      const resIndex = parseInt(element.getAttribute('data-group-index'), 10);\n      const firstChild = this.getFirstChild(resIndex);\n      element.style.height = firstChild.offsetHeight + 'px';\n      const width = Math.round(element.offsetWidth / firstChild.offsetWidth);\n      element.style.width = firstChild.offsetWidth * width + 'px';\n    }\n    const blockIndicator = [].slice.call(this.element.querySelectorAll('.' + BLOCK_INDICATOR_CLASS));\n    for (const element of blockIndicator) {\n      const resIndex = parseInt(element.getAttribute('data-group-index'), 10);\n      element.style.top = this.getRowTop(resIndex) + this.getFirstChild(resIndex).offsetHeight - BLOCK_INDICATOR_HEIGHT + 'px';\n    }\n  }\n  getStartTime(event, eventData) {\n    let startTime = event[this.fields.startTime];\n    const schedule = getStartEndHours(startTime, this.startHour, this.endHour);\n    if (schedule.startHour.getTime() >= eventData[this.fields.startTime]) {\n      startTime = schedule.startHour;\n    } else if (schedule.endHour.getTime() <= eventData[this.fields.startTime]) {\n      startTime = this.getNextDay(schedule.startHour, eventData);\n    } else {\n      startTime = eventData[this.fields.startTime];\n    }\n    // To overcome the overflow\n    eventData.trimStartTime = event[this.fields.isAllDay] ? schedule.startHour : eventData[this.fields.startTime];\n    return startTime;\n  }\n  getNextDay(startTime, eventData) {\n    let startDate;\n    for (let i = 1; i <= this.dateRender.length; i++) {\n      startDate = addDays(startTime, i);\n      if (this.parent.getIndexOfDate(this.dateRender, resetTime(new Date(startTime.getTime()))) !== -1) {\n        eventData.count = eventData.count - 1;\n        return startDate;\n      }\n    }\n    return startDate;\n  }\n  getEndTime(event, eventData) {\n    let endTime = event[this.fields.endTime];\n    const schedule = getStartEndHours(endTime, this.startHour, this.endHour);\n    if (this.parent.currentView === 'TimelineMonth' || !this.parent.activeViewOptions.timeScale.enable || this.parent.activeViewOptions.headerRows.length > 0 && this.parent.activeViewOptions.headerRows.slice(-1)[0].option !== 'Hour') {\n      endTime = eventData[this.fields.endTime];\n    } else {\n      endTime = eventData[this.fields.endTime];\n      if (schedule.endHour.getTime() <= eventData[this.fields.endTime]) {\n        endTime = schedule.endHour;\n      }\n      if (schedule.startHour.getTime() >= eventData[this.fields.endTime].getTime() && !event.isAllDay) {\n        endTime = this.getPreviousDay(schedule.startHour, schedule.endHour, eventData);\n      }\n    }\n    // To overcome the overflow\n    eventData.trimEndTime = event[this.fields.isAllDay] ? schedule.endHour : eventData[this.fields.endTime];\n    return endTime;\n  }\n  getPreviousDay(startTime, endTime, eventData) {\n    for (let i = 1; i <= this.dateRender.length; i++) {\n      let endDate = addDays(endTime, -i);\n      if (this.parent.getIndexOfDate(this.dateRender, resetTime(new Date(startTime.getTime()))) !== -1) {\n        endDate = resetTime(new Date(endDate.getTime()));\n        endDate.setHours(endTime.getHours(), endTime.getMinutes(), endTime.getSeconds());\n        const count = eventData.count;\n        const actualEndTime = eventData[this.fields.endTime];\n        eventData.count = actualEndTime.getHours() !== 0 || actualEndTime.getMinutes() !== 0 ? count - 1 : count;\n        return endDate;\n      }\n    }\n    return eventData[this.fields.endTime];\n  }\n  getEventWidth(startDate, endDate, isAllDay, count) {\n    if (this.renderType === 'day' || isAllDay) {\n      return count * this.slotsPerDay * this.cellWidth;\n    }\n    if (this.isSameDay(startDate, endDate)) {\n      return this.getSameDayEventsWidth(startDate, endDate);\n    } else {\n      return this.getSpannedEventsWidth(startDate, endDate, count);\n    }\n  }\n  getSameDayEventsWidth(startDate, endDate) {\n    return (getUniversalTime(endDate) - getUniversalTime(startDate)) / MS_PER_MINUTE * (this.cellWidth * this.slotCount) / this.interval;\n  }\n  getSpannedEventsWidth(startDate, endDate, diffInDays) {\n    const width = diffInDays * this.slotsPerDay * this.cellWidth;\n    let endWidth;\n    const start = getStartEndHours(resetTime(new Date(startDate.getTime())), this.startHour, this.endHour);\n    const startWidth = this.getSameDayEventsWidth(start.startHour, startDate);\n    if (this.parent.getIndexOfDate(this.dateRender, resetTime(new Date(endDate.getTime()))) === -1) {\n      endWidth = 0;\n    } else {\n      const end = getStartEndHours(resetTime(new Date(endDate.getTime())), this.startHour, this.endHour);\n      endWidth = this.getSameDayEventsWidth(endDate, end.endHour);\n      endWidth = this.slotsPerDay * this.cellWidth === endWidth ? 0 : endWidth;\n    }\n    const spannedWidth = startWidth + endWidth;\n    return width > spannedWidth ? width - spannedWidth : width - startWidth;\n  }\n  isSameDay(startTime, endTime) {\n    const startDay = this.parent.getIndexOfDate(this.dateRender, resetTime(new Date(startTime.getTime())));\n    const endDay = this.parent.getIndexOfDate(this.dateRender, resetTime(new Date(endTime.getTime())));\n    return startDay === endDay;\n  }\n  getAppointmentLeft(schedule, startTime, day) {\n    const slotTd = this.isSameDay(startTime, schedule.startHour) ? (getUniversalTime(startTime) - getUniversalTime(schedule.startHour)) / (MS_PER_MINUTE * this.interval) * this.slotCount : 0;\n    if (day === 0) {\n      return slotTd;\n    } else {\n      const daySlot = Math.round((getUniversalTime(schedule.endHour) - getUniversalTime(schedule.startHour)) / MS_PER_MINUTE / this.interval * this.slotCount);\n      return daySlot * day + slotTd;\n    }\n  }\n  getPosition(startTime, endTime, isAllDay, day) {\n    if (this.renderType === 'day' || isAllDay) {\n      return day * this.slotsPerDay * this.cellWidth;\n    }\n    const currentDate = resetTime(new Date(this.dateRender[day].getTime()));\n    const schedule = getStartEndHours(currentDate, this.startHour, this.endHour);\n    let cellIndex;\n    if (schedule.endHour.getTime() <= endTime.getTime() && schedule.startHour.getTime() >= startTime.getTime()) {\n      cellIndex = this.getAppointmentLeft(schedule, schedule.startHour, day);\n    } else if (schedule.endHour.getTime() <= endTime.getTime()) {\n      cellIndex = this.getAppointmentLeft(schedule, startTime, day);\n    } else if (schedule.startHour.getTime() >= startTime.getTime()) {\n      cellIndex = this.getAppointmentLeft(schedule, schedule.startHour, day);\n    } else {\n      cellIndex = this.getAppointmentLeft(schedule, startTime, day);\n    }\n    return cellIndex * this.cellWidth;\n  }\n  getFilterEvents(startDate, endDate, startTime, endTime, gIndex, eventsList) {\n    if (this.renderType === 'day') {\n      return this.getFilteredEvents(startDate, endDate, gIndex, eventsList);\n    } else {\n      return this.getFilteredEvents(startTime, endTime, gIndex, eventsList);\n    }\n  }\n  isAlreadyAvail(appPos, cellTd) {\n    const moreIndicator = [].slice.call(cellTd.querySelectorAll('.' + MORE_INDICATOR_CLASS));\n    for (let i = 0; i < moreIndicator.length; i++) {\n      let indicatorPos;\n      if (moreIndicator) {\n        indicatorPos = this.parent.enableRtl ? moreIndicator[i].style.right : moreIndicator[i].style.left;\n      }\n      if (parseInt(indicatorPos, 10) === Math.floor(appPos)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  getRowTop(resIndex) {\n    if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {\n      return this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS + ' ' + 'tbody td[data-group-index=\"' + resIndex.toString() + '\"]').offsetTop;\n    }\n    return 0;\n  }\n  getCellTd() {\n    const wrapIndex = this.parent.uiStateValues.isGroupAdaptive ? 0 : this.rowIndex;\n    return this.eventContainers[wrapIndex];\n  }\n  renderBlockIndicator(cellTd, position, resIndex) {\n    // No need to render block icon for Year, Month and Week header rows\n    if (this.parent.headerRows.length > 0 && (this.parent.headerRows[this.parent.headerRows.length - 1].option !== 'Hour' || this.parent.headerRows[this.parent.headerRows.length - 1].option !== 'Date')) {\n      return;\n    }\n    position = Math.floor(position / this.cellWidth) * this.cellWidth + this.cellWidth - BLOCK_INDICATOR_WIDTH;\n    if (!this.isAlreadyAvail(position, cellTd)) {\n      const blockIndicator = createElement('div', {\n        className: 'e-icons ' + BLOCK_INDICATOR_CLASS\n      });\n      if (this.parent.activeViewOptions.group.resources.length > 0) {\n        blockIndicator.setAttribute('data-group-index', resIndex.toString());\n      }\n      if (this.parent.enableRtl) {\n        blockIndicator.style.right = position + 'px';\n      } else {\n        blockIndicator.style.left = position + 'px';\n      }\n      blockIndicator.style.top = this.getRowTop(resIndex) + this.cellHeight - BLOCK_INDICATOR_HEIGHT + 'px';\n      this.renderElement(cellTd, blockIndicator);\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  setMaxEventHeight(event, cell) {\n    setStyleAttribute(event, {\n      'height': this.cellHeight - (this.maxHeight ? 0 : EVENT_GAP$1) - (this.maxHeight ? 0 : this.moreIndicatorHeight) + 'px'\n    });\n  }\n  destroy() {\n    this.renderType = null;\n    this.eventContainers = null;\n    this.dayLength = null;\n    this.content = null;\n    super.destroy();\n    this.parent = null;\n  }\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Inline Edit interactions\n */\nclass InlineEdit {\n  constructor(parent) {\n    this.parent = parent;\n    this.parent.on(inlineClick, this.inlineEdit, this);\n  }\n  inlineEdit(args) {\n    if (this.parent.quickPopup) {\n      this.parent.quickPopup.quickPopupHide();\n    }\n    if (args.type === 'Cell') {\n      const moreWrapper = this.parent.element.querySelector('.' + MORE_POPUP_WRAPPER_CLASS);\n      if (moreWrapper && moreWrapper.classList.contains(POPUP_OPEN)) {\n        this.parent.quickPopup.morePopup.hide();\n      }\n      this.removeInlineAppointmentElement();\n      this.cellEdit(args);\n    } else {\n      if (this.parent.element.querySelector('.' + INLINE_SUBJECT_CLASS) !== args.element.querySelector('.' + INLINE_SUBJECT_CLASS)) {\n        this.removeInlineAppointmentElement();\n      }\n      this.eventEdit(args);\n    }\n  }\n  cellEdit(args) {\n    const saveObj = this.generateEventData();\n    let cellIndex = args.element.cellIndex;\n    let count = this.getEventDaysCount(saveObj);\n    if (count > 1) {\n      count = Math.round(count);\n      count--;\n      cellIndex = cellIndex - count;\n    }\n    const start = resetTime(new Date('' + saveObj[this.parent.eventFields.startTime])).getTime();\n    const end = resetTime(new Date('' + saveObj[this.parent.eventFields.endTime])).getTime();\n    const resIndex = args.groupIndex || 0;\n    if (this.parent.currentView === 'Day' || this.parent.currentView === 'Week' || this.parent.currentView === 'WorkWeek') {\n      const dayIndex = saveObj[this.parent.eventFields.startTime].getDay();\n      this.createVerticalViewInline(saveObj, dayIndex, resIndex, cellIndex);\n    } else if (this.parent.currentView === 'Month') {\n      this.createMonthViewInline(saveObj, resIndex, start, end);\n    } else {\n      this.createTimelineViewInline(saveObj, start, end, resIndex);\n    }\n    const inlineSubject = this.parent.element.querySelector('.' + INLINE_SUBJECT_CLASS);\n    if (inlineSubject) {\n      inlineSubject.focus();\n    }\n  }\n  eventEdit(args) {\n    let inlineSubject = args.element.querySelector('.' + INLINE_SUBJECT_CLASS);\n    let subject;\n    if (inlineSubject) {\n      subject = inlineSubject.value;\n    } else {\n      const subEle = args.element.querySelector('.' + SUBJECT_CLASS);\n      const timeEle = args.element.querySelector('.' + APPOINTMENT_TIME);\n      subject = subEle.innerText;\n      inlineSubject = createElement('input', {\n        className: INLINE_SUBJECT_CLASS,\n        attrs: {\n          value: subject\n        }\n      });\n      addClass([subEle], DISABLE_CLASS);\n      if (closest(args.element, '.' + MORE_POPUP_WRAPPER_CLASS)) {\n        args.element.insertBefore(inlineSubject, subEle);\n      } else if (['Agenda', 'MonthAgenda'].indexOf(this.parent.currentView) > -1) {\n        const subjectWrap = args.element.querySelector('.' + SUBJECT_WRAP);\n        subjectWrap.insertBefore(inlineSubject, subjectWrap.firstChild);\n      } else {\n        const elementSelector = ['TimelineDay', 'TimelineWeek', 'TimelineWorkWeek', 'TimelineMonth'].indexOf(this.parent.currentView) > -1 ? '.e-inner-wrap' : '.e-appointment-details';\n        args.element.querySelector(elementSelector).insertBefore(inlineSubject, timeEle);\n      }\n      inlineSubject.focus();\n    }\n    inlineSubject.setSelectionRange(subject.length, subject.length);\n  }\n  createVerticalViewInline(saveObj, dayIndex, resIndex, daysCount) {\n    const count = this.getEventDaysCount(saveObj);\n    const verticalEvent = new VerticalEvent(this.parent);\n    verticalEvent.initializeValues();\n    const index = verticalEvent.dateRender[resIndex].map(date => date.getDay()).indexOf(dayIndex);\n    if (count >= 1) {\n      verticalEvent.allDayElement = [].slice.call(this.parent.element.querySelectorAll('.' + ALLDAY_CELLS_CLASS));\n      verticalEvent.slots.push(...this.parent.activeView.renderDates.map(date => +date));\n      const allDayElements = [].slice.call(this.parent.element.querySelectorAll('.' + ALLDAY_APPOINTMENT_CLASS));\n      let allDayLevel = 0;\n      if (allDayElements.length > 0) {\n        allDayLevel = Math.floor(this.parent.element.querySelector('.' + ALLDAY_ROW_CLASS).getBoundingClientRect().height / allDayElements[0].offsetHeight) - 1;\n      }\n      verticalEvent.allDayLevel = allDayLevel;\n      verticalEvent.renderAllDayEvents(saveObj, index, resIndex, daysCount, this.parent.allowInline);\n    } else {\n      verticalEvent.renderNormalEvents(saveObj, index, resIndex, daysCount, this.parent.allowInline);\n    }\n  }\n  createMonthViewInline(saveObj, index, start, end) {\n    const count = this.getEventDaysCount(saveObj);\n    const saveObject = this.parent.eventBase.cloneEventObject(saveObj, start, end, count, false, false);\n    const monthEvent = new MonthEvent(this.parent);\n    monthEvent.dateRender = this.parent.activeView.renderDates;\n    monthEvent.inlineValue = this.parent.allowInline;\n    let renderDates = this.parent.activeView.renderDates;\n    let workDays = this.parent.activeViewOptions.workDays;\n    let monthCellSelector = '.' + WORK_CELLS_CLASS;\n    if (this.parent.activeViewOptions.group.resources.length > 0) {\n      monthCellSelector += '[data-group-index=\"' + index + '\"]';\n      const resourceData = this.parent.resourceBase.lastResourceLevel[index];\n      renderDates = resourceData.renderDates;\n      workDays = resourceData.workDays;\n    }\n    monthEvent.workCells = [].slice.call(this.parent.element.querySelectorAll(monthCellSelector));\n    monthEvent.cellWidth = monthEvent.workCells[0].offsetWidth;\n    monthEvent.cellHeight = monthEvent.workCells[0].offsetHeight;\n    monthEvent.eventHeight = getElementHeightFromClass(this.parent.monthModule.element, APPOINTMENT_CLASS);\n    monthEvent.getSlotDates(workDays);\n    const filteredDates = monthEvent.getRenderedDates(renderDates);\n    const spannedEvents = monthEvent.splitEvent(saveObject, filteredDates || renderDates);\n    for (const eventData of spannedEvents) {\n      monthEvent.renderEvents(eventData, index);\n    }\n    const inlineSubject = this.parent.element.querySelector('.' + INLINE_SUBJECT_CLASS);\n    inlineSubject.focus();\n  }\n  createTimelineViewInline(saveObj, start, end, resIndex) {\n    const count = this.getEventDaysCount(saveObj);\n    const saveObject = this.parent.eventBase.cloneEventObject(saveObj, start, end, count, false, false);\n    const timelineView = new TimelineEvent(this.parent, this.parent.activeViewOptions.timeScale.enable ? 'hour' : 'day');\n    timelineView.dateRender = this.parent.activeView.renderDates;\n    timelineView.eventContainers = [].slice.call(this.parent.element.querySelectorAll('.' + APPOINTMENT_CONTAINER_CLASS));\n    const workCell = this.parent.element.querySelector('.' + WORK_CELLS_CLASS);\n    timelineView.inlineValue = this.parent.allowInline;\n    timelineView.cellWidth = workCell.offsetWidth;\n    timelineView.cellHeight = workCell.offsetHeight;\n    const dayLength = this.parent.element.querySelectorAll('.' + CONTENT_TABLE_CLASS + ' tbody tr').length === 0 ? 0 : this.parent.element.querySelectorAll('.' + CONTENT_TABLE_CLASS + ' tbody tr')[0].children.length;\n    timelineView.slotsPerDay = dayLength / timelineView.dateRender.length;\n    timelineView.eventHeight = getElementHeightFromClass(timelineView.element, APPOINTMENT_CLASS);\n    timelineView.renderEvents(saveObject, resIndex);\n  }\n  getEventDaysCount(saveObj) {\n    const startDate = saveObj[this.parent.eventFields.startTime];\n    const endDate = saveObj[this.parent.eventFields.endTime];\n    const daysCount = Math.abs(endDate.getTime() - startDate.getTime()) / MS_PER_DAY;\n    return daysCount;\n  }\n  generateEventData(target) {\n    const inlineElement = this.parent.element.querySelector('.' + INLINE_SUBJECT_CLASS);\n    const subject = inlineElement ? inlineElement.value : target ? target.innerHTML : '';\n    const saveObj = {};\n    saveObj[this.parent.eventFields.id] = this.parent.eventBase.getEventMaxID();\n    saveObj[this.parent.eventFields.subject] = subject;\n    saveObj[this.parent.eventFields.startTime] = this.parent.activeCellsData.startTime;\n    saveObj[this.parent.eventFields.endTime] = this.parent.activeCellsData.endTime;\n    saveObj[this.parent.eventFields.isAllDay] = this.parent.activeCellsData.isAllDay;\n    this.parent.eventWindow.setDefaultValueToObject(saveObj);\n    if (this.parent.resourceBase) {\n      this.parent.resourceBase.setResourceValues(saveObj, this.parent.activeCellsData.groupIndex);\n    }\n    return saveObj;\n  }\n  documentClick() {\n    const target = this.parent.element.querySelector('.' + INLINE_SUBJECT_CLASS);\n    if (target && target.value !== '') {\n      this.inlineCrudActions(target);\n    } else {\n      this.removeInlineAppointmentElement();\n    }\n  }\n  inlineCrudActions(target) {\n    if (closest(target, '.' + INLINE_APPOINTMENT_CLASS)) {\n      const saveObj = this.generateEventData(target);\n      this.parent.addEvent(saveObj);\n    } else {\n      const eventTarget = closest(target, '.' + APPOINTMENT_CLASS);\n      const eventDetails = this.parent.getEventDetails(eventTarget);\n      eventDetails[this.parent.eventFields.subject] = target.value;\n      let currentAction;\n      if (eventDetails[this.parent.eventFields.id] === eventDetails[this.parent.eventFields.recurrenceID]) {\n        currentAction = 'EditOccurrence';\n        eventDetails[this.parent.eventFields.id] = this.parent.eventBase.getEventMaxID();\n      }\n      this.parent.saveEvent(eventDetails, currentAction);\n    }\n    this.removeInlineAppointmentElement();\n  }\n  createInlineAppointmentElement(inlineData) {\n    const inlineAppointmentElement = createElement('div', {\n      className: APPOINTMENT_CLASS + ' ' + INLINE_APPOINTMENT_CLASS\n    });\n    const inlineDetails = createElement('div', {\n      className: APPOINTMENT_DETAILS\n    });\n    inlineAppointmentElement.appendChild(inlineDetails);\n    const inline = createElement('input', {\n      className: INLINE_SUBJECT_CLASS\n    });\n    inlineDetails.appendChild(inline);\n    if (inlineData) {\n      this.parent.eventBase.applyResourceColor(inlineAppointmentElement, inlineData, 'backgroundColor');\n    }\n    return inlineAppointmentElement;\n  }\n  removeInlineAppointmentElement() {\n    const inlineAppointment = [].slice.call(this.parent.element.querySelectorAll('.' + INLINE_APPOINTMENT_CLASS));\n    if (inlineAppointment.length > 0) {\n      inlineAppointment.forEach(node => remove(node));\n    }\n    const inlineSubject = this.parent.element.querySelector('.' + INLINE_SUBJECT_CLASS);\n    if (inlineSubject) {\n      const appointmentSubject = closest(inlineSubject, '.' + APPOINTMENT_CLASS);\n      removeClass([appointmentSubject.querySelector('.' + SUBJECT_CLASS)], DISABLE_CLASS);\n      remove(inlineSubject);\n    }\n  }\n  destroy() {\n    this.parent.off(inlineClick, this.inlineEdit);\n  }\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Appointment window field validation\n */\nclass FieldValidator {\n  renderFormValidator(form, rules, element, locale) {\n    this.element = element;\n    this.formObj = new FormValidator(form, {\n      locale: locale,\n      customPlacement: (inputElement, error) => {\n        this.errorPlacement(inputElement, error);\n      },\n      rules: rules,\n      validationComplete: args => {\n        this.validationComplete(args);\n      },\n      focusout: args => {\n        this.focusOut(args);\n      }\n    });\n  }\n  focusOut(args) {\n    const target = args.relatedTarget;\n    if (target && (target.classList.contains('e-dlg-closeicon-btn') || target.classList.contains('e-close') || target.classList.contains(ALLDAY_CELLS_CLASS) || target.classList.contains(HEADER_CELLS_CLASS) || target.classList.contains(QUICK_POPUP_EVENT_DETAILS_CLASS) || target.classList.contains(WORK_CELLS_CLASS) || target.classList.contains(EVENT_WINDOW_CANCEL_BUTTON_CLASS))) {\n      this.ignoreError = true;\n    } else {\n      this.ignoreError = false;\n    }\n  }\n  validationComplete(args) {\n    const elem = this.element.querySelector('#' + args.inputName + '_Error');\n    if (elem) {\n      elem.style.display = args.status === 'failure' ? '' : 'none';\n    }\n  }\n  errorPlacement(inputElement, error) {\n    const id = error.getAttribute('for');\n    const elem = this.element.querySelector('#' + id + '_Error');\n    if (!elem && !this.ignoreError) {\n      this.createTooltip(inputElement, error, id, '');\n    }\n    if (!isNullOrUndefined(elem)) {\n      elem.querySelector('.e-error').innerHTML = error.innerHTML;\n    }\n  }\n  createTooltip(element, error, name, display) {\n    let dlgContent;\n    let client;\n    const inputClient = element.getBoundingClientRect();\n    if (this.element.classList.contains(POPUP_WRAPPER_CLASS)) {\n      dlgContent = this.element;\n      client = this.element.getBoundingClientRect();\n    } else {\n      dlgContent = this.element.querySelector('.e-schedule-dialog .e-dlg-content');\n      client = dlgContent.getBoundingClientRect();\n    }\n    const div = createElement('div', {\n      className: 'e-tooltip-wrap e-popup ' + ERROR_VALIDATION_CLASS,\n      id: name + '_Error',\n      styles: 'display:' + display + ';top:' + (inputClient.bottom - client.top + dlgContent.scrollTop + 9) + 'px;left:' + (inputClient.left - client.left + dlgContent.scrollLeft + inputClient.width / 2) + 'px;'\n    });\n    const content = createElement('div', {\n      className: 'e-tip-content'\n    });\n    content.appendChild(error);\n    const arrow = createElement('div', {\n      className: 'e-arrow-tip e-tip-top'\n    });\n    arrow.appendChild(createElement('div', {\n      className: 'e-arrow-tip-outer e-tip-top'\n    }));\n    arrow.appendChild(createElement('div', {\n      className: 'e-arrow-tip-inner e-tip-top'\n    }));\n    div.appendChild(content);\n    div.appendChild(arrow);\n    dlgContent.appendChild(div);\n    div.style.left = parseInt(div.style.left, 10) - div.offsetWidth / 2 + 'px';\n  }\n  destroyToolTip() {\n    if (this.element) {\n      const elements = [].slice.call(this.element.querySelectorAll('.' + ERROR_VALIDATION_CLASS));\n      for (const elem of elements) {\n        remove(elem);\n      }\n    }\n    if (this.formObj && this.formObj.element) {\n      this.formObj.reset();\n    }\n  }\n  destroy() {\n    if (this.formObj && this.formObj.element && !this.formObj.isDestroyed) {\n      this.formObj.destroy();\n    }\n    this.formObj = null;\n    this.element = null;\n  }\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst EVENT_FIELD = 'e-field';\n/**\n * Quick Popups interactions\n */\nclass QuickPopups {\n  constructor(parent) {\n    this.isMultipleEventSelect = false;\n    this.isCrudAction = false;\n    this.parent = parent;\n    this.l10n = this.parent.localeObj;\n    this.fieldValidator = new FieldValidator();\n    this.render();\n    this.addEventListener();\n  }\n  render() {\n    this.renderQuickPopup();\n    this.renderMorePopup();\n    this.renderQuickDialog();\n  }\n  renderQuickPopup() {\n    const quickPopupWrapper = createElement('div', {\n      className: POPUP_WRAPPER_CLASS + ' e-popup-close'\n    });\n    if (this.parent.isAdaptive) {\n      document.body.appendChild(quickPopupWrapper);\n      addClass([quickPopupWrapper], DEVICE_CLASS);\n    } else {\n      this.parent.element.appendChild(quickPopupWrapper);\n    }\n    this.quickPopup = new Popup(quickPopupWrapper, {\n      targetType: this.parent.isAdaptive ? 'container' : 'relative',\n      enableRtl: this.parent.enableRtl,\n      open: this.quickPopupOpen.bind(this),\n      close: this.quickPopupClose.bind(this),\n      hideAnimation: this.parent.isAdaptive ? {\n        name: 'ZoomOut'\n      } : {\n        name: 'FadeOut',\n        duration: 150\n      },\n      showAnimation: this.parent.isAdaptive ? {\n        name: 'ZoomIn'\n      } : {\n        name: 'FadeIn',\n        duration: 150\n      },\n      collision: this.parent.isAdaptive ? {\n        X: 'fit',\n        Y: 'fit'\n      } : this.parent.enableRtl ? {\n        X: 'flip',\n        Y: 'fit'\n      } : {\n        X: 'none',\n        Y: 'fit'\n      },\n      position: this.parent.isAdaptive || this.parent.enableRtl ? {\n        X: 'left',\n        Y: 'top'\n      } : {\n        X: 'right',\n        Y: 'top'\n      },\n      viewPortElement: this.parent.isAdaptive ? document.body : this.parent.element,\n      zIndex: this.parent.isAdaptive ? 1004 : 3\n    });\n  }\n  renderMorePopup() {\n    const moreEventPopup = `<div class=\"${MORE_EVENT_POPUP_CLASS}\"><div class=\"${MORE_EVENT_HEADER_CLASS}\">` + `<div class=\"${MORE_EVENT_CLOSE_CLASS}\" title=\"${this.l10n.getConstant('close')}\" tabindex=\"0\"></div>` + `<div class=\"${MORE_EVENT_DATE_HEADER_CLASS}\"><div class=\"${MORE_EVENT_HEADER_DAY_CLASS}\"></div>` + `<div class=\"${MORE_EVENT_HEADER_DATE_CLASS} ${NAVIGATE_CLASS}\" tabindex=\"0\"></div></div></div></div>`;\n    const moreEventWrapper = createElement('div', {\n      className: MORE_POPUP_WRAPPER_CLASS + ' e-popup-close',\n      innerHTML: moreEventPopup\n    });\n    if (this.parent.isAdaptive) {\n      document.body.appendChild(moreEventWrapper);\n      addClass([moreEventWrapper], DEVICE_CLASS);\n    } else {\n      this.parent.element.appendChild(moreEventWrapper);\n    }\n    this.morePopup = new Popup(moreEventWrapper, {\n      targetType: this.parent.isAdaptive ? 'container' : 'relative',\n      enableRtl: this.parent.enableRtl,\n      hideAnimation: {\n        name: 'ZoomOut',\n        duration: 300\n      },\n      showAnimation: {\n        name: 'ZoomIn',\n        duration: 300\n      },\n      open: this.morePopupOpen.bind(this),\n      close: this.morePopupClose.bind(this),\n      collision: this.parent.isAdaptive ? {\n        X: 'fit',\n        Y: 'fit'\n      } : this.parent.enableRtl ? {\n        X: 'flip',\n        Y: 'fit'\n      } : {\n        X: 'flip',\n        Y: 'flip'\n      },\n      viewPortElement: this.parent.isAdaptive ? document.body : this.parent.element,\n      zIndex: this.parent.isAdaptive ? 1002 : 2\n    });\n    const closeButton = this.morePopup.element.querySelector('.' + MORE_EVENT_CLOSE_CLASS);\n    this.renderButton('e-round', ICON + ' ' + CLOSE_ICON_CLASS, false, closeButton, this.closeClick);\n    EventHandler.add(this.morePopup.element.querySelector('.' + MORE_EVENT_HEADER_DATE_CLASS), 'click', this.navigationClick, this);\n  }\n  renderQuickDialog() {\n    const buttonModel = [{\n      buttonModel: {\n        cssClass: 'e-quick-alertok e-flat',\n        isPrimary: true\n      },\n      click: this.dialogButtonClick.bind(this)\n    }, {\n      buttonModel: {\n        cssClass: 'e-quick-alertcancel e-flat',\n        isPrimary: false\n      },\n      click: this.dialogButtonClick.bind(this)\n    }, {\n      buttonModel: {\n        cssClass: 'e-quick-dialog-cancel e-disable e-flat',\n        isPrimary: false\n      },\n      click: this.dialogButtonClick.bind(this)\n    }];\n    if (this.parent.eventSettings.editFollowingEvents) {\n      const followingSeriesButton = {\n        buttonModel: {\n          cssClass: 'e-quick-alertfollowing e-flat',\n          isPrimary: false\n        },\n        click: this.dialogButtonClick.bind(this)\n      };\n      buttonModel.splice(1, 0, followingSeriesButton);\n    }\n    this.quickDialog = new Dialog({\n      animationSettings: {\n        effect: 'Zoom'\n      },\n      buttons: buttonModel,\n      cssClass: QUICK_DIALOG_CLASS,\n      closeOnEscape: true,\n      enableRtl: this.parent.enableRtl,\n      beforeClose: this.beforeQuickDialogClose.bind(this),\n      isModal: true,\n      position: {\n        X: 'center',\n        Y: 'center'\n      },\n      showCloseIcon: true,\n      target: document.body,\n      visible: false,\n      width: 'auto'\n    });\n    const dialogElement = createElement('div', {\n      id: this.parent.element.id + 'QuickDialog'\n    });\n    this.parent.element.appendChild(dialogElement);\n    this.quickDialog.appendTo(dialogElement);\n    const okButton = this.quickDialog.element.querySelector('.' + QUICK_DIALOG_ALERT_OK);\n    if (okButton) {\n      okButton.setAttribute('aria-label', this.l10n.getConstant('occurrence'));\n      okButton.setAttribute('aria-label', okButton.innerHTML);\n    }\n    const cancelButton = this.quickDialog.element.querySelector('.' + QUICK_DIALOG_ALERT_CANCEL);\n    if (cancelButton) {\n      cancelButton.setAttribute('aria-label', this.l10n.getConstant('series'));\n      cancelButton.setAttribute('aria-label', cancelButton.innerHTML);\n    }\n    if (this.quickDialog.element.querySelector('.e-dlg-closeicon-btn')) {\n      this.quickDialog.element.querySelector('.e-dlg-closeicon-btn').setAttribute('title', this.l10n.getConstant('close'));\n    }\n  }\n  // eslint-disable-next-line max-len\n  renderButton(className, iconName, isDisabled, element, clickEvent) {\n    const buttonObj = new Button({\n      cssClass: className,\n      disabled: isDisabled,\n      enableRtl: this.parent.enableRtl,\n      iconCss: iconName\n    });\n    buttonObj.appendTo(element);\n    EventHandler.add(element, 'click', clickEvent, this);\n    removeClass([element], ICON);\n  }\n  quickDialogClass(action) {\n    const classList$$1 = [QUICK_DIALOG_OCCURRENCE_CLASS, QUICK_DIALOG_SERIES_CLASS, QUICK_DIALOG_DELETE_CLASS, QUICK_DIALOG_CANCEL_CLASS, QUICK_DIALOG_ALERT_BTN_CLASS, DISABLE_CLASS];\n    const okButton = this.quickDialog.element.querySelector('.' + QUICK_DIALOG_ALERT_OK);\n    const cancelButton = this.quickDialog.element.querySelector('.' + QUICK_DIALOG_ALERT_CANCEL);\n    const followingEventButton = this.quickDialog.element.querySelector('.' + QUICK_DIALOG_ALERT_FOLLOWING);\n    removeClass([okButton, cancelButton], classList$$1);\n    addClass([this.quickDialog.element.querySelector('.' + QUICK_DIALOG_CANCEL_CLASS)], DISABLE_CLASS);\n    if (this.parent.eventSettings.editFollowingEvents) {\n      addClass([followingEventButton], DISABLE_CLASS);\n      removeClass([this.quickDialog.element], FOLLOWING_EVENTS_DIALOG);\n    }\n    switch (action) {\n      case 'Recurrence':\n        addClass([okButton], QUICK_DIALOG_OCCURRENCE_CLASS);\n        addClass([cancelButton], QUICK_DIALOG_SERIES_CLASS);\n        if (this.parent.eventSettings.editFollowingEvents) {\n          removeClass([followingEventButton], DISABLE_CLASS);\n          addClass([this.quickDialog.element], FOLLOWING_EVENTS_DIALOG);\n          addClass([followingEventButton], QUICK_DIALOG_FOLLOWING_EVENTS_CLASS);\n        }\n        break;\n      case 'Delete':\n        addClass([okButton], QUICK_DIALOG_DELETE_CLASS);\n        addClass([cancelButton], QUICK_DIALOG_CANCEL_CLASS);\n        break;\n      case 'Alert':\n        addClass([okButton], [QUICK_DIALOG_ALERT_OK, QUICK_DIALOG_ALERT_BTN_CLASS]);\n        addClass([cancelButton], [QUICK_DIALOG_ALERT_CANCEL, DISABLE_CLASS]);\n        break;\n    }\n  }\n  applyFormValidation() {\n    const form = this.quickPopup.element.querySelector('.' + FORM_CLASS);\n    const rules = {};\n    rules[this.parent.eventSettings.fields.subject.name] = this.parent.eventSettings.fields.subject.validation;\n    this.fieldValidator.renderFormValidator(form, rules, this.quickPopup.element, this.parent.locale);\n  }\n  openRecurrenceAlert() {\n    const editDeleteOnly = this.quickDialog.element.querySelector('.' + QUICK_DIALOG_ALERT_OK);\n    if (editDeleteOnly) {\n      editDeleteOnly.innerHTML = this.l10n.getConstant(this.parent.currentAction === 'Delete' ? 'deleteEvent' : 'editEvent');\n      editDeleteOnly.setAttribute('aria-label', editDeleteOnly.innerHTML);\n    }\n    const editFollowingEventsOnly = this.quickDialog.element.querySelector('.' + QUICK_DIALOG_ALERT_FOLLOWING);\n    if (editFollowingEventsOnly) {\n      editFollowingEventsOnly.innerHTML = this.l10n.getConstant('editFollowingEvent');\n      editFollowingEventsOnly.setAttribute('aria-label', editFollowingEventsOnly.innerHTML);\n    }\n    const editDeleteSeries = this.quickDialog.element.querySelector('.' + QUICK_DIALOG_ALERT_CANCEL);\n    if (editDeleteSeries) {\n      editDeleteSeries.innerHTML = this.l10n.getConstant(this.parent.currentAction === 'Delete' ? 'deleteSeries' : 'editSeries');\n      editDeleteSeries.setAttribute('aria-label', editDeleteSeries.innerHTML);\n    }\n    this.quickDialog.content = this.l10n.getConstant('editContent');\n    this.quickDialog.header = this.l10n.getConstant(this.parent.currentAction === 'Delete' ? 'deleteTitle' : 'editTitle');\n    this.quickDialogClass('Recurrence');\n    const activeEvent = this.parent.activeEventData.event;\n    if (this.parent.eventSettings.editFollowingEvents && this.parent.currentAction === 'EditOccurrence' && !isNullOrUndefined(activeEvent[this.parent.eventFields.recurrenceID]) && activeEvent[this.parent.eventFields.recurrenceID] !== activeEvent[this.parent.eventFields.id]) {\n      const followingEventButton = this.quickDialog.element.querySelector('.' + QUICK_DIALOG_ALERT_FOLLOWING);\n      addClass([followingEventButton], DISABLE_CLASS);\n    }\n    this.showQuickDialog('RecurrenceAlert');\n  }\n  openRecurrenceValidationAlert(type) {\n    this.quickDialogClass('Alert');\n    const okButton = this.quickDialog.element.querySelector('.' + QUICK_DIALOG_ALERT_OK);\n    okButton.innerHTML = this.l10n.getConstant('ok');\n    okButton.setAttribute('aria-label', okButton.innerHTML);\n    const cancelButton = this.quickDialog.element.querySelector('.' + QUICK_DIALOG_ALERT_CANCEL);\n    cancelButton.innerHTML = this.l10n.getConstant('cancel');\n    cancelButton.setAttribute('aria-label', cancelButton.innerHTML);\n    this.quickDialog.header = this.l10n.getConstant('alert');\n    let dialogCancel;\n    switch (type) {\n      case 'wrongPattern':\n        addClass([cancelButton], DISABLE_CLASS);\n        this.quickDialog.content = this.l10n.getConstant('wrongPattern');\n        break;\n      case 'createError':\n        addClass([cancelButton], DISABLE_CLASS);\n        this.quickDialog.content = this.l10n.getConstant('createError');\n        break;\n      case 'sameDayAlert':\n        addClass([cancelButton], DISABLE_CLASS);\n        this.quickDialog.content = this.l10n.getConstant('sameDayAlert');\n        break;\n      case 'seriesChangeAlert':\n        dialogCancel = this.quickDialog.element.querySelector('.' + QUICK_DIALOG_CANCEL_CLASS);\n        removeClass([cancelButton, dialogCancel], DISABLE_CLASS);\n        this.quickDialog.content = this.l10n.getConstant('seriesChangeAlert');\n        okButton.innerHTML = this.l10n.getConstant('yes');\n        cancelButton.innerHTML = this.l10n.getConstant('no');\n        dialogCancel.innerHTML = this.l10n.getConstant('cancel');\n        break;\n      case 'occurrenceAlert':\n        addClass([cancelButton], DISABLE_CLASS);\n        this.quickDialog.content = this.l10n.getConstant('occurenceAlert');\n        break;\n    }\n    if (!this.parent.enableRecurrenceValidation && type === 'wrongPattern' || this.parent.enableRecurrenceValidation) {\n      this.showQuickDialog('RecurrenceValidationAlert');\n    }\n  }\n  openDeleteAlert() {\n    if (this.parent.activeViewOptions.readonly) {\n      return;\n    }\n    const okButton = this.quickDialog.element.querySelector('.' + QUICK_DIALOG_ALERT_OK);\n    if (okButton) {\n      okButton.innerHTML = this.l10n.getConstant('delete');\n      okButton.setAttribute('aria-label', okButton.innerHTML);\n    }\n    const cancelButton = this.quickDialog.element.querySelector('.' + QUICK_DIALOG_ALERT_CANCEL);\n    if (cancelButton) {\n      cancelButton.innerHTML = this.l10n.getConstant('cancel');\n      cancelButton.setAttribute('aria-label', cancelButton.innerHTML);\n    }\n    this.quickDialog.content = this.parent.activeEventData.event.length > 1 ? this.l10n.getConstant('deleteMultipleContent') : this.l10n.getConstant('deleteContent');\n    this.quickDialog.header = this.parent.activeEventData.event.length > 1 ? this.l10n.getConstant('deleteMultipleEvent') : this.l10n.getConstant('deleteEvent');\n    this.quickDialogClass('Delete');\n    this.showQuickDialog('DeleteAlert');\n  }\n  openValidationError(type, eventData) {\n    this.quickDialog.header = this.l10n.getConstant('alert');\n    this.quickDialog.content = this.l10n.getConstant(type);\n    const okButton = this.quickDialog.element.querySelector('.' + QUICK_DIALOG_ALERT_OK);\n    if (okButton) {\n      okButton.innerHTML = this.l10n.getConstant('ok');\n      okButton.setAttribute('aria-label', okButton.innerHTML);\n    }\n    const cancelButton = this.quickDialog.element.querySelector('.' + QUICK_DIALOG_ALERT_CANCEL);\n    if (cancelButton) {\n      cancelButton.innerHTML = this.l10n.getConstant('cancel');\n      okButton.setAttribute('aria-label', cancelButton.innerHTML);\n    }\n    this.quickDialogClass('Alert');\n    this.showQuickDialog('ValidationAlert', eventData);\n  }\n  showQuickDialog(popupType, eventData) {\n    this.quickDialog.dataBind();\n    const eventProp = {\n      type: popupType,\n      cancel: false,\n      element: this.quickDialog.element,\n      data: extend({}, eventData || this.parent.activeEventData.event, null, true)\n    };\n    this.parent.trigger(popupOpen, eventProp, popupArgs => {\n      if (!popupArgs.cancel) {\n        this.quickDialog.show();\n      }\n    });\n  }\n  createMoreEventList(eventCollection, groupOrder, groupIndex) {\n    const fields = this.parent.eventFields;\n    const moreEventContentEle = createElement('div', {\n      className: MORE_EVENT_CONTENT_CLASS\n    });\n    let moreEventWrapperEle = createElement('div', {\n      className: MORE_EVENT_WRAPPER_CLASS\n    });\n    if (eventCollection.length === 0) {\n      moreEventWrapperEle = createElement('div', {\n        className: MORE_EVENT_CONTENT_CLASS,\n        innerHTML: this.l10n.getConstant('emptyContainer')\n      });\n    } else {\n      for (const eventData of eventCollection) {\n        const eventText = eventData[fields.subject] || this.parent.eventSettings.fields.subject.default || this.parent.localeObj.getConstant('addTitle');\n        const appointmentElement = createElement('div', {\n          className: APPOINTMENT_CLASS,\n          attrs: {\n            'data-id': '' + eventData[fields.id],\n            'data-guid': eventData.Guid,\n            'role': 'button',\n            'tabindex': '0',\n            'aria-readonly': this.parent.eventBase.getReadonlyAttribute(eventData),\n            'aria-selected': 'false',\n            'aria-grabbed': 'true',\n            'aria-label': this.parent.getAnnouncementString(eventData)\n          }\n        });\n        let templateElement;\n        if (!isNullOrUndefined(this.parent.activeViewOptions.eventTemplate)) {\n          const tempId = this.parent.element.id + '_' + this.parent.activeViewOptions.eventTemplateName + 'eventTemplate';\n          templateElement = this.parent.getAppointmentTemplate()(eventData, this.parent, 'eventTemplate', tempId, false);\n          append(templateElement, appointmentElement);\n        } else {\n          appointmentElement.appendChild(createElement('div', {\n            className: SUBJECT_CLASS,\n            innerHTML: eventText\n          }));\n        }\n        if (!isNullOrUndefined(groupIndex)) {\n          appointmentElement.setAttribute('data-group-index', groupIndex);\n        }\n        if (!isNullOrUndefined(eventData[fields.recurrenceRule])) {\n          const iconClass = eventData[fields.id] === eventData[fields.recurrenceID] ? EVENT_RECURRENCE_ICON_CLASS : EVENT_RECURRENCE_EDIT_ICON_CLASS;\n          appointmentElement.appendChild(createElement('div', {\n            className: ICON + ' ' + iconClass\n          }));\n        }\n        const args = {\n          data: extend({}, eventData, null, true),\n          element: appointmentElement,\n          cancel: false\n        };\n        this.parent.trigger(eventRendered, args, eventArgs => {\n          if (!eventArgs.cancel) {\n            moreEventWrapperEle.appendChild(appointmentElement);\n            const isPreventCrud = this.parent.isAdaptive || this.parent.currentView === 'Year';\n            this.parent.eventBase.wireAppointmentEvents(appointmentElement, eventData, isPreventCrud);\n            this.parent.eventBase.applyResourceColor(appointmentElement, eventData, 'backgroundColor', groupOrder);\n          }\n        });\n      }\n    }\n    moreEventContentEle.appendChild(moreEventWrapperEle);\n    return moreEventContentEle;\n  }\n  tapHoldEventPopup(e) {\n    const target = closest(e.target, '.' + APPOINTMENT_CLASS);\n    this.isMultipleEventSelect = false;\n    this.parent.selectedElements = [];\n    this.isMultipleEventSelect = true;\n    this.parent.eventBase.getSelectedEventElements(target);\n    this.parent.activeEventData = this.parent.eventBase.getSelectedEvents();\n    const guid = target.getAttribute('data-guid');\n    const eventObj = this.parent.eventBase.getEventByGuid(guid);\n    if (isNullOrUndefined(eventObj)) {\n      return;\n    }\n    const eventTitle = eventObj[this.parent.eventFields.subject] || this.l10n.getConstant('noTitle');\n    const eventTemplate = `<div class=\"${MULTIPLE_EVENT_POPUP_CLASS}\"><div class=\"${POPUP_HEADER_CLASS}\">` + `<button class=\"${CLOSE_CLASS}\" title=\"${this.l10n.getConstant('close')}\"></button>` + `<div class=\"${SUBJECT_CLASS}\">${eventTitle}</div>` + `<button class=\"${EDIT_CLASS}\" title=\"${this.l10n.getConstant('edit')}\"></button>` + `<button class=\"${DELETE_CLASS}\" title=\"${this.l10n.getConstant('delete')}\"></button></div></div>`;\n    this.quickPopup.element.innerHTML = eventTemplate;\n    const closeIcon = this.quickPopup.element.querySelector('.' + CLOSE_CLASS);\n    this.renderButton('e-flat e-round e-small', ICON + ' ' + CLOSE_ICON_CLASS, false, closeIcon, this.closeClick);\n    const readonly = this.parent.activeViewOptions.readonly || eventObj[this.parent.eventFields.isReadonly];\n    const editAction = !this.parent.eventSettings.allowEditing || readonly;\n    const deleteAction = !this.parent.eventSettings.allowDeleting || readonly;\n    const editIcon = this.quickPopup.element.querySelector('.' + EDIT_CLASS);\n    if (editIcon) {\n      this.renderButton('e-flat e-round e-small', ICON + ' ' + EDIT_ICON_CLASS, editAction, editIcon, this.editClick);\n    }\n    const deleteIcon = this.quickPopup.element.querySelector('.' + DELETE_CLASS);\n    if (deleteIcon) {\n      this.renderButton('e-flat e-round e-small', ICON + ' ' + DELETE_ICON_CLASS, deleteAction, deleteIcon, this.deleteClick);\n    }\n    this.beforeQuickPopupOpen(target);\n  }\n  isCellBlocked(args) {\n    const tempObj = {};\n    tempObj[this.parent.eventFields.startTime] = this.parent.activeCellsData.startTime;\n    tempObj[this.parent.eventFields.endTime] = this.parent.activeCellsData.endTime;\n    tempObj[this.parent.eventFields.isAllDay] = this.parent.activeCellsData.isAllDay;\n    if (this.parent.activeViewOptions.group.resources.length > 0) {\n      const targetCell = args.element instanceof Array ? args.element[0] : args.element;\n      const groupIndex = parseInt(targetCell.getAttribute('data-group-index'), 10);\n      this.parent.resourceBase.setResourceValues(tempObj, isNaN(groupIndex) ? null : groupIndex);\n    }\n    return this.parent.eventBase.isBlockRange(tempObj);\n  }\n  cellClick(args) {\n    const date = new Date(args.startTime.getTime());\n    if (!this.parent.showQuickInfo || !this.parent.eventSettings.allowAdding || this.parent.currentView === 'MonthAgenda' || this.isCellBlocked(args) || !this.parent.isMinMaxDate(new Date(date.setHours(0, 0, 0, 0)))) {\n      this.quickPopupHide();\n      return;\n    }\n    const targetEle = args.event.target;\n    if (this.parent.isAdaptive) {\n      this.quickPopupHide();\n      let newEventClone = this.parent.element.querySelector('.' + NEW_EVENT_CLASS);\n      if (isNullOrUndefined(newEventClone)) {\n        newEventClone = createElement('div', {\n          className: NEW_EVENT_CLASS,\n          innerHTML: `<div class=\"e-title\">+ ${this.l10n.getConstant('newEvent')}</div>`\n        });\n      }\n      const targetCell = closest(targetEle, '.' + WORK_CELLS_CLASS + ',.' + ALLDAY_CELLS_CLASS);\n      if (targetCell) {\n        targetCell.appendChild(newEventClone);\n      }\n      return;\n    }\n    const target = closest(targetEle, '.' + WORK_CELLS_CLASS + ',.' + ALLDAY_CELLS_CLASS + ',.' + HEADER_CELLS_CLASS);\n    if (isNullOrUndefined(target) || targetEle.classList.contains(MORE_INDICATOR_CLASS)) {\n      return;\n    }\n    const isSameTarget = this.quickPopup.relateTo === target;\n    if (isSameTarget && this.quickPopup.element.classList.contains(POPUP_OPEN)) {\n      const subjectElement = this.quickPopup.element.querySelector('.' + SUBJECT_CLASS);\n      if (subjectElement) {\n        subjectElement.focus();\n      }\n      return;\n    }\n    const temp = {};\n    temp[this.parent.eventFields.startTime] = this.parent.activeCellsData.startTime;\n    temp[this.parent.eventFields.endTime] = this.parent.activeCellsData.endTime;\n    temp[this.parent.eventFields.isAllDay] = this.parent.activeCellsData.isAllDay;\n    const quickCellPopup = createElement('div', {\n      className: CELL_POPUP_CLASS\n    });\n    quickCellPopup.appendChild(this.getPopupHeader('Cell', temp));\n    quickCellPopup.appendChild(this.getPopupContent('Cell', args, temp));\n    quickCellPopup.appendChild(this.getPopupFooter('Cell', temp));\n    const subjectElement = quickCellPopup.querySelector('.' + SUBJECT_CLASS);\n    if (subjectElement) {\n      Input.createInput({\n        element: subjectElement,\n        properties: {\n          placeholder: this.l10n.getConstant('addTitle')\n        }\n      });\n    }\n    if (!isNullOrUndefined(this.parent.eventSettings.fields.subject.default)) {\n      subjectElement.value = this.parent.eventSettings.fields.subject.default;\n    }\n    const closeIcon = quickCellPopup.querySelector('.' + CLOSE_CLASS);\n    if (closeIcon) {\n      this.renderButton('e-flat e-round e-small', ICON + ' ' + CLOSE_ICON_CLASS, false, closeIcon, this.popupClose);\n    }\n    const moreButton = quickCellPopup.querySelector('.' + QUICK_POPUP_EVENT_DETAILS_CLASS);\n    if (moreButton) {\n      this.renderButton('e-flat', '', false, moreButton, this.detailsClick);\n    }\n    const saveButton = quickCellPopup.querySelector('.' + EVENT_CREATE_CLASS);\n    if (saveButton) {\n      this.renderButton('e-flat e-primary', '', this.parent.activeViewOptions.readonly, saveButton, this.saveClick);\n    }\n    if (this.morePopup) {\n      this.morePopup.hide();\n    }\n    this.quickPopup.content = quickCellPopup;\n    this.quickPopup.relateTo = target;\n    this.quickPopup.dataBind();\n    this.beforeQuickPopupOpen(target);\n  }\n  isSameEventClick(events) {\n    const isSameTarget = this.quickPopup.relateTo === closest(events.element, '.' + APPOINTMENT_CLASS);\n    if (isSameTarget && this.quickPopup.element.classList.contains(POPUP_OPEN)) {\n      const editIcon = this.quickPopup.element.querySelector('.' + EDIT_CLASS);\n      if (editIcon) {\n        editIcon.focus();\n      }\n      if (!this.parent.isAdaptive) {\n        const editButton = this.quickPopup.element.querySelector('.' + EDIT_EVENT_CLASS);\n        if (editButton) {\n          editButton.focus();\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n  isQuickTemplate(type) {\n    return this.parent.quickInfoTemplates.templateType === 'Both' || this.parent.quickInfoTemplates.templateType === type;\n  }\n  eventClick(events) {\n    if (this.parent.eventTooltip) {\n      this.parent.eventTooltip.close();\n    }\n    if (!this.parent.showQuickInfo) {\n      return;\n    }\n    if (this.parent.isAdaptive && this.isMultipleEventSelect) {\n      this.updateTapHoldEventPopup(closest(events.element, '.' + APPOINTMENT_CLASS));\n    } else {\n      const isSameTarget = this.isSameEventClick(events);\n      if (isSameTarget) {\n        return;\n      }\n      const eventData = events.event;\n      const quickEventPopup = createElement('div', {\n        className: EVENT_POPUP_CLASS\n      });\n      quickEventPopup.appendChild(this.getPopupHeader('Event', eventData));\n      quickEventPopup.appendChild(this.getPopupContent('Event', events, eventData));\n      quickEventPopup.appendChild(this.getPopupFooter('Event', eventData));\n      const readonly = this.parent.activeViewOptions.readonly || eventData[this.parent.eventFields.isReadonly];\n      const editAction = !this.parent.eventSettings.allowEditing || readonly;\n      const deleteAction = !this.parent.eventSettings.allowDeleting || readonly;\n      const editIcon = quickEventPopup.querySelector('.' + EDIT_CLASS);\n      const buttonClass = 'e-flat e-round e-small';\n      if (editIcon) {\n        this.renderButton(buttonClass, ICON + ' ' + EDIT_ICON_CLASS, editAction, editIcon, this.editClick);\n      }\n      const deleteIcon = quickEventPopup.querySelector('.' + DELETE_CLASS);\n      if (deleteIcon) {\n        this.renderButton(buttonClass, ICON + ' ' + DELETE_ICON_CLASS, deleteAction, deleteIcon, this.deleteClick);\n      }\n      const closeIcon = quickEventPopup.querySelector('.' + CLOSE_CLASS);\n      if (closeIcon) {\n        this.renderButton(buttonClass, ICON + ' ' + CLOSE_ICON_CLASS, false, closeIcon, this.popupClose);\n      }\n      const editButton = quickEventPopup.querySelector('.' + EDIT_EVENT_CLASS);\n      if (editButton) {\n        this.renderButton('e-flat e-primary', '', editAction, editButton, this.editClick);\n      }\n      const deleteButton = quickEventPopup.querySelector('.' + DELETE_EVENT_CLASS);\n      if (deleteButton) {\n        this.renderButton('e-flat', '', deleteAction, deleteButton, this.deleteClick);\n      }\n      if (this.morePopup && !closest(events.element, '.' + MORE_EVENT_WRAPPER_CLASS)) {\n        this.morePopup.hide();\n      }\n      this.quickPopup.content = quickEventPopup;\n      this.quickPopup.relateTo = this.parent.isAdaptive ? document.body : closest(events.element, '.' + APPOINTMENT_CLASS);\n      this.quickPopup.dataBind();\n      this.beforeQuickPopupOpen(events.element);\n    }\n  }\n  getPopupHeader(headerType, headerData) {\n    const headerTemplate = createElement('div', {\n      className: POPUP_HEADER_CLASS\n    });\n    if (this.isQuickTemplate(headerType) && this.parent.quickInfoTemplates.header) {\n      const headerArgs = extend({}, headerData, {\n        elementType: headerType.toLowerCase()\n      }, true);\n      const templateId = this.parent.element.id;\n      const headerTemp = [].slice.call(this.parent.getQuickInfoTemplatesHeader()(headerArgs, this.parent, 'header', templateId + '_headerTemplate', false));\n      append([].slice.call(headerTemp), headerTemplate);\n    } else {\n      let header;\n      let args;\n      switch (headerType) {\n        case 'Cell':\n          header = `<div class=\"${POPUP_HEADER_ICON_WRAPPER}\"><button class=\"${CLOSE_CLASS}\" title=` + `\"${this.l10n.getConstant('close')}\"></button></div>`;\n          break;\n        case 'Event':\n          args = this.getFormattedString(headerData);\n          header = `<div class=\"${POPUP_HEADER_ICON_WRAPPER}\">` + `<button class=\"${EDIT_CLASS + ' ' + ICON}\" title=\"${this.l10n.getConstant('edit')}\"></button>` + `<button class=\"${DELETE_CLASS + ' ' + ICON}\" title=\"${this.l10n.getConstant('delete')}\"></button>` + `<button class=\"${CLOSE_CLASS}\" title=\"${this.l10n.getConstant('close')}\"></button></div>` + `<div class=\"${SUBJECT_WRAP}\"><div class=\"${SUBJECT_CLASS} ${TEXT_ELLIPSIS}\" ` + `title=\"${args.eventSubject}\">${args.eventSubject}</div></div >`;\n          break;\n      }\n      const templateWrapper = createElement('div', {\n        innerHTML: header\n      });\n      append([].slice.call(templateWrapper.childNodes), headerTemplate);\n    }\n    return headerTemplate;\n  }\n  getPopupContent(type, args, data) {\n    const contentTemplate = createElement('div', {\n      className: POPUP_CONTENT_CLASS\n    });\n    if (this.isQuickTemplate(type) && this.parent.quickInfoTemplates.content) {\n      const contentArgs = extend({}, data, {\n        elementType: type.toLowerCase()\n      }, true);\n      const templateId = this.parent.element.id;\n      const contentTemp = [].slice.call(this.parent.getQuickInfoTemplatesContent()(contentArgs, this.parent, 'content', templateId + '_contentTemplate', false));\n      append([].slice.call(contentTemp), contentTemplate);\n    } else {\n      let content;\n      let cellDetails;\n      let argsData;\n      const resourceText = this.getResourceText(args, type.toLowerCase());\n      switch (type) {\n        case 'Cell':\n          cellDetails = this.getFormattedString(data);\n          content = `<table class=\"${POPUP_TABLE_CLASS}\"><tbody><tr><td><form class=\"${FORM_CLASS}\" onsubmit=` + `\"return false;\"><input class=\"${SUBJECT_CLASS} ${EVENT_FIELD}\" type=\"text\" name=` + `\"${this.parent.eventFields.subject}\" /></form></td></tr><tr><td><div class=\"${DATE_TIME_CLASS}\">` + `<div class=\"${DATE_TIME_ICON_CLASS} ${ICON}\"></div><div class=\"${DATE_TIME_DETAILS_CLASS} ` + `${TEXT_ELLIPSIS}\">${cellDetails.details}</div></div>` + `${this.parent.activeViewOptions.group.resources.length > 0 ? `<div class=\"${RESOURCE_CLASS}\">` + `<div class=\"${RESOURCE_ICON_CLASS} ${ICON} \"></div><div class=\"${RESOURCE_DETAILS_CLASS} ` + `${TEXT_ELLIPSIS}\">${resourceText}</div></div>` : ''}</td></tr></tbody></table>`;\n          break;\n        case 'Event':\n          argsData = this.getFormattedString(data);\n          content = '<div class=\"' + DATE_TIME_CLASS + '\"><div class=\"' + DATE_TIME_ICON_CLASS + ' ' + ICON + '\"></div><div class=\"' + DATE_TIME_WRAPPER_CLASS + ' ' + TEXT_ELLIPSIS + '\"><div class=\"' + DATE_TIME_DETAILS_CLASS + ' ' + TEXT_ELLIPSIS + '\">' + argsData.details + '</div>';\n          if (data[this.parent.eventFields.recurrenceRule]) {\n            content += '<div class=\"' + RECURRENCE_SUMMARY_CLASS + ' ' + TEXT_ELLIPSIS + '\">' + this.getRecurrenceSummary(data) + '</div>';\n          }\n          content += '</div></div>';\n          if (data[this.parent.eventFields.location]) {\n            content += '<div class=\"' + LOCATION_CLASS + '\"><div class=\"' + LOCATION_ICON_CLASS + ' ' + ICON + '\"></div><div class=\"' + LOCATION_DETAILS_CLASS + ' ' + TEXT_ELLIPSIS + '\">' + data[this.parent.eventFields.location] + '</div></div>';\n          }\n          if (data[this.parent.eventFields.startTimezone] || data[this.parent.eventFields.endTimezone]) {\n            content += '<div class=\"' + TIME_ZONE_CLASS + '\"><div class=\"' + TIME_ZONE_ICON_CLASS + ' ' + ICON + '\"></div><div class=\"' + TIME_ZONE_DETAILS_CLASS + ' ' + TEXT_ELLIPSIS + '\">' + this.getTimezone(data) + '</div></div>';\n          }\n          if (data[this.parent.eventFields.description]) {\n            content += '<div class=\"' + DESCRIPTION_CLASS + '\"><div class=\"' + DESCRIPTION_ICON_CLASS + ' ' + ICON + '\"></div><div class=\"' + DESCRIPTION_DETAILS_CLASS + ' ' + TEXT_ELLIPSIS + '\">' + data[this.parent.eventFields.description] + '</div></div>';\n          }\n          if (this.parent.resourceCollection.length > 0) {\n            content += '<div class=\"' + RESOURCE_CLASS + '\"><div class=\"' + RESOURCE_ICON_CLASS + ' ' + ICON + '\"></div><div class=\"' + RESOURCE_DETAILS_CLASS + ' ' + TEXT_ELLIPSIS + '\">' + resourceText + '</div></div>';\n          }\n          break;\n      }\n      const templateWrapper = createElement('div', {\n        innerHTML: content\n      });\n      append([].slice.call(templateWrapper.childNodes), contentTemplate);\n    }\n    return contentTemplate;\n  }\n  getPopupFooter(footerType, footerData) {\n    const footerTemplate = createElement('div', {\n      className: POPUP_FOOTER_CLASS\n    });\n    if (this.isQuickTemplate(footerType) && this.parent.quickInfoTemplates.footer) {\n      const footerArgs = extend({}, footerData, {\n        elementType: footerType.toLowerCase()\n      }, true);\n      const templateId = this.parent.element.id;\n      const footerTemp = [].slice.call(this.parent.getQuickInfoTemplatesFooter()(footerArgs, this.parent, 'footer', templateId + '_footerTemplate', false));\n      append([].slice.call(footerTemp), footerTemplate);\n    } else {\n      let footer;\n      switch (footerType) {\n        case 'Cell':\n          footer = `<button class=\"${QUICK_POPUP_EVENT_DETAILS_CLASS + ' ' + TEXT_ELLIPSIS}\" title=` + `\"${this.l10n.getConstant('moreDetails')}\">${this.l10n.getConstant('moreDetails')}</button>` + `<button class=\"${EVENT_CREATE_CLASS} ${TEXT_ELLIPSIS}\" title=\"${this.l10n.getConstant('save')}\">` + `${this.l10n.getConstant('save')}</button>`;\n          break;\n        case 'Event':\n          footer = `${this.parent.isAdaptive ? '' : `<button class=\"${EDIT_EVENT_CLASS} ` + `${TEXT_ELLIPSIS}\" title=\"${this.l10n.getConstant('edit')}\">${this.l10n.getConstant('edit')}</button>` + `<button class=\"${DELETE_EVENT_CLASS} ${TEXT_ELLIPSIS}\" title=\"${this.l10n.getConstant('delete')}\">` + `${this.l10n.getConstant('delete')}</button>`}`;\n          break;\n      }\n      const templateWrapper = createElement('div', {\n        innerHTML: footer\n      });\n      append([].slice.call(templateWrapper.childNodes), footerTemplate);\n    }\n    return footerTemplate;\n  }\n  getResourceText(args, type) {\n    if (this.parent.resourceCollection.length === 0) {\n      return null;\n    }\n    let resourceValue = '';\n    if (this.parent.activeViewOptions.group.resources.length === 0) {\n      const resourceCollection = this.parent.resourceBase.resourceCollection.slice(-1)[0];\n      const resourceData = resourceCollection.dataSource;\n      if (type === 'event') {\n        const eventData = args.event;\n        for (const data of resourceData) {\n          const resourceId = eventData[resourceCollection.field];\n          if (resourceId instanceof Array) {\n            if (resourceId.indexOf(data[resourceCollection.idField]) > -1) {\n              const id = resourceId[resourceId.indexOf(data[resourceCollection.idField])];\n              const resource = resourceData.filter(e => e[resourceCollection.idField] === id)[0];\n              resourceValue += resourceValue === '' ? resource[resourceCollection.textField] : ', ' + resource[resourceCollection.textField];\n            }\n          } else if (data[resourceCollection.idField] === resourceId) {\n            resourceValue = data[resourceCollection.textField].toString();\n          }\n        }\n      } else {\n        resourceValue = resourceData[0][resourceCollection.textField].toString();\n      }\n    } else {\n      if (type === 'event') {\n        const eventData = args.event;\n        let resourceData;\n        let lastResource;\n        for (let i = this.parent.resourceBase.resourceCollection.length - 1; i >= 0; i--) {\n          resourceData = eventData[this.parent.resourceBase.resourceCollection[i].field];\n          if (!isNullOrUndefined(resourceData)) {\n            lastResource = this.parent.resourceBase.resourceCollection[i];\n            break;\n          }\n        }\n        if (!Array.isArray(resourceData)) {\n          resourceData = [resourceData];\n        }\n        const resNames = [];\n        const lastResourceData = lastResource.dataSource;\n        resourceData.forEach(value => {\n          let text;\n          const i = findIndexInData(lastResourceData, lastResource.idField, value);\n          if (i > -1) {\n            text = lastResourceData[i][lastResource.textField];\n          }\n          if (text) {\n            resNames.push(text);\n          }\n        });\n        resourceValue = resNames.join(', ');\n      } else {\n        const argsData = args;\n        const groupIndex = !isNullOrUndefined(argsData.groupIndex) ? argsData.groupIndex : 0;\n        const resourceDetails = this.parent.resourceBase.lastResourceLevel[groupIndex];\n        resourceValue = resourceDetails.resourceData[resourceDetails.resource.textField];\n      }\n    }\n    return resourceValue;\n  }\n  getFormattedString(eventData) {\n    const fields = this.parent.eventFields;\n    const eventSubject = eventData[fields.subject] || this.l10n.getConstant('noTitle');\n    const startDate = eventData[fields.startTime];\n    const endDate = eventData[fields.endTime];\n    const startDateDetails = this.getDateFormat(startDate, 'long');\n    const endDateDetails = eventData[fields.isAllDay] && endDate.getHours() === 0 && endDate.getMinutes() === 0 ? this.getDateFormat(addDays(new Date(endDate.getTime()), -1), 'long') : this.getDateFormat(endDate, 'long');\n    const startTimeDetail = this.parent.getTimeString(startDate);\n    const endTimeDetail = this.parent.getTimeString(endDate);\n    let details = '';\n    const spanLength = endDate.getDate() !== startDate.getDate() && (endDate.getTime() - startDate.getTime()) / (60 * 60 * 1000) < 24 ? 1 : 0;\n    if (eventData[fields.isAllDay]) {\n      details = startDateDetails + ' (' + this.l10n.getConstant('allDay') + ')';\n      if ((endDate.getTime() - startDate.getTime()) / MS_PER_DAY > 1) {\n        details += '&nbsp;-&nbsp;' + endDateDetails + ' (' + this.l10n.getConstant('allDay') + ')';\n      }\n    } else if ((endDate.getTime() - startDate.getTime()) / MS_PER_DAY >= 1 || spanLength > 0) {\n      details = startDateDetails + ' (' + startTimeDetail + ')' + '&nbsp;-&nbsp;' + endDateDetails + ' (' + endTimeDetail + ')';\n    } else {\n      details = startDateDetails + ' (' + (startTimeDetail + '&nbsp;-&nbsp;' + endTimeDetail) + ')';\n    }\n    return {\n      eventSubject: eventSubject,\n      details: details\n    };\n  }\n  moreEventClick(data, endDate, groupIndex) {\n    this.quickPopupHide(true);\n    const moreEventContentEle = this.morePopup.element.querySelector('.' + MORE_EVENT_CONTENT_CLASS);\n    if (moreEventContentEle) {\n      remove(moreEventContentEle);\n    }\n    const selectedDate = data.date.getTime().toString();\n    const target = closest(data.element, '.' + MORE_INDICATOR_CLASS + ',.' + WORK_CELLS_CLASS);\n    const day = this.parent.globalize.formatDate(data.date, {\n      format: 'E',\n      calendar: this.parent.getCalendarMode()\n    });\n    this.morePopup.element.querySelector('.' + MORE_EVENT_HEADER_DAY_CLASS).innerHTML = capitalizeFirstWord(day, 'single');\n    const dateElement = this.morePopup.element.querySelector('.' + MORE_EVENT_HEADER_DATE_CLASS);\n    dateElement.innerHTML = this.getDateFormat(data.date, 'd');\n    dateElement.setAttribute('data-date', selectedDate);\n    dateElement.setAttribute('data-end-date', endDate.getTime().toString());\n    let groupOrder;\n    if (!isNullOrUndefined(groupIndex)) {\n      dateElement.setAttribute('data-group-index', groupIndex);\n      groupOrder = this.parent.resourceBase.lastResourceLevel[parseInt(groupIndex, 10)].groupOrder;\n    }\n    const moreEventElements = this.createMoreEventList(data.event, groupOrder, groupIndex);\n    this.morePopup.element.querySelector('.' + MORE_EVENT_POPUP_CLASS).appendChild(moreEventElements);\n    removeClass(this.morePopup.element.querySelector('.' + MORE_EVENT_DATE_HEADER_CLASS).childNodes, CURRENTDATE_CLASS);\n    if (resetTime(data.date).getTime() === resetTime(this.parent.getCurrentTime()).getTime()) {\n      addClass(this.morePopup.element.querySelector('.' + MORE_EVENT_DATE_HEADER_CLASS).childNodes, CURRENTDATE_CLASS);\n    }\n    if (!this.parent.isAdaptive) {\n      if (this.parent.currentView.indexOf('Timeline') !== -1) {\n        const gIndex = target.getAttribute('data-group-index');\n        const startDate = new Date(parseInt(target.getAttribute('data-start-date'), 10));\n        startDate.setHours(startDate.getHours(), startDate.getMinutes(), 0);\n        const tdDate = startDate.getTime().toString();\n        if (isNullOrUndefined(gIndex)) {\n          this.morePopup.relateTo = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS + ' tbody tr td[data-date=\"' + tdDate + '\"]');\n        } else {\n          this.morePopup.relateTo = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS + ' tbody tr td[data-group-index=\"' + gIndex + '\"][data-date=\"' + tdDate + '\"]');\n          if (isNullOrUndefined(this.morePopup.relateTo)) {\n            const workCells = [].slice.call(this.parent.element.querySelectorAll('.' + CONTENT_WRAP_CLASS + ' tbody tr td[data-group-index=\"' + gIndex + '\"]'));\n            for (let i = 0; i < workCells.length; i++) {\n              const date = workCells[i].getAttribute('data-date');\n              if (date < tdDate) {\n                this.morePopup.relateTo = workCells[i];\n              }\n            }\n          }\n        }\n      } else {\n        this.morePopup.relateTo = closest(target, '.' + WORK_CELLS_CLASS);\n      }\n    }\n    this.parent.renderTemplates();\n    const eventProp = {\n      type: 'EventContainer',\n      cancel: false,\n      element: this.morePopup.element,\n      data: data\n    };\n    this.parent.trigger(popupOpen, eventProp, popupArgs => {\n      if (!popupArgs.cancel) {\n        this.morePopup.show();\n      }\n    });\n  }\n  saveClick(event) {\n    this.applyFormValidation();\n    this.dialogEvent = event;\n    this.isCrudAction = true;\n    this.quickPopupHide();\n  }\n  detailsClick(event) {\n    const subjectEle = this.quickPopup.element.querySelector('.' + SUBJECT_CLASS);\n    if (subjectEle && subjectEle.value !== '') {\n      extend(this.parent.activeCellsData, {\n        subject: subjectEle.value\n      });\n    }\n    this.dialogEvent = event;\n    this.isCrudAction = false;\n    this.fieldValidator.destroyToolTip();\n    this.quickPopupHide();\n    this.parent.eventWindow.openEditor(this.parent.activeCellsData, 'Add');\n  }\n  editClick(event) {\n    this.dialogEvent = event;\n    this.quickPopupHide(true);\n    const data = this.parent.activeEventData.event;\n    this.parent.currentAction = 'EditSeries';\n    if (!isNullOrUndefined(data[this.parent.eventFields.recurrenceRule])) {\n      this.parent.currentAction = 'EditOccurrence';\n      this.openRecurrenceAlert();\n    } else {\n      this.parent.eventWindow.openEditor(data, this.parent.currentAction);\n    }\n  }\n  deleteClick(event) {\n    this.dialogEvent = event;\n    this.quickPopupHide(true);\n    this.parent.currentAction = 'Delete';\n    if (this.parent.activeEventData.event[this.parent.eventFields.recurrenceRule]) {\n      this.openRecurrenceAlert();\n    } else {\n      this.openDeleteAlert();\n    }\n  }\n  updateMoreEventContent() {\n    if (this.morePopup.element.classList.contains('e-popup-close')) {\n      return;\n    }\n    const moreEventContentEle = this.morePopup.element.querySelector('.' + MORE_EVENT_CONTENT_CLASS);\n    if (moreEventContentEle) {\n      remove(moreEventContentEle);\n    }\n    const dateElement = this.morePopup.element.querySelector('.' + MORE_EVENT_HEADER_DATE_CLASS);\n    const startDate = new Date(parseInt(dateElement.getAttribute('data-date'), 10));\n    const endDate = new Date(parseInt(dateElement.getAttribute('data-end-date'), 10));\n    const groupIndex = dateElement.getAttribute('data-group-index');\n    let data;\n    let groupOrder;\n    if (!isNullOrUndefined(groupIndex)) {\n      data = this.parent.resourceBase.lastResourceLevel[parseInt(groupIndex, 10)];\n      groupOrder = data.groupOrder;\n    }\n    const events = this.parent.eventBase.filterEvents(startDate, endDate, this.parent.eventsProcessed, data);\n    const moreElement = this.createMoreEventList(events, groupOrder, groupIndex);\n    this.morePopup.element.querySelector('.' + MORE_EVENT_POPUP_CLASS).appendChild(moreElement);\n  }\n  closeClick(event) {\n    this.dialogEvent = event;\n    if (this.parent.currentView === 'Year' && this.parent.activeCellsData && this.parent.activeCellsData.element) {\n      this.parent.selectCell(this.parent.activeCellsData.element);\n    }\n    this.quickPopupHide();\n    this.morePopup.hide();\n  }\n  dialogButtonClick(event) {\n    this.dialogEvent = event;\n    this.quickDialog.hide();\n    const target = event.target;\n    const cancelBtn = this.quickDialog.element.querySelector('.' + QUICK_DIALOG_ALERT_CANCEL);\n    const eventData = this.parent.activeEventData.event;\n    if (target.classList.contains(QUICK_DIALOG_OCCURRENCE_CLASS)) {\n      this.parent.currentAction = this.parent.currentAction === 'Delete' ? 'DeleteOccurrence' : 'EditOccurrence';\n      switch (this.parent.currentAction) {\n        case 'EditOccurrence':\n          this.parent.eventWindow.openEditor(eventData, this.parent.currentAction);\n          break;\n        case 'DeleteOccurrence':\n          this.parent.crudModule.deleteEvent(eventData, this.parent.currentAction);\n          break;\n      }\n    } else if (target.classList.contains(QUICK_DIALOG_FOLLOWING_EVENTS_CLASS)) {\n      this.parent.currentAction = this.parent.currentAction === 'Delete' ? 'DeleteFollowingEvents' : 'EditFollowingEvents';\n      switch (this.parent.currentAction) {\n        case 'EditFollowingEvents':\n          this.parent.eventWindow.openEditor(eventData, this.parent.currentAction);\n          break;\n        case 'DeleteFollowingEvents':\n          this.parent.crudModule.deleteEvent(eventData, this.parent.currentAction);\n          break;\n      }\n    } else if (target.classList.contains(QUICK_DIALOG_SERIES_CLASS)) {\n      this.parent.currentAction = this.parent.currentAction === 'Delete' ? 'DeleteSeries' : 'EditSeries';\n      switch (this.parent.currentAction) {\n        case 'EditSeries':\n          this.parent.eventWindow.openEditor(this.parent.eventBase.getParentEvent(eventData, true), this.parent.currentAction);\n          break;\n        case 'DeleteSeries':\n          this.parent.crudModule.deleteEvent(eventData, this.parent.currentAction);\n          break;\n      }\n    } else if (target.classList.contains(QUICK_DIALOG_DELETE_CLASS)) {\n      this.parent.crudModule.deleteEvent(eventData, this.parent.currentAction);\n    } else if (!cancelBtn.classList.contains(DISABLE_CLASS) && (target.classList.contains(QUICK_DIALOG_ALERT_OK) || target.classList.contains(QUICK_DIALOG_ALERT_CANCEL) && !cancelBtn.classList.contains(QUICK_DIALOG_CANCEL_CLASS))) {\n      this.parent.uiStateValues.isIgnoreOccurrence = target.classList.contains(QUICK_DIALOG_ALERT_CANCEL);\n      this.parent.eventWindow.eventSave(event, this.l10n.getConstant('ok'));\n    }\n  }\n  updateTapHoldEventPopup(target) {\n    const selectedElements = this.parent.eventBase.getSelectedEventElements(target);\n    this.parent.activeEventData = this.parent.eventBase.getSelectedEvents();\n    if (selectedElements.length > 0) {\n      const eventObj = this.parent.eventBase.getEventByGuid(selectedElements[0].getAttribute('data-guid'));\n      const titleContent = selectedElements.length === 1 ? eventObj[this.parent.eventFields.subject] || this.l10n.getConstant('noTitle') : '(' + selectedElements.length + ')' + '&nbsp;' + this.l10n.getConstant('selectedItems');\n      this.quickPopup.element.querySelector('.' + SUBJECT_CLASS).innerHTML = titleContent;\n      if (selectedElements.length > 1) {\n        addClass([this.quickPopup.element.querySelector('.' + EDIT_ICON_CLASS)], HIDDEN_CLASS);\n      } else {\n        removeClass([this.quickPopup.element.querySelector('.' + EDIT_ICON_CLASS)], HIDDEN_CLASS);\n      }\n    } else {\n      this.parent.selectedElements = [];\n      this.quickPopupHide();\n    }\n  }\n  getTimezone(event) {\n    let zoneDetails = '';\n    zoneDetails += event[this.parent.eventFields.startTimezone] || '';\n    zoneDetails += zoneDetails === '' ? '' : ' - ';\n    zoneDetails += event[this.parent.eventFields.endTimezone] || '';\n    return zoneDetails;\n  }\n  getRecurrenceSummary(event) {\n    const recurrenceEditor = this.parent.eventWindow.getRecurrenceEditorInstance();\n    if (recurrenceEditor) {\n      const ruleSummary = recurrenceEditor.getRuleSummary(event[this.parent.eventFields.recurrenceRule]);\n      return ruleSummary.charAt(0).toUpperCase() + ruleSummary.slice(1);\n    }\n    return '';\n  }\n  getDateFormat(date, skeletonString) {\n    return capitalizeFirstWord(this.parent.globalize.formatDate(date, {\n      skeleton: skeletonString,\n      calendar: this.parent.getCalendarMode()\n    }), 'single');\n  }\n  getDataFromTarget(target) {\n    if (target.classList.contains(APPOINTMENT_CLASS)) {\n      return this.parent.activeEventData.event;\n    }\n    // Deprecated cells data in quick popups\n    const eventObj = {\n      startTime: this.parent.activeCellsData.startTime,\n      endTime: this.parent.activeCellsData.endTime,\n      isAllDay: this.parent.activeCellsData.isAllDay,\n      groupIndex: this.parent.activeCellsData.groupIndex\n    };\n    const cellsData = this.parent.activeCellsData;\n    this.parent.eventWindow.convertToEventData(cellsData, eventObj);\n    return eventObj;\n  }\n  beforeQuickDialogClose(e) {\n    const args = {\n      event: e.event || this.dialogEvent,\n      type: isNullOrUndefined(this.parent.activeEventData.event) ? 'ValidationAlert' : !isNullOrUndefined(this.parent.activeEventData.event[this.parent.eventFields.recurrenceRule]) ? 'RecurrenceAlert' : 'DeleteAlert',\n      cancel: false,\n      data: this.parent.activeEventData.event,\n      element: this.quickDialog.element\n    };\n    this.parent.trigger(popupClose, args, popupCloseArgs => {\n      if (!popupCloseArgs.cancel) {\n        this.parent.eventBase.focusElement(true);\n      }\n    });\n  }\n  beforeQuickPopupOpen(target) {\n    this.parent.renderTemplates();\n    const isEventPopup = this.quickPopup.element.querySelector('.' + EVENT_POPUP_CLASS);\n    const popupType = this.parent.isAdaptive ? isEventPopup ? 'ViewEventInfo' : 'EditEventInfo' : 'QuickInfo';\n    const eventProp = {\n      type: popupType,\n      cancel: false,\n      data: extend({}, this.getDataFromTarget(target), null, true),\n      target: target,\n      element: this.quickPopup.element\n    };\n    this.parent.trigger(popupOpen, eventProp, popupArgs => {\n      if (popupArgs.cancel) {\n        this.quickPopupHide();\n        this.destroyPopupButtons('quickPopup');\n        if (popupArgs.element.classList.contains(POPUP_OPEN)) {\n          this.quickPopupClose();\n        }\n        removeChildren(this.quickPopup.element);\n        this.isMultipleEventSelect = false;\n      } else {\n        const display = this.quickPopup.element.style.display;\n        this.quickPopup.element.style.display = 'block';\n        if (this.parent.isAdaptive) {\n          this.quickPopup.element.removeAttribute('style');\n          this.quickPopup.element.style.display = 'block';\n          this.quickPopup.element.style.height = formatUnit(popupType === 'EditEventInfo' ? 65 : window.innerHeight);\n        } else {\n          this.quickPopup.offsetX = 10;\n          this.quickPopup.collision = {\n            X: this.parent.enableRtl ? 'flip' : 'none',\n            Y: 'fit'\n          };\n          this.quickPopup.position = {\n            X: this.parent.enableRtl ? 'left' : 'right',\n            Y: this.parent.enableRtl ? 'bottom' : 'top'\n          };\n          this.quickPopup.dataBind();\n          this.quickPopup.refreshPosition(null, true);\n          const collide = isCollide(this.quickPopup.element, this.parent.element);\n          if (collide.indexOf(this.parent.enableRtl ? 'left' : 'right') > -1) {\n            this.quickPopup.offsetX = -target.offsetWidth - 10 - this.quickPopup.element.offsetWidth;\n            this.quickPopup.dataBind();\n            const leftCollide = isCollide(this.quickPopup.element, this.parent.element);\n            if (leftCollide.indexOf('left') > -1) {\n              this.quickPopup.position = {\n                X: 'center',\n                Y: 'center'\n              };\n              this.quickPopup.collision = {\n                X: 'fit',\n                Y: 'fit'\n              };\n              this.quickPopup.offsetX = -(this.quickPopup.element.offsetWidth / 2);\n              this.quickPopup.dataBind();\n            }\n          }\n          if (this.parent.virtualScrollModule && (collide.indexOf('top') > -1 || collide.indexOf('bottom') > -1)) {\n            const element = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS + ' table');\n            const translateY = getTranslateY(element);\n            this.quickPopup.offsetY = translateY;\n            this.quickPopup.dataBind();\n          }\n        }\n        if (isEventPopup) {\n          this.applyEventColor();\n        }\n        this.quickPopup.element.style.display = display;\n        this.quickPopup.dataBind();\n        this.quickPopup.show();\n      }\n    });\n  }\n  applyEventColor() {\n    let colorField = '';\n    if (this.parent.currentView === 'Agenda' || this.parent.currentView === 'MonthAgenda') {\n      colorField = this.parent.enableRtl ? 'border-right-color' : 'border-left-color';\n    } else {\n      colorField = 'background-color';\n    }\n    let color = this.parent.activeEventData.element.style[colorField];\n    if (color === '') {\n      return;\n    }\n    let colorEle = this.quickPopup.element.querySelector('.' + POPUP_HEADER_CLASS);\n    const footerEle = this.quickPopup.element.querySelector('.' + POPUP_FOOTER_CLASS);\n    if (footerEle && footerEle.offsetParent) {\n      colorEle = this.quickPopup.element.querySelector('.' + SUBJECT_CLASS);\n      if (colorEle) {\n        colorEle.style.borderLeftColor = color;\n        color = `rgba(${color.match(/\\d+/g).join()},0.3)`;\n      }\n    }\n    if (colorEle) {\n      colorEle.style.backgroundColor = color;\n    }\n  }\n  quickPopupOpen() {\n    if (this.parent.isAdaptive) {\n      this.quickPopup.element.style.top = '0px';\n      return;\n    }\n    if (this.quickPopup.element.querySelector('.' + CELL_POPUP_CLASS)) {\n      const subjectElement = this.quickPopup.element.querySelector('.' + SUBJECT_CLASS);\n      if (subjectElement) {\n        subjectElement.focus();\n      }\n    } else {\n      const editElement = this.quickPopup.element.querySelector('.' + EDIT_EVENT_CLASS);\n      if (editElement) {\n        editElement.focus();\n      }\n      const editIcon = this.quickPopup.element.querySelector('.' + EDIT_CLASS);\n      if (editIcon) {\n        editIcon.focus();\n      }\n    }\n  }\n  quickPopupClose() {\n    this.parent.eventBase.focusElement();\n    this.quickPopup.relateTo = WORK_CELLS_CLASS;\n    this.fieldValidator.destroyToolTip();\n    if (this.quickPopup.element.querySelectorAll('.e-formvalidator').length) {\n      this.fieldValidator.destroy();\n    }\n    this.destroyPopupButtons('quickPopup');\n    removeChildren(this.quickPopup.element);\n  }\n  morePopupOpen() {\n    if (this.parent.isAdaptive) {\n      this.morePopup.element.style.top = '0px';\n      this.morePopup.element.style.left = '0px';\n      this.morePopup.element.style.height = formatUnit(window.innerHeight);\n      return;\n    }\n    this.morePopup.element.querySelector('.' + MORE_EVENT_HEADER_DATE_CLASS).focus();\n    this.morePopup.refreshPosition();\n  }\n  morePopupClose() {\n    const moreWrapper = this.parent.element.querySelector('.' + MORE_EVENT_WRAPPER_CLASS);\n    if (moreWrapper) {\n      remove(moreWrapper);\n    }\n  }\n  popupClose(event) {\n    this.dialogEvent = event;\n    this.isCrudAction = false;\n    this.quickPopupHide(true);\n  }\n  quickPopupHide(hideAnimation) {\n    if (!this.quickPopup.element.classList.contains(POPUP_OPEN)) {\n      return;\n    }\n    const isCellPopup = this.quickPopup.element.querySelector('.' + CELL_POPUP_CLASS);\n    let popupData;\n    if (isCellPopup) {\n      const formvalidator = this.quickPopup.element.querySelector('.e-formvalidator');\n      if (this.isCrudAction && formvalidator && !formvalidator.ej2_instances[0].validate()) {\n        return;\n      }\n      const fields = this.parent.eventFields;\n      const saveObj = this.parent.eventWindow.getObjectFromFormData(POPUP_WRAPPER_CLASS);\n      this.parent.eventWindow.setDefaultValueToObject(saveObj);\n      saveObj[fields.id] = this.parent.eventBase.getEventMaxID();\n      saveObj[fields.startTime] = this.parent.activeCellsData.startTime;\n      saveObj[fields.endTime] = this.parent.activeCellsData.endTime;\n      saveObj[fields.isAllDay] = this.parent.activeCellsData.isAllDay;\n      if (this.parent.resourceBase) {\n        this.parent.resourceBase.setResourceValues(saveObj);\n      }\n      popupData = saveObj;\n    } else {\n      popupData = this.parent.activeEventData.event;\n    }\n    const isEventPopup = this.quickPopup.element.querySelector('.' + EVENT_POPUP_CLASS);\n    const args = {\n      event: this.dialogEvent,\n      type: this.parent.isAdaptive ? isEventPopup ? 'ViewEventInfo' : 'EditEventInfo' : 'QuickInfo',\n      cancel: false,\n      data: popupData,\n      element: this.quickPopup.element,\n      target: isCellPopup ? this.parent.activeCellsData.element : this.parent.activeEventData.element\n    };\n    this.parent.trigger(popupClose, args, popupCloseArgs => {\n      if (!popupCloseArgs.cancel) {\n        if (this.quickPopup.element.classList.contains('e-popup-open')) {\n          if (isCellPopup && this.isCrudAction) {\n            this.parent.currentAction = 'Add';\n            this.parent.crudModule.addEvent(popupCloseArgs.data);\n          }\n          if (hideAnimation) {\n            const animation = this.quickPopup.hideAnimation;\n            this.quickPopup.hideAnimation = null;\n            this.quickPopup.hide();\n            this.quickPopup.hideAnimation = animation;\n          } else {\n            this.quickPopup.hide();\n          }\n          this.isMultipleEventSelect = false;\n          this.isCrudAction = false;\n        }\n      }\n    });\n  }\n  navigationClick(e) {\n    const navigateEle = closest(e.target, '.' + NAVIGATE_CLASS);\n    if (!isNullOrUndefined(navigateEle)) {\n      const date = this.parent.getDateFromElement(e.currentTarget);\n      if (!isNullOrUndefined(date)) {\n        this.closeClick(e);\n        this.parent.setProperties({\n          selectedDate: date\n        }, true);\n        this.parent.changeView(this.parent.getNavigateView(), e);\n      }\n    }\n  }\n  documentClick(e) {\n    const target = e.event.target;\n    const classNames = '.' + POPUP_WRAPPER_CLASS + ',.' + HEADER_CELLS_CLASS + ',.' + ALLDAY_CELLS_CLASS + ',.' + WORK_CELLS_CLASS + ',.' + APPOINTMENT_CLASS + ',.e-popup';\n    const popupWrap = this.parent.element.querySelector('.' + POPUP_WRAPPER_CLASS);\n    if (popupWrap && popupWrap.childElementCount > 0 && !closest(target, classNames) || !closest(target, classNames)) {\n      this.quickPopupHide();\n      this.parent.removeNewEventElement();\n    }\n    const tar = this.parent.element.querySelector('.' + INLINE_SUBJECT_CLASS);\n    if (tar && tar !== target && this.parent.allowInline) {\n      this.parent.inlineModule.documentClick();\n    }\n    if (closest(target, '.' + APPOINTMENT_CLASS + ',.' + HEADER_CELLS_CLASS)) {\n      this.parent.removeNewEventElement();\n    }\n    if (!closest(target, '.' + MORE_POPUP_WRAPPER_CLASS) && target.classList && !target.classList.contains(MORE_INDICATOR_CLASS) && !closest(target, '.' + POPUP_OPEN) && !closest(target, '.' + WORK_CELLS_CLASS)) {\n      this.morePopup.hide();\n    }\n  }\n  onClosePopup(event) {\n    if (!isNullOrUndefined(event)) {\n      this.dialogEvent = event;\n    }\n    this.quickPopupHide();\n    this.parent.eventBase.focusElement();\n  }\n  addEventListener() {\n    this.parent.on(cellClick, this.cellClick, this);\n    this.parent.on(eventClick, this.eventClick, this);\n    this.parent.on(documentClick, this.documentClick, this);\n    this.parent.on(dataReady, this.updateMoreEventContent, this);\n  }\n  removeEventListener() {\n    this.parent.off(cellClick, this.cellClick);\n    this.parent.off(eventClick, this.eventClick);\n    this.parent.off(documentClick, this.documentClick);\n    this.parent.off(dataReady, this.updateMoreEventContent);\n  }\n  destroyPopupButtons(popupName) {\n    const popup = popupName === 'quickPopup' ? this.quickPopup : this.morePopup;\n    const buttonCollections = [].slice.call(popup.element.querySelectorAll('.e-control.e-btn'));\n    for (const button of buttonCollections) {\n      const instance = button.ej2_instances[0];\n      if (instance) {\n        instance.destroy();\n      }\n    }\n  }\n  refreshQuickDialog() {\n    this.destroyQuickDialog();\n    this.renderQuickDialog();\n  }\n  refreshQuickPopup() {\n    this.destroyQuickPopup();\n    this.renderQuickPopup();\n  }\n  refreshMorePopup() {\n    this.destroyMorePopup();\n    this.renderMorePopup();\n  }\n  destroyQuickDialog() {\n    if (this.quickDialog.element) {\n      this.quickDialog.destroy();\n      remove(this.quickDialog.element);\n      this.quickDialog = null;\n    }\n  }\n  destroyQuickPopup() {\n    if (this.quickPopup.element) {\n      this.destroyPopupButtons('quickPopup');\n      this.quickPopup.destroy();\n      remove(this.quickPopup.element);\n      this.quickPopup = null;\n    }\n  }\n  destroyMorePopup() {\n    if (this.morePopup.element) {\n      this.destroyPopupButtons('morePopup');\n      this.morePopup.destroy();\n      remove(this.morePopup.element);\n      this.morePopup = null;\n    }\n  }\n  destroy() {\n    if (this.quickPopup.element.querySelectorAll('.e-formvalidator').length) {\n      this.fieldValidator.destroy();\n    }\n    this.removeEventListener();\n    this.destroyQuickPopup();\n    this.destroyMorePopup();\n    this.destroyQuickDialog();\n    this.parent = null;\n    this.l10n = null;\n    this.isCrudAction = null;\n    this.fieldValidator = null;\n    this.isMultipleEventSelect = null;\n  }\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Tooltip for Schedule\n */\nclass EventTooltip {\n  constructor(parent) {\n    this.parent = parent;\n    this.tooltipObj = new Tooltip({\n      animation: {\n        close: {\n          effect: 'FadeOut'\n        }\n      },\n      content: 'No title',\n      position: 'BottomRight',\n      offsetY: 10,\n      mouseTrail: this.parent.isAdaptive ? false : true,\n      showTipPointer: false,\n      cssClass: this.parent.cssClass + ' ' + EVENT_TOOLTIP_ROOT_CLASS,\n      target: this.getTargets(),\n      beforeRender: this.onBeforeRender.bind(this),\n      beforeClose: this.onBeforeClose.bind(this),\n      enableRtl: this.parent.enableRtl\n    });\n    this.tooltipObj.appendTo(this.parent.element);\n  }\n  getTargets() {\n    const targets = [];\n    if (this.parent.activeViewOptions.group.headerTooltipTemplate) {\n      targets.push('.' + RESOURCE_CELLS_CLASS);\n    }\n    if (this.parent.eventSettings.enableTooltip) {\n      targets.push('.' + APPOINTMENT_CLASS);\n    }\n    return targets.join(',');\n  }\n  onBeforeRender(args) {\n    if (!isNullOrUndefined(args.target.getAttribute('data-tooltip-id'))) {\n      return;\n    }\n    if (args.target.classList.contains(RESOURCE_CELLS_CLASS) && this.parent.activeViewOptions.group.resources.length > 0) {\n      let resCollection;\n      if (this.parent.activeView.isTimelineView()) {\n        const index = parseInt(args.target.getAttribute('data-group-index'), 10);\n        resCollection = this.parent.resourceBase.lastResourceLevel[index];\n      } else {\n        const rowIndex = args.target.parentNode.sectionRowIndex;\n        const cellIndex = args.target.cellIndex;\n        resCollection = this.parent.activeView.getColumnLevels()[rowIndex][cellIndex];\n      }\n      const data = {\n        resource: resCollection.resource,\n        resourceData: resCollection.resourceData\n      };\n      const contentContainer = createElement('div');\n      const templateId = this.parent.element.id + '_headerTooltipTemplate';\n      const tooltipTemplate = [].slice.call(this.parent.getHeaderTooltipTemplate()(data, this.parent, 'headerTooltipTemplate', templateId, false));\n      append(tooltipTemplate, contentContainer);\n      this.setContent(contentContainer);\n      this.parent.renderTemplates();\n      return;\n    }\n    const record = this.parent.eventBase.getEventByGuid(args.target.getAttribute('data-guid'));\n    if (isNullOrUndefined(record)) {\n      return;\n    }\n    if (!isNullOrUndefined(this.parent.eventSettings.tooltipTemplate)) {\n      const contentContainer = createElement('div');\n      const templateId = this.parent.element.id + '_tooltipTemplate';\n      const tooltipTemplate = [].slice.call(this.parent.getEventTooltipTemplate()(record, this.parent, 'tooltipTemplate', templateId, false));\n      append(tooltipTemplate, contentContainer);\n      this.setContent(contentContainer);\n    } else {\n      const globalize = this.parent.globalize;\n      const fields = this.parent.eventFields;\n      const eventStart = new Date('' + record[fields.startTime]);\n      let eventEnd = new Date('' + record[fields.endTime]);\n      eventEnd = eventEnd.getHours() === 0 && eventEnd.getMinutes() === 0 ? new Date(eventEnd.setMilliseconds(-1000)) : eventEnd;\n      const startDate = resetTime(new Date('' + eventStart));\n      const endDate = resetTime(new Date('' + eventEnd));\n      const tooltipSubject = record[fields.subject] || this.parent.eventSettings.fields.subject.default || this.parent.localeObj.getConstant('addTitle');\n      const tooltipLocation = !isNullOrUndefined(record[fields.location]) ? record[fields.location] : '';\n      let startMonthDate = '';\n      let startMonthYearDate = '';\n      let endMonthYearDate = '';\n      startMonthDate = globalize.formatDate(eventStart, {\n        type: 'date',\n        skeleton: 'MMMd',\n        calendar: this.parent.getCalendarMode()\n      });\n      startMonthYearDate = globalize.formatDate(eventStart, {\n        type: 'date',\n        skeleton: 'medium',\n        calendar: this.parent.getCalendarMode()\n      });\n      endMonthYearDate = globalize.formatDate(eventEnd, {\n        type: 'date',\n        skeleton: 'medium',\n        calendar: this.parent.getCalendarMode()\n      });\n      startMonthDate = capitalizeFirstWord(startMonthDate, 'single');\n      startMonthYearDate = capitalizeFirstWord(startMonthYearDate, 'single');\n      endMonthYearDate = capitalizeFirstWord(endMonthYearDate, 'single');\n      const skeleton = 'short';\n      const startTime = globalize.formatDate(eventStart, {\n        type: 'time',\n        skeleton: skeleton,\n        calendar: this.parent.getCalendarMode()\n      });\n      const endTime = globalize.formatDate(eventEnd, {\n        type: 'time',\n        skeleton: skeleton,\n        calendar: this.parent.getCalendarMode()\n      });\n      let tooltipDetails;\n      if (startDate.getTime() === endDate.getTime()) {\n        tooltipDetails = globalize.formatDate(eventStart, {\n          type: 'date',\n          skeleton: 'long',\n          calendar: this.parent.getCalendarMode()\n        });\n        tooltipDetails = capitalizeFirstWord(tooltipDetails, 'single');\n      } else {\n        tooltipDetails = startDate.getFullYear() === endDate.getFullYear() ? startMonthDate + ' - ' + endMonthYearDate : startMonthYearDate + ' - ' + endMonthYearDate;\n      }\n      const tooltipTime = record[fields.isAllDay] ? this.parent.localeObj.getConstant('allDay') : startTime + ' - ' + endTime;\n      const content = '<div><div class=\"e-subject\">' + tooltipSubject + '</div>' + '<div class=\"e-location\">' + tooltipLocation + '</div>' + '<div class=\"e-details\">' + tooltipDetails + '</div>' + '<div class=\"e-all-day\">' + tooltipTime + '</div></div>';\n      this.setContent(content);\n    }\n    this.parent.renderTemplates();\n  }\n  onBeforeClose() {\n    this.parent.resetTemplates(['tooltipTemplate', 'headerTooltipTemplate']);\n  }\n  setContent(content) {\n    this.tooltipObj.setProperties({\n      content: content\n    }, true);\n  }\n  close() {\n    this.tooltipObj.close();\n  }\n  destroy() {\n    this.tooltipObj.destroy();\n    addClass([this.parent.element], 'e-control');\n    this.tooltipObj = null;\n    this.parent = null;\n  }\n}\nvar __decorate$1 = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nconst HEADER = 'e-editor';\nconst INPUTWARAPPER = 'e-input-wrapper';\nconst INPUTWARAPPERSIDE = 'e-input-wrapper-side';\nconst REPEATELEMENT = 'e-repeat-element';\nconst REPEATINTERVAL = 'e-repeat-interval';\nconst INTERVALCLASS = 'e-interval';\nconst DAYWRAPPER = 'e-days';\nconst WEEKWRAPPER = 'e-non-week';\nconst WEEKPOSITION = 'e-week-position';\nconst DAYPOSITION = 'e-day-position';\nconst YEAREXPANDERWRAPPER = 'e-year-expander';\nconst YEAREXPANDERELEMENT = 'e-year-expander-element';\nconst MONETHEXPANDERWRAPPER = 'e-month-expander';\nconst MONETHEXPANDWRAPPER = 'e-month-expand-wrapper';\nconst MONTHEXPANDERELEMENT = 'e-month-expander-element';\nconst MONTHEXPANDERCHECKBOXWRAPPER = 'e-month-expander-checkbox-wrapper';\nconst FORMLEFT = 'e-form-left';\nconst FORMRIGHT = 'e-form-right';\nconst MONTHDAYWRAPPER = 'e-month-day';\nconst MONTHEXPANNDERELEM = 'e-month-expander-wrapper';\nconst MONTHPOS = 'e-month-pos';\nconst MONTHWEEK = 'e-month-week';\nconst ENDON = 'e-end-on';\nconst MONTHEXPANDERLABEL = 'e-month-expander-label';\nconst WEEKEXPANDERLABEL = 'e-week-expander-label';\nconst ENDONLABEL = 'e-end-on-label';\nconst ENDONLEFT = 'e-end-on-left';\nconst MONTHDAYELEMENT = 'e-monthday-element';\nconst ENDONELEMENT = 'e-end-on-element';\nconst ENDONDATE = 'e-end-on-date';\nconst UNTILDATE = 'e-until-date';\nconst ENDONCOUNTWRAPPER = 'e-end-on-count';\nconst ENDONCOUNT = 'e-recurrence-count';\nconst HIDEWRAPPER = 'e-hide-recurrence-element';\nconst RTLCLASS = 'e-rtl';\nconst PRIMARY = 'e-primary';\nconst ACTIVE = 'e-active';\nconst RECURRENCETABLE = 'e-recurrence-table';\nconst REPEATCONTENT = 'e-repeat-content';\nconst REPEATCONTENTWRAPPER = 'e-repeat-content-wrapper';\nconst NONE = 'none';\nconst DAILY = 'daily';\nconst WEEKLY = 'weekly';\nconst MONTHLY = 'monthly';\nconst YEARLY = 'yearly';\nconst NEVER = 'never';\nconst UNTIL$1 = 'until';\nconst COUNT = 'count';\nconst TEXTFIELD = 'text';\nconst VALUEFIELD = 'value';\nconst LAST = 'last';\nconst REPEAT = 'repeat';\nconst REPEATEVERY = 'repeatEvery';\nconst ON$1 = 'on';\nconst END = 'end';\nconst RADIOLABEL = 'onDay';\nconst RULEUNTIL = 'UNTIL';\nconst RULEBYDAY = 'BYDAY';\nconst RULEBYMONTHDAY = 'BYMONTHDAY';\nconst RULEBYMONTH = 'BYMONTH';\nconst RULEINTERVAL = 'INTERVAL';\nconst RULECOUNT = 'COUNT';\nconst RULESETPOS = 'BYSETPOS';\nconst RULEFREQ = 'FREQ';\nconst RULEDAILY = 'DAILY';\nconst RULEWEEKLY = 'WEEKLY';\nconst RULEMONTHLY = 'MONTHLY';\nconst RULEYEARLY = 'YEARLY';\nconst RULESUNDAY = 'SU';\nconst RULEMONDAY = 'MO';\nconst RULETUESDAY = 'TU';\nconst RULEWEDNESDAY = 'WE';\nconst RULETHURSDAY = 'TH';\nconst RULEFRIDAY = 'FR';\nconst RULESATURDAY = 'SA';\nconst KEYSUNDAY = 'sun';\nconst KEYMONDAY = 'mon';\nconst KEYTUESDAY = 'tue';\nconst KEYWEDNESDAY = 'wed';\nconst KEYTHURSDAY = 'thu';\nconst KEYFRIDAY = 'fri';\nconst KEYSATURDAY = 'sat';\nconst EQUAL = '=';\nconst SEMICOLON = ';';\nconst COMMA = ',';\nconst FIRST = 'first';\nconst SECOND = 'second';\nconst THIRD = 'third';\nconst FOURTH = 'fourth';\nconst contentType = {\n  none: '',\n  daily: 'days',\n  weekly: 'weeks',\n  monthly: 'months',\n  yearly: 'years'\n};\nconst valueData = {\n  'sun': RULESUNDAY,\n  'mon': RULEMONDAY,\n  'tue': RULETUESDAY,\n  'wed': RULEWEDNESDAY,\n  'thu': RULETHURSDAY,\n  'fri': RULEFRIDAY,\n  'sat': RULESATURDAY\n};\nconst neverClassList = [DAYWRAPPER, WEEKWRAPPER, ENDON, INTERVALCLASS, YEAREXPANDERWRAPPER, MONETHEXPANDERWRAPPER];\nconst weekClassList = [WEEKWRAPPER];\nconst monthClassList = [DAYWRAPPER, YEAREXPANDERWRAPPER];\nconst yearClassList = [DAYWRAPPER];\nconst dailyClassList = [DAYWRAPPER, WEEKWRAPPER, YEAREXPANDERWRAPPER, MONETHEXPANDERWRAPPER];\nconst noEndClassList = [ENDONDATE, ENDONCOUNTWRAPPER];\nconst endOnCountClassList = [ENDONDATE];\nconst endOnDateClassList = [ENDONCOUNTWRAPPER];\n/**\n * Represents the RecurrenceEditor component.\n * ```html\n * <div id=\"recurrence\"></div>\n * ```\n * ```typescript\n * <script>\n *   var recObj = new RecurrenceEditor();\n *   recObj.appendTo(\"#recurrence\");\n * </script>\n * ```\n */\nlet RecurrenceEditor = class RecurrenceEditor extends Component {\n  /**\n   * Constructor for creating the widget\n   *\n   * @param {RecurrenceEditorModel} options Accepts the recurrence editor model properties to initiate the rendering\n   * @param {string | HTMLElement} element Accepts the DOM element reference\n   */\n  constructor(options, element) {\n    super(options, element);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this.defaultLocale = {\n      none: 'None',\n      daily: 'Daily',\n      weekly: 'Weekly',\n      monthly: 'Monthly',\n      month: 'Month',\n      yearly: 'Yearly',\n      never: 'Never',\n      until: 'Until',\n      count: 'Count',\n      first: 'First',\n      second: 'Second',\n      third: 'Third',\n      fourth: 'Fourth',\n      last: 'Last',\n      repeat: 'Repeat',\n      repeatEvery: 'Repeat every',\n      on: 'Repeat On',\n      end: 'End',\n      onDay: 'Day',\n      days: 'Day(s)',\n      weeks: 'Week(s)',\n      months: 'Month(s)',\n      years: 'Year(s)',\n      every: 'every',\n      summaryTimes: 'time(s)',\n      summaryOn: 'on',\n      summaryUntil: 'until',\n      summaryRepeat: 'Repeats',\n      summaryDay: 'day(s)',\n      summaryWeek: 'week(s)',\n      summaryMonth: 'month(s)',\n      summaryYear: 'year(s)',\n      monthWeek: 'Month Week',\n      monthPosition: 'Month Position',\n      monthExpander: 'Month Expander',\n      yearExpander: 'Year Expander',\n      repeatInterval: 'Repeat Interval'\n    };\n    this.renderStatus = false;\n    this.dayButtons = [];\n    this.monthButtons = [];\n  }\n  startState(freq, endOn, startDate) {\n    this.showFormElement();\n    this.updateForm(freq);\n    this.freshOnEndForm();\n    this.updateEndOnForm(endOn);\n    this.selectMonthDay(startDate);\n    this.updateUntilDate(startDate);\n    this.onMonthDay.setProperties({\n      checked: true\n    });\n  }\n  preRender() {\n    this.localeObj = new L10n(this.getModuleName(), this.defaultLocale, this.locale);\n    this.calendarUtil = getCalendarUtil(this.calendarMode);\n  }\n  applyCustomClass(cssClass) {\n    if (cssClass) {\n      addClass([this.element], cssClass.split(' '));\n    }\n  }\n  initialize() {\n    addClass([this.element], 'e-' + this.getModuleName());\n    this.renderComponent();\n    if (!isNullOrUndefined(this.value) && this.value !== '') {\n      this.setRecurrenceRule(this.value);\n    } else {\n      if (!isNullOrUndefined(this.repeatType.value)) {\n        this.startState(this.repeatType.value.toString().toUpperCase(), NEVER, this.startDate);\n        this.updateForm(this.repeatType.value.toString());\n      }\n      if (this.selectedType > 0) {\n        this.setProperties({\n          value: this.getRecurrenceRule()\n        }, false);\n      }\n    }\n    this.applyCustomClass(this.cssClass);\n  }\n  triggerChangeEvent() {\n    if (this.renderStatus) {\n      const value = this.getRecurrenceRule();\n      this.trigger('change', {\n        value: value\n      }, args => this.setProperties({\n        value: args.value\n      }, false));\n    }\n  }\n  resetDayButton() {\n    const elements = [].slice.call(this.element.querySelectorAll('.' + DAYWRAPPER + ' button'));\n    elements.forEach(element => removeClass([element], [ACTIVE, PRIMARY]));\n  }\n  daySelection(dayIndex) {\n    this.resetDayButton();\n    const days = [0, 1, 2, 3, 4, 5, 6];\n    this.rotateArray(days, this.firstDayOfWeek);\n    const element = this.element.querySelector('.' + DAYWRAPPER + ' button[data-index=\"' + days.indexOf(dayIndex) + '\"]');\n    if (element) {\n      addClass([element], [ACTIVE, PRIMARY]);\n    }\n  }\n  rtlClass(status) {\n    if (status) {\n      addClass([this.element], RTLCLASS);\n    } else {\n      removeClass([this.element], RTLCLASS);\n    }\n  }\n  updateUntilDate(date) {\n    const tempDate = new Date(date.getTime());\n    tempDate.setDate(tempDate.getDate() + 60);\n    this.untilDateObj.setProperties({\n      value: tempDate\n    });\n  }\n  selectMonthDay(date) {\n    const weekday = [KEYSUNDAY, KEYMONDAY, KEYTUESDAY, KEYWEDNESDAY, KEYTHURSDAY, KEYFRIDAY, KEYSATURDAY];\n    this.monthDate.setProperties({\n      value: this.calendarUtil.getDate(date)\n    });\n    this.monthWeekDays.setProperties({\n      value: valueData[weekday[date.getDay()]]\n    });\n    this.monthValue.setProperties({\n      value: '' + this.calendarUtil.getMonth(date)\n    });\n    this.monthWeekPos.setProperties({\n      value: this.getDayPosition(date)\n    });\n    this.daySelection(date.getDay());\n  }\n  updateForm(state) {\n    this.repeatType.setProperties({\n      value: state\n    });\n    const end = this.element.querySelector('.' + ENDON);\n    if (state === DAILY) {\n      classList(end, [FORMLEFT], [FORMRIGHT]);\n    } else {\n      classList(end, [FORMRIGHT], [FORMLEFT]);\n    }\n    switch (state) {\n      case NONE:\n        neverClassList.forEach(className => addClass([this.element.querySelector('.' + className)], HIDEWRAPPER));\n        break;\n      case WEEKLY:\n        weekClassList.forEach(className => addClass([this.element.querySelector('.' + className)], HIDEWRAPPER));\n        break;\n      case MONTHLY:\n        monthClassList.forEach(className => addClass([this.element.querySelector('.' + className)], HIDEWRAPPER));\n        break;\n      case YEARLY:\n        yearClassList.forEach(className => addClass([this.element.querySelector('.' + className)], HIDEWRAPPER));\n        break;\n      case DAILY:\n        dailyClassList.forEach(className => addClass([this.element.querySelector('.' + className)], HIDEWRAPPER));\n        break;\n    }\n  }\n  updateEndOnForm(state) {\n    this.endType.setProperties({\n      value: state\n    });\n    switch (state) {\n      case NEVER:\n        noEndClassList.forEach(className => addClass([this.element.querySelector('.' + className)], HIDEWRAPPER));\n        break;\n      case UNTIL$1:\n        endOnDateClassList.forEach(className => addClass([this.element.querySelector('.' + className)], HIDEWRAPPER));\n        break;\n      case COUNT:\n        endOnCountClassList.forEach(className => addClass([this.element.querySelector('.' + className)], HIDEWRAPPER));\n        break;\n    }\n  }\n  freshOnEndForm() {\n    noEndClassList.forEach(className => {\n      const element = this.element.querySelector('.' + className);\n      if (element) {\n        removeClass([element], HIDEWRAPPER);\n      }\n    });\n  }\n  showFormElement() {\n    neverClassList.forEach(className => {\n      const hideElement = this.element.querySelector('.' + className);\n      if (hideElement) {\n        removeClass([hideElement], HIDEWRAPPER);\n      }\n    });\n  }\n  renderDropdowns() {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    this.repeatType = new DropDownList({\n      //set the data to dataSource property\n      dataSource: this.getRepeatData(),\n      floatLabelType: 'Always',\n      enableRtl: this.enableRtl,\n      index: this.selectedType,\n      fields: {\n        text: TEXTFIELD,\n        value: VALUEFIELD\n      },\n      placeholder: this.localeObj.getConstant(REPEAT),\n      htmlAttributes: {\n        'title': this.localeObj.getConstant(REPEAT)\n      },\n      change: args => {\n        self.setProperties({\n          selectedType: this.frequencies.indexOf(args.value)\n        }, false);\n        self.element.querySelector('.' + REPEATCONTENT).innerHTML = self.localeObj.getConstant(contentType[args.value]);\n        self.showFormElement();\n        self.updateForm(args.value);\n        self.resetFormValues();\n        self.triggerChangeEvent();\n      }\n    });\n    // set placeholder to DropDownList input element\n    this.repeatType.appendTo(this.element.querySelector('.' + REPEATELEMENT));\n    this.endType = new DropDownList({\n      dataSource: this.getEndData(),\n      popupWidth: this.getPopupWidth(),\n      enableRtl: this.enableRtl,\n      index: 1,\n      fields: {\n        text: TEXTFIELD,\n        value: VALUEFIELD\n      },\n      change: args => {\n        self.freshOnEndForm();\n        self.updateEndOnForm(args.value);\n        self.resetFormValues();\n        self.triggerChangeEvent();\n      }\n    });\n    this.endType.appendTo(this.element.querySelector('.' + ENDONELEMENT));\n    const renderDropDownList = dropDownData => {\n      return new DropDownList({\n        dataSource: dropDownData,\n        popupWidth: this.getPopupWidth(),\n        enableRtl: this.enableRtl,\n        fields: {\n          text: TEXTFIELD,\n          value: VALUEFIELD\n        },\n        index: 1,\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        change: args => {\n          self.onWeekDay.setProperties({\n            checked: true\n          });\n          self.resetFormValues();\n          self.triggerChangeEvent();\n        }\n      });\n    };\n    this.monthWeekPos = renderDropDownList(this.getMonthPosData());\n    this.monthWeekPos.appendTo(this.element.querySelector('.' + MONTHPOS));\n    this.monthWeekDays = renderDropDownList(this.getDayData('wide'));\n    this.monthWeekDays.appendTo(this.element.querySelector('.' + MONTHWEEK));\n    this.monthValue = new DropDownList({\n      dataSource: this.getMonthData(),\n      fields: {\n        text: TEXTFIELD,\n        value: VALUEFIELD\n      },\n      enableRtl: this.enableRtl,\n      index: 7,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      change: args => {\n        self.resetFormValues();\n        self.triggerChangeEvent();\n      }\n    });\n    this.monthValue.appendTo(this.element.querySelector('.' + YEAREXPANDERELEMENT));\n  }\n  setDefaultValue() {\n    const formelement = [].slice.call(this.element.querySelectorAll('.e-control .e-numerictextbox'));\n    for (const element of formelement) {\n      const instance = element.ej2_instances[0];\n      if (instance.element.classList.contains(REPEATINTERVAL)) {\n        instance.value = 1;\n        instance.dataBind();\n      } else if (instance.element.classList.contains(ENDONCOUNT)) {\n        instance.value = 10;\n        instance.dataBind();\n      }\n    }\n  }\n  resetFormValues() {\n    const recurreneElement = [].slice.call(this.element.querySelectorAll('.e-control [type=\"text\"]'));\n    for (const element of recurreneElement) {\n      let instance;\n      if (element.classList.contains('e-datepicker')) {\n        instance = element.ej2_instances[0];\n        if (instance.value) {\n          // eslint-disable-next-line no-self-assign\n          instance.value = instance.value;\n          instance.dataBind();\n        } else {\n          this.updateUntilDate(this.startDate);\n        }\n      } else if (element.classList.contains('e-dropdownlist')) {\n        instance = element.ej2_instances[0];\n        instance.index = instance.index || 0;\n        instance.dataBind();\n      } else if (element.classList.contains('e-numerictextbox')) {\n        instance = element.ej2_instances[0];\n        let value;\n        if (instance.element.classList.contains(REPEATINTERVAL)) {\n          value = 1;\n        } else if (instance.element.classList.contains(ENDONCOUNT)) {\n          value = 10;\n        } else {\n          value = this.startDate.getDate();\n        }\n        instance.value = instance.value || value;\n        instance.dataBind();\n      }\n    }\n  }\n  getPopupWidth() {\n    return Browser.isDevice ? '100%' : 'auto';\n  }\n  renderDatePickers() {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    this.untilDateObj = new DatePicker({\n      firstDayOfWeek: this.firstDayOfWeek,\n      enableRtl: this.enableRtl,\n      locale: this.locale,\n      min: this.minDate,\n      max: this.maxDate,\n      format: isNullOrUndefined(this.dateFormat) ? this.getFormat('dateFormats') : this.dateFormat,\n      change: args => {\n        if (args.value) {\n          self.triggerChangeEvent();\n        }\n      }\n    });\n    this.untilDateObj.appendTo(this.element.querySelector('.' + UNTILDATE));\n  }\n  getFormat(formatType) {\n    let format;\n    if (this.locale === 'en' || this.locale === 'en-US') {\n      format = getValue(formatType + '.short', getDefaultDateObject(this.getCalendarMode()));\n    } else {\n      format = getValue('main.' + '' + this.locale + '.dates.calendars.' + this.getCalendarMode() + '.' + formatType + '.short', cldrData);\n    }\n    return format;\n  }\n  dayButtonRender() {\n    const btns = [].slice.call(this.element.querySelectorAll('.' + DAYWRAPPER + ' button'));\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    for (const btn of btns) {\n      const button = new Button({\n        isToggle: true,\n        enableRtl: this.enableRtl\n      }, btn);\n      this.dayButtons.push(button);\n      EventHandler.add(btn, 'click', args => {\n        const btns = [].slice.call(this.element.querySelectorAll('.' + DAYWRAPPER + ' button.' + PRIMARY));\n        const element = args.target;\n        if (!element.classList.contains(PRIMARY)) {\n          addClass([element], PRIMARY);\n          self.triggerChangeEvent();\n        } else if (btns.length > 1) {\n          removeClass([element], PRIMARY);\n          self.triggerChangeEvent();\n        }\n      });\n    }\n  }\n  radioButtonRender() {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    this.onMonthDay = new RadioButton({\n      label: this.localeObj.getConstant(RADIOLABEL),\n      enableRtl: this.enableRtl,\n      name: 'monthType',\n      value: 'day',\n      change: () => {\n        self.resetFormValues();\n        self.triggerChangeEvent();\n      }\n    });\n    this.onMonthDay.appendTo(this.element.querySelector('.' + MONTHEXPANDERELEMENT));\n    this.monthButtons.push(this.onMonthDay);\n    this.onWeekDay = new RadioButton({\n      label: this.localeObj.getConstant('monthExpander'),\n      cssClass: 'e-month-type',\n      name: 'monthType',\n      enableRtl: this.enableRtl,\n      value: 'daypos',\n      change: () => {\n        self.resetFormValues();\n        self.triggerChangeEvent();\n      }\n    });\n    this.onWeekDay.appendTo(this.element.querySelector('.' + MONTHEXPANNDERELEM));\n    this.monthButtons.push(this.onWeekDay);\n  }\n  numericTextboxRender() {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    this.recurrenceCount = new NumericTextBox({\n      value: 10,\n      format: '#',\n      enableRtl: this.enableRtl,\n      min: 1,\n      max: 999,\n      change: () => {\n        self.triggerChangeEvent();\n      }\n    });\n    this.recurrenceCount.appendTo(this.element.querySelector('.' + ENDONCOUNT));\n    this.monthDate = new NumericTextBox({\n      value: 1,\n      format: '#',\n      enableRtl: this.enableRtl,\n      min: 1,\n      max: 31,\n      change: () => {\n        self.onMonthDay.setProperties({\n          checked: true\n        });\n        self.triggerChangeEvent();\n      }\n    });\n    this.monthDate.appendTo(this.element.querySelector('.' + MONTHDAYWRAPPER));\n    this.repeatInterval = new NumericTextBox({\n      value: 1,\n      format: '#',\n      min: 1,\n      max: 999,\n      enableRtl: this.enableRtl,\n      floatLabelType: 'Always',\n      placeholder: this.localeObj.getConstant(REPEATEVERY),\n      change: () => {\n        self.triggerChangeEvent();\n      }\n    });\n    this.repeatInterval.appendTo(this.element.querySelector('.' + REPEATINTERVAL));\n  }\n  renderComponent() {\n    this.setTemplate();\n    this.renderDropdowns();\n    this.renderDatePickers();\n    this.dayButtonRender();\n    this.radioButtonRender();\n    this.numericTextboxRender();\n  }\n  rotateArray(data, count) {\n    let temp;\n    for (let index = 0; index < count; index++) {\n      temp = data.shift();\n      data.push(temp);\n    }\n  }\n  getEndData() {\n    const endData = [NEVER, UNTIL$1, COUNT];\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    const dataSource = [];\n    endData.forEach(data => {\n      dataSource.push({\n        text: self.localeObj.getConstant(data),\n        value: data\n      });\n    });\n    return dataSource;\n  }\n  getDayPosition(date) {\n    let temp = new Date(date.getTime());\n    let endDate = new Date(date.getTime());\n    const day = date.getDay();\n    const positionCollection = [];\n    temp = this.calendarUtil.getMonthStartDate(temp);\n    endDate = this.calendarUtil.getMonthEndDate(endDate);\n    while (temp < endDate) {\n      if (temp.getDay() === day) {\n        positionCollection.push(temp.getTime());\n      }\n      temp.setDate(temp.getDate() + 1);\n    }\n    if (positionCollection.indexOf(date.getTime()) === positionCollection.length - 1) {\n      return -1;\n    }\n    return positionCollection.indexOf(date.getTime()) + 1;\n  }\n  getRepeatData() {\n    const data = [];\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    this.frequencies.forEach(element => {\n      const textValue = element === NONE ? NEVER : element;\n      data.push({\n        text: self.localeObj.getConstant(textValue),\n        value: element\n      });\n    });\n    return data;\n  }\n  getMonthPosData() {\n    const monthpos = [FIRST, SECOND, THIRD, FOURTH, LAST];\n    const monthposValue = {\n      first: 1,\n      second: 2,\n      third: 3,\n      fourth: 4,\n      last: -1\n    };\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    const dataSource = [];\n    monthpos.forEach(data => {\n      dataSource.push({\n        text: self.localeObj.getConstant(data),\n        value: monthposValue[data]\n      });\n    });\n    return dataSource;\n  }\n  getDayData(format) {\n    const weekday = [KEYSUNDAY, KEYMONDAY, KEYTUESDAY, KEYWEDNESDAY, KEYTHURSDAY, KEYFRIDAY, KEYSATURDAY];\n    const dayData = [];\n    let cldrObj;\n    this.rotateArray(weekday, this.firstDayOfWeek);\n    if (this.locale === 'en' || this.locale === 'en-US') {\n      const nameSpaceString = 'days.stand-alone.';\n      cldrObj = getValue(nameSpaceString + format, getDefaultDateObject(this.getCalendarMode()));\n    } else {\n      const nameSpaceString = 'main.' + '' + this.locale + '.dates.calendars.' + this.getCalendarMode() + '.days.stand-alone.' + format;\n      cldrObj = getValue(nameSpaceString, cldrData);\n    }\n    for (const obj of weekday) {\n      const day = getValue(obj, cldrObj);\n      dayData.push({\n        text: format === 'narrow' ? day : capitalizeFirstWord(day, 'single'),\n        value: valueData[obj]\n      });\n    }\n    return dayData;\n  }\n  getMonthData() {\n    const monthData = [];\n    let cldrObj;\n    if (this.locale === 'en' || this.locale === 'en-US') {\n      const nameSpaceString = 'months.stand-alone.wide';\n      cldrObj = getValue(nameSpaceString, getDefaultDateObject(this.getCalendarMode()));\n    } else {\n      const nameSpaceString = 'main.' + '' + this.locale + '.dates.calendars.' + this.getCalendarMode() + '.months.stand-alone.wide';\n      cldrObj = getValue(nameSpaceString, cldrData);\n    }\n    for (const obj of Object.keys(cldrObj)) {\n      monthData.push({\n        text: capitalizeFirstWord(getValue(obj, cldrObj), 'single'),\n        value: obj\n      });\n    }\n    return monthData;\n  }\n  setTemplate() {\n    const dayData = this.getDayData('narrow');\n    const fullDay = this.getDayData('wide');\n    this.element.innerHTML = '<div class=\"' + HEADER + '\">' + '<div class=\"' + INPUTWARAPPER + ' ' + FORMLEFT + '\">' + '<input type=\"text\" tabindex=\"0\" class=\"' + REPEATELEMENT + '\"label=\"' + REPEATELEMENT.substr(2) + '\" />' + '</div><div class=\"' + INPUTWARAPPER + ' ' + INTERVALCLASS + ' ' + FORMRIGHT + '\"><table  class=\"' + RECURRENCETABLE + ' ' + REPEATCONTENTWRAPPER + '\"><tr>' + '<td><input type=\"text\" tabindex=\"0\" class=\"' + REPEATINTERVAL + '\"title=\"' + this.localeObj.getConstant('repeatEvery') + '\" /></td>' + '<td><span class=\"' + REPEATCONTENT + '\"></span></td>' + '</tr></table></div><div class=\"' + INPUTWARAPPERSIDE + ' ' + DAYWRAPPER + ' ' + FORMLEFT + '\">' + '<div class=' + WEEKEXPANDERLABEL + '>' + this.localeObj.getConstant(ON$1) + '</div>' + '<button type=\"button\" class=\"e-round\" data-index=\"0\" title=\"' + fullDay[0].text + '\">' + dayData[0].text + '</button>' + '<button type=\"button\" class=\"e-round\" data-index=\"1\" title=\"' + fullDay[1].text + '\">' + dayData[1].text + '</button>' + '<button type=\"button\" class=\"e-round\" data-index=\"2\" title=\"' + fullDay[2].text + '\">' + dayData[2].text + '</button>' + '<button type=\"button\" class=\"e-round\" data-index=\"3\" title=\"' + fullDay[3].text + '\">' + dayData[3].text + '</button>' + '<button type=\"button\" class=\"e-round\" data-index=\"4\" title=\"' + fullDay[4].text + '\">' + dayData[4].text + '</button>' + '<button type=\"button\" class=\"e-round\" data-index=\"5\" title=\"' + fullDay[5].text + '\">' + dayData[5].text + '</button>' + '<button type=\"button\" class=\"e-round\" data-index=\"6\" title=\"' + fullDay[6].text + '\">' + dayData[6].text + '</button></div>' + '<div class=\"' + INPUTWARAPPERSIDE + ' ' + WEEKWRAPPER + ' ' + FORMLEFT + '\">' + '<div class=' + MONTHEXPANDERLABEL + '>' + this.localeObj.getConstant(ON$1) + '</div>' + '<div class=\"' + YEAREXPANDERWRAPPER + '\">' + '<input class=\"' + YEAREXPANDERELEMENT + '\" type=\"text\" tabindex=\"0\" title=\"' + this.localeObj.getConstant('yearExpander') + '\"/>' + '</div>' + '<div class=\"' + MONETHEXPANDERWRAPPER + '\">' + '<table class=\"' + RECURRENCETABLE + ' ' + MONETHEXPANDWRAPPER + '\"><tr><td>' + '<div class=\"' + INPUTWARAPPER + ' ' + MONTHEXPANDERCHECKBOXWRAPPER + '\">' + '<input class=\"' + MONTHEXPANDERELEMENT + '\"title=\"' + this.localeObj.getConstant('monthExpander') + '\" type=\"radio\">' + '</div></td>' + '<td colspan=\"2\"><div class=\"' + INPUTWARAPPER + ' ' + MONTHDAYELEMENT + '\">' + '<input type=\"text\" tabindex=\"0\" class=\"' + MONTHDAYWRAPPER + '\"title=\"' + this.localeObj.getConstant('on') + '\" />' + '</div></td></tr>' + '<tr><td>' + '<div class=\"' + INPUTWARAPPER + ' ' + MONTHEXPANDERCHECKBOXWRAPPER + '\" style=\"min-width: 30px;margin-bottom:18px;\">' + '<input class=\"' + MONTHEXPANNDERELEM + '\"title=\"' + this.localeObj.getConstant('monthExpander') + '\" type=\"radio\">' + '</div></td>' + '<td><div class=\"' + INPUTWARAPPER + ' ' + WEEKPOSITION + '\" >' + '<input type=\"text\" tabindex=\"0\" class=\"' + MONTHPOS + '\"title=\"' + this.localeObj.getConstant('monthPosition') + '\" />' + '</div></td>' + '<td><div class=\"' + INPUTWARAPPER + ' ' + DAYPOSITION + '\">' + '<input type=\"text\" tabindex=\"0\" class=\"' + MONTHWEEK + '\"title=\"' + this.localeObj.getConstant('monthWeek') + '\" />' + '</div></td></tr></table>' + '</div></div>' + '<div class=\"' + INPUTWARAPPERSIDE + ' ' + ENDON + ' ' + FORMRIGHT + '\">' + '<div class=' + ENDONLABEL + '>' + this.localeObj.getConstant(END) + '</div>' + '<div class=\"' + INPUTWARAPPER + ' ' + ENDONLEFT + '\">' + '<input type=\"text\" tabindex=\"0\" class=\"' + ENDONELEMENT + '\"title=\"' + this.localeObj.getConstant(END) + '\" />' + '</div>' + '<div class=\"' + INPUTWARAPPER + ' ' + ENDONDATE + '\" >' + '<input type=\"text\" tabindex=\"0\" class=\"' + UNTILDATE + '\"title=\"' + this.localeObj.getConstant(UNTIL$1) + '\" />' + '</div>' + '<div class=\"' + INPUTWARAPPER + ' ' + ENDONCOUNTWRAPPER + '\">' + '<input type=\"text\" tabindex=\"0\" class=\"' + ENDONCOUNT + '\"title=\"' + this.localeObj.getConstant(COUNT) + '\" />' + '</div></div>' + '</div></div>';\n  }\n  getSelectedDaysData() {\n    let ruleData = RULEBYDAY + EQUAL;\n    const elements = [].slice.call(this.element.querySelectorAll('.' + DAYWRAPPER + ' button.' + PRIMARY));\n    const weekday = [RULESUNDAY, RULEMONDAY, RULETUESDAY, RULEWEDNESDAY, RULETHURSDAY, RULEFRIDAY, RULESATURDAY];\n    this.rotateArray(weekday, this.firstDayOfWeek);\n    for (let index = 0; index < elements.length; index++) {\n      ruleData += weekday[parseInt(elements[index].getAttribute('data-index'), 10)] + (index === elements.length - 1 ? '' : COMMA);\n    }\n    return ruleData + SEMICOLON;\n  }\n  getSelectedMonthData() {\n    let ruleData;\n    if (this.onWeekDay.checked) {\n      ruleData = RULEBYDAY + EQUAL + this.monthWeekDays.value + SEMICOLON + RULESETPOS + EQUAL + this.monthWeekPos.value + SEMICOLON;\n    } else {\n      ruleData = RULEBYMONTHDAY + EQUAL + this.monthDate.value + SEMICOLON;\n    }\n    return ruleData;\n  }\n  getIntervalData() {\n    return RULEINTERVAL + EQUAL + this.repeatInterval.value + SEMICOLON;\n  }\n  getEndOnCount() {\n    return RULECOUNT + EQUAL + this.recurrenceCount.value + SEMICOLON;\n  }\n  getYearMonthRuleData() {\n    return RULEBYMONTH + EQUAL + this.monthValue.value + SEMICOLON;\n  }\n  updateWeekButton(keys) {\n    const weekday = [RULESUNDAY, RULEMONDAY, RULETUESDAY, RULEWEDNESDAY, RULETHURSDAY, RULEFRIDAY, RULESATURDAY];\n    this.rotateArray(weekday, this.firstDayOfWeek);\n    for (const obj of this.dayButtons) {\n      const index = parseInt(obj.element.getAttribute('data-index'), 10);\n      if (keys.indexOf(weekday[index]) !== -1) {\n        obj.setProperties({\n          isPrimary: true\n        });\n      } else {\n        obj.setProperties({\n          isPrimary: false\n        });\n      }\n    }\n  }\n  updateMonthUI() {\n    if (this.ruleObject.monthDay.length) {\n      this.monthDate.setProperties({\n        value: this.ruleObject.monthDay[0]\n      });\n      this.onMonthDay.setProperties({\n        checked: true\n      });\n    } else {\n      this.onWeekDay.setProperties({\n        checked: true\n      });\n      this.monthWeekPos.setProperties({\n        value: this.ruleObject.setPosition\n      });\n      for (const key of Object.keys(valueData)) {\n        if (valueData[key] === this.ruleObject.day[0]) {\n          this.monthWeekDays.setProperties({\n            value: this.ruleObject.day[0]\n          });\n          break;\n        }\n      }\n    }\n  }\n  updateUI(repeat, state) {\n    this.repeatInterval.setProperties({\n      value: this.ruleObject.interval\n    });\n    switch (state) {\n      case UNTIL$1:\n        this.untilDateObj.setProperties({\n          value: this.ruleObject.until\n        });\n        break;\n      case COUNT:\n        this.recurrenceCount.setProperties({\n          value: this.ruleObject.count\n        });\n        break;\n    }\n    switch (repeat) {\n      case WEEKLY:\n        this.updateWeekButton(this.ruleObject.day);\n        break;\n      case YEARLY:\n        this.monthValue.setProperties({\n          index: this.ruleObject.month[0] - 1\n        });\n        this.updateMonthUI();\n        break;\n      case MONTHLY:\n        this.updateMonthUI();\n        break;\n    }\n  }\n  getUntilData() {\n    if (!this.untilDateObj.value) {\n      return '';\n    }\n    const tempStr = getRecurrenceStringFromDate(this.untilDateObj.value);\n    return RULEUNTIL + EQUAL + tempStr + SEMICOLON;\n  }\n  destroyComponents() {\n    if (!this.recurrenceCount.isDestroyed) {\n      this.recurrenceCount.destroy();\n    }\n    if (!this.monthDate.isDestroyed) {\n      this.monthDate.destroy();\n    }\n    if (!this.repeatInterval.isDestroyed) {\n      this.repeatInterval.destroy();\n    }\n    if (!this.untilDateObj.isDestroyed) {\n      this.untilDateObj.destroy();\n    }\n    if (!this.repeatType.isDestroyed) {\n      this.repeatType.destroy();\n    }\n    if (!this.endType.isDestroyed) {\n      this.endType.destroy();\n    }\n    if (!this.monthWeekPos.isDestroyed) {\n      this.monthWeekPos.destroy();\n    }\n    if (!this.monthWeekDays.isDestroyed) {\n      this.monthWeekDays.destroy();\n    }\n    if (!this.monthValue.isDestroyed) {\n      this.monthValue.destroy();\n    }\n    this.dayButtons.forEach(element => {\n      if (!element.isDestroyed) {\n        element.destroy();\n      }\n    });\n    this.dayButtons = [];\n    this.monthButtons.forEach(element => {\n      if (!element.isDestroyed) {\n        element.destroy();\n      }\n    });\n    this.monthButtons = [];\n  }\n  resetFields() {\n    this.startState(NONE, NEVER, this.startDate);\n    this.setDefaultValue();\n  }\n  updateRuleUntilDate(startDate) {\n    if (this.untilDateObj.value && startDate) {\n      const untilDate = this.untilDateObj.value;\n      const newUntilDate = new Date(untilDate.getFullYear(), untilDate.getMonth(), untilDate.getDate(), startDate.getHours(), startDate.getMinutes(), startDate.getMilliseconds());\n      this.untilDateObj.setProperties({\n        value: newUntilDate\n      });\n    }\n  }\n  getCalendarMode() {\n    return this.calendarMode.toLowerCase();\n  }\n  getRuleSummary(rule = this.getRecurrenceRule()) {\n    return generateSummary(rule, this.localeObj, this.locale, this.calendarMode);\n  }\n  getRecurrenceDates(startDate, rule, excludeDate, maximumCount, viewDate) {\n    viewDate = isNullOrUndefined(viewDate) ? this.startDate : viewDate;\n    return generate(startDate, rule, excludeDate, this.firstDayOfWeek, maximumCount, viewDate, this.calendarMode);\n  }\n  getRecurrenceRule() {\n    let ruleData = RULEFREQ + EQUAL;\n    switch (this.repeatType.value) {\n      case DAILY:\n        ruleData += RULEDAILY + SEMICOLON;\n        break;\n      case WEEKLY:\n        ruleData += RULEWEEKLY + SEMICOLON + this.getSelectedDaysData();\n        break;\n      case MONTHLY:\n        ruleData += RULEMONTHLY + SEMICOLON + this.getSelectedMonthData();\n        break;\n      case YEARLY:\n        ruleData += RULEYEARLY + SEMICOLON + this.getSelectedMonthData() + this.getYearMonthRuleData();\n        break;\n      case NONE:\n        return '';\n    }\n    ruleData += this.getIntervalData();\n    switch (this.endType.value) {\n      case UNTIL$1:\n        ruleData += this.getUntilData();\n        break;\n      case COUNT:\n        ruleData += this.getEndOnCount();\n        break;\n    }\n    return ruleData;\n  }\n  setRecurrenceRule(rule, startDate = this.startDate) {\n    if (!rule) {\n      this.repeatType.setProperties({\n        value: NONE\n      });\n      return;\n    }\n    this.renderStatus = false;\n    this.ruleObject = extractObjectFromRule(rule);\n    const endon = this.ruleObject.count ? COUNT : this.ruleObject.until ? UNTIL$1 : NEVER;\n    switch (this.ruleObject.freq) {\n      case RULEDAILY:\n        this.startState(DAILY, endon, startDate);\n        this.updateUI(DAILY, endon);\n        break;\n      case RULEWEEKLY:\n        this.startState(WEEKLY, endon, startDate);\n        this.updateUI(WEEKLY, endon);\n        break;\n      case RULEMONTHLY:\n        this.startState(MONTHLY, endon, startDate);\n        this.updateUI(MONTHLY, endon);\n        break;\n      case RULEYEARLY:\n        this.startState(YEARLY, endon, startDate);\n        this.updateUI(YEARLY, endon);\n        break;\n    }\n    this.renderStatus = true;\n    this.triggerChangeEvent();\n  }\n  /**\n   * Destroys the widget.\n   *\n   * @returns {void}\n   */\n  destroy() {\n    this.destroyComponents();\n    super.destroy();\n    let removeClasses = ['e-' + this.getModuleName()];\n    if (this.cssClass) {\n      removeClasses = removeClasses.concat(this.cssClass.split(' '));\n    }\n    removeClass([this.element], removeClasses);\n    while (this.element.firstElementChild) {\n      this.element.removeChild(this.element.firstElementChild);\n    }\n  }\n  /**\n   * Get component name.\n   *\n   * @returns {string} Returns the module name\n   * @private\n   */\n  getModuleName() {\n    return 'recurrenceeditor';\n  }\n  /**\n   * Get the properties to be maintained in the persisted state.\n   *\n   * @returns {string} Returns the persisted state\n   */\n  getPersistData() {\n    return this.addOnPersist([]);\n  }\n  /**\n   * Initialize the control rendering\n   *\n   * @returns {void}\n   * @private\n   */\n  render() {\n    this.initialize();\n    this.rtlClass(this.enableRtl);\n    this.renderStatus = true;\n    this.renderComplete();\n  }\n  /**\n   * Called internally, if any of the property value changed.\n   *\n   * @param {RecurrenceEditorModel} newProp Accepts the changed properties new values\n   * @param {RecurrenceEditorModel} oldProp Accepts the changed properties old values\n   * @returns {void}\n   * @private\n   */\n  onPropertyChanged(newProp, oldProp) {\n    for (const prop of Object.keys(newProp)) {\n      switch (prop) {\n        case 'startDate':\n          this.selectMonthDay(newProp.startDate);\n          this.updateUntilDate(newProp.startDate);\n          this.endType.setProperties({\n            index: 0\n          });\n          break;\n        case 'enableRtl':\n          this.rtlClass(newProp.enableRtl);\n          break;\n        case 'cssClass':\n          if (oldProp.cssClass) {\n            removeClass([this.element], oldProp.cssClass.split(' '));\n          }\n          if (newProp.cssClass) {\n            addClass([this.element], newProp.cssClass.split(' '));\n          }\n          break;\n        case 'selectedType':\n          this.repeatType.setProperties({\n            index: this.selectedType\n          });\n          break;\n        case 'minDate':\n          this.untilDateObj.setProperties({\n            minDate: this.minDate\n          });\n          break;\n        case 'maxDate':\n          this.untilDateObj.setProperties({\n            maxDate: this.maxDate\n          });\n          break;\n        case 'value':\n          if (this.getRecurrenceRule() !== this.value) {\n            this.setRecurrenceRule(this.value);\n          }\n          break;\n        case 'calendarMode':\n          this.calendarMode = newProp.calendarMode;\n          this.calendarUtil = getCalendarUtil(newProp.calendarMode);\n          break;\n        case 'locale':\n        case 'frequencies':\n        case 'firstDayOfWeek':\n          this.refresh();\n          break;\n        case 'dateFormat':\n          this.untilDateObj.setProperties({\n            format: newProp.dateFormat\n          });\n          break;\n      }\n    }\n  }\n};\n__decorate$1([Property(['none', 'daily', 'weekly', 'monthly', 'yearly'])], RecurrenceEditor.prototype, \"frequencies\", void 0);\n__decorate$1([Property(0)], RecurrenceEditor.prototype, \"firstDayOfWeek\", void 0);\n__decorate$1([Property(new Date())], RecurrenceEditor.prototype, \"startDate\", void 0);\n__decorate$1([Property()], RecurrenceEditor.prototype, \"dateFormat\", void 0);\n__decorate$1([Property('Gregorian')], RecurrenceEditor.prototype, \"calendarMode\", void 0);\n__decorate$1([Property()], RecurrenceEditor.prototype, \"cssClass\", void 0);\n__decorate$1([Property()], RecurrenceEditor.prototype, \"value\", void 0);\n__decorate$1([Property(new Date(1900, 0, 1))], RecurrenceEditor.prototype, \"minDate\", void 0);\n__decorate$1([Property(new Date(2099, 11, 31))], RecurrenceEditor.prototype, \"maxDate\", void 0);\n__decorate$1([Property(0)], RecurrenceEditor.prototype, \"selectedType\", void 0);\n__decorate$1([Event()], RecurrenceEditor.prototype, \"change\", void 0);\nRecurrenceEditor = __decorate$1([NotifyPropertyChanges], RecurrenceEditor);\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst EVENT_FIELD$1 = 'e-field';\nconst REPEAT_CONTAINER_CLASS = 'e-recurrence-container';\nconst REPEAT_BUTTON_ICON_CLASS = 'e-recurrence-edit';\nconst REPEAT_BUTTON_CLASS = 'e-recurrence-edit-button';\nconst REPEAT_DIALOG_CLASS = 'e-recurrence-dialog';\nconst HIDE_STYLE_CLASS = 'e-hide';\n/**\n * Event editor window\n */\nclass EventWindow {\n  constructor(parent) {\n    this.parent = parent;\n    this.l10n = this.parent.localeObj;\n    this.fields = this.parent.eventFields;\n    this.eventWindowTime = {\n      startTime: new Date(),\n      endTime: new Date()\n    };\n    this.renderEventWindow();\n  }\n  renderEventWindow() {\n    this.element = createElement('div', {\n      id: this.parent.element.id + '_dialog_wrapper'\n    });\n    this.parent.element.appendChild(this.element);\n    const dialogModel = {\n      animationSettings: {\n        effect: 'Zoom'\n      },\n      content: this.getEventWindowContent(),\n      cssClass: EVENT_WINDOW_DIALOG_CLASS,\n      enableRtl: this.parent.enableRtl,\n      height: this.parent.isAdaptive ? '100%' : 'auto',\n      minHeight: '300px',\n      isModal: true,\n      showCloseIcon: this.parent.isAdaptive ? false : true,\n      target: document.body,\n      visible: false,\n      width: '500px',\n      beforeOpen: this.onBeforeOpen.bind(this),\n      beforeClose: this.onBeforeClose.bind(this)\n    };\n    if (this.parent.isAdaptive) {\n      dialogModel.cssClass = EVENT_WINDOW_DIALOG_CLASS + ' ' + DEVICE_CLASS;\n      dialogModel.header = '<div class=\"e-title-header\"><div class=\"e-back-icon e-icons\"></div><div class=\"e-title-text\">' + this.l10n.getConstant('newEvent') + '</div><div class=\"e-save-icon e-icons\"></div></div>';\n    } else {\n      dialogModel.buttons = [{\n        buttonModel: {\n          content: this.l10n.getConstant('deleteButton'),\n          cssClass: DELETE_EVENT_CLASS,\n          disabled: !this.parent.eventSettings.allowDeleting || this.parent.readonly\n        },\n        click: this.eventDelete.bind(this)\n      }, {\n        buttonModel: {\n          content: this.l10n.getConstant('saveButton'),\n          cssClass: 'e-primary ' + EVENT_WINDOW_SAVE_BUTTON_CLASS,\n          isPrimary: true,\n          disabled: !this.parent.eventSettings.allowAdding || this.parent.readonly\n        },\n        click: this.eventSave.bind(this)\n      }, {\n        buttonModel: {\n          cssClass: EVENT_WINDOW_CANCEL_BUTTON_CLASS,\n          content: this.l10n.getConstant('cancelButton')\n        },\n        click: this.dialogClose.bind(this)\n      }];\n      dialogModel.header = '<div class=\"e-title-text\">' + this.l10n.getConstant('newEvent') + '</div>';\n    }\n    this.dialogObject = new Dialog(dialogModel, this.element);\n    if (this.dialogObject.element.querySelector('.e-dlg-closeicon-btn')) {\n      this.dialogObject.element.querySelector('.e-dlg-closeicon-btn').setAttribute('title', this.l10n.getConstant('close'));\n    }\n    addClass([this.element.parentElement], EVENT_WINDOW_DIALOG_CLASS + '-container');\n    if (this.parent.isAdaptive) {\n      EventHandler.add(this.element.querySelector('.' + EVENT_WINDOW_BACK_ICON_CLASS), 'click', this.dialogClose, this);\n      EventHandler.add(this.element.querySelector('.' + EVENT_WINDOW_SAVE_ICON_CLASS), 'click', this.eventSave, this);\n    }\n    EventHandler.add(this.dialogObject.element, 'keydown', this.preventEventSave, this);\n    this.applyFormValidation();\n  }\n  refresh() {\n    this.destroy(true);\n    this.renderEventWindow();\n  }\n  refreshRecurrenceEditor() {\n    if (this.recurrenceEditor) {\n      const recurrenceEditor = this.recurrenceEditor.element;\n      this.recurrenceEditor.destroy();\n      this.createRecurrenceEditor(recurrenceEditor);\n    }\n  }\n  setRecurrenceEditor(recurrenceEditor) {\n    if (this.parent.editorTemplate) {\n      this.recurrenceEditor = recurrenceEditor;\n    }\n  }\n  openEditor(data, type, isEventData, repeatType) {\n    this.parent.currentAction = type;\n    this.parent.removeNewEventElement();\n    if (this.parent.quickPopup) {\n      this.parent.quickPopup.quickPopupHide(true);\n    }\n    this.parent.inlineModule.removeInlineAppointmentElement();\n    if (type === 'Add') {\n      let eventObj = {};\n      this.cellClickAction = !isEventData;\n      this.parent.activeCellsData = data;\n      const event = data;\n      if (this.cellClickAction) {\n        this.convertToEventData(event, eventObj);\n      } else {\n        this.parent.activeCellsData = {\n          startTime: event.startTime || event[this.fields.startTime],\n          endTime: event.endTime || event[this.fields.endTime],\n          isAllDay: event.isAllDay || event[this.fields.isAllDay],\n          element: event.element,\n          groupIndex: event.groupIndex\n        };\n        eventObj = event;\n      }\n      data = eventObj;\n    }\n    if (!isNullOrUndefined(this.parent.editorTemplate)) {\n      this.renderFormElements(this.element.querySelector('.e-schedule-form'), data);\n    }\n    if (!this.parent.isAdaptive && isNullOrUndefined(this.parent.editorTemplate)) {\n      removeClass([this.dialogObject.element.querySelector('.e-recurrenceeditor')], DISABLE_CLASS);\n    }\n    if (this.recurrenceEditor) {\n      this.recurrenceEditor.firstDayOfWeek = this.parent.activeViewOptions.firstDayOfWeek;\n    }\n    switch (type) {\n      case 'Add':\n        this.onCellDetailsUpdate(data, repeatType);\n        break;\n      case 'Save':\n      case 'EditOccurrence':\n      case 'EditSeries':\n      case 'EditFollowingEvents':\n        if (type === 'EditOccurrence' && !this.parent.isAdaptive && isNullOrUndefined(this.parent.editorTemplate)) {\n          addClass([this.dialogObject.element.querySelector('.e-recurrenceeditor')], DISABLE_CLASS);\n        }\n        this.cellClickAction = false;\n        this.onEventDetailsUpdate(data);\n        break;\n    }\n  }\n  setDialogContent() {\n    this.dialogObject.content = this.getEventWindowContent();\n    this.dialogObject.dataBind();\n  }\n  preventEventSave(e) {\n    if (this.parent && !this.parent.allowKeyboardInteraction && e.code === 'Enter') {\n      this.isEnterKey = true;\n    }\n  }\n  onBeforeOpen(args) {\n    const eventProp = {\n      type: 'Editor',\n      data: this.eventData,\n      cancel: false,\n      element: this.element,\n      target: this.cellClickAction ? this.parent.activeCellsData.element : this.parent.activeEventData.element\n    };\n    if (this.cellClickAction) {\n      eventProp.duration = this.getSlotDuration();\n    }\n    const saveObj = this.getInstance(EVENT_WINDOW_SAVE_BUTTON_CLASS);\n    if (saveObj) {\n      saveObj.disabled = !(this.cellClickAction ? this.parent.eventSettings.allowAdding : this.parent.eventSettings.allowEditing);\n      saveObj.dataBind();\n    }\n    const deleteObj = this.getInstance(DELETE_EVENT_CLASS);\n    if (deleteObj) {\n      deleteObj.disabled = !this.parent.eventSettings.allowDeleting;\n      deleteObj.dataBind();\n    }\n    const callBackPromise = new Deferred();\n    this.parent.trigger(popupOpen, eventProp, popupArgs => {\n      args.cancel = popupArgs.cancel;\n      this.duration = this.cellClickAction ? popupArgs.duration : null;\n      this.refreshDateTimePicker(this.duration);\n      if (this.cellClickAction && popupArgs.duration !== this.getSlotDuration() && isNullOrUndefined(this.parent.editorTemplate)) {\n        const startObj = this.getInstance(EVENT_WINDOW_START_CLASS);\n        const endObj = this.getInstance(EVENT_WINDOW_END_CLASS);\n        endObj.value = new Date(startObj.value.getTime() + MS_PER_MINUTE * popupArgs.duration);\n        endObj.dataBind();\n      }\n      if (this.parent.editorTemplate && this.element.querySelector('.e-recurrenceeditor') && !this.recurrenceEditor) {\n        this.recurrenceEditor = this.getInstance('e-recurrenceeditor');\n      }\n      callBackPromise.resolve(args);\n    });\n    return callBackPromise;\n  }\n  onBeforeClose(args) {\n    if (args.isInteracted) {\n      this.isCrudAction = false;\n    }\n    const eventProp = {\n      type: 'Editor',\n      event: args.event || this.dialogEvent,\n      data: this.eventCrudData,\n      cancel: false,\n      element: this.element,\n      target: this.cellClickAction ? this.parent.activeCellsData.element : this.parent.activeEventData.element\n    };\n    const callBackPromise = new Deferred();\n    this.parent.trigger(popupClose, eventProp, popupArgs => {\n      args.cancel = popupArgs.cancel;\n      if (!popupArgs.cancel) {\n        if (this.isCrudAction) {\n          args.cancel = this.processCrudActions(popupArgs.data);\n          this.isCrudAction = args.cancel;\n        }\n        if (!this.isCrudAction) {\n          this.resetForm();\n          this.parent.eventBase.focusElement(true);\n          this.eventCrudData = null;\n        }\n      }\n      callBackPromise.resolve(args);\n    });\n    return callBackPromise;\n  }\n  getEventWindowContent() {\n    const container = createElement('div', {\n      className: FORM_CONTAINER_CLASS\n    });\n    const form = createElement('form', {\n      id: this.parent.element.id + 'EditForm',\n      className: FORM_CLASS,\n      attrs: {\n        onsubmit: 'return false;'\n      }\n    });\n    this.renderFormElements(form);\n    container.appendChild(form);\n    return container;\n  }\n  renderFormElements(form, args) {\n    if (!isNullOrUndefined(this.parent.editorTemplate)) {\n      if (args) {\n        if (this.recurrenceEditor) {\n          this.recurrenceEditor.destroy();\n          this.recurrenceEditor = null;\n        }\n        this.destroyComponents();\n        const formElements = [].slice.call(form.children);\n        for (const element of formElements) {\n          remove(element);\n        }\n      }\n      const templateId = this.parent.element.id + '_editorTemplate';\n      const tempEle = [].slice.call(this.parent.getEditorTemplate()(args || {}, this.parent, 'editorTemplate', templateId, false));\n      append(tempEle, form);\n      this.parent.renderTemplates();\n    } else {\n      form.appendChild(this.getDefaultEventWindowContent());\n    }\n  }\n  getDefaultEventWindowContent() {\n    const parentDiv = this.createDivElement(EVENT_WINDOW_DIALOG_PARENT_CLASS);\n    const titleLocationDiv = this.createDivElement(EVENT_WINDOW_TITLE_LOCATION_DIV_CLASS);\n    parentDiv.appendChild(titleLocationDiv);\n    titleLocationDiv.appendChild(this.renderTextBox(SUBJECT_CLASS));\n    titleLocationDiv.querySelector('.' + SUBJECT_CLASS).setAttribute('title', this.parent.editorTitles.subject);\n    titleLocationDiv.appendChild(this.renderTextBox(LOCATION_CLASS));\n    titleLocationDiv.querySelector('.' + LOCATION_CLASS).setAttribute('title', this.parent.editorTitles.location);\n    const startEndDateTimeDiv = this.createDivElement(EVENT_WINDOW_START_END_DIV_CLASS);\n    parentDiv.appendChild(startEndDateTimeDiv);\n    startEndDateTimeDiv.appendChild(this.renderDateTimePicker(EVENT_WINDOW_START_CLASS, this.onTimeChange.bind(this)));\n    startEndDateTimeDiv.querySelector('.' + EVENT_WINDOW_START_CLASS).setAttribute('title', this.parent.editorTitles.startTime);\n    startEndDateTimeDiv.appendChild(this.renderDateTimePicker(EVENT_WINDOW_END_CLASS));\n    startEndDateTimeDiv.querySelector('.' + EVENT_WINDOW_END_CLASS).setAttribute('title', this.parent.editorTitles.endTime);\n    const allDayTimezoneDiv = this.createDivElement(EVENT_WINDOW_ALLDAY_TZ_DIV_CLASS);\n    parentDiv.appendChild(allDayTimezoneDiv);\n    allDayTimezoneDiv.appendChild(this.renderCheckBox(EVENT_WINDOW_ALL_DAY_CLASS));\n    allDayTimezoneDiv.appendChild(this.renderCheckBox(TIME_ZONE_CLASS));\n    const timezoneParentDiv = this.createDivElement(EVENT_WINDOW_TIME_ZONE_DIV_CLASS);\n    parentDiv.appendChild(timezoneParentDiv);\n    timezoneParentDiv.appendChild(this.renderDropDown(EVENT_WINDOW_START_TZ_CLASS));\n    timezoneParentDiv.appendChild(this.renderDropDown(EVENT_WINDOW_END_TZ_CLASS));\n    const repeatParentDiv = this.createDivElement(EVENT_WINDOW_REPEAT_DIV_CLASS);\n    parentDiv.appendChild(repeatParentDiv);\n    const repeatDiv = this.renderCheckBox(EVENT_WINDOW_REPEAT_CLASS);\n    const repeatEditContainer = createElement('span', {\n      className: REPEAT_CONTAINER_CLASS\n    });\n    const button = createElement('button', {\n      className: REPEAT_BUTTON_CLASS,\n      attrs: {\n        type: 'button',\n        'title': this.l10n.getConstant('editRecurrence')\n      }\n    });\n    this.buttonObj = new Button({\n      iconCss: REPEAT_BUTTON_ICON_CLASS + ' e-icons',\n      cssClass: 'e-medium ' + this.parent.cssClass\n    });\n    repeatEditContainer.appendChild(button);\n    this.buttonObj.appendTo(button);\n    repeatDiv.appendChild(repeatEditContainer);\n    repeatParentDiv.appendChild(repeatDiv);\n    if (this.parent.isAdaptive) {\n      EventHandler.add(button, 'click', this.loadRecurrenceEditor, this);\n    } else {\n      this.createRecurrenceEditor(parentDiv);\n    }\n    if (this.parent.resourceCollection.length > 0) {\n      const resourceParentDiv = this.createDivElement(EVENT_WINDOW_RESOURCES_DIV_CLASS);\n      for (const resource of this.parent.resourceBase.resourceCollection) {\n        resourceParentDiv.appendChild(this.renderResourceDetails(resource));\n      }\n      parentDiv.appendChild(resourceParentDiv);\n    }\n    const description = this.createDivElement(DESCRIPTION_CLASS + '-row');\n    description.appendChild(this.renderTextBox(DESCRIPTION_CLASS));\n    description.querySelector('.' + DESCRIPTION_CLASS).setAttribute('title', this.parent.editorTitles.description);\n    parentDiv.appendChild(description);\n    const submit = createElement('button', {\n      attrs: {\n        type: 'hidden',\n        title: 'submit',\n        style: 'display:none'\n      }\n    });\n    parentDiv.appendChild(submit);\n    return parentDiv;\n  }\n  createRecurrenceEditor(parentDiv) {\n    const recurrenceEditor = this.createDivElement();\n    parentDiv.appendChild(recurrenceEditor);\n    this.recurrenceEditor = this.renderRecurrenceEditor();\n    this.recurrenceEditor.appendTo(recurrenceEditor);\n    this.updateMinMaxDateToEditor();\n  }\n  createDivElement(className) {\n    return createElement('div', {\n      className: className\n    });\n  }\n  createInputElement(className, fieldName, type) {\n    return createElement(type || 'input', {\n      className: className,\n      attrs: {\n        type: 'text',\n        name: fieldName,\n        value: '',\n        id: fieldName,\n        title: this.l10n.getConstant(fieldName.charAt(0).toLowerCase() + fieldName.slice(1)) === '' ? fieldName : this.l10n.getConstant(fieldName.charAt(0).toLowerCase() + fieldName.slice(1))\n      }\n    });\n  }\n  getSlotDuration() {\n    return this.parent.activeViewOptions.timeScale.interval / this.parent.activeViewOptions.timeScale.slotCount;\n  }\n  renderDateTimePicker(value, changeEvent) {\n    const dateTimeDiv = this.createDivElement(value + '-container');\n    const fieldName = this.getFieldName(value);\n    const dateTimeInput = this.createInputElement(value + ' ' + EVENT_FIELD$1, fieldName);\n    dateTimeDiv.appendChild(dateTimeInput);\n    const dateTimePicker = new DateTimePicker({\n      change: changeEvent,\n      firstDayOfWeek: this.parent.activeViewOptions.firstDayOfWeek,\n      calendarMode: this.parent.calendarMode,\n      min: this.parent.minDate,\n      max: new Date(new Date(+this.parent.maxDate).setHours(23, 59, 59)),\n      cssClass: this.parent.cssClass,\n      enableRtl: this.parent.enableRtl,\n      locale: this.parent.locale,\n      floatLabelType: 'Always',\n      timeFormat: this.parent.activeViewOptions.timeFormat,\n      format: (isNullOrUndefined(this.parent.dateFormat) ? this.getFormat('dateFormats') : this.parent.dateFormat) + ' ' + this.parent.activeViewOptions.timeFormat,\n      placeholder: this.getFieldLabel(value),\n      step: this.getSlotDuration(),\n      width: '100%'\n    });\n    dateTimePicker.appendTo(dateTimeInput);\n    return dateTimeDiv;\n  }\n  refreshDateTimePicker(duration) {\n    const elementSelector = '.' + EVENT_WINDOW_START_CLASS + ',.' + EVENT_WINDOW_END_CLASS;\n    const startEndElement = [].slice.call(this.element.querySelectorAll(elementSelector));\n    for (const element of startEndElement) {\n      const instance = element.ej2_instances[0];\n      instance.firstDayOfWeek = this.parent.activeViewOptions.firstDayOfWeek;\n      instance.timeFormat = this.parent.activeViewOptions.timeFormat;\n      instance.step = duration || this.getSlotDuration();\n      instance.dataBind();\n    }\n  }\n  onTimeChange() {\n    const startObj = this.getInstance(EVENT_WINDOW_START_CLASS);\n    if (startObj.element.parentElement.classList.contains('e-input-focus')) {\n      const endObj = this.getInstance(EVENT_WINDOW_END_CLASS);\n      let duration = 0;\n      if (this.cellClickAction) {\n        duration = MS_PER_MINUTE * this.duration;\n        this.eventWindowTime.startTime = startObj.value;\n      } else {\n        duration = this.eventData[this.fields.endTime].getTime() - this.eventData[this.fields.startTime].getTime();\n      }\n      const endDate = isNullOrUndefined(startObj.value) ? null : new Date(startObj.value.getTime() + duration);\n      if (this.cellClickAction) {\n        this.eventWindowTime.endTime = endDate;\n      }\n      endObj.value = endDate;\n      endObj.dataBind();\n    }\n    if (this.recurrenceEditor) {\n      this.recurrenceEditor.updateRuleUntilDate(this.eventWindowTime.startTime);\n    }\n  }\n  renderResourceDetails(resourceData) {\n    const fieldName = resourceData.field;\n    const value = 'e-' + fieldName;\n    const labelValue = resourceData.title;\n    const resourceDiv = this.createDivElement(value + '-container' + ' ' + 'e-resources');\n    const resourceInput = this.createInputElement(value + ' ' + EVENT_FIELD$1, fieldName);\n    resourceDiv.appendChild(resourceInput);\n    const resourceTemplate = '<div class=\"e-resource-template\"><div class=\"e-resource-color\" style=\"background-color:${' + resourceData.colorField + '}\"></div><div class=\"e-resource-text\">${' + resourceData.textField + '}</div></div>';\n    if (resourceData.allowMultiple) {\n      const listObj = new MultiSelect({\n        cssClass: this.parent.cssClass || '',\n        dataSource: resourceData.dataSource,\n        change: this.onMultiselectResourceChange.bind(this),\n        itemTemplate: resourceTemplate,\n        fields: {\n          text: resourceData.textField,\n          value: resourceData.idField\n        },\n        htmlAttributes: {\n          'title': labelValue,\n          'name': fieldName\n        },\n        floatLabelType: 'Always',\n        placeholder: labelValue,\n        popupHeight: '230px',\n        popupWidth: '447px',\n        mode: 'Box'\n      });\n      listObj.appendTo(resourceInput);\n    } else {\n      const dropDownList = new DropDownList({\n        cssClass: this.parent.cssClass || '',\n        change: this.onDropdownResourceChange.bind(this),\n        dataSource: resourceData.dataSource,\n        enableRtl: this.parent.enableRtl,\n        fields: {\n          text: resourceData.textField,\n          value: resourceData.idField\n        },\n        htmlAttributes: {\n          'title': labelValue,\n          'name': fieldName\n        },\n        floatLabelType: 'Always',\n        placeholder: labelValue,\n        popupHeight: '230px',\n        popupWidth: '447px',\n        itemTemplate: resourceTemplate\n      });\n      dropDownList.appendTo(resourceInput);\n    }\n    return resourceDiv;\n  }\n  renderDropDown(value) {\n    const fieldName = this.getFieldName(value);\n    const timezoneDiv = this.createDivElement(value + '-container');\n    const timezoneInput = this.createInputElement(value + ' ' + EVENT_FIELD$1, fieldName);\n    timezoneDiv.appendChild(timezoneInput);\n    const dropDownList = new DropDownList({\n      allowFiltering: true,\n      change: this.onTimezoneChange.bind(this),\n      cssClass: this.parent.cssClass || '',\n      dataSource: this.parent.timezoneDataSource,\n      enableRtl: this.parent.enableRtl,\n      fields: {\n        text: 'Text',\n        value: 'Value'\n      },\n      filterBarPlaceholder: this.parent.localeObj.getConstant('searchTimezone'),\n      noRecordsTemplate: this.parent.localeObj.getConstant('noRecords'),\n      filtering: e => {\n        let query = new Query();\n        query = e.text !== '' ? query.where('Text', 'contains', e.text, true) : query;\n        e.updateData(this.parent.timezoneDataSource, query);\n      },\n      htmlAttributes: {\n        'title': this.getFieldLabel(value),\n        'name': fieldName\n      },\n      floatLabelType: 'Always',\n      placeholder: this.getFieldLabel(value),\n      popupHeight: '230px'\n    });\n    dropDownList.appendTo(timezoneInput);\n    return timezoneDiv;\n  }\n  onMultiselectResourceChange(args) {\n    if (!args.value || !this.parent.activeViewOptions.group.byGroupID || this.parent.resourceCollection.length <= 1) {\n      return;\n    }\n    const resourceCollection = this.parent.resourceBase.resourceCollection;\n    const fieldName = args.element.getAttribute('name') || this.getColumnName(args.element);\n    for (let i = 0; i < resourceCollection.length; i++) {\n      if (resourceCollection[i].field === fieldName && i < resourceCollection.length - 1) {\n        const resObject = this.createInstance(i);\n        let datasource = [];\n        for (let j = 0; j < args.value.length; j++) {\n          const resourceModel = resourceCollection[i + 1];\n          // eslint-disable-next-line max-len\n          const filter = resourceModel.dataSource.filter(data => data[resourceModel.groupIDField] === args.value[j])[0];\n          const groupId = filter[resourceCollection[i + 1].groupIDField];\n          const filterRes = this.filterDatasource(i, groupId);\n          datasource = datasource.concat(filterRes);\n        }\n        resObject.dataSource = datasource;\n        resObject.dataBind();\n      }\n    }\n  }\n  createInstance(index) {\n    const resourceData = this.parent.resourceBase.resourceCollection[index + 1];\n    const resObject = this.element.querySelector('.e-' + resourceData.field).ej2_instances[0];\n    return resObject;\n  }\n  onDropdownResourceChange(args) {\n    if (!args.value || this.parent.resourceCollection.length <= 1 || !this.parent.activeViewOptions.group.byGroupID) {\n      return;\n    }\n    const fieldName = args.element.getAttribute('name') || this.getColumnName(args.element);\n    const resourceCollection = this.parent.resourceBase.resourceCollection;\n    for (let i = 0; i < resourceCollection.length; i++) {\n      if (i < resourceCollection.length - 1 && resourceCollection[i].field === fieldName) {\n        const resObj = this.createInstance(i);\n        const groupId = args.itemData[resourceCollection[i].idField];\n        resObj.dataSource = this.filterDatasource(i, groupId);\n        resObj.dataBind();\n        const resValue = resObj.dataSource[0][resourceCollection[i + 1].idField];\n        resObj.value = resourceCollection[i + 1].allowMultiple ? [resValue] : resValue;\n        resObj.dataBind();\n      }\n    }\n  }\n  filterDatasource(index, groupId) {\n    const resourceData = this.parent.resourceBase.resourceCollection[index + 1];\n    return resourceData.dataSource.filter(data => data[resourceData.groupIDField] === groupId);\n  }\n  onTimezoneChange(args) {\n    const fieldName = args.element.getAttribute('name') || this.getColumnName(args.element);\n    if (fieldName === this.parent.eventFields.startTimezone) {\n      const startTimezoneObj = this.getInstance(EVENT_WINDOW_START_TZ_CLASS);\n      const endTimezoneObj = this.getInstance(EVENT_WINDOW_END_TZ_CLASS);\n      endTimezoneObj.value = startTimezoneObj.value;\n      endTimezoneObj.dataBind();\n    }\n  }\n  renderCheckBox(value) {\n    const checkBoxDiv = this.createDivElement(value + '-container');\n    const fieldName = this.getFieldName(value);\n    const checkBoxInput = this.createInputElement(value + ' ' + EVENT_FIELD$1, fieldName);\n    checkBoxDiv.appendChild(checkBoxInput);\n    const checkBox = new CheckBox({\n      change: this.onChange.bind(this),\n      cssClass: value + ' ' + this.parent.cssClass,\n      enableRtl: this.parent.enableRtl,\n      label: this.getFieldLabel(value)\n    });\n    checkBox.appendTo(checkBoxInput);\n    checkBoxInput.setAttribute('name', fieldName);\n    if (fieldName === 'Repeat') {\n      this.repeatStatus = checkBox;\n    }\n    return checkBoxDiv;\n  }\n  renderTextBox(value) {\n    const textBoxDiv = this.createDivElement(value + '-container');\n    const fieldName = this.getFieldName(value);\n    const elementType = value === DESCRIPTION_CLASS ? 'textarea' : 'input';\n    const textBoxInput = this.createInputElement(value + ' ' + EVENT_FIELD$1, fieldName, elementType);\n    textBoxDiv.appendChild(textBoxInput);\n    Input.createInput({\n      element: textBoxInput,\n      floatLabelType: 'Always',\n      properties: {\n        enableRtl: this.parent.enableRtl,\n        placeholder: this.getFieldLabel(value)\n      }\n    });\n    return textBoxDiv;\n  }\n  getFieldName(name) {\n    let fieldName = '';\n    switch (name) {\n      case SUBJECT_CLASS:\n        fieldName = this.fields.subject;\n        break;\n      case LOCATION_CLASS:\n        fieldName = this.fields.location;\n        break;\n      case EVENT_WINDOW_START_CLASS:\n        fieldName = this.fields.startTime;\n        break;\n      case EVENT_WINDOW_END_CLASS:\n        fieldName = this.fields.endTime;\n        break;\n      case DESCRIPTION_CLASS:\n        fieldName = this.fields.description;\n        break;\n      case EVENT_WINDOW_ALL_DAY_CLASS:\n        fieldName = this.fields.isAllDay;\n        break;\n      case EVENT_WINDOW_START_TZ_CLASS:\n        fieldName = this.fields.startTimezone;\n        break;\n      case EVENT_WINDOW_END_TZ_CLASS:\n        fieldName = this.fields.endTimezone;\n        break;\n      case TIME_ZONE_CLASS:\n        fieldName = 'Timezone';\n        break;\n      case EVENT_WINDOW_REPEAT_CLASS:\n        fieldName = 'Repeat';\n        break;\n    }\n    return fieldName;\n  }\n  getFieldLabel(fieldName) {\n    let labelText = '';\n    switch (fieldName) {\n      case SUBJECT_CLASS:\n        labelText = this.parent.editorTitles.subject;\n        break;\n      case LOCATION_CLASS:\n        labelText = this.parent.editorTitles.location;\n        break;\n      case DESCRIPTION_CLASS:\n        labelText = this.parent.editorTitles.description;\n        break;\n      case EVENT_WINDOW_START_CLASS:\n        labelText = this.parent.editorTitles.startTime;\n        break;\n      case EVENT_WINDOW_END_CLASS:\n        labelText = this.parent.editorTitles.endTime;\n        break;\n      case EVENT_WINDOW_START_TZ_CLASS:\n        labelText = this.parent.editorTitles.startTimezone;\n        break;\n      case EVENT_WINDOW_END_TZ_CLASS:\n        labelText = this.parent.editorTitles.endTimezone;\n        break;\n      case EVENT_WINDOW_REPEAT_CLASS:\n        labelText = this.parent.editorTitles.recurrenceRule;\n        break;\n      case EVENT_WINDOW_ALL_DAY_CLASS:\n        labelText = this.parent.editorTitles.isAllDay;\n        break;\n      case TIME_ZONE_CLASS:\n        labelText = this.l10n.getConstant('timezone');\n        break;\n    }\n    return labelText;\n  }\n  onChange(args) {\n    const target = args.event.currentTarget.querySelector('input');\n    if (target.classList.contains(EVENT_WINDOW_ALL_DAY_CLASS)) {\n      this.onAllDayChange(args.checked);\n    } else if (target.classList.contains(TIME_ZONE_CLASS)) {\n      this.timezoneChangeStyle(args.checked);\n    } else if (target.classList.contains(EVENT_WINDOW_REPEAT_CLASS)) {\n      this.onRepeatChange(args.checked);\n    }\n  }\n  renderRepeatDialog() {\n    const element = createElement('div');\n    this.repeatDialogObject = new Dialog({\n      header: this.l10n.getConstant('recurrence'),\n      visible: false,\n      content: '<div class=\"e-rec-editor\"></div>',\n      closeOnEscape: true,\n      width: '90%',\n      buttons: [{\n        click: this.repeatSaveDialog.bind(this),\n        buttonModel: {\n          content: this.l10n.getConstant('save'),\n          cssClass: 'e-save',\n          isPrimary: true\n        }\n      }, {\n        click: this.repeatCancelDialog.bind(this),\n        buttonModel: {\n          cssClass: 'e-cancel',\n          content: this.l10n.getConstant('cancel')\n        }\n      }],\n      target: this.element,\n      animationSettings: {\n        effect: 'Zoom'\n      },\n      enableRtl: this.parent.enableRtl,\n      isModal: true,\n      cssClass: REPEAT_DIALOG_CLASS,\n      open: this.repeatOpenDialog.bind(this)\n    });\n    this.element.appendChild(element);\n    this.repeatDialogObject.appendTo(element);\n    this.createRecurrenceEditor(this.repeatDialogObject.element.querySelector('.e-rec-editor'));\n  }\n  loadRecurrenceEditor() {\n    this.repeatDialogObject.show();\n    if (this.recurrenceEditor && this.repeatRule) {\n      this.recurrenceEditor.setRecurrenceRule(this.repeatRule);\n    }\n  }\n  onRepeatChange(state) {\n    if (state) {\n      if (!this.repeatDialogObject) {\n        this.renderRepeatDialog();\n      }\n      this.recurrenceEditor.setProperties({\n        startDate: this.repeatStartDate,\n        selectedType: 0\n      });\n      this.loadRecurrenceEditor();\n    } else {\n      if (this.repeatDialogObject) {\n        this.repeatDialogObject.hide();\n      }\n      this.repeatRule = '';\n      if (this.recurrenceEditor) {\n        this.recurrenceEditor.setRecurrenceRule(this.repeatRule);\n        this.updateRepeatLabel(this.repeatRule);\n      }\n      const element = this.element.querySelector('.' + REPEAT_CONTAINER_CLASS);\n      addClass([element], HIDE_STYLE_CLASS);\n    }\n  }\n  repeatSaveDialog() {\n    this.repeatRule = this.recurrenceEditor.getRecurrenceRule();\n    const element = this.element.querySelector('.' + REPEAT_CONTAINER_CLASS);\n    if (this.recurrenceEditor.getRecurrenceRule()) {\n      removeClass([element], HIDE_STYLE_CLASS);\n    } else {\n      addClass([element], HIDE_STYLE_CLASS);\n      this.repeatStatus.setProperties({\n        checked: false\n      });\n    }\n    this.updateRepeatLabel(this.repeatRule);\n    this.closeRepeatDialog();\n  }\n  closeRepeatDialog() {\n    this.repeatDialogObject.hide();\n  }\n  repeatCancelDialog() {\n    this.closeRepeatDialog();\n    if (this.recurrenceEditor) {\n      this.recurrenceEditor.setRecurrenceRule(this.repeatTempRule);\n    }\n    if (!this.repeatTempRule) {\n      this.repeatStatus.setProperties({\n        checked: false\n      });\n    }\n  }\n  repeatOpenDialog() {\n    this.repeatTempRule = this.recurrenceEditor.getRecurrenceRule();\n  }\n  onCellDetailsUpdate(eventObj, repeatType) {\n    if (!this.parent.eventSettings.allowAdding) {\n      return;\n    }\n    this.element.querySelector('.' + FORM_CLASS).removeAttribute('data-id');\n    this.element.querySelector('.' + EVENT_WINDOW_TITLE_TEXT_CLASS).innerHTML = this.l10n.getConstant('newEvent');\n    eventObj.Timezone = false;\n    this.repeatStartDate = eventObj[this.fields.startTime];\n    this.repeatRule = '';\n    if (!isNullOrUndefined(this.parent.eventSettings.fields.subject.default)) {\n      eventObj[this.fields.subject] = this.parent.eventSettings.fields.subject.default;\n    }\n    if (!isNullOrUndefined(this.parent.eventSettings.fields.location.default)) {\n      eventObj[this.fields.location] = this.parent.eventSettings.fields.location.default;\n    }\n    if (!isNullOrUndefined(this.parent.eventSettings.fields.description.default)) {\n      eventObj[this.fields.description] = this.parent.eventSettings.fields.description.default;\n    }\n    this.showDetails(eventObj);\n    if (eventObj[this.fields.recurrenceRule] && this.recurrenceEditor) {\n      this.recurrenceEditor.setRecurrenceRule(eventObj[this.fields.recurrenceRule], eventObj[this.fields.startTime]);\n      this.repeatRule = eventObj[this.fields.recurrenceRule];\n    }\n    const deleteButton = this.element.querySelector('.' + DELETE_EVENT_CLASS);\n    if (deleteButton) {\n      addClass([deleteButton], DISABLE_CLASS);\n    }\n    if (this.recurrenceEditor) {\n      this.recurrenceEditor.setProperties({\n        startDate: eventObj[this.fields.startTime],\n        selectedType: !isNullOrUndefined(repeatType) ? repeatType : !isNullOrUndefined(eventObj[this.fields.recurrenceRule]) ? this.recurrenceEditor.selectedType : 0\n      });\n    }\n    if (this.parent.isAdaptive && isNullOrUndefined(this.parent.editorTemplate)) {\n      const element = this.element.querySelector('.' + REPEAT_CONTAINER_CLASS);\n      addClass([element], HIDE_STYLE_CLASS);\n      this.updateRepeatLabel(this.repeatRule);\n    } else {\n      const saveButton = this.element.querySelector('.' + EVENT_WINDOW_SAVE_BUTTON_CLASS);\n      this.disableButton(saveButton, false);\n    }\n    this.dialogObject.show();\n  }\n  convertToEventData(cellsData, eventObj) {\n    if (cellsData.subject) {\n      eventObj[this.fields.subject] = cellsData.subject;\n    }\n    eventObj[this.fields.startTime] = cellsData.startTime;\n    eventObj[this.fields.endTime] = cellsData.endTime;\n    eventObj[this.fields.isAllDay] = cellsData.isAllDay;\n    if (cellsData.RecurrenceRule) {\n      eventObj[this.fields.recurrenceRule] = cellsData.RecurrenceRule;\n    }\n    if (this.parent.resourceCollection.length > 0 || this.parent.activeViewOptions.group.resources.length > 0) {\n      this.parent.resourceBase.setResourceValues(eventObj);\n    }\n  }\n  applyFormValidation() {\n    const getValidationRule = rules => rules && Object.keys(rules).length > 0 ? rules : undefined;\n    const form = this.element.querySelector('.' + FORM_CLASS);\n    const rules = {};\n    rules[this.parent.eventSettings.fields.subject.name] = getValidationRule(this.parent.eventSettings.fields.subject.validation);\n    rules[this.parent.eventSettings.fields.location.name] = getValidationRule(this.parent.eventSettings.fields.location.validation);\n    rules[this.parent.eventSettings.fields.startTime.name] = getValidationRule(this.parent.eventSettings.fields.startTime.validation);\n    rules[this.parent.eventSettings.fields.endTime.name] = getValidationRule(this.parent.eventSettings.fields.endTime.validation);\n    rules[this.parent.eventSettings.fields.description.name] = getValidationRule(this.parent.eventSettings.fields.description.validation);\n    this.fieldValidator = new FieldValidator();\n    this.fieldValidator.renderFormValidator(form, rules, this.element, this.parent.locale);\n  }\n  showDetails(eventData) {\n    const eventObj = extend({}, eventData, null, true);\n    if (eventObj[this.fields.endTime].getHours() === 0 && eventObj[this.fields.endTime].getMinutes() === 0) {\n      this.trimAllDay(eventObj);\n    }\n    this.eventData = eventObj;\n    const formElements = this.getFormElements(EVENT_WINDOW_DIALOG_CLASS);\n    const keyNames = Object.keys(eventObj);\n    for (const curElement of formElements) {\n      const columnName = curElement.name || this.getColumnName(curElement);\n      if (!isNullOrUndefined(columnName) && columnName !== '') {\n        if (keyNames.indexOf(columnName) !== -1) {\n          this.setValueToElement(curElement, eventObj[columnName]);\n        } else {\n          this.setDefaultValueToElement(curElement);\n        }\n      }\n    }\n    if (isNullOrUndefined(this.parent.editorTemplate)) {\n      this.onAllDayChange(eventObj[this.fields.isAllDay]);\n      const timezoneObj = this.getInstance(TIME_ZONE_CLASS + '.' + EVENT_FIELD$1);\n      if (!(isNullOrUndefined(eventObj[this.fields.startTimezone]) && isNullOrUndefined(eventObj[this.fields.endTimezone]))) {\n        timezoneObj.checked = true;\n        timezoneObj.dataBind();\n      }\n      this.timezoneChangeStyle(timezoneObj.checked);\n      delete eventObj.Timezone;\n    }\n  }\n  getColumnName(element) {\n    let attrName = element.getAttribute('data-name') || '';\n    if (attrName === '') {\n      let isDropDowns = false;\n      let fieldSelector = '';\n      if (element.classList.contains('e-dropdownlist')) {\n        fieldSelector = 'e-ddl';\n        isDropDowns = true;\n      } else if (element.classList.contains('e-multiselect')) {\n        fieldSelector = 'e-multiselect';\n        isDropDowns = true;\n      } else if (element.classList.contains('e-datetimepicker')) {\n        fieldSelector = 'e-datetimepicker';\n      } else if (element.classList.contains('e-datepicker')) {\n        fieldSelector = 'e-datepicker';\n      } else if (element.classList.contains('e-checkbox')) {\n        fieldSelector = 'e-checkbox';\n      }\n      const classSelector = isDropDowns ? `.${fieldSelector}:not(.e-control)` : `.${fieldSelector}`;\n      const control = closest(element, classSelector) || element.querySelector(`.${fieldSelector}`);\n      if (control) {\n        const attrEle = control.querySelector('[name]');\n        if (attrEle) {\n          attrName = attrEle.name;\n        }\n      }\n    }\n    return attrName;\n  }\n  onAllDayChange(allDayStatus) {\n    const startObj = this.getInstance(EVENT_WINDOW_START_CLASS);\n    const endObj = this.getInstance(EVENT_WINDOW_END_CLASS);\n    const timezoneDiv = this.element.querySelector('.e-time-zone-container');\n    let format;\n    if (allDayStatus) {\n      format = isNullOrUndefined(this.parent.dateFormat) ? this.getFormat('dateFormats') : this.parent.dateFormat;\n      addClass(this.element.querySelectorAll('.e-time-icon'), EVENT_WINDOW_ICON_DISABLE_CLASS);\n      addClass([timezoneDiv], DISABLE_CLASS);\n      if (this.element.querySelector('.' + EVENT_WINDOW_TIME_ZONE_DIV_CLASS)) {\n        removeClass([this.element.querySelector('.' + EVENT_WINDOW_TIME_ZONE_DIV_CLASS)], ENABLE_CLASS);\n      }\n      startObj.format = endObj.format = format;\n    } else {\n      format = isNullOrUndefined(this.parent.dateFormat) ? this.getFormat('dateFormats') + ' ' + this.parent.activeViewOptions.timeFormat : this.parent.dateFormat + ' ' + this.parent.activeViewOptions.timeFormat;\n      removeClass(this.element.querySelectorAll('.e-time-icon'), EVENT_WINDOW_ICON_DISABLE_CLASS);\n      removeClass([timezoneDiv], DISABLE_CLASS);\n      if (this.element.querySelector('.e-checkbox-wrapper .e-time-zone').checked) {\n        addClass([this.element.querySelector('.' + EVENT_WINDOW_TIME_ZONE_DIV_CLASS)], ENABLE_CLASS);\n      }\n      startObj.format = endObj.format = format;\n    }\n    if (this.cellClickAction) {\n      this.updateDateTime(allDayStatus, startObj, endObj);\n    }\n    startObj.dataBind();\n    endObj.dataBind();\n    if (!isNullOrUndefined(this.recurrenceEditor)) {\n      this.recurrenceEditor.updateRuleUntilDate(startObj.value);\n    }\n  }\n  updateDateTime(allDayStatus, startObj, endObj) {\n    let startDate;\n    let endDate;\n    if (allDayStatus) {\n      startDate = resetTime(new Date(this.eventWindowTime.startTime.getTime()));\n      if (this.parent.activeCellsData.isAllDay) {\n        const temp = addDays(new Date(this.eventWindowTime.endTime.getTime()), -1).getTime();\n        endDate = +this.eventWindowTime.startTime > temp ? this.eventWindowTime.endTime : new Date(temp);\n      } else {\n        endDate = resetTime(new Date(this.eventWindowTime.endTime.getTime()));\n      }\n    } else {\n      const start = this.parent.activeCellsData.startTime;\n      startDate = new Date(this.eventWindowTime.startTime.getTime());\n      startDate.setHours(start.getHours(), start.getMinutes(), start.getSeconds());\n      if (this.parent.activeCellsData.isAllDay) {\n        const startHour = this.parent.getStartEndTime(this.parent.workHours.start);\n        startDate.setHours(startHour.getHours(), startHour.getMinutes(), startHour.getSeconds());\n        endDate = new Date(startDate.getTime());\n        endDate.setMilliseconds(MS_PER_MINUTE * this.getSlotDuration());\n      } else {\n        endDate = new Date(startDate.getTime());\n        endDate.setMilliseconds(this.parent.activeCellsData.endTime.getTime() - this.parent.activeCellsData.startTime.getTime());\n      }\n    }\n    this.eventWindowTime = {\n      startTime: new Date(startDate.getTime()),\n      endTime: new Date(endDate.getTime())\n    };\n    startObj.value = startDate;\n    endObj.value = endDate;\n    startObj.dataBind();\n    endObj.dataBind();\n  }\n  getFormat(formatType) {\n    let format;\n    if (this.parent.locale === 'en' || this.parent.locale === 'en-US') {\n      format = getValue(formatType + '.short', getDefaultDateObject(this.parent.getCalendarMode()));\n    } else {\n      format = getValue(`main.${this.parent.locale}.dates.calendars.${this.parent.getCalendarMode()}.${formatType}.short`, cldrData);\n    }\n    return format;\n  }\n  onEventDetailsUpdate(eventObj) {\n    if (!this.parent.eventSettings.allowEditing) {\n      return;\n    }\n    if (!this.parent.isAdaptive) {\n      removeClass([this.element.querySelector('.' + DELETE_EVENT_CLASS)], DISABLE_CLASS);\n    }\n    this.element.querySelector('.' + EVENT_WINDOW_TITLE_TEXT_CLASS).innerHTML = this.l10n.getConstant('editEvent');\n    this.element.querySelector('.' + FORM_CLASS).setAttribute('data-id', eventObj[this.fields.id].toString());\n    if (isNullOrUndefined(this.parent.editorTemplate)) {\n      eventObj = extend({}, eventObj, null, true);\n      const timezoneObj = this.getInstance(TIME_ZONE_CLASS + '.' + EVENT_FIELD$1);\n      let timezoneValue;\n      if (eventObj[this.fields.startTimezone] || eventObj[this.fields.endTimezone]) {\n        timezoneValue = true;\n        this.parent.eventBase.timezoneConvert(eventObj);\n      } else {\n        timezoneValue = false;\n      }\n      eventObj.Timezone = timezoneValue;\n      timezoneObj.checked = timezoneValue;\n      timezoneObj.dataBind();\n    }\n    this.showDetails(eventObj);\n    if (eventObj[this.fields.recurrenceRule] && this.recurrenceEditor) {\n      this.recurrenceEditor.setRecurrenceRule(eventObj[this.fields.recurrenceRule], eventObj[this.fields.startTime]);\n    } else if (!this.parent.isAdaptive && this.recurrenceEditor) {\n      this.recurrenceEditor.setProperties({\n        startDate: eventObj[this.fields.startTime]\n      });\n      this.recurrenceEditor.setRecurrenceRule('');\n    }\n    this.repeatStartDate = eventObj[this.fields.startTime];\n    this.repeatRule = '';\n    if (eventObj[this.fields.recurrenceRule]) {\n      if (this.recurrenceEditor) {\n        this.recurrenceEditor.setRecurrenceRule(eventObj[this.fields.recurrenceRule], eventObj[this.fields.startTime]);\n      }\n      this.repeatRule = eventObj[this.fields.recurrenceRule];\n    }\n    if (this.parent.isAdaptive && isNullOrUndefined(this.parent.editorTemplate)) {\n      const element = this.element.querySelector('.' + REPEAT_CONTAINER_CLASS);\n      if (eventObj[this.fields.recurrenceRule]) {\n        removeClass([element], HIDE_STYLE_CLASS);\n        this.repeatStatus.setProperties({\n          checked: true\n        });\n      } else {\n        addClass([element], HIDE_STYLE_CLASS);\n        this.repeatStatus.setProperties({\n          checked: false\n        });\n      }\n      this.updateRepeatLabel(this.repeatRule);\n    }\n    const isDisable = this.parent.readonly || eventObj[this.fields.isReadonly];\n    if (!this.parent.isAdaptive) {\n      const saveButton = this.element.querySelector('.' + EVENT_WINDOW_SAVE_BUTTON_CLASS);\n      const deleteButton = this.element.querySelector('.' + DELETE_EVENT_CLASS);\n      this.disableButton(saveButton, isDisable);\n      this.disableButton(deleteButton, isDisable);\n    } else {\n      const saveIcon = this.element.querySelector('.' + EVENT_WINDOW_SAVE_ICON_CLASS);\n      if (saveIcon) {\n        if (isDisable) {\n          addClass([saveIcon], ICON_DISABLE_CLASS);\n        } else {\n          removeClass([saveIcon], ICON_DISABLE_CLASS);\n        }\n      }\n    }\n    this.dialogObject.show();\n  }\n  disableButton(element, value) {\n    if (element) {\n      element.ej2_instances[0].disabled = value;\n    }\n  }\n  renderRecurrenceEditor() {\n    return new RecurrenceEditor({\n      calendarMode: this.parent.calendarMode,\n      cssClass: this.parent.cssClass,\n      dateFormat: this.parent.dateFormat,\n      enableRtl: this.parent.enableRtl,\n      firstDayOfWeek: this.parent.activeViewOptions.firstDayOfWeek,\n      locale: this.parent.locale\n    });\n  }\n  updateMinMaxDateToEditor() {\n    const startDate = this.element.querySelector('.e-start');\n    const endDate = this.element.querySelector('.e-end');\n    if (startDate && endDate) {\n      const startObj = startDate.ej2_instances[0];\n      const endObj = endDate.ej2_instances[0];\n      startObj.min = this.parent.minDate;\n      startObj.max = this.parent.maxDate;\n      endObj.min = this.parent.minDate;\n      endObj.max = this.parent.maxDate;\n      startObj.dataBind();\n      endObj.dataBind();\n    }\n    if (this.recurrenceEditor) {\n      const untilDate = this.recurrenceEditor.element.querySelector('.e-until-date');\n      if (untilDate) {\n        const untilObj = untilDate.ej2_instances[0];\n        untilObj.min = this.parent.minDate;\n        untilObj.max = this.parent.maxDate;\n        untilObj.dataBind();\n      }\n    }\n  }\n  updateRepeatLabel(repeatRule) {\n    if (this.parent.isAdaptive && !this.repeatDialogObject) {\n      this.renderRepeatDialog();\n    }\n    const data = repeatRule ? this.l10n.getConstant('repeats') + ' ' + this.recurrenceEditor.getRuleSummary(repeatRule) : this.l10n.getConstant('repeat');\n    this.repeatStatus.setProperties({\n      label: data\n    });\n  }\n  dialogClose(event) {\n    if (this.isEnterKey) {\n      this.isEnterKey = false;\n      return;\n    }\n    this.dialogEvent = event;\n    this.isCrudAction = false;\n    this.parent.activeEventData = {\n      event: undefined,\n      element: undefined\n    };\n    this.parent.currentAction = null;\n    this.dialogObject.hide();\n  }\n  resetForm() {\n    this.fieldValidator.destroyToolTip();\n    this.resetFormFields();\n    if (!this.parent.isAdaptive && this.recurrenceEditor && !this.recurrenceEditor.isDestroyed) {\n      this.recurrenceEditor.resetFields();\n    }\n  }\n  timezoneChangeStyle(value) {\n    const timezoneDiv = this.element.querySelector('.' + EVENT_WINDOW_TIME_ZONE_DIV_CLASS);\n    const localTimezoneName = this.parent.tzModule.getLocalTimezoneName();\n    if (value) {\n      addClass([timezoneDiv], ENABLE_CLASS);\n      const startTimezoneObj = this.getInstance(EVENT_WINDOW_START_TZ_CLASS);\n      const endTimezoneObj = this.getInstance(EVENT_WINDOW_END_TZ_CLASS);\n      const timezone = startTimezoneObj.dataSource;\n      if (!startTimezoneObj.value || !this.parent.timezone) {\n        const found = timezone.some(tz => {\n          return tz.Value === localTimezoneName;\n        });\n        if (!found) {\n          timezone.push({\n            Value: localTimezoneName,\n            Text: localTimezoneName\n          });\n          startTimezoneObj.dataSource = timezone;\n          endTimezoneObj.dataSource = timezone;\n          startTimezoneObj.dataBind();\n          endTimezoneObj.dataBind();\n        }\n      }\n      startTimezoneObj.value = startTimezoneObj.value || this.parent.timezone || localTimezoneName;\n      endTimezoneObj.value = endTimezoneObj.value || this.parent.timezone || localTimezoneName;\n      startTimezoneObj.dataBind();\n      endTimezoneObj.dataBind();\n    } else {\n      removeClass([timezoneDiv], ENABLE_CLASS);\n    }\n  }\n  resetFormFields() {\n    const formElement = this.getFormElements(EVENT_WINDOW_DIALOG_CLASS);\n    for (const currentElement of formElement) {\n      const columnName = currentElement.name || this.getColumnName(currentElement);\n      if (!isNullOrUndefined(columnName) && columnName !== '') {\n        this.setDefaultValueToElement(currentElement);\n      }\n    }\n  }\n  eventSave(event, alert) {\n    if (this.isEnterKey) {\n      this.isEnterKey = false;\n      return;\n    }\n    const formElement = this.element.querySelector('.' + FORM_CLASS);\n    if (formElement && formElement.classList.contains('e-formvalidator') && !formElement.ej2_instances[0].validate()) {\n      return;\n    }\n    const dataCollection = this.getEventDataFromEditor();\n    if (this.processEventValidation(dataCollection.tempData, alert)) {\n      return;\n    }\n    this.eventCrudData = dataCollection.eventData;\n    this.dialogEvent = event;\n    this.isCrudAction = true;\n    this.dialogObject.hide();\n  }\n  getEventDataFromEditor() {\n    const eventObj = extend({}, this.getObjectFromFormData(EVENT_WINDOW_DIALOG_CLASS));\n    if (!eventObj.Timezone) {\n      eventObj[this.fields.startTimezone] = null;\n      eventObj[this.fields.endTimezone] = null;\n    }\n    delete eventObj.Timezone;\n    delete eventObj.Repeat;\n    this.setDefaultValueToObject(eventObj);\n    eventObj[this.fields.recurrenceRule] = this.recurrenceEditor ? this.recurrenceEditor.getRecurrenceRule() || null : undefined;\n    const tempObj = extend({}, eventObj, null, true);\n    if (eventObj[this.fields.isAllDay]) {\n      eventObj[this.fields.startTime] = isNullOrUndefined(eventObj[this.fields.startTime]) ? null : resetTime(new Date(eventObj[this.fields.startTime].getTime()));\n      eventObj[this.fields.endTime] = isNullOrUndefined(eventObj[this.fields.endTime]) ? null : addDays(resetTime(new Date(eventObj[this.fields.endTime].getTime())), 1);\n    }\n    return {\n      eventData: eventObj,\n      tempData: tempObj\n    };\n  }\n  processEventValidation(eventObj, alert) {\n    let alertType;\n    if (isNullOrUndefined(this.parent.editorTemplate)) {\n      if (!eventObj[this.fields.startTime] || !eventObj[this.fields.endTime]) {\n        this.parent.quickPopup.openValidationError('invalidDateError');\n        return true;\n      }\n      if (eventObj[this.fields.startTime] > eventObj[this.fields.endTime]) {\n        this.parent.quickPopup.openValidationError('startEndError');\n        return true;\n      }\n    }\n    if (this.recurrenceEditor && this.recurrenceEditor.value && this.recurrenceEditor.value !== '') {\n      alertType = this.recurrenceValidation(eventObj[this.fields.startTime], eventObj[this.fields.endTime], alert);\n      let isShowAlert = true;\n      if (alertType === 'seriesChangeAlert' && this.parent.uiStateValues.isIgnoreOccurrence) {\n        isShowAlert = false;\n      }\n      if (!isNullOrUndefined(alertType) && isShowAlert && (!this.parent.enableRecurrenceValidation && alertType === 'wrongPattern' || this.parent.enableRecurrenceValidation)) {\n        this.parent.quickPopup.openRecurrenceValidationAlert(alertType);\n        return true;\n      }\n    }\n    return false;\n  }\n  processCrudActions(eventObj) {\n    this.parent.uiStateValues.isBlock = false;\n    const resourceData = this.getResourceData(eventObj);\n    const isResourceEventExpand = (this.parent.activeViewOptions.group.resources.length > 0 || this.parent.resourceCollection.length > 0) && !this.parent.activeViewOptions.group.allowGroupEdit && !isNullOrUndefined(resourceData);\n    const eventId = this.getEventIdFromForm();\n    if (!isNullOrUndefined(eventId)) {\n      let eveId = this.parent.eventBase.getEventIDType() === 'string' ? eventId : parseInt(eventId, 10);\n      let editedData = this.parent.eventsData.filter(data => data[this.fields.id] === eveId)[0];\n      if (isNullOrUndefined(editedData)) {\n        editedData = this.parent.blockData.filter(data => data[this.fields.id] === eveId)[0];\n      }\n      eventObj = extend({}, editedData, eventObj);\n      if (eventObj[this.fields.isReadonly]) {\n        return false;\n      }\n      let currentAction;\n      if (!isNullOrUndefined(editedData[this.fields.recurrenceRule])) {\n        currentAction = this.parent.currentAction;\n        eventObj.Guid = this.parent.activeEventData.event.Guid;\n        if (this.parent.currentAction === 'EditOccurrence') {\n          if (!eventObj[this.fields.recurrenceID]) {\n            eventObj[this.fields.id] = this.parent.eventBase.getEventMaxID();\n            eventObj.Guid = this.parent.activeEventData.event.Guid;\n          } else {\n            eveId = eventObj[this.fields.recurrenceID];\n            currentAction = null;\n          }\n          if (this.parent.enableRecurrenceValidation && this.editOccurrenceValidation(eveId, eventObj)) {\n            return true;\n          }\n        }\n        if (this.parent.currentAction === 'EditSeries' || eventObj[this.fields.id] !== editedData[this.fields.id]) {\n          eventObj[this.fields.recurrenceID] = editedData[this.fields.id];\n        } else if (this.parent.currentAction === 'EditFollowingEvents') {\n          eventObj[this.fields.id] = this.parent.eventBase.getEventMaxID();\n          eventObj[this.fields.followingID] = editedData[this.fields.id];\n        }\n      }\n      if (isResourceEventExpand) {\n        this.resourceSaveEvent(eventObj, 'Save', currentAction);\n      } else {\n        this.parent.saveEvent(eventObj, currentAction);\n      }\n    } else {\n      this.parent.currentAction = 'Add';\n      if (isResourceEventExpand) {\n        this.resourceSaveEvent(eventObj, this.parent.currentAction);\n      } else {\n        eventObj[this.fields.id] = this.parent.eventBase.getEventMaxID();\n        this.parent.addEvent(eventObj);\n      }\n    }\n    return this.parent.uiStateValues.isBlock;\n  }\n  getResourceData(eventObj) {\n    let resourceData = null;\n    if (!isNullOrUndefined(this.parent.resourceBase) && !isNullOrUndefined(this.parent.resourceBase.resourceCollection) && this.parent.resourceBase.resourceCollection.length > 0) {\n      const lastResourceData = this.parent.resourceBase.resourceCollection.slice(-1)[0];\n      resourceData = eventObj[lastResourceData.field];\n    }\n    return resourceData;\n  }\n  getObjectFromFormData(className) {\n    const formElement = this.getFormElements(className);\n    const eventObj = {};\n    for (const currentElement of formElement) {\n      const columnName = currentElement.name || this.getColumnName(currentElement);\n      if (!isNullOrUndefined(columnName) && columnName !== '') {\n        eventObj[columnName] = this.getValueFromElement(currentElement);\n      }\n    }\n    return eventObj;\n  }\n  setDefaultValueToObject(eventObj) {\n    if (!isNullOrUndefined(eventObj[this.fields.subject])) {\n      eventObj[this.fields.subject] = eventObj[this.fields.subject] || this.parent.eventSettings.fields.subject.default || this.l10n.getConstant('addTitle');\n    }\n    if (!isNullOrUndefined(eventObj[this.fields.location])) {\n      eventObj[this.fields.location] = eventObj[this.fields.location] || this.parent.eventSettings.fields.location.default;\n    }\n    if (!isNullOrUndefined(eventObj[this.fields.description])) {\n      eventObj[this.fields.description] = eventObj[this.fields.description] || this.parent.eventSettings.fields.description.default;\n    }\n  }\n  recurrenceValidation(startDate, endDate, alert) {\n    let alertMessage;\n    const recEditor = this.recurrenceEditor;\n    const interval = this.getInstance('e-repeat-interval.e-numerictextbox').value;\n    if (alert !== this.l10n.getConstant('ok')) {\n      const activeEvent = this.parent.activeEventData.event;\n      let excludedEvents = [];\n      if ((this.parent.currentAction === 'EditSeries' || this.parent.currentAction === 'EditFollowingEvents') && !isNullOrUndefined(activeEvent)) {\n        const eventStartTime = activeEvent[this.parent.eventFields.startTime];\n        const seriesEvents = this.parent.eventBase.getSeriesEvents(this.eventData, eventStartTime);\n        if (seriesEvents.length > 0) {\n          excludedEvents = this.parent.eventBase.getEditedOccurrences(seriesEvents, eventStartTime);\n        } else {\n          const event = this.parent.eventBase.getEventById(activeEvent[this.parent.eventFields.id]);\n          excludedEvents = this.parent.eventBase.getEditedOccurrences([event], eventStartTime);\n        }\n        if (this.parent.currentAction === 'EditSeries' && !isNullOrUndefined(this.eventData[this.parent.eventFields.recurrenceException])) {\n          excludedEvents.push(this.eventData);\n        }\n      }\n      if (excludedEvents.length > 0) {\n        alertMessage = 'seriesChangeAlert';\n      }\n      if (this.getInstance('e-end-on-left .e-ddl .e-dropdownlist').value === 'until' && this.getInstance('e-end-on-date .e-datepicker').value < startDate) {\n        alertMessage = 'wrongPattern';\n      }\n      if (isNullOrUndefined(alertMessage)) {\n        let types = recEditor.value.split(';')[1].split('=')[1].split(',');\n        const obj = {\n          'SU': 0,\n          'MO': 1,\n          'TU': 2,\n          'WE': 3,\n          'TH': 4,\n          'FR': 5,\n          'SA': 6\n        };\n        const temp = [];\n        const tempDiff = [];\n        let tempValue;\n        switch (recEditor.value.split(';')[0].split('=')[1]) {\n          case 'DAILY':\n            if ((endDate.getTime() - startDate.getTime()) / (1000 * 3600) > interval * 24) {\n              alertMessage = 'createError';\n            }\n            break;\n          case 'WEEKLY':\n            types = recEditor.value.split(';')[1].split('=')[1].split(',');\n            for (let index = 0; index < types.length * (interval + 1); index++) {\n              temp[index] = types.length > index ? obj[types[index]] : temp[index - types.length] + 7 * interval;\n            }\n            tempValue = temp.sort((a, b) => a - b);\n            for (let index = 1; index < tempValue.length; index++) {\n              tempDiff.push(tempValue[index] - tempValue[index - 1]);\n            }\n            if ((endDate.getTime() - startDate.getTime()) / (1000 * 3600) >= Math.min(...tempDiff) * 24 || isNullOrUndefined(interval)) {\n              alertMessage = 'createError';\n            }\n            break;\n          case 'MONTHLY':\n            if (endDate.getTime() >= new Date(+startDate).setMonth(startDate.getMonth() + interval)) {\n              alertMessage = 'createError';\n            }\n            break;\n          case 'YEARLY':\n            if (endDate.getTime() >= new Date(+startDate).setFullYear(startDate.getFullYear() + interval)) {\n              alertMessage = 'createError';\n            }\n            break;\n        }\n      }\n    } else {\n      if (endDate.getTime() >= new Date(+startDate).setMonth(startDate.getMonth() + interval)) {\n        alertMessage = 'createError';\n      }\n      if (isNullOrUndefined(alertMessage)) {\n        this.parent.quickPopup.quickDialog.hide();\n      }\n    }\n    if (isNullOrUndefined(interval)) {\n      alertMessage = 'createError';\n    }\n    return alertMessage;\n  }\n  getRecurrenceIndex(recColl, event) {\n    let recIndex;\n    for (let index = 0; index < recColl.length; index++) {\n      if (event[this.fields.startTime].valueOf() === recColl[index][this.fields.startTime].valueOf()) {\n        recIndex = index;\n        break;\n      }\n    }\n    return recIndex;\n  }\n  trimAllDay(data) {\n    if (data[this.fields.isAllDay]) {\n      const temp = addDays(new Date(+data[this.fields.endTime]), -1).getTime();\n      data[this.fields.endTime] = +data[this.fields.startTime] > temp ? data[this.fields.endTime] : new Date(temp);\n    }\n  }\n  editOccurrenceValidation(eventId, currentData, editData) {\n    if (editData === void 0) {\n      editData = this.eventData;\n    }\n    const recurColl = this.parent.getOccurrencesByID(eventId);\n    const excludedDatas = this.parent.eventsData.filter(data => data[this.fields.recurrenceID] === eventId);\n    excludedDatas.map(data => recurColl.push(extend({}, data)));\n    currentData = extend({}, currentData);\n    this.trimAllDay(currentData);\n    for (const data of recurColl) {\n      this.trimAllDay(data);\n    }\n    this.parent.eventBase.sortByTime(recurColl);\n    const index = this.getRecurrenceIndex(recurColl, editData);\n    if (isNullOrUndefined(index)) {\n      return false;\n    }\n    if (index === 0) {\n      if (!isNullOrUndefined(recurColl[index + 1])) {\n        if (!(resetTime(new Date(+recurColl[index + 1][this.fields.startTime])).getTime() > resetTime(new Date(+currentData[this.fields.endTime])).getTime()) && resetTime(new Date(+recurColl[recurColl.length - 1][this.fields.endTime])).getTime() >= resetTime(new Date(+currentData[this.fields.startTime])).getTime()) {\n          this.parent.quickPopup.openRecurrenceValidationAlert('sameDayAlert');\n          return true;\n        } else if (resetTime(new Date(+recurColl[recurColl.length - 1][this.fields.endTime])).getTime() < resetTime(new Date(+currentData[this.fields.startTime])).getTime()) {\n          this.parent.quickPopup.openRecurrenceValidationAlert('occurrenceAlert');\n          return true;\n        }\n      }\n      return false;\n    } else {\n      if (index === recurColl.length - 1) {\n        if (!(resetTime(new Date(+recurColl[index - 1][this.fields.endTime])).getTime() < resetTime(new Date(+currentData[this.fields.startTime])).getTime()) && resetTime(new Date(+recurColl[recurColl.length - 1 - index][this.fields.startTime])).getTime() <= resetTime(new Date(+currentData[this.fields.endTime])).getTime()) {\n          this.parent.quickPopup.openRecurrenceValidationAlert('sameDayAlert');\n          return true;\n        } else if (resetTime(new Date(+recurColl[recurColl.length - 1 - index][this.fields.endTime])).getTime() > resetTime(new Date(+currentData[this.fields.startTime])).getTime()) {\n          this.parent.quickPopup.openRecurrenceValidationAlert('occurrenceAlert');\n          return true;\n        }\n      } else if (!((resetTime(new Date(+recurColl[index - 1][this.fields.endTime])).getTime() < resetTime(new Date(+currentData[this.fields.startTime])).getTime() || resetTime(new Date(+recurColl[0][this.fields.startTime])).getTime() > resetTime(new Date(+currentData[this.fields.startTime])).getTime()) && (resetTime(new Date(+recurColl[index + 1][this.fields.startTime])).getTime() > resetTime(new Date(+currentData[this.fields.endTime])).getTime() || resetTime(new Date(+recurColl[recurColl.length - 1][this.fields.endTime])).getTime() < resetTime(new Date(+currentData[this.fields.startTime])).getTime()))) {\n        this.parent.quickPopup.openRecurrenceValidationAlert('sameDayAlert');\n        return true;\n      } else if (resetTime(new Date(+recurColl[index + 1][this.fields.endTime])).getTime() < resetTime(new Date(+currentData[this.fields.startTime])).getTime() || resetTime(new Date(+recurColl[index - 1][this.fields.startTime])).getTime() > resetTime(new Date(+currentData[this.fields.endTime])).getTime()) {\n        this.parent.quickPopup.openRecurrenceValidationAlert('occurrenceAlert');\n        return true;\n      }\n    }\n    return false;\n  }\n  resourceSaveEvent(eventObj, action, currentAction) {\n    const lastResourceData = this.parent.resourceBase.resourceCollection.slice(-1)[0];\n    let resourceData = eventObj[lastResourceData.field];\n    resourceData = resourceData instanceof Array ? resourceData : [resourceData];\n    const lastLevel = this.parent.resourceBase.lastResourceLevel;\n    const eventList = [];\n    for (let i = 0; i < resourceData.length; i++) {\n      const events = extend({}, eventObj, null, true);\n      events[this.fields.id] = this.parent.eventBase.getEventMaxID();\n      const temp = [];\n      const addValues = () => {\n        if (action === 'Save' && i === resourceData.length - 1) {\n          if (temp.length > 0) {\n            temp[0][this.fields.id] = eventObj[this.fields.id];\n            for (let k = 1; k < temp.length; k++) {\n              temp[k][this.fields.id] = this.parent.eventBase.getEventMaxID(i);\n              eventList.push(temp[k]);\n              this.parent.saveEvent(temp[0], currentAction);\n            }\n          } else {\n            events[this.fields.id] = eventObj[this.fields.id];\n            this.parent.saveEvent(events, currentAction);\n          }\n        } else {\n          if (temp.length > 0) {\n            for (let j = 0; j < temp.length; j++) {\n              temp[j][this.fields.id] = this.parent.eventBase.getEventMaxID(j);\n              eventList.push(temp[j]);\n            }\n          } else {\n            events[this.fields.id] = this.parent.eventBase.getEventMaxID(i);\n            eventList.push(events);\n          }\n        }\n      };\n      if (this.parent.activeViewOptions.group.byGroupID && !isNullOrUndefined(lastLevel)) {\n        const lastResource = lastResourceData.dataSource;\n        const resCol = this.parent.resourceCollection;\n        let index;\n        if (resCol.length > 1) {\n          index = findIndexInData(lastResource, lastResourceData.idField, resourceData[i], events, resCol);\n        } else {\n          index = findIndexInData(lastResource, lastResourceData.idField, resourceData[i]);\n        }\n        if (index < 0) {\n          return;\n        }\n        const groupId = lastResource[index][lastResourceData.groupIDField];\n        const filter = lastLevel.filter(obj => obj.resourceData[lastResourceData.idField] === resourceData[i]).filter(obj => obj.resourceData[lastResourceData.groupIDField] === groupId)[0];\n        const groupOrder = filter.groupOrder;\n        for (let index = 0; index < this.parent.resourceBase.resourceCollection.length; index++) {\n          const field = this.parent.resourceBase.resourceCollection[index].field;\n          events[field] = groupOrder[index] instanceof Array ? groupOrder[index][0] : groupOrder[index];\n        }\n        addValues();\n      } else {\n        for (let index = 0; index < this.parent.resourceBase.resourceCollection.length - 1; index++) {\n          const field = this.parent.resourceBase.resourceCollection[index].field;\n          if (events[field] instanceof Array && events[field].length > 1) {\n            for (let k = 0; k < events[field].length; k++) {\n              const event = extend({}, events, null, true);\n              event[field] = eventObj[field][k];\n              event[lastResourceData.field] = resourceData[i];\n              temp.push(event);\n            }\n          } else {\n            if (temp.length === 0) {\n              events[field] = eventObj[field] instanceof Array ? eventObj[field][0] : eventObj[field];\n              events[lastResourceData.field] = resourceData[i];\n            } else {\n              for (let l = 0; l < temp.length; l++) {\n                temp[l][field] = eventObj[field] instanceof Array ? eventObj[field][0] : eventObj[field];\n              }\n            }\n          }\n        }\n        events[lastResourceData.field] = resourceData[i];\n        addValues();\n      }\n    }\n    if (eventList.length > 0) {\n      for (const event of eventList) {\n        event[this.fields.recurrenceException] = null;\n        event[this.fields.recurrenceID] = null;\n      }\n      this.parent.addEvent(eventList);\n    }\n  }\n  getEventIdFromForm() {\n    return this.element.querySelector('.' + FORM_CLASS).getAttribute('data-id');\n  }\n  getFormElements(className) {\n    let elements = [];\n    if (className === EVENT_WINDOW_DIALOG_CLASS) {\n      elements = [].slice.call(this.element.querySelectorAll('.' + EVENT_FIELD$1));\n    } else {\n      elements = [].slice.call(this.parent.element.querySelectorAll('.' + className + ' .' + EVENT_FIELD$1));\n    }\n    return elements;\n  }\n  getValueFromElement(element) {\n    let value;\n    if (element.classList.contains('e-datepicker')) {\n      value = element.ej2_instances[0].value;\n    } else if (element.classList.contains('e-datetimepicker')) {\n      value = element.ej2_instances[0].value;\n    } else if (element.classList.contains('e-dropdownlist')) {\n      value = element.ej2_instances[0].value;\n    } else if (element.classList.contains('e-multiselect')) {\n      value = element.ej2_instances[0].value;\n    } else if (element.classList.contains('e-checkbox')) {\n      value = element.ej2_instances[0].checked;\n    } else {\n      if (element.type === 'checkbox') {\n        value = element.checked;\n      } else {\n        value = SanitizeHtmlHelper.sanitize(element.value);\n      }\n    }\n    return value;\n  }\n  setValueToElement(element, value) {\n    if (element.classList.contains('e-datepicker')) {\n      const instance = element.ej2_instances[0];\n      instance.value = value;\n      instance.dataBind();\n    } else if (element.classList.contains('e-datetimepicker')) {\n      const instance = element.ej2_instances[0];\n      if (instance.element.classList.contains(EVENT_WINDOW_START_CLASS)) {\n        this.eventWindowTime.startTime = new Date('' + value);\n      } else {\n        this.eventWindowTime.endTime = new Date('' + value);\n      }\n      instance.value = value;\n      instance.dataBind();\n    } else if (element.classList.contains('e-dropdownlist')) {\n      const instance = element.ej2_instances[0];\n      instance.value = value;\n      instance.dataBind();\n    } else if (element.classList.contains('e-multiselect')) {\n      const instance = element.ej2_instances[0];\n      instance.value = [];\n      instance.value = value instanceof Array ? value : [value];\n      instance.dataBind();\n    } else if (element.classList.contains('e-checkbox')) {\n      const instance = element.ej2_instances[0];\n      instance.checked = value;\n      instance.dataBind();\n    } else {\n      if (element.type !== 'checkbox') {\n        element.value = value || '';\n      } else {\n        element.checked = value;\n      }\n    }\n  }\n  setDefaultValueToElement(element) {\n    if (element.classList.contains('e-datepicker')) {\n      const instance = element.ej2_instances[0];\n      instance.value = this.parent.getCurrentTime();\n      instance.dataBind();\n    } else if (element.classList.contains('e-datetimepicker')) {\n      const instance = element.ej2_instances[0];\n      const dateValue = this.parent.getCurrentTime();\n      this.eventWindowTime = {\n        startTime: dateValue,\n        endTime: dateValue\n      };\n      instance.value = dateValue;\n      instance.dataBind();\n    } else if (element.classList.contains('e-dropdownlist')) {\n      const instance = element.ej2_instances[0];\n      instance.value = null;\n      instance.dataBind();\n    } else if (element.classList.contains('e-multiselect')) {\n      const instance = element.ej2_instances[0];\n      instance.value = [];\n      instance.dataBind();\n    } else if (element.classList.contains('e-checkbox')) {\n      const instance = element.ej2_instances[0];\n      instance.checked = false;\n      instance.dataBind();\n    } else {\n      if (element.type === 'checkbox') {\n        element.checked = false;\n      } else {\n        element.value = '';\n      }\n    }\n  }\n  getInstance(className) {\n    const element = this.element.querySelector('.' + className);\n    return element ? element.ej2_instances[0] : null;\n  }\n  eventDelete(event) {\n    if (this.isEnterKey) {\n      this.isEnterKey = false;\n      return;\n    }\n    switch (this.parent.currentAction) {\n      case 'EditOccurrence':\n        if (!isNullOrUndefined(this.parent.activeEventData.event[this.parent.eventFields.recurrenceRule])) {\n          this.parent.currentAction = 'DeleteOccurrence';\n        } else {\n          this.parent.currentAction = 'Delete';\n        }\n        break;\n      case 'EditSeries':\n        this.parent.currentAction = 'DeleteSeries';\n        break;\n      case 'Save':\n        this.parent.currentAction = 'Delete';\n        break;\n      case 'EditFollowingEvents':\n        if (!isNullOrUndefined(this.parent.activeEventData.event[this.parent.eventFields.recurrenceRule])) {\n          this.parent.currentAction = 'DeleteFollowingEvents';\n        }\n        break;\n    }\n    this.dialogEvent = event;\n    this.isCrudAction = false;\n    this.dialogObject.hide();\n    this.parent.quickPopup.openDeleteAlert();\n  }\n  getRecurrenceEditorInstance() {\n    if (this.parent.isAdaptive && !this.repeatDialogObject) {\n      this.renderRepeatDialog();\n    }\n    return this.recurrenceEditor;\n  }\n  destroyComponents() {\n    const formElements = this.getFormElements(EVENT_WINDOW_DIALOG_CLASS);\n    for (const element of formElements) {\n      let instance;\n      if (element.classList.contains('e-datetimepicker')) {\n        instance = element.ej2_instances;\n      } else if (element.classList.contains('e-datepicker')) {\n        instance = element.ej2_instances;\n      } else if (element.classList.contains('e-checkbox')) {\n        instance = element.ej2_instances;\n      } else if (element.classList.contains('e-dropdownlist')) {\n        instance = element.ej2_instances;\n      } else if (element.classList.contains('e-multiselect')) {\n        instance = element.ej2_instances;\n      }\n      if (instance && instance[0]) {\n        instance[0].destroy();\n      }\n    }\n    if (this.buttonObj) {\n      this.buttonObj.destroy();\n    }\n  }\n  destroy(isIgnore) {\n    if (this.parent && !this.parent.isDestroyed) {\n      this.parent.resetTemplates(['editorTemplate']);\n    }\n    this.destroyComponents();\n    if (this.recurrenceEditor) {\n      this.recurrenceEditor.destroy();\n      this.recurrenceEditor = null;\n    }\n    if (this.fieldValidator) {\n      this.fieldValidator.destroy();\n      this.fieldValidator = null;\n    }\n    if (this.repeatDialogObject) {\n      this.repeatDialogObject.destroy();\n      this.repeatDialogObject = null;\n    }\n    if (this.dialogObject) {\n      if (this.dialogObject.element) {\n        EventHandler.remove(this.dialogObject.element, 'keydown', this.preventEventSave);\n      }\n      this.dialogObject.destroy();\n      this.dialogObject = null;\n    }\n    if (this.element) {\n      remove(this.element);\n      this.element = null;\n    }\n    if (!isIgnore) {\n      this.l10n = null;\n      this.parent = null;\n      this.fields = null;\n      this.buttonObj = null;\n      this.repeatStatus = null;\n      this.eventWindowTime = null;\n    }\n  }\n}\n\n/**\n * Virtual Scroll\n */\nclass VirtualScroll {\n  constructor(parent) {\n    this.translateY = 0;\n    this.itemSize = 60;\n    this.bufferCount = 3;\n    this.renderedLength = 0;\n    this.averageRowHeight = 0;\n    this.isScrollHeightNull = true;\n    this.parent = parent;\n    this.addEventListener();\n  }\n  addEventListener() {\n    if (!this.parent || this.parent && this.parent.isDestroyed) {\n      return;\n    }\n    this.parent.on(virtualScroll, this.virtualScrolling, this);\n  }\n  removeEventListener() {\n    if (!this.parent || this.parent && this.parent.isDestroyed) {\n      return;\n    }\n    this.parent.off(virtualScroll, this.virtualScrolling);\n  }\n  getRenderedCount() {\n    this.setItemSize();\n    return Math.ceil(this.parent.element.clientHeight / this.itemSize) + this.bufferCount;\n  }\n  setTranslateValue() {\n    const resWrap = this.parent.element.querySelector('.' + RESOURCE_COLUMN_WRAP_CLASS);\n    const conWrap = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS);\n    const eventWrap = this.parent.element.querySelector('.' + EVENT_TABLE_CLASS);\n    const timeIndicator = this.parent.element.querySelector('.' + CURRENT_TIMELINE_CLASS);\n    this.renderVirtualTrackHeight(conWrap, resWrap);\n    this.setTranslate(resWrap, conWrap, eventWrap, timeIndicator);\n  }\n  renderVirtualTrackHeight(contentWrap, resourceWrap) {\n    this.parent.resourceBase.setExpandedResources();\n    if (this.isScrollHeightNull) {\n      const wrap = createElement('div', {\n        className: VIRTUAL_TRACK_CLASS\n      });\n      const resWrap = [].slice.call(resourceWrap.querySelectorAll('table td'));\n      const startIndex = parseInt(resWrap[0].getAttribute('data-group-index'), 10);\n      const endIndex = parseInt(resWrap[resWrap.length - 1].getAttribute('data-group-index'), 10);\n      this.parent.resourceBase.renderedResources = this.parent.resourceBase.expandedResources.filter(resource => resource.groupIndex >= startIndex && resource.groupIndex <= endIndex);\n      this.setItemSize();\n      wrap.style.height = this.parent.resourceBase.expandedResources.length * this.itemSize + 'px';\n      this.isScrollHeightNull = false;\n      const virtual = this.parent.element.querySelector('.' + VIRTUAL_TRACK_CLASS);\n      if (!isNullOrUndefined(virtual)) {\n        remove(virtual);\n      }\n      contentWrap.appendChild(wrap);\n    }\n  }\n  renderVirtualTrack(contentWrap) {\n    const wrap = createElement('div', {\n      className: VIRTUAL_TRACK_CLASS\n    });\n    wrap.style.height = this.parent.resourceBase.expandedResources.length * this.itemSize + 'px';\n    contentWrap.appendChild(wrap);\n  }\n  updateVirtualScrollHeight() {\n    const virtual = this.parent.element.querySelector('.' + VIRTUAL_TRACK_CLASS);\n    const lastResourceIndex = this.parent.resourceBase.expandedResources[this.parent.resourceBase.expandedResources.length - 1].groupIndex;\n    const lastRenderIndex = this.parent.resourceBase.renderedResources[this.parent.resourceBase.renderedResources.length - 1].groupIndex;\n    if (lastRenderIndex !== lastResourceIndex) {\n      const conTable = this.parent.element.querySelector('.' + CONTENT_TABLE_CLASS);\n      this.renderedLength = conTable.querySelector('tbody').children.length;\n      virtual.style.height = conTable.offsetHeight + (this.parent.resourceBase.expandedResources.length - this.renderedLength) * conTable.offsetHeight / this.renderedLength + 'px';\n    } else {\n      virtual.style.height = '';\n    }\n    this.averageRowHeight = virtual.offsetHeight / this.parent.resourceBase.expandedResources.length;\n  }\n  updateVirtualTrackHeight(wrap) {\n    const resourceCount = this.parent.resourceBase.renderedResources.length;\n    if (resourceCount !== this.getRenderedCount()) {\n      wrap.style.height = this.parent.element.querySelector('.e-content-wrap').clientHeight + 'px';\n      const resWrap = this.parent.element.querySelector('.' + RESOURCE_COLUMN_WRAP_CLASS);\n      const conWrap = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS);\n      const eventWrap = this.parent.element.querySelector('.' + EVENT_TABLE_CLASS);\n      this.translateY = 0;\n      this.setTranslate(resWrap, conWrap, eventWrap);\n    } else {\n      const lastRenderIndex = this.parent.resourceBase.renderedResources[resourceCount - 1].groupIndex;\n      const lastCollIndex = this.parent.resourceBase.expandedResources[this.parent.resourceBase.expandedResources.length - 1].groupIndex;\n      let renderedResCount = resourceCount + (lastCollIndex - lastRenderIndex);\n      renderedResCount = renderedResCount > this.parent.resourceBase.expandedResources.length ? this.parent.resourceBase.expandedResources.length : renderedResCount;\n      wrap.style.height = renderedResCount * this.itemSize + 'px';\n    }\n  }\n  setItemSize() {\n    this.itemSize = getElementHeightFromClass(this.parent.activeView.element, WORK_CELLS_CLASS) || this.itemSize;\n  }\n  renderEvents() {\n    this.setTabIndex();\n    this.parent.refreshEvents(false);\n    this.parent.notify(contentReady, {});\n    this.parent.hideSpinner();\n  }\n  virtualScrolling() {\n    if (this.parent.quickPopup) {\n      this.parent.quickPopup.quickPopupHide();\n      this.parent.quickPopup.morePopup.hide();\n    }\n    const resWrap = this.parent.element.querySelector('.' + RESOURCE_COLUMN_WRAP_CLASS);\n    const conWrap = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS);\n    const eventWrap = this.parent.element.querySelector('.' + EVENT_TABLE_CLASS);\n    const timeIndicator = this.parent.element.querySelector('.' + CURRENT_TIMELINE_CLASS);\n    const conTable = this.parent.element.querySelector('.' + CONTENT_TABLE_CLASS);\n    this.renderedLength = resWrap.querySelector('tbody').children.length;\n    const firstTDIndex = parseInt(resWrap.querySelector('tbody td').getAttribute('data-group-index'), 10);\n    const scrollHeight = this.parent.rowAutoHeight ? conTable.offsetHeight - conWrap.offsetHeight : this.bufferCount * this.itemSize;\n    addClass([conWrap], 'e-transition');\n    let resCollection = [];\n    if (conWrap.scrollTop - this.translateY < 0) {\n      resCollection = this.upScroll(conWrap, firstTDIndex);\n    } else if (conWrap.scrollTop - this.translateY > scrollHeight) {\n      resCollection = this.downScroll(conWrap, firstTDIndex);\n    }\n    if (!isNullOrUndefined(resCollection) && resCollection.length > 0) {\n      this.parent.showSpinner();\n      const selectedEle = this.parent.getSelectedElements();\n      this.focusedEle = selectedEle[selectedEle.length - 1] || this.focusedEle;\n      this.updateContent(resWrap, conWrap, eventWrap, resCollection);\n      this.setTranslate(resWrap, conWrap, eventWrap, timeIndicator);\n      if (this.parent.dragAndDropModule && this.parent.dragAndDropModule.actionObj.action === 'drag') {\n        this.parent.dragAndDropModule.navigationWrapper();\n      }\n      window.clearTimeout(this.timeValue);\n      this.timeValue = window.setTimeout(() => {\n        this.renderEvents();\n      }, 250);\n    }\n  }\n  upScroll(conWrap, firstTDIndex) {\n    let index = 0;\n    index = ~~(conWrap.scrollTop / this.itemSize) + Math.ceil(conWrap.clientHeight / this.itemSize) - this.renderedLength;\n    if (this.parent.rowAutoHeight) {\n      index = index > firstTDIndex ? firstTDIndex - this.bufferCount : index;\n    }\n    index = index > 0 ? index : 0;\n    const prevSetCollection = this.getBufferCollection(index, index + this.renderedLength);\n    this.parent.resourceBase.renderedResources = prevSetCollection;\n    if (firstTDIndex === 0) {\n      this.translateY = conWrap.scrollTop;\n    } else {\n      let height = this.parent.rowAutoHeight ? this.averageRowHeight : this.itemSize;\n      height = height > 0 ? height : this.itemSize;\n      this.translateY = conWrap.scrollTop - this.bufferCount * height > 0 ? conWrap.scrollTop - this.bufferCount * height : 0;\n    }\n    return prevSetCollection;\n  }\n  downScroll(conWrap, firstTDIndex) {\n    const lastResource = this.parent.resourceBase.renderedResources[this.parent.resourceBase.renderedResources.length - 1].groupIndex;\n    const lastResourceIndex = this.parent.resourceBase.expandedResources[this.parent.resourceBase.expandedResources.length - 1].groupIndex;\n    if (lastResource === lastResourceIndex) {\n      return null;\n    }\n    let nextSetResIndex = 0;\n    nextSetResIndex = ~~(conWrap.scrollTop / this.itemSize);\n    if (this.parent.rowAutoHeight) {\n      nextSetResIndex = ~~((conWrap.scrollTop - this.translateY) / this.averageRowHeight) + firstTDIndex;\n      nextSetResIndex = nextSetResIndex > firstTDIndex + this.bufferCount ? nextSetResIndex : firstTDIndex + this.bufferCount;\n    }\n    let lastIndex = nextSetResIndex + this.renderedLength;\n    lastIndex = lastIndex > this.parent.resourceBase.expandedResources.length ? nextSetResIndex + (this.parent.resourceBase.expandedResources.length - nextSetResIndex) : lastIndex;\n    const nextSetCollection = this.getBufferCollection(lastIndex - this.renderedLength, lastIndex);\n    this.translateY = conWrap.scrollTop;\n    return nextSetCollection;\n  }\n  updateContent(resWrap, conWrap, eventWrap, resCollection) {\n    const renderedLength = resWrap.querySelector('tbody').children.length;\n    if (document.activeElement && document.activeElement.classList.contains(RESOURCE_CELLS_CLASS)) {\n      this.isResourceCell = true;\n      this.parent.element.focus();\n    }\n    for (let i = 0; i < renderedLength; i++) {\n      remove(resWrap.querySelector('tbody tr'));\n      remove(conWrap.querySelector('tbody tr'));\n      remove(eventWrap.querySelector('div'));\n    }\n    this.parent.resourceBase.renderedResources = resCollection;\n    const resourceRows = this.parent.resourceBase.getContentRows(resCollection, true);\n    const contentRows = this.parent.activeView.getContentRows();\n    const eventRows = this.parent.activeView.getEventRows(resCollection.length);\n    append(resourceRows, resWrap.querySelector('tbody'));\n    append(contentRows, conWrap.querySelector('tbody'));\n    append(eventRows, eventWrap);\n  }\n  getBufferCollection(startIndex, endIndex) {\n    return this.parent.resourceBase.expandedResources.slice(startIndex, endIndex);\n  }\n  setTranslate(resWrap, conWrap, eventWrap, timeIndicator) {\n    setStyleAttribute(resWrap.querySelector('table'), {\n      transform: `translateY(${this.translateY}px)`\n    });\n    setStyleAttribute(conWrap.querySelector('table'), {\n      transform: `translateY(${this.translateY}px)`\n    });\n    setStyleAttribute(eventWrap, {\n      transform: `translateY(${this.translateY}px)`\n    });\n    if (!isNullOrUndefined(timeIndicator)) {\n      setStyleAttribute(timeIndicator, {\n        transform: `translateY(${this.translateY}px)`\n      });\n    }\n  }\n  updateFocusedWorkCell() {\n    if (this.focusedEle) {\n      const date = parseInt(this.focusedEle.getAttribute('data-date'), 10);\n      const groupIndex = parseInt(this.focusedEle.getAttribute('data-group-index'), 10);\n      const ele = this.parent.element.querySelector(`.${WORK_CELLS_CLASS}[data-date=\"${date}\"][data-group-index=\"${groupIndex}\"]`);\n      if (ele) {\n        this.parent.addSelectedClass([ele], ele, true);\n      }\n      this.focusedEle = null;\n    }\n  }\n  setTabIndex() {\n    const resColWrap = this.parent.element.querySelector('.' + RESOURCE_COLUMN_WRAP_CLASS);\n    const resCells = [].slice.call(this.parent.element.querySelectorAll('.' + RESOURCE_CELLS_CLASS));\n    if (resCells && resColWrap) {\n      resCells.forEach(element => {\n        if (element.getBoundingClientRect().top >= resColWrap.getBoundingClientRect().top) {\n          element.setAttribute('tabindex', '0');\n        }\n      });\n    }\n    const focusResCell = this.parent.element.querySelector(`.${RESOURCE_CELLS_CLASS}[tabindex=\"${0}\"]`);\n    if (this.isResourceCell && focusResCell) {\n      focusResCell.focus();\n      this.isResourceCell = false;\n    }\n  }\n  destroy() {\n    this.removeEventListener();\n  }\n}\n\n/**\n * Schedule DOM rendering\n */\nclass Render {\n  constructor(parent) {\n    this.parent = parent;\n  }\n  render(viewName, isDataRefresh = true) {\n    this.initializeLayout(viewName);\n    if (this.parent.activeView && isDataRefresh) {\n      this.parent.crudModule.refreshDataManager();\n    }\n  }\n  initializeLayout(viewName) {\n    if (this.parent.activeView) {\n      const templates = ['cellTemplate', 'eventTemplate', 'tooltipTemplate', 'majorSlotTemplate', 'minorSlotTemplate', 'headerTooltipTemplate', 'dateHeaderTemplate', 'dayHeaderTemplate', 'mothHeaderTemplate', 'headerIndentTemplate', 'resourceHeaderTemplate', 'cellHeaderTemplate'];\n      this.parent.resetTemplates(templates);\n      this.parent.activeView.removeEventListener();\n      this.parent.activeView.destroy();\n    }\n    switch (viewName) {\n      case 'Day':\n        this.parent.activeView = this.parent.dayModule;\n        break;\n      case 'Week':\n        this.parent.activeView = this.parent.weekModule;\n        break;\n      case 'WorkWeek':\n        this.parent.activeView = this.parent.workWeekModule;\n        break;\n      case 'Month':\n        this.parent.activeView = this.parent.monthModule;\n        break;\n      case 'Year':\n        this.parent.activeView = this.parent.yearModule;\n        break;\n      case 'Agenda':\n        this.parent.activeView = this.parent.agendaModule;\n        break;\n      case 'MonthAgenda':\n        this.parent.activeView = this.parent.monthAgendaModule;\n        break;\n      case 'TimelineDay':\n        this.parent.activeView = this.parent.timelineViewsModule;\n        this.parent.activeView.viewClass = 'e-timeline-day-view';\n        break;\n      case 'TimelineWorkWeek':\n        this.parent.activeView = this.parent.timelineViewsModule;\n        this.parent.activeView.viewClass = 'e-timeline-work-week-view';\n        break;\n      case 'TimelineWeek':\n        this.parent.activeView = this.parent.timelineViewsModule;\n        this.parent.activeView.viewClass = 'e-timeline-week-view';\n        break;\n      case 'TimelineMonth':\n        this.parent.activeView = this.parent.timelineMonthModule;\n        break;\n      case 'TimelineYear':\n        this.parent.activeView = this.parent.timelineYearModule;\n        break;\n    }\n    if (isNullOrUndefined(this.parent.activeView)) {\n      const firstView = this.parent.viewCollections[0].option;\n      if (firstView) {\n        this.parent.setProperties({\n          currentView: firstView\n        }, true);\n        if (this.parent.headerModule) {\n          this.parent.headerModule.updateActiveView();\n          this.parent.headerModule.setCalendarView();\n        }\n        return this.initializeLayout(firstView);\n      }\n      throw Error('Inject required modules');\n    }\n    this.parent.activeView.viewIndex = this.parent.viewIndex;\n    this.updateLabelText(viewName);\n    this.parent.activeView.addEventListener();\n    this.parent.activeView.getRenderDates();\n    this.parent.uiStateValues.isGroupAdaptive = this.parent.activeViewOptions.group.resources.length > 0 && (this.parent.enableAdaptiveUI && !this.parent.isAdaptive || this.parent.isAdaptive && this.parent.activeViewOptions.group.enableCompactView);\n    if (this.parent.virtualScrollModule) {\n      this.parent.virtualScrollModule.destroy();\n      this.parent.virtualScrollModule = null;\n    }\n    if (this.parent.currentView.indexOf('Timeline') !== -1 && this.parent.currentView.indexOf('Year') === -1 && this.parent.activeViewOptions.allowVirtualScrolling && this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {\n      this.parent.virtualScrollModule = new VirtualScroll(this.parent);\n      this.parent.uiStateValues.top = 0;\n    }\n    this.updateHeader();\n    this.parent.activeView.renderLayout(CURRENT_PANEL_CLASS);\n    this.parent.renderTemplates();\n    if (this.parent.eventTooltip) {\n      this.parent.eventTooltip.destroy();\n      this.parent.eventTooltip = null;\n    }\n    if (this.parent.eventSettings.enableTooltip || this.parent.activeViewOptions.group.resources.length > 0 && this.parent.activeViewOptions.group.headerTooltipTemplate) {\n      this.parent.eventTooltip = new EventTooltip(this.parent);\n    }\n  }\n  updateHeader() {\n    if (this.parent.headerModule) {\n      this.parent.headerModule.setDayOfWeek(this.parent.activeViewOptions.firstDayOfWeek);\n      if (this.parent.activeViewOptions.readonly) {\n        addClass([this.parent.element], READ_ONLY);\n      } else if (this.parent.element.classList.contains(READ_ONLY)) {\n        removeClass([this.parent.element], READ_ONLY);\n      }\n      this.parent.headerModule.updateDateRange(this.parent.activeView.getDateRangeText());\n      this.parent.headerModule.updateHeaderItems('remove');\n    }\n  }\n  updateLabelText(view) {\n    const content = this.parent.activeView.getLabelText(view);\n    this.parent.element.setAttribute('role', 'main');\n    this.parent.element.setAttribute('aria-label', content);\n  }\n}\nvar __decorate$2 = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n/**\n * A class that represents the configuration of working hours related options of scheduler.\n */\nclass WorkHours extends ChildProperty {}\n__decorate$2([Property(true)], WorkHours.prototype, \"highlight\", void 0);\n__decorate$2([Property('09:00')], WorkHours.prototype, \"start\", void 0);\n__decorate$2([Property('18:00')], WorkHours.prototype, \"end\", void 0);\nvar __decorate$3 = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n/**\n * A class that represents the configuration of options related to timescale on scheduler.\n */\nclass TimeScale extends ChildProperty {}\n__decorate$3([Property(true)], TimeScale.prototype, \"enable\", void 0);\n__decorate$3([Property(60)], TimeScale.prototype, \"interval\", void 0);\n__decorate$3([Property(2)], TimeScale.prototype, \"slotCount\", void 0);\n__decorate$3([Property()], TimeScale.prototype, \"minorSlotTemplate\", void 0);\n__decorate$3([Property()], TimeScale.prototype, \"majorSlotTemplate\", void 0);\nvar __decorate$4 = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n/**\n * A class that defines the template options available to customize the quick popup of scheduler.\n */\nclass QuickInfoTemplates extends ChildProperty {}\n__decorate$4([Property('Both')], QuickInfoTemplates.prototype, \"templateType\", void 0);\n__decorate$4([Property()], QuickInfoTemplates.prototype, \"header\", void 0);\n__decorate$4([Property()], QuickInfoTemplates.prototype, \"content\", void 0);\n__decorate$4([Property()], QuickInfoTemplates.prototype, \"footer\", void 0);\nvar __decorate$5 = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n/**\n * A class that represents the header rows related configurations on timeline views.\n */\nclass HeaderRows extends ChildProperty {}\n__decorate$5([Property()], HeaderRows.prototype, \"option\", void 0);\n__decorate$5([Property()], HeaderRows.prototype, \"template\", void 0);\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable max-len */\n/**\n * Schedule CRUD operations\n */\nclass Crud {\n  constructor(parent) {\n    this.parent = parent;\n    this.crudObj = {\n      sourceEvent: null,\n      targetEvent: null,\n      isCrudAction: false\n    };\n  }\n  getQuery() {\n    const start = this.parent.activeView.startDate();\n    const end = this.parent.activeView.endDate();\n    return this.parent.dataModule.generateQuery(start, end);\n  }\n  getTable() {\n    if (this.parent.eventSettings.query) {\n      const query = this.parent.eventSettings.query.clone();\n      return query.fromTable;\n    }\n    return null;\n  }\n  refreshDataManager() {\n    if (!this.parent.activeView) {\n      return;\n    }\n    const start = this.parent.activeView.startDate();\n    const end = this.parent.activeView.endDate();\n    const dataManager = this.parent.dataModule.getData(this.parent.dataModule.generateQuery(start, end));\n    dataManager.then(e => this.dataManagerSuccess(e)).catch(e => this.dataManagerFailure(e));\n  }\n  dataManagerSuccess(e) {\n    if (!this.parent || this.parent && this.parent.isDestroyed) {\n      return;\n    }\n    this.parent.trigger(dataBinding, e, args => {\n      const resultData = extend([], args.result, null, true);\n      this.parent.eventsData = resultData.filter(data => !data[this.parent.eventFields.isBlock]);\n      this.parent.blockData = resultData.filter(data => data[this.parent.eventFields.isBlock]);\n      this.parent.refreshEvents(false);\n      if (this.parent.dragAndDropModule && this.parent.dragAndDropModule.actionObj.action === 'drag') {\n        this.parent.dragAndDropModule.navigationWrapper();\n      }\n      this.parent.trigger(dataBound, null, () => {\n        this.parent.hideSpinner();\n        if (this.parent.isPrinting) {\n          this.parent.notify(print$1, {});\n        }\n      });\n    });\n  }\n  dataManagerFailure(e) {\n    if (!this.parent || this.parent && this.parent.isDestroyed) {\n      return;\n    }\n    this.parent.trigger(actionFailure, {\n      error: e\n    }, () => this.parent.hideSpinner());\n  }\n  refreshData(args) {\n    const actionArgs = {\n      requestType: args.requestType,\n      cancel: false,\n      data: args.data,\n      addedRecords: args.editParams.addedRecords,\n      changedRecords: args.editParams.changedRecords,\n      deletedRecords: args.editParams.deletedRecords\n    };\n    if (this.parent.dragAndDropModule && this.parent.dragAndDropModule.actionObj && this.parent.dragAndDropModule.actionObj.element) {\n      this.parent.dragAndDropModule.actionObj.element.style.display = 'none';\n    }\n    if (this.parent.resizeModule && this.parent.resizeModule.actionObj && this.parent.resizeModule.actionObj.element) {\n      this.parent.resizeModule.actionObj.element.style.display = 'none';\n    }\n    if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.activeViewOptions.group.allowGroupEdit && !this.parent.rowAutoHeight && !this.parent.virtualScrollModule && this.parent.activeViewOptions.group.byGroupID) {\n      if (args.requestType === 'eventCreated' || args.requestType === 'eventRemoved') {\n        this.crudObj.isCrudAction = true;\n        this.crudObj.sourceEvent = [];\n        const crudData = args.data instanceof Array ? args.data.length === 0 && args.requestType === 'eventRemoved' ? args.editParams.deletedRecords : args.data : (typeof args.data === 'string' || typeof args.data === 'number') && args.requestType === 'eventRemoved' ? args.editParams.deletedRecords : [args.data];\n        for (const data of crudData) {\n          this.crudObj.isCrudAction = !(args.requestType === 'eventRemoved' && !isNullOrUndefined(data.parent));\n          const groupIndex = this.parent.eventBase.getGroupIndexFromEvent(data);\n          if (groupIndex > -1 && this.parent.crudModule.crudObj.sourceEvent.filter(tdData => tdData.groupIndex === groupIndex).length === 0 && this.crudObj.isCrudAction) {\n            this.crudObj.sourceEvent.push(this.parent.resourceBase.lastResourceLevel[groupIndex]);\n          }\n        }\n        this.crudObj.targetEvent = this.crudObj.sourceEvent;\n      }\n    }\n    if (this.parent.dataModule.dataManager.dataSource.offline) {\n      this.parent.trigger(actionComplete, actionArgs, offlineArgs => {\n        if (!offlineArgs.cancel) {\n          this.refreshDataManager();\n        }\n      });\n    } else {\n      args.promise.then(() => {\n        if (!this.parent || this.parent && this.parent.isDestroyed) {\n          return;\n        }\n        this.parent.trigger(actionComplete, actionArgs, onlineArgs => {\n          if (!onlineArgs.cancel) {\n            this.refreshDataManager();\n          }\n        });\n      }).catch(e => {\n        if (!this.parent || this.parent && this.parent.isDestroyed) {\n          return;\n        }\n        this.parent.trigger(actionFailure, {\n          error: e\n        });\n      });\n    }\n  }\n  addEvent(eventData) {\n    if (this.parent.eventSettings.allowAdding && !this.parent.activeViewOptions.readonly) {\n      if (!this.isBlockEvent(eventData) && this.parent.eventBase.isBlockRange(eventData)) {\n        this.parent.quickPopup.openValidationError('blockAlert', eventData);\n        return;\n      }\n      const addEvents = eventData instanceof Array ? eventData : [eventData];\n      const args = {\n        requestType: 'eventCreate',\n        cancel: false,\n        data: addEvents,\n        addedRecords: addEvents,\n        changedRecords: [],\n        deletedRecords: []\n      };\n      this.parent.trigger(actionBegin, args, addArgs => {\n        if (!addArgs.cancel) {\n          const fields = this.parent.eventFields;\n          const editParams = {\n            addedRecords: [],\n            changedRecords: [],\n            deletedRecords: []\n          };\n          let promise;\n          if (addArgs.addedRecords instanceof Array) {\n            for (let event of addArgs.addedRecords) {\n              event = this.parent.eventBase.updateEventDateTime(event);\n              const eventData = extend({}, this.parent.eventBase.processTimezone(event, true), null, true);\n              editParams.addedRecords.push(eventData);\n            }\n            promise = this.parent.dataModule.dataManager.saveChanges(editParams, fields.id, this.getTable(), this.getQuery());\n          } else {\n            const event = this.parent.eventBase.processTimezone(addArgs.addedRecords, true);\n            editParams.addedRecords.push(event);\n            promise = this.parent.dataModule.dataManager.insert(event, this.getTable(), this.getQuery());\n          }\n          const crudArgs = {\n            requestType: 'eventCreated',\n            cancel: false,\n            data: addArgs.addedRecords,\n            promise: promise,\n            editParams: editParams\n          };\n          this.refreshData(crudArgs);\n        }\n      });\n    }\n  }\n  saveEvent(eventData, action) {\n    if (this.parent.eventSettings.allowEditing && !this.parent.activeViewOptions.readonly) {\n      if (this.parent.currentAction !== 'EditFollowingEvents' && !this.isBlockEvent(eventData) && this.parent.eventBase.isBlockRange(eventData)) {\n        this.parent.quickPopup.openValidationError('blockAlert', eventData);\n        return;\n      }\n      this.parent.currentAction = action;\n      if (action) {\n        switch (action) {\n          case 'Save':\n            this.processSave(eventData);\n            break;\n          case 'EditOccurrence':\n            this.processOccurrences(eventData, action);\n            break;\n          case 'EditFollowingEvents':\n            this.processFollowSeries(eventData, action);\n            break;\n          case 'EditSeries':\n            this.processEntireSeries(eventData, action);\n            break;\n        }\n      } else {\n        const updateEvents = eventData instanceof Array ? eventData : [eventData];\n        const args = {\n          requestType: 'eventChange',\n          cancel: false,\n          data: eventData,\n          addedRecords: [],\n          changedRecords: updateEvents,\n          deletedRecords: []\n        };\n        this.parent.trigger(actionBegin, args, saveArgs => {\n          if (!saveArgs.cancel) {\n            let promise;\n            const fields = this.parent.eventFields;\n            const editParams = {\n              addedRecords: [],\n              changedRecords: [],\n              deletedRecords: []\n            };\n            if (saveArgs.changedRecords instanceof Array) {\n              for (let event of saveArgs.changedRecords) {\n                event = this.parent.eventBase.updateEventDateTime(event);\n                const eventData = extend({}, this.parent.eventBase.processTimezone(event, true), null, true);\n                editParams.changedRecords.push(eventData);\n              }\n              promise = this.parent.dataModule.dataManager.saveChanges(editParams, fields.id, this.getTable(), this.getQuery());\n            } else {\n              const event = this.parent.eventBase.processTimezone(saveArgs.changedRecords, true);\n              editParams.changedRecords.push(event);\n              promise = this.parent.dataModule.dataManager.update(fields.id, event, this.getTable(), this.getQuery());\n            }\n            const crudArgs = {\n              requestType: 'eventChanged',\n              cancel: false,\n              data: saveArgs.changedRecords,\n              promise: promise,\n              editParams: editParams\n            };\n            this.refreshData(crudArgs);\n          }\n        });\n      }\n    }\n  }\n  deleteEvent(eventData, action) {\n    if (this.parent.eventSettings.allowDeleting && !this.parent.activeViewOptions.readonly) {\n      this.parent.currentAction = action;\n      let deleteEvents = [];\n      if (typeof eventData === 'string' || typeof eventData === 'number') {\n        deleteEvents = this.parent.eventsData.filter(eventObj => eventObj[this.parent.eventFields.id] === eventData);\n      } else {\n        deleteEvents = eventData instanceof Array ? eventData : [eventData];\n      }\n      if (action) {\n        switch (action) {\n          case 'Delete':\n            this.processDelete(deleteEvents);\n            break;\n          case 'DeleteOccurrence':\n            this.processOccurrences(deleteEvents, action);\n            break;\n          case 'DeleteFollowingEvents':\n            this.processFollowSeries(deleteEvents, action);\n            break;\n          case 'DeleteSeries':\n            this.processEntireSeries(deleteEvents, action);\n            break;\n        }\n      } else {\n        const args = {\n          requestType: 'eventRemove',\n          cancel: false,\n          data: eventData,\n          addedRecords: [],\n          changedRecords: [],\n          deletedRecords: deleteEvents\n        };\n        this.parent.trigger(actionBegin, args, deleteArgs => {\n          if (!deleteArgs.cancel) {\n            let promise;\n            const fields = this.parent.eventFields;\n            const editParams = {\n              addedRecords: [],\n              changedRecords: [],\n              deletedRecords: []\n            };\n            if (deleteArgs.deletedRecords.length > 1) {\n              editParams.deletedRecords = editParams.deletedRecords.concat(deleteArgs.deletedRecords);\n              promise = this.parent.dataModule.dataManager.saveChanges(editParams, fields.id, this.getTable(), this.getQuery());\n            } else {\n              editParams.deletedRecords.push(deleteArgs.deletedRecords[0]);\n              promise = this.parent.dataModule.dataManager.remove(fields.id, deleteArgs.deletedRecords[0], this.getTable(), this.getQuery());\n            }\n            this.parent.eventBase.selectWorkCellByTime(deleteArgs.deletedRecords);\n            const crudArgs = {\n              requestType: 'eventRemoved',\n              cancel: false,\n              data: deleteArgs.deletedRecords,\n              promise: promise,\n              editParams: editParams\n            };\n            this.refreshData(crudArgs);\n          }\n        });\n      }\n    }\n  }\n  processOccurrences(eventData, action) {\n    let occurrenceData = [];\n    let isDeletedRecords = false;\n    if (eventData instanceof Array) {\n      for (const event of eventData) {\n        occurrenceData.push({\n          occurrence: event,\n          parent: this.getParentEvent(event)\n        });\n      }\n    } else {\n      occurrenceData = {\n        occurrence: eventData,\n        parent: this.getParentEvent(eventData)\n      };\n    }\n    const updateEvents = eventData instanceof Array ? eventData : [eventData];\n    const args = {\n      requestType: action === 'EditOccurrence' ? 'eventChange' : 'eventRemove',\n      cancel: false,\n      addedRecords: [],\n      changedRecords: updateEvents,\n      deletedRecords: []\n    };\n    args.data = occurrenceData;\n    this.parent.trigger(actionBegin, args, occurrenceArgs => {\n      if (!occurrenceArgs.cancel) {\n        const fields = this.parent.eventFields;\n        const editParams = {\n          addedRecords: [],\n          changedRecords: [],\n          deletedRecords: []\n        };\n        const occurrenceEvents = occurrenceData instanceof Array ? occurrenceData : [occurrenceData];\n        for (let a = 0, count = occurrenceArgs.changedRecords.length; a < count; a++) {\n          const childEvent = occurrenceArgs.changedRecords[a];\n          const parentEvent = occurrenceEvents[a].parent;\n          const parentException = parentEvent[fields.recurrenceException];\n          let editedData;\n          let exceptionDate;\n          switch (action) {\n            case 'EditOccurrence':\n              editedData = this.parent.eventsProcessed.filter(event => event.Guid === childEvent.Guid)[0];\n              exceptionDate = this.excludeDateCheck(editedData[fields.startTime], parentException);\n              if (exceptionDate !== parentEvent[fields.recurrenceException]) {\n                parentEvent[fields.recurrenceException] = exceptionDate;\n                childEvent[fields.recurrenceException] = getRecurrenceStringFromDate(editedData[fields.startTime]);\n                childEvent[fields.recurrenceID] = parentEvent[fields.id];\n                childEvent[fields.followingID] = null;\n                editParams.changedRecords.push(this.parent.eventBase.processTimezone(parentEvent, true));\n                editParams.addedRecords.push(this.parent.eventBase.processTimezone(childEvent, true));\n              } else {\n                editParams.changedRecords.push(this.parent.eventBase.processTimezone(childEvent, true));\n              }\n              break;\n            case 'DeleteOccurrence':\n              if (!childEvent[fields.recurrenceException]) {\n                parentEvent[fields.recurrenceException] = this.excludeDateCheck(childEvent[fields.startTime], parentException);\n                editParams.changedRecords.push(this.parent.eventBase.processTimezone(parentEvent, true));\n              }\n              if (childEvent[fields.id] !== parentEvent[fields.id]) {\n                editParams.deletedRecords.push(childEvent);\n                isDeletedRecords = true;\n              }\n              break;\n          }\n        }\n        const promise = this.parent.dataModule.dataManager.saveChanges(editParams, fields.id, this.getTable(), this.getQuery());\n        this.parent.eventBase.selectWorkCellByTime(occurrenceArgs.changedRecords);\n        const crudArgs = {\n          requestType: action === 'EditOccurrence' ? 'eventChanged' : 'eventRemoved',\n          cancel: false,\n          data: isDeletedRecords ? occurrenceArgs.deletedRecords : occurrenceArgs.changedRecords,\n          promise: promise,\n          editParams: editParams\n        };\n        this.refreshData(crudArgs);\n      }\n    });\n  }\n  processFollowSeries(eventData, action) {\n    let followData = [];\n    if (eventData instanceof Array) {\n      for (const event of eventData) {\n        followData.push({\n          occurrence: event,\n          parent: this.getParentEvent(event)\n        });\n      }\n    } else {\n      followData = {\n        occurrence: eventData,\n        parent: this.getParentEvent(eventData)\n      };\n    }\n    const updateFollowEvents = eventData instanceof Array ? eventData : [eventData];\n    const args = {\n      requestType: action === 'EditFollowingEvents' ? 'eventChange' : 'eventRemove',\n      cancel: false,\n      addedRecords: [],\n      changedRecords: updateFollowEvents,\n      deletedRecords: []\n    };\n    args.data = followData;\n    this.parent.trigger(actionBegin, args, followArgs => {\n      if (!followArgs.cancel) {\n        const fields = this.parent.eventFields;\n        const editParams = {\n          addedRecords: [],\n          changedRecords: [],\n          deletedRecords: []\n        };\n        const followEvents = followData instanceof Array ? followData : [followData];\n        for (let a = 0, count = followArgs.changedRecords.length; a < count; a++) {\n          const childEvent = followArgs.changedRecords[a];\n          const parentEvent = followEvents[a].parent;\n          const followData = this.parent.eventBase.getEventCollections(parentEvent, childEvent);\n          let isSpanned;\n          switch (action) {\n            case 'EditFollowingEvents':\n              this.processRecurrenceRule(parentEvent, childEvent);\n              isSpanned = !this.parent.eventBase.isFollowingEvent(parentEvent, childEvent);\n              childEvent[fields.followingID] = isSpanned ? null : parentEvent[fields.id];\n              childEvent[fields.recurrenceID] = null;\n              editParams.addedRecords.push(this.parent.eventBase.processTimezone(childEvent, true));\n              editParams.changedRecords.push(this.parent.eventBase.processTimezone(parentEvent, true));\n              if (!this.parent.uiStateValues.isIgnoreOccurrence) {\n                childEvent[fields.recurrenceException] = null;\n                if (followData.occurrence.length > 0) {\n                  const rule = followData.occurrence.slice(-1)[0][fields.recurrenceRule];\n                  if (rule.indexOf('COUNT') === -1) {\n                    childEvent[fields.recurrenceRule] = rule;\n                  }\n                }\n                if (followData.follow.length > 0) {\n                  childEvent[fields.recurrenceRule] = followData.follow.slice(-1)[0][fields.recurrenceRule];\n                  editParams.deletedRecords = editParams.deletedRecords.concat(followData.follow);\n                }\n                if (isSpanned) {\n                  followData.occurrence = followData.occurrence.filter(eventObj => eventObj[fields.recurrenceID] === childEvent[fields.id]);\n                }\n                editParams.deletedRecords = editParams.deletedRecords.concat(followData.occurrence);\n              }\n              break;\n            case 'DeleteFollowingEvents':\n              this.processRecurrenceRule(parentEvent, childEvent[fields.startTime]);\n              editParams.changedRecords.push(this.parent.eventBase.processTimezone(parentEvent, true));\n              editParams.deletedRecords = editParams.deletedRecords.concat(followData.occurrence).concat(followData.follow);\n              break;\n          }\n        }\n        const promise = this.parent.dataModule.dataManager.saveChanges(editParams, fields.id, this.getTable(), this.getQuery());\n        this.parent.eventBase.selectWorkCellByTime(followArgs.changedRecords);\n        const crudArgs = {\n          requestType: action === 'EditFollowingEvents' ? 'eventChanged' : 'eventRemoved',\n          cancel: false,\n          data: followArgs.changedRecords,\n          promise: promise,\n          editParams: editParams\n        };\n        this.refreshData(crudArgs);\n      }\n    });\n  }\n  processEntireSeries(eventData, action) {\n    let seriesData = [];\n    let isDeletedRecords = false;\n    if (eventData instanceof Array) {\n      for (const event of eventData) {\n        seriesData.push(this.getParentEvent(event, true));\n      }\n    } else {\n      seriesData = this.getParentEvent(eventData, true);\n    }\n    const updateSeriesEvents = eventData instanceof Array ? eventData : [eventData];\n    const args = {\n      requestType: action === 'EditSeries' ? 'eventChange' : 'eventRemove',\n      cancel: false,\n      addedRecords: [],\n      changedRecords: updateSeriesEvents,\n      deletedRecords: []\n    };\n    args.data = seriesData;\n    this.parent.trigger(actionBegin, args, seriesArgs => {\n      if (!seriesArgs.cancel) {\n        const fields = this.parent.eventFields;\n        const editParams = {\n          addedRecords: [],\n          changedRecords: [],\n          deletedRecords: []\n        };\n        const seriesEvents = seriesData instanceof Array ? seriesData : [seriesData];\n        for (let a = 0, count = seriesArgs.changedRecords.length; a < count; a++) {\n          const childEvent = seriesArgs.changedRecords[a];\n          const parentEvent = seriesEvents[a];\n          const eventCollections = this.parent.eventBase.getEventCollections(parentEvent);\n          const deletedEvents = eventCollections.follow.concat(eventCollections.occurrence);\n          switch (action) {\n            case 'EditSeries':\n              if (childEvent[fields.startTime] > parentEvent[fields.startTime] && childEvent[fields.recurrenceRule]) {\n                this.processRecurrenceRule(parentEvent, childEvent);\n              }\n              childEvent[fields.id] = parentEvent[fields.id];\n              childEvent[fields.recurrenceID] = null;\n              childEvent[fields.followingID] = null;\n              if (this.parent.uiStateValues.isIgnoreOccurrence && childEvent[fields.recurrenceException]) {\n                const originalParent = this.parent.eventsData.filter(eventObj => eventObj[fields.id] === childEvent[fields.id]);\n                if (originalParent.length > 0) {\n                  childEvent[fields.recurrenceRule] = originalParent[0][fields.recurrenceRule];\n                }\n              } else {\n                childEvent[fields.recurrenceException] = null;\n                editParams.deletedRecords = editParams.deletedRecords.concat(deletedEvents);\n              }\n              editParams.changedRecords.push(this.parent.eventBase.processTimezone(childEvent, true));\n              this.parent.uiStateValues.isIgnoreOccurrence = false;\n              break;\n            case 'DeleteSeries':\n              editParams.deletedRecords = editParams.deletedRecords.concat(deletedEvents.concat(parentEvent));\n              isDeletedRecords = true;\n              break;\n          }\n        }\n        const promise = this.parent.dataModule.dataManager.saveChanges(editParams, fields.id, this.getTable(), this.getQuery());\n        this.parent.eventBase.selectWorkCellByTime(seriesArgs.changedRecords);\n        const crudArgs = {\n          requestType: action === 'EditSeries' ? 'eventChanged' : 'eventRemoved',\n          cancel: false,\n          data: isDeletedRecords ? seriesArgs.deletedRecords : seriesArgs.changedRecords,\n          promise: promise,\n          editParams: editParams\n        };\n        this.refreshData(crudArgs);\n      }\n    });\n  }\n  processDelete(eventData) {\n    const deleteData = [];\n    for (const eventObj of eventData) {\n      if (eventObj[this.parent.eventFields.recurrenceRule]) {\n        deleteData.push({\n          occurrence: eventObj,\n          parent: this.getParentEvent(eventObj)\n        });\n      } else {\n        deleteData.push(eventObj);\n      }\n    }\n    const args = {\n      requestType: 'eventRemove',\n      cancel: false,\n      addedRecords: [],\n      changedRecords: [],\n      deletedRecords: eventData\n    };\n    args.data = deleteData;\n    this.parent.trigger(actionBegin, args, deleteArgs => {\n      if (!deleteArgs.cancel) {\n        const fields = this.parent.eventFields;\n        const editParams = {\n          addedRecords: [],\n          changedRecords: [],\n          deletedRecords: []\n        };\n        for (let a = 0, count = deleteArgs.deletedRecords.length; a < count; a++) {\n          let isDelete = isNullOrUndefined(deleteArgs.deletedRecords[a][this.parent.eventFields.recurrenceRule]);\n          if (!isDelete) {\n            const parentEvent = deleteData[a].parent;\n            const isEdited = editParams.changedRecords.filter(obj => obj[fields.id] === parentEvent[fields.id]);\n            const editedDate = deleteArgs.deletedRecords[a][fields.startTime];\n            if (isEdited.length > 0) {\n              const editedData = isEdited[0];\n              editedData[fields.recurrenceException] = this.excludeDateCheck(editedDate, editedData[fields.recurrenceException]);\n            } else {\n              parentEvent[fields.recurrenceException] = this.excludeDateCheck(editedDate, parentEvent[fields.recurrenceException]);\n            }\n            if (isEdited.length === 0) {\n              editParams.changedRecords.push(this.parent.eventBase.processTimezone(parentEvent, true));\n            }\n            isDelete = deleteArgs.deletedRecords[a][fields.id] !== parentEvent[fields.id];\n          }\n          if (isDelete) {\n            editParams.deletedRecords.push(deleteArgs.deletedRecords[a]);\n          }\n        }\n        const promise = this.parent.dataModule.dataManager.saveChanges(editParams, fields.id, this.getTable(), this.getQuery());\n        const crudArgs = {\n          requestType: 'eventRemoved',\n          cancel: false,\n          data: deleteArgs.deletedRecords,\n          promise: promise,\n          editParams: editParams\n        };\n        this.refreshData(crudArgs);\n      }\n    });\n  }\n  processSave(data) {\n    const eventData = data instanceof Array ? data : [data];\n    const editData = [];\n    for (const eventObj of eventData) {\n      if (eventObj[this.parent.eventFields.recurrenceRule]) {\n        editData.push({\n          occurrence: eventObj,\n          parent: this.getParentEvent(eventObj)\n        });\n      } else {\n        editData.push(eventObj);\n      }\n    }\n    const args = {\n      requestType: 'eventChange',\n      cancel: false,\n      addedRecords: [],\n      changedRecords: eventData,\n      deletedRecords: []\n    };\n    args.data = editData;\n    this.parent.trigger(actionBegin, args, editArgs => {\n      if (!editArgs.cancel) {\n        const fields = this.parent.eventFields;\n        const editParams = {\n          addedRecords: [],\n          changedRecords: [],\n          deletedRecords: []\n        };\n        for (const record of editArgs.changedRecords) {\n          if (!isNullOrUndefined(record[fields.recurrenceRule]) && isNullOrUndefined(record[fields.recurrenceException])) {\n            const exceptionString = getRecurrenceStringFromDate(record[fields.startTime]);\n            const parentEle = this.getParentEvent(record);\n            parentEle[fields.recurrenceException] = isNullOrUndefined(parentEle[fields.recurrenceException]) ? exceptionString : parentEle[fields.recurrenceException].concat(',' + exceptionString);\n            record[fields.id] = this.parent.getEventMaxID();\n            record[fields.recurrenceException] = exceptionString;\n            editParams.addedRecords.push(this.parent.eventBase.processTimezone(record, true));\n            editParams.changedRecords.push(this.parent.eventBase.processTimezone(parentEle, true));\n          } else {\n            editParams.changedRecords.push(this.parent.eventBase.processTimezone(record, true));\n          }\n        }\n        const promise = this.parent.dataModule.dataManager.saveChanges(editParams, fields.id, this.getTable(), this.getQuery());\n        const crudArgs = {\n          requestType: 'eventChanged',\n          cancel: false,\n          data: editArgs.changedRecords,\n          promise: promise,\n          editParams: editParams\n        };\n        this.refreshData(crudArgs);\n      }\n    });\n  }\n  getParentEvent(event, isParent = false) {\n    const parentEvent = this.parent.eventBase.getParentEvent(event, isParent) || event;\n    if (parentEvent[this.parent.eventFields.startTimezone] || parentEvent[this.parent.eventFields.endTimezone]) {\n      this.parent.eventBase.timezoneConvert(parentEvent);\n    }\n    return parentEvent;\n  }\n  excludeDateCheck(eventStartTime, exceptionDateList) {\n    const exDate = getRecurrenceStringFromDate(eventStartTime);\n    if (!isNullOrUndefined(exceptionDateList)) {\n      if (exceptionDateList.indexOf(exDate) === -1) {\n        exceptionDateList = !isNullOrUndefined(exceptionDateList) ? exceptionDateList + ',' + exDate : exDate;\n      }\n    } else {\n      exceptionDateList = exDate;\n    }\n    return exceptionDateList;\n  }\n  processRecurrenceRule(parentEvent, followEvent) {\n    const fields = this.parent.eventFields;\n    const recurrenceRule = parentEvent[fields.recurrenceRule];\n    let endDate;\n    if (followEvent instanceof Date) {\n      endDate = new Date(+followEvent);\n    } else {\n      endDate = new Date(+followEvent[fields.startTime]);\n      const newRecurrenceRule = followEvent[fields.recurrenceRule];\n      const startDate = parentEvent[fields.startTime];\n      const ruleException = this.parent.currentAction === 'DeleteFollowingEvents' ? followEvent[fields.recurrenceException] : null;\n      const dateCollection = generate(startDate, newRecurrenceRule, ruleException, this.parent.activeViewOptions.firstDayOfWeek);\n      const untilDate = new Date(dateCollection.slice(-1)[0]);\n      untilDate.setHours(endDate.getHours(), endDate.getMinutes(), endDate.getSeconds());\n      endDate.setHours(startDate.getHours(), startDate.getMinutes(), startDate.getSeconds());\n      followEvent[fields.recurrenceRule] = this.getUpdatedRecurrenceRule(newRecurrenceRule, new Date(+untilDate), false);\n    }\n    parentEvent[fields.recurrenceRule] = this.getUpdatedRecurrenceRule(recurrenceRule, addDays(new Date(endDate.getTime()), -1), true);\n  }\n  getUpdatedRecurrenceRule(recurrenceRule, untilDate, isParent) {\n    const splitRule = recurrenceRule.split(';');\n    let updatedRule = '';\n    for (let rule of splitRule) {\n      if (rule !== '') {\n        const ruleKey = rule.split('=')[0];\n        let ruleValue = rule.split('=')[1];\n        if (ruleKey === 'COUNT' || ruleKey === 'UNTIL') {\n          ruleValue = getRecurrenceStringFromDate(untilDate);\n          rule = rule.replace(rule, 'UNTIL=' + ruleValue);\n        }\n        updatedRule += rule + ';';\n      }\n    }\n    if (isParent && updatedRule.indexOf('UNTIL') === -1) {\n      updatedRule += 'UNTIL=' + getRecurrenceStringFromDate(untilDate);\n    }\n    return updatedRule;\n  }\n  isBlockEvent(eventData) {\n    const eventCollection = eventData instanceof Array ? eventData : [eventData];\n    let value = false;\n    for (const event of eventCollection) {\n      value = event[this.parent.eventFields.isBlock] || false;\n    }\n    return value;\n  }\n  /**\n   * To destroy the crud module.\n   *\n   * @returns {void}\n   * @private\n   */\n  destroy() {\n    this.crudObj = null;\n    this.parent = null;\n  }\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Work cell interactions\n */\nclass WorkCellInteraction {\n  constructor(parent) {\n    this.parent = parent;\n    EventHandler.add(this.parent.element, 'mouseover', this.onHover, this);\n  }\n  cellMouseDown(e) {\n    if (this.isPreventAction(e)) {\n      return;\n    }\n    this.parent.notify(cellMouseDown, {\n      event: e\n    });\n  }\n  cellClick(e) {\n    if (this.isPreventAction(e)) {\n      return;\n    }\n    const queryStr = '.' + WORK_CELLS_CLASS + ',.' + ALLDAY_CELLS_CLASS + ',.' + HEADER_CELLS_CLASS;\n    const target = closest(e.target, queryStr);\n    if (isNullOrUndefined(target)) {\n      return;\n    }\n    if (!isNullOrUndefined(closest(e.target, '.' + NEW_EVENT_CLASS))) {\n      this.parent.eventWindow.openEditor(this.parent.activeCellsData, 'Add');\n      return;\n    }\n    const navigateEle = closest(e.target, '.' + NAVIGATE_CLASS);\n    const navigateView = this.parent.getNavigateView();\n    const sameView = this.parent.currentView === navigateView;\n    if (isNullOrUndefined(navigateEle) || sameView || isNullOrUndefined(this.parent.viewOptions[navigateView.charAt(0).toLowerCase() + navigateView.slice(1)])) {\n      if (this.parent.activeViewOptions.readonly && this.parent.currentView !== 'MonthAgenda') {\n        if (this.parent.quickPopup) {\n          this.parent.quickPopup.quickPopupHide();\n        }\n        return;\n      }\n      if (this.parent.isAdaptive && (e.target.classList.contains(MORE_INDICATOR_CLASS) || closest(e.target, '.' + MORE_INDICATOR_CLASS))) {\n        return;\n      }\n      const isWorkCell = target.classList.contains(WORK_CELLS_CLASS) || target.classList.contains(ALLDAY_CELLS_CLASS);\n      if (isWorkCell && e.shiftKey && e.which === 1 && this.parent.keyboardInteractionModule) {\n        this.parent.keyboardInteractionModule.onMouseSelection(e);\n        return;\n      }\n      this.parent.activeCellsData = this.parent.getCellDetails(target);\n      const args = extend(this.parent.activeCellsData, {\n        cancel: false,\n        event: e,\n        name: 'cellClick'\n      });\n      this.parent.trigger(cellClick, args, clickArgs => {\n        if (!clickArgs.cancel) {\n          if (isWorkCell) {\n            this.parent.selectCell(target);\n          }\n          if (this.parent.allowInline) {\n            const inlineArgs = {\n              element: clickArgs.element,\n              groupIndex: clickArgs.groupIndex,\n              type: 'Cell'\n            };\n            this.parent.notify(inlineClick, inlineArgs);\n          } else {\n            this.parent.notify(cellClick, clickArgs);\n          }\n        } else {\n          if (this.parent.quickPopup) {\n            this.parent.quickPopup.quickPopupHide();\n          }\n        }\n      });\n    } else {\n      const date = this.parent.getDateFromElement(target);\n      if (!isNullOrUndefined(date) && !this.parent.isAdaptive && this.parent.isMinMaxDate(date)) {\n        this.parent.setProperties({\n          selectedDate: date\n        }, true);\n        this.parent.changeView(this.parent.getNavigateView(), e);\n      }\n    }\n  }\n  cellDblClick(e) {\n    const queryStr = '.' + WORK_CELLS_CLASS + ',.' + ALLDAY_CELLS_CLASS + ',.' + HEADER_CELLS_CLASS;\n    const target = closest(e.target, queryStr);\n    if (this.parent.activeViewOptions.readonly || this.isPreventAction(e) || isNullOrUndefined(target)) {\n      return;\n    }\n    const args = extend(this.parent.activeCellsData, {\n      cancel: false,\n      event: e,\n      name: 'cellDoubleClick'\n    });\n    this.parent.trigger(cellDoubleClick, args, clickArgs => {\n      const date = new Date(clickArgs.startTime.getTime());\n      if (!this.parent.isMinMaxDate(new Date(date.setHours(0, 0, 0, 0)))) {\n        return;\n      }\n      if (!clickArgs.cancel) {\n        this.parent.eventWindow.openEditor(this.parent.activeCellsData, 'Add');\n      }\n    });\n  }\n  onHover(e) {\n    const targetSelector = '.' + WORK_CELLS_CLASS + ',.' + TIME_SLOT_CLASS + ',.' + ALLDAY_CELLS_CLASS + ',.' + HEADER_CELLS_CLASS + ',.' + RESOURCE_CELLS_CLASS + ',.' + APPOINTMENT_CLASS + ',.' + WEEK_NUMBER_CLASS + ',.' + MONTH_HEADER_CLASS;\n    const hoverTarget = closest(e.target, targetSelector);\n    if (hoverTarget) {\n      const hoverArgs = {\n        element: hoverTarget,\n        event: e\n      };\n      this.parent.trigger(hover, hoverArgs);\n    }\n  }\n  isPreventAction(e) {\n    if (closest(e.target, '.' + NAVIGATE_CLASS)) {\n      return false;\n    }\n    if (closest(e.target, '.' + APPOINTMENT_WRAPPER_CLASS) && !closest(e.target, '.' + MORE_INDICATOR_CLASS)) {\n      return true;\n    }\n    let target = closest(e.target, '.' + APPOINTMENT_CLASS + ',.' + RESOURCE_GROUP_CELLS_CLASS);\n    if (!isNullOrUndefined(target)) {\n      return true;\n    }\n    target = closest(e.target, '.' + HEADER_CELLS_CLASS);\n    if (this.parent.activeView.isTimelineView() && !isNullOrUndefined(target)) {\n      return true;\n    }\n    return false;\n  }\n  destroy() {\n    EventHandler.remove(this.parent.element, 'mouseover', this.onHover);\n  }\n}\nvar __decorate$8 = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Configuration that applies on each appointment field options of scheduler.\n */\nclass FieldOptions extends ChildProperty {}\n__decorate$8([Property()], FieldOptions.prototype, \"name\", void 0);\n__decorate$8([Property()], FieldOptions.prototype, \"default\", void 0);\n__decorate$8([Property()], FieldOptions.prototype, \"title\", void 0);\n__decorate$8([Property({})], FieldOptions.prototype, \"validation\", void 0);\nvar __decorate$7 = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n/**\n * A Class that holds the collection of event fields that requires to be mapped with the dataSource\n * fields along with its available configuration settings. Each field in it accepts both string and Object\n *  data type. When each of the field is assigned with simple `string` value, it is assumed that the dataSource field\n *  name is mapped with it. If the `object` type is defined on each fields, then the validation related settings and mapping of\n *  those fields with dataSource can be given altogether within it.\n */\nclass Field extends ChildProperty {}\n__decorate$7([Property('Id')], Field.prototype, \"id\", void 0);\n__decorate$7([Property('IsBlock')], Field.prototype, \"isBlock\", void 0);\n__decorate$7([Complex({\n  name: 'Subject'\n}, FieldOptions)], Field.prototype, \"subject\", void 0);\n__decorate$7([Complex({\n  name: 'StartTime'\n}, FieldOptions)], Field.prototype, \"startTime\", void 0);\n__decorate$7([Complex({\n  name: 'EndTime'\n}, FieldOptions)], Field.prototype, \"endTime\", void 0);\n__decorate$7([Complex({\n  name: 'StartTimezone'\n}, FieldOptions)], Field.prototype, \"startTimezone\", void 0);\n__decorate$7([Complex({\n  name: 'EndTimezone'\n}, FieldOptions)], Field.prototype, \"endTimezone\", void 0);\n__decorate$7([Complex({\n  name: 'Location'\n}, FieldOptions)], Field.prototype, \"location\", void 0);\n__decorate$7([Complex({\n  name: 'Description'\n}, FieldOptions)], Field.prototype, \"description\", void 0);\n__decorate$7([Complex({\n  name: 'IsAllDay'\n}, FieldOptions)], Field.prototype, \"isAllDay\", void 0);\n__decorate$7([Complex({\n  name: 'RecurrenceID'\n}, FieldOptions)], Field.prototype, \"recurrenceID\", void 0);\n__decorate$7([Complex({\n  name: 'RecurrenceRule'\n}, FieldOptions)], Field.prototype, \"recurrenceRule\", void 0);\n__decorate$7([Complex({\n  name: 'RecurrenceException'\n}, FieldOptions)], Field.prototype, \"recurrenceException\", void 0);\n__decorate$7([Property('IsReadonly')], Field.prototype, \"isReadonly\", void 0);\n__decorate$7([Property('FollowingID')], Field.prototype, \"followingID\", void 0);\nvar __decorate$6 = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Holds the configuration of event related options and dataSource binding to Schedule.\n */\nclass EventSettings extends ChildProperty {}\n__decorate$6([Property()], EventSettings.prototype, \"template\", void 0);\n__decorate$6([Property([])], EventSettings.prototype, \"dataSource\", void 0);\n__decorate$6([Property()], EventSettings.prototype, \"query\", void 0);\n__decorate$6([Complex({}, Field)], EventSettings.prototype, \"fields\", void 0);\n__decorate$6([Property(false)], EventSettings.prototype, \"enableTooltip\", void 0);\n__decorate$6([Property('AllDayRow')], EventSettings.prototype, \"spannedEventPlacement\", void 0);\n__decorate$6([Property(1)], EventSettings.prototype, \"minimumEventDuration\", void 0);\n__decorate$6([Property()], EventSettings.prototype, \"tooltipTemplate\", void 0);\n__decorate$6([Property()], EventSettings.prototype, \"resourceColorField\", void 0);\n__decorate$6([Property(false)], EventSettings.prototype, \"editFollowingEvents\", void 0);\n__decorate$6([Property(true)], EventSettings.prototype, \"allowAdding\", void 0);\n__decorate$6([Property(true)], EventSettings.prototype, \"allowEditing\", void 0);\n__decorate$6([Property(true)], EventSettings.prototype, \"allowDeleting\", void 0);\n__decorate$6([Property(false)], EventSettings.prototype, \"enableMaxHeight\", void 0);\n__decorate$6([Property(false)], EventSettings.prototype, \"enableIndicator\", void 0);\n__decorate$6([Property(false)], EventSettings.prototype, \"ignoreWhitespace\", void 0);\n__decorate$6([Property()], EventSettings.prototype, \"sortComparer\", void 0);\nvar __decorate$9 = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n/**\n * A class that holds the resource grouping related configurations on Schedule.\n */\nclass Group extends ChildProperty {}\n__decorate$9([Property(false)], Group.prototype, \"byDate\", void 0);\n__decorate$9([Property(true)], Group.prototype, \"byGroupID\", void 0);\n__decorate$9([Property(false)], Group.prototype, \"allowGroupEdit\", void 0);\n__decorate$9([Property([])], Group.prototype, \"resources\", void 0);\n__decorate$9([Property(true)], Group.prototype, \"enableCompactView\", void 0);\n__decorate$9([Property()], Group.prototype, \"headerTooltipTemplate\", void 0);\nvar __decorate$10 = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * A class that represents the resource related configurations and its data binding options.\n */\nclass Resources extends ChildProperty {}\n__decorate$10([Property()], Resources.prototype, \"field\", void 0);\n__decorate$10([Property()], Resources.prototype, \"title\", void 0);\n__decorate$10([Property()], Resources.prototype, \"name\", void 0);\n__decorate$10([Property(false)], Resources.prototype, \"allowMultiple\", void 0);\n__decorate$10([Property([])], Resources.prototype, \"dataSource\", void 0);\n__decorate$10([Property()], Resources.prototype, \"query\", void 0);\n__decorate$10([Property('Id')], Resources.prototype, \"idField\", void 0);\n__decorate$10([Property('Text')], Resources.prototype, \"textField\", void 0);\n__decorate$10([Property('Expanded')], Resources.prototype, \"expandedField\", void 0);\n__decorate$10([Property('GroupID')], Resources.prototype, \"groupIDField\", void 0);\n__decorate$10([Property('Color')], Resources.prototype, \"colorField\", void 0);\n__decorate$10([Property('StartHour')], Resources.prototype, \"startHourField\", void 0);\n__decorate$10([Property('EndHour')], Resources.prototype, \"endHourField\", void 0);\n__decorate$10([Property('WorkDays')], Resources.prototype, \"workDaysField\", void 0);\n__decorate$10([Property('CssClass')], Resources.prototype, \"cssClassField\", void 0);\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable max-len */\nclass ResourceBase {\n  constructor(parent) {\n    this.resourceCollection = [];\n    this.leftPixel = 25;\n    this.parent = parent;\n  }\n  renderResourceHeaderIndent(tr) {\n    const resColTd = createElement('td', {\n      className: RESOURCE_LEFT_TD_CLASS\n    });\n    const resColDiv = createElement('div', {\n      className: RESOURCE_TEXT_CLASS\n    });\n    if (this.parent.activeViewOptions.headerIndentTemplate) {\n      const data = {\n        className: [resColTd.className],\n        type: 'emptyCells'\n      };\n      this.parent.renderHeaderIndentTemplate(data, resColTd);\n    } else {\n      resColTd.appendChild(resColDiv);\n    }\n    const args = {\n      elementType: 'emptyCells',\n      element: resColTd\n    };\n    this.parent.trigger(renderCell, args);\n    tr.appendChild(resColTd);\n  }\n  hideResourceRows(tBody) {\n    if (this.resourceCollection.length <= 1 || this.parent.virtualScrollModule) {\n      return;\n    }\n    const trCount = this.lastResourceLevel.length;\n    for (let i = 0; i < trCount; i++) {\n      const resData = this.lastResourceLevel[i].resourceData;\n      const res = this.lastResourceLevel[i].resource;\n      if (resData.ClassName === RESOURCE_PARENT_CLASS && !resData[res.expandedField] && !isNullOrUndefined(resData[res.expandedField])) {\n        const trCollection = [].slice.call(tBody.children);\n        const slicedCollection = trCollection.slice(i + 1, i + (parseInt(resData.Count, 10) + 1));\n        addClass(slicedCollection, HIDDEN_CLASS);\n      }\n    }\n  }\n  createResourceColumn() {\n    const resColl = this.resourceCollection;\n    const resDiv = createElement('div', {\n      className: RESOURCE_COLUMN_WRAP_CLASS\n    });\n    const tbl = this.parent.activeView.createTableLayout(RESOURCE_COLUMN_TABLE_CLASS);\n    if (!this.parent.uiStateValues.isGroupAdaptive && this.parent.rowAutoHeight && this.parent.activeView.isTimelineView() && this.parent.activeViewOptions.group.resources.length > 0) {\n      addClass([tbl], AUTO_HEIGHT);\n    }\n    const tBody = tbl.querySelector('tbody');\n    let resData = this.generateTreeData(true);\n    this.countCalculation(resColl.slice(0, -2), resColl.slice(0, -1));\n    this.renderedResources = this.lastResourceLevel;\n    if (this.parent.virtualScrollModule) {\n      const resourceCount = this.parent.virtualScrollModule.getRenderedCount();\n      this.setExpandedResources();\n      resData = this.expandedResources.slice(0, resourceCount);\n      this.renderedResources = resData;\n    }\n    append(this.getContentRows(resData), tBody);\n    this.hideResourceRows(tBody);\n    tbl.appendChild(tBody);\n    resDiv.appendChild(tbl);\n    return resDiv;\n  }\n  setRenderedResources() {\n    const resColl = this.resourceCollection;\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const temp = this.generateTreeData(true);\n    this.countCalculation(resColl.slice(0, -2), resColl.slice(0, -1));\n    this.renderedResources = this.lastResourceLevel;\n  }\n  setExpandedResources() {\n    const resources = [];\n    for (let i = 0; i < this.lastResourceLevel.length; i++) {\n      const resource = this.lastResourceLevel[i].resourceData;\n      const count = resource.Count;\n      resources.push(this.lastResourceLevel[i]);\n      const isExpanded = resource[this.lastResourceLevel[i].resource.expandedField];\n      if (!isNullOrUndefined(isExpanded) && !isExpanded && count > 0) {\n        i = i + count;\n      }\n    }\n    this.expandedResources = resources;\n  }\n  getContentRows(resData, isVirtualScroll) {\n    const resRows = [];\n    let left;\n    let rIndex;\n    const resColl = this.resourceCollection;\n    const tr = createElement('tr');\n    const td = createElement('td', {\n      attrs: {\n        tabindex: isVirtualScroll ? '-1' : '0'\n      }\n    });\n    for (let i = 0; i < resData.length; i++) {\n      const ntd = td.cloneNode();\n      rIndex = findIndexInData(resColl, 'name', resData[i].resource.name);\n      if (rIndex === resColl.length - 1) {\n        extend(resData[i].resourceData, {\n          ClassName: RESOURCE_CHILD_CLASS\n        });\n        this.renderedResources[i].className = [RESOURCE_CHILD_CLASS];\n      } else {\n        extend(resData[i].resourceData, {\n          ClassName: RESOURCE_PARENT_CLASS\n        });\n        this.renderedResources[i].className = [RESOURCE_PARENT_CLASS];\n      }\n      left = rIndex * this.leftPixel + 'px';\n      if (resData[i].resourceData.ClassName === RESOURCE_PARENT_CLASS && !isNullOrUndefined(resData[i].resourceData.Count) && resData[i].resourceData.Count > 0) {\n        let iconClass;\n        if (resData[i].resourceData[resColl[rIndex].expandedField] || isNullOrUndefined(resData[i].resourceData[resColl[rIndex].expandedField])) {\n          iconClass = RESOURCE_COLLAPSE_CLASS;\n        } else {\n          iconClass = RESOURCE_EXPAND_CLASS;\n        }\n        const iconDiv = createElement('div');\n        addClass([iconDiv], [RESOURCE_TREE_ICON_CLASS, iconClass]);\n        this.setMargin(iconDiv, left);\n        ntd.appendChild(iconDiv);\n        if (this.resourceCollection.length > 1) {\n          EventHandler.add(iconDiv, 'click', this.onTreeIconClick, this);\n        }\n      }\n      this.parent.activeView.setResourceHeaderContent(ntd, resData[i], RESOURCE_TEXT_CLASS);\n      ntd.setAttribute('data-group-index', resData[i].groupIndex.toString());\n      ntd.setAttribute('aria-label', resData[i].resourceData[resData[i].resource.textField] + ' resource');\n      if (!this.parent.activeViewOptions.resourceHeaderTemplate) {\n        this.setMargin(ntd.querySelector('.' + RESOURCE_TEXT_CLASS), left);\n      }\n      const classCollection = [RESOURCE_CELLS_CLASS, resData[i].resourceData.ClassName];\n      addClass([ntd], classCollection);\n      const args = {\n        elementType: 'resourceHeader',\n        element: ntd,\n        groupIndex: resData[i].groupIndex\n      };\n      this.parent.trigger(renderCell, args);\n      const ntr = tr.cloneNode();\n      ntr.appendChild(ntd);\n      resRows.push(ntr);\n    }\n    return resRows;\n  }\n  setMargin(element, value) {\n    if (!this.parent.enableRtl) {\n      element.style.marginLeft = value;\n    } else {\n      element.style.marginRight = value;\n    }\n  }\n  countCalculation(parentCollection, wholeCollection) {\n    let collection;\n    for (let y = 0; y < parentCollection.length; y++) {\n      const data = parentCollection[parentCollection.length - (y + 1)].dataSource;\n      for (let x = 0; x < data.length; x++) {\n        let totalCount = 0;\n        if (this.parent.activeViewOptions.group.byGroupID) {\n          const query = new Query().where(wholeCollection[wholeCollection.length - 1].groupIDField, 'equal', data[x][parentCollection[parentCollection.length - (y + 1)].idField]);\n          collection = new DataManager(wholeCollection[wholeCollection.length - 1].dataSource).executeLocal(query);\n        } else {\n          collection = wholeCollection[wholeCollection.length - 1].dataSource;\n        }\n        for (let z = 0; z < collection.length; z++) {\n          totalCount = totalCount + parseInt(collection[z].Count, 10);\n        }\n        totalCount = totalCount + parseInt(data[x].Count, 10);\n        extend(data[x], {\n          Count: totalCount\n        });\n      }\n      wholeCollection = wholeCollection.slice(0, -1);\n    }\n  }\n  onTreeIconClick(e) {\n    if (this.parent.eventTooltip) {\n      this.parent.eventTooltip.close();\n    }\n    const target = e.target;\n    let hide;\n    const trElement = closest(target, '.' + RESOURCE_PARENT_CLASS).parentElement;\n    const index = parseInt(trElement.children[0].getAttribute('data-group-index'), 10);\n    let args = {\n      cancel: false,\n      event: e,\n      groupIndex: index,\n      requestType: !target.classList.contains(RESOURCE_COLLAPSE_CLASS) ? 'resourceExpand' : 'resourceCollapse'\n    };\n    this.parent.trigger(actionBegin, args, actionArgs => {\n      if (!actionArgs.cancel) {\n        if (target.classList.contains(RESOURCE_COLLAPSE_CLASS)) {\n          classList(target, [RESOURCE_EXPAND_CLASS], [RESOURCE_COLLAPSE_CLASS]);\n          hide = true;\n        } else {\n          classList(target, [RESOURCE_COLLAPSE_CLASS], [RESOURCE_EXPAND_CLASS]);\n          hide = false;\n        }\n        const eventElements = [].slice.call(this.parent.element.querySelectorAll('.' + APPOINTMENT_CLASS));\n        for (const element of eventElements) {\n          remove(element);\n        }\n        if (this.parent.virtualScrollModule) {\n          this.updateVirtualContent(index, hide, e, target);\n        } else {\n          this.updateContent(index, hide);\n        }\n        const data = {\n          cssProperties: this.parent.getCssProperties(),\n          module: 'scroll'\n        };\n        this.parent.notify(scrollUiUpdate, data);\n        args = {\n          cancel: false,\n          event: e,\n          groupIndex: index,\n          requestType: target.classList.contains(RESOURCE_COLLAPSE_CLASS) ? 'resourceExpanded' : 'resourceCollapsed'\n        };\n        this.parent.refreshEvents(false);\n        this.parent.trigger(actionComplete, args);\n      }\n    });\n  }\n  updateContent(index, hide) {\n    const rowCollection = [];\n    const workCellCollection = [];\n    const headerRowCollection = [];\n    let pNode;\n    const clickedRes = this.lastResourceLevel[index].resourceData;\n    const resRows = [].slice.call(this.parent.element.querySelectorAll('.' + RESOURCE_COLUMN_WRAP_CLASS + ' ' + 'tr'));\n    const contentRows = [].slice.call(this.parent.element.querySelectorAll('.' + CONTENT_WRAP_CLASS + ' ' + 'tbody tr'));\n    const eventRows = [].slice.call(this.parent.element.querySelectorAll('.' + CONTENT_WRAP_CLASS + ' .' + APPOINTMENT_CONTAINER_CLASS));\n    for (let j = 0; j < clickedRes.Count; j++) {\n      rowCollection.push(resRows[index + j + 1]);\n      workCellCollection.push(contentRows[index + j + 1]);\n      headerRowCollection.push(eventRows[index + j + 1]);\n    }\n    const clonedCollection = this.lastResourceLevel;\n    for (let i = 0; i < rowCollection.length; i++) {\n      let expanded = true;\n      pNode = rowCollection[i].children[0].classList.contains(RESOURCE_PARENT_CLASS);\n      clonedCollection[index].resourceData[clonedCollection[index].resource.expandedField] = !hide;\n      if (hide) {\n        if (pNode) {\n          const trElem = rowCollection[i].querySelector('.' + RESOURCE_TREE_ICON_CLASS);\n          if (trElem) {\n            classList(trElem, [RESOURCE_EXPAND_CLASS], [RESOURCE_COLLAPSE_CLASS]);\n          }\n        }\n        if (!rowCollection[i].classList.contains(HIDDEN_CLASS)) {\n          addClass([rowCollection[i], workCellCollection[i], headerRowCollection[i]], HIDDEN_CLASS);\n        }\n      } else {\n        if (pNode) {\n          const rowIndex = rowCollection[i].rowIndex;\n          if (!clonedCollection[rowIndex].resourceData[clonedCollection[rowIndex].resource.expandedField] && !isNullOrUndefined(clonedCollection[rowIndex].resourceData[clonedCollection[rowIndex].resource.expandedField])) {\n            rowCollection.splice(i + 1, parseInt(clonedCollection[rowIndex].resourceData.Count, 10));\n            workCellCollection.splice(i + 1, parseInt(clonedCollection[rowIndex].resourceData.Count, 10));\n            headerRowCollection.splice(i + 1, parseInt(clonedCollection[rowIndex].resourceData.Count, 10));\n            expanded = false;\n          }\n          if (expanded) {\n            const trElem = rowCollection[i].querySelector('.' + RESOURCE_TREE_ICON_CLASS);\n            if (trElem) {\n              classList(trElem, [RESOURCE_COLLAPSE_CLASS], [RESOURCE_EXPAND_CLASS]);\n            }\n          }\n        }\n        if (rowCollection[i].classList.contains(HIDDEN_CLASS)) {\n          removeClass([rowCollection[i], workCellCollection[i], headerRowCollection[i]], HIDDEN_CLASS);\n        }\n      }\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  updateVirtualContent(index, expand, e, target) {\n    this.lastResourceLevel[index].resourceData[this.lastResourceLevel[index].resource.expandedField] = !expand;\n    this.setExpandedResources();\n    const resourceCount = this.parent.virtualScrollModule.getRenderedCount();\n    const startIndex = this.expandedResources.indexOf(this.renderedResources[0]);\n    this.renderedResources = this.expandedResources.slice(startIndex, startIndex + resourceCount);\n    if (this.renderedResources.length < resourceCount) {\n      let sIndex = this.expandedResources.length - resourceCount;\n      sIndex = sIndex > 0 ? sIndex : 0;\n      this.renderedResources = this.expandedResources.slice(sIndex, this.expandedResources.length);\n    }\n    const virtualTrack = this.parent.element.querySelector('.' + VIRTUAL_TRACK_CLASS);\n    this.parent.virtualScrollModule.updateVirtualTrackHeight(virtualTrack);\n    const resTable = this.parent.element.querySelector('.' + RESOURCE_COLUMN_WRAP_CLASS + ' ' + 'table');\n    const contentTable = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS + ' ' + 'table');\n    const eventTable = this.parent.element.querySelector('.' + EVENT_TABLE_CLASS);\n    this.parent.virtualScrollModule.updateContent(resTable, contentTable, eventTable, this.renderedResources);\n    const timeIndicator = this.parent.element.querySelector('.' + CURRENT_TIMELINE_CLASS);\n    if (!isNullOrUndefined(timeIndicator)) {\n      timeIndicator.style.height = this.parent.element.querySelector('.' + CONTENT_TABLE_CLASS).offsetHeight + 'px';\n    }\n  }\n  renderResourceHeader() {\n    const resourceWrapper = createElement('div', {\n      className: RESOURCE_TOOLBAR_CONTAINER\n    });\n    resourceWrapper.innerHTML = '<div class=\"' + RESOURCE_HEADER_TOOLBAR + '\"><div class=\"' + RESOURCE_MENU + '\">' + '<div class=\"e-icons ' + RESOURCE_MENU_ICON + '\"></div></div><div class=\"' + RESOURCE_LEVEL_TITLE + '\"></div></div>';\n    if (this.parent.currentView === 'MonthAgenda') {\n      const target = this.parent.activeView.getPanel().querySelector('.' + CONTENT_WRAP_CLASS);\n      target.insertBefore(resourceWrapper, target.querySelector('.' + WRAPPER_CONTAINER_CLASS));\n    } else {\n      this.parent.element.insertBefore(resourceWrapper, this.parent.element.querySelector('.' + TABLE_CONTAINER_CLASS));\n    }\n    this.renderResourceHeaderText();\n    EventHandler.add(resourceWrapper.querySelector('.' + RESOURCE_MENU_ICON), 'click', this.menuClick, this);\n  }\n  renderResourceTree() {\n    this.popupOverlay = createElement('div', {\n      className: RESOURCE_TREE_POPUP_OVERLAY\n    });\n    const treeWrapper = createElement('div', {\n      className: RESOURCE_TREE_POPUP + ' e-popup-close'\n    });\n    if (this.parent.currentView === 'MonthAgenda') {\n      const target = this.parent.activeView.getPanel().querySelector('.' + WRAPPER_CONTAINER_CLASS);\n      target.insertBefore(treeWrapper, target.children[0]);\n      target.appendChild(this.popupOverlay);\n    } else {\n      this.parent.element.querySelector('.' + TABLE_CONTAINER_CLASS).appendChild(treeWrapper);\n      this.parent.element.querySelector('.' + TABLE_CONTAINER_CLASS).appendChild(this.popupOverlay);\n    }\n    const resourceTree = createElement('div', {\n      className: RESOURCE_TREE\n    });\n    treeWrapper.appendChild(resourceTree);\n    this.treeViewObj = new TreeView({\n      cssClass: this.parent.cssClass,\n      enableRtl: this.parent.enableRtl,\n      fields: {\n        dataSource: [].slice.call(this.generateTreeData()),\n        id: 'resourceId',\n        text: 'resourceName',\n        child: 'resourceChild'\n      },\n      nodeTemplate: this.parent.resourceHeaderTemplate,\n      nodeClicked: this.resourceClick.bind(this)\n    });\n    this.treeViewObj.appendTo(resourceTree);\n    this.treeViewObj.expandAll();\n    this.treePopup = new Popup(treeWrapper, {\n      targetType: 'relative',\n      actionOnScroll: 'none',\n      content: this.treeViewObj.element,\n      relateTo: this.parent.element.querySelector('.' + TABLE_CONTAINER_CLASS),\n      enableRtl: this.parent.enableRtl,\n      hideAnimation: {\n        name: 'SlideLeftOut',\n        duration: 500\n      },\n      showAnimation: {\n        name: 'SlideLeftIn',\n        duration: 500\n      },\n      viewPortElement: this.parent.element.querySelector('.' + (this.parent.currentView === 'MonthAgenda' ? WRAPPER_CONTAINER_CLASS : TABLE_CONTAINER_CLASS))\n    });\n    this.parent.on(documentClick, this.documentClick, this);\n  }\n  generateTreeData(isTimeLine) {\n    const treeCollection = [];\n    const resTreeColl = [];\n    let groupIndex = 0;\n    for (let i = 0, len = this.resourceTreeLevel.length; i < len; i++) {\n      const treeHandler = (treeLevel, index, levelId) => {\n        const resource = this.resourceCollection[index];\n        let treeArgs;\n        let resObj;\n        if (!isTimeLine) {\n          treeArgs = {\n            resourceId: levelId,\n            resourceName: treeLevel.resourceData[resource.textField],\n            resource: treeLevel.resource,\n            resourceData: treeLevel.resourceData\n          };\n        } else {\n          resObj = {\n            type: 'resourceHeader',\n            resource: treeLevel.resource,\n            resourceData: treeLevel.resourceData,\n            groupIndex: groupIndex,\n            groupOrder: treeLevel.groupOrder\n          };\n          resTreeColl.push(resObj);\n          groupIndex++;\n        }\n        if (treeLevel.child.length > 0 && !isTimeLine) {\n          treeArgs.resourceChild = [];\n        }\n        let count = 1;\n        for (const tree of treeLevel.child) {\n          if (!isTimeLine) {\n            treeArgs.resourceChild.push(treeHandler(tree, index + 1, levelId + '-' + count));\n          } else {\n            treeHandler(tree, index + 1, levelId + '-' + count);\n          }\n          count += 1;\n        }\n        if (isTimeLine) {\n          extend(resObj.resourceData, {\n            Count: count - 1\n          });\n        }\n        return treeArgs;\n      };\n      if (!isTimeLine) {\n        treeCollection.push(treeHandler(this.resourceTreeLevel[i], 0, (i + 1).toString()));\n      } else {\n        treeHandler(this.resourceTreeLevel[i], 0, (i + 1).toString());\n      }\n    }\n    if (isTimeLine) {\n      this.lastResourceLevel = resTreeColl;\n      return resTreeColl;\n    } else {\n      return treeCollection;\n    }\n  }\n  renderResourceHeaderText() {\n    const resource = this.lastResourceLevel[this.parent.uiStateValues.groupIndex];\n    const headerCollection = [];\n    for (let i = 0, len = resource.groupOrder.length; i < len; i++) {\n      const resourceLevel = this.resourceCollection[i];\n      const resourceText = resourceLevel.dataSource.filter(resData => resData[resourceLevel.idField] === resource.groupOrder[i]);\n      const resourceName = createElement('div', {\n        className: RESOURCE_NAME,\n        innerHTML: resourceText[0][resourceLevel.textField]\n      });\n      headerCollection.push(resourceName);\n      const levelIcon = createElement('div', {\n        className: 'e-icons e-icon-next'\n      });\n      headerCollection.push(levelIcon);\n    }\n    headerCollection.pop();\n    const target = this.parent.currentView === 'MonthAgenda' ? this.parent.activeView.getPanel() : this.parent.element;\n    const headerWrapper = target.querySelector('.' + RESOURCE_LEVEL_TITLE);\n    removeChildren(headerWrapper);\n    for (const header of headerCollection) {\n      headerWrapper.appendChild(header);\n    }\n    if (this.lastResourceLevel.length === 1) {\n      addClass([this.parent.element.querySelector('.' + RESOURCE_MENU)], DISABLE_CLASS);\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  menuClick(event) {\n    if (this.parent.element.querySelector('.' + RESOURCE_TREE_POPUP).classList.contains(POPUP_OPEN)) {\n      this.treePopup.hide();\n      removeClass([this.popupOverlay], ENABLE_CLASS);\n    } else {\n      const treeNodes = [].slice.call(this.treeViewObj.element.querySelectorAll('.e-list-item:not(.e-has-child)'));\n      removeClass(treeNodes, 'e-active');\n      addClass([treeNodes[this.parent.uiStateValues.groupIndex]], 'e-active');\n      this.treePopup.show();\n      addClass([this.popupOverlay], ENABLE_CLASS);\n    }\n  }\n  selectResourceByIndex(groupIndex) {\n    if (this.lastResourceLevel && groupIndex > -1 && groupIndex < this.lastResourceLevel.length) {\n      this.triggerEvents(groupIndex);\n    }\n  }\n  resourceClick(event) {\n    if (!event.node.classList.contains('e-has-child')) {\n      this.treePopup.hide();\n      removeClass([this.popupOverlay], ENABLE_CLASS);\n      const treeNodes = [].slice.call(this.treeViewObj.element.querySelectorAll('.e-list-item:not(.e-has-child)'));\n      const groupIndex = treeNodes.indexOf(event.node);\n      this.triggerEvents(groupIndex, event);\n      event.event.preventDefault();\n    }\n  }\n  triggerEvents(groupIndex, event) {\n    let args = {\n      cancel: false,\n      event: event ? event.event : null,\n      groupIndex: groupIndex,\n      requestType: 'resourceChange'\n    };\n    this.parent.trigger(actionBegin, args, actionArgs => {\n      if (!actionArgs.cancel) {\n        this.parent.uiStateValues.groupIndex = actionArgs.groupIndex;\n        this.parent.renderModule.render(this.parent.currentView);\n        args = {\n          cancel: false,\n          event: event ? event.event : null,\n          groupIndex: this.parent.uiStateValues.groupIndex,\n          requestType: 'resourceChanged'\n        };\n        this.parent.trigger(actionComplete, args);\n      }\n    });\n  }\n  documentClick(args) {\n    if (closest(args.event.target, '.' + RESOURCE_TREE_POPUP)) {\n      return;\n    }\n    const treeWrapper = this.parent.element.querySelector('.' + RESOURCE_TREE_POPUP);\n    if (treeWrapper && treeWrapper.classList.contains(POPUP_OPEN)) {\n      this.treePopup.hide();\n      removeClass([this.popupOverlay], ENABLE_CLASS);\n    }\n  }\n  bindResourcesData(isSetModel) {\n    this.parent.showSpinner();\n    const promises = [];\n    for (const resource of this.parent.resources) {\n      const dataModule = new Data(resource.dataSource, resource.query);\n      promises.push(dataModule.getData(dataModule.generateQuery()));\n    }\n    Promise.all(promises).then(e => this.dataManagerSuccess(e, isSetModel)).catch(e => this.parent.crudModule.dataManagerFailure(e));\n  }\n  dataManagerSuccess(e, isSetModel) {\n    if (!this.parent || this.parent && this.parent.isDestroyed) {\n      return;\n    }\n    this.parent.resourceCollection = [];\n    for (let i = 0, length = e.length; i < length; i++) {\n      const resource = this.parent.resources[i];\n      const resourceObj = this.getResourceModel(resource, e[i].result);\n      this.parent.resourceCollection.push(resourceObj);\n    }\n    this.refreshLayout(isSetModel);\n  }\n  getResourceModel(resource, resourceData) {\n    const resourceObj = {\n      field: resource.field,\n      title: resource.title,\n      name: resource.name,\n      allowMultiple: resource.allowMultiple,\n      dataSource: resourceData || resource.dataSource,\n      idField: resource.idField,\n      textField: resource.textField,\n      groupIDField: resource.groupIDField,\n      colorField: resource.colorField,\n      startHourField: resource.startHourField,\n      endHourField: resource.endHourField,\n      workDaysField: resource.workDaysField,\n      expandedField: resource.expandedField,\n      cssClassField: resource.cssClassField\n    };\n    return resourceObj;\n  }\n  refreshLayout(isSetModel) {\n    if (isNullOrUndefined(this.parent.uiStateValues.groupIndex) || !this.parent.enablePersistence) {\n      this.parent.uiStateValues.groupIndex = 0;\n    }\n    this.parent.renderElements(isSetModel);\n  }\n  setResourceCollection() {\n    let requiredResources = [];\n    this.resourceCollection = [];\n    this.colorIndex = null;\n    if (this.parent.activeViewOptions.group.resources.length > 0) {\n      for (const resource of this.parent.activeViewOptions.group.resources) {\n        const index = findIndexInData(this.parent.resourceCollection, 'name', resource);\n        if (index >= 0) {\n          requiredResources.push(this.parent.resourceCollection[index]);\n        }\n      }\n    } else if (this.parent.resourceCollection.length > 0) {\n      requiredResources = this.parent.resourceCollection;\n    }\n    let index = 0;\n    for (const resource of requiredResources) {\n      const resources = this.getResourceModel(resource);\n      if (resource.name === this.parent.eventSettings.resourceColorField) {\n        this.colorIndex = index;\n      }\n      index++;\n      this.resourceCollection.push(resources);\n    }\n    if (isNullOrUndefined(this.colorIndex)) {\n      this.colorIndex = this.resourceCollection.length - 1;\n    }\n  }\n  generateResourceLevels(innerDates, isTimeLine) {\n    const resources = this.resourceCollection;\n    const resTreeGroup = [];\n    let lastColumnDates = [];\n    const group = (resources, index, prevResource, prevResourceData, prevOrder) => {\n      const resTree = [];\n      const resource = resources[0];\n      if (resource) {\n        let data;\n        if (prevResourceData && this.parent.activeViewOptions.group.byGroupID) {\n          const id = prevResourceData[prevResource.idField];\n          data = resource.dataSource.filter(e => e[resource.groupIDField] === id);\n        } else {\n          data = resource.dataSource;\n        }\n        for (let i = 0; i < data.length; i++) {\n          let groupOrder = [];\n          if (prevOrder && prevOrder.length > 0) {\n            groupOrder = groupOrder.concat(prevOrder);\n          }\n          groupOrder.push(data[i][resource.idField]);\n          const items = group(resources.slice(1), index + 1, resource, data[i], groupOrder);\n          // Here validate child item empty top level resource only\n          if (index === 0 && items.length === 0 && this.resourceCollection.length > 1) {\n            continue;\n          }\n          let dateCol = [];\n          let renderDates = this.parent.activeView.renderDates;\n          let resWorkDays;\n          if (!this.parent.activeViewOptions.group.byDate && index + 1 === this.resourceCollection.length) {\n            const workDays = data[i][resource.workDaysField];\n            const resStartHour = data[i][resource.startHourField];\n            const resEndHour = data[i][resource.endHourField];\n            if (workDays && workDays.length > 0) {\n              renderDates = this.parent.activeView.getRenderDates(workDays);\n              resWorkDays = workDays;\n              dateCol = this.parent.activeView.getDateSlots(renderDates, workDays);\n            } else {\n              resWorkDays = this.parent.activeViewOptions.workDays;\n              dateCol = innerDates;\n            }\n            const dateSlots = this.generateCustomHours(dateCol, resStartHour, resEndHour, groupOrder);\n            lastColumnDates = lastColumnDates.concat(dateSlots);\n          }\n          const resCssClass = data[i][resource.cssClassField];\n          const slotData = {\n            type: 'resourceHeader',\n            className: ['e-resource-cells'],\n            resourceLevelIndex: index,\n            groupOrder: groupOrder,\n            resource: resource,\n            resourceData: data[i],\n            colSpan: this.parent.activeViewOptions.group.byDate ? 1 : dateCol.length,\n            renderDates: renderDates,\n            workDays: resWorkDays,\n            cssClass: resCssClass,\n            child: items\n          };\n          resTree.push(slotData);\n        }\n        if (!resTreeGroup[index]) {\n          resTreeGroup[index] = [];\n        }\n        if (resTree.length > 0) {\n          resTreeGroup[index].push(resTree);\n        }\n        return resTree;\n      }\n      return [];\n    };\n    this.resourceTreeLevel = group(resources, 0);\n    return isTimeLine ? [] : this.generateHeaderLevels(resTreeGroup, lastColumnDates, innerDates);\n  }\n  generateCustomHours(renderDates, startHour, endHour, groupOrder) {\n    const dateSlots = extend([], renderDates, null, true);\n    for (const dateSlot of dateSlots) {\n      if (startHour) {\n        dateSlot.startHour = this.parent.getStartEndTime(startHour);\n      }\n      if (endHour) {\n        dateSlot.endHour = this.parent.getStartEndTime(endHour);\n      }\n      if (groupOrder) {\n        dateSlot.groupOrder = groupOrder;\n      }\n    }\n    return dateSlots;\n  }\n  generateHeaderLevels(resTreeGroup, lastColumnDates, headerDates) {\n    const headerLevels = [];\n    for (let i = resTreeGroup.length - 1; i >= 0; i--) {\n      let temp = 0;\n      for (const currentLevelChilds of resTreeGroup[i]) {\n        for (const currentLevelChild of currentLevelChilds) {\n          if (resTreeGroup[i + 1] && resTreeGroup[i + 1].length > 0) {\n            const nextLevelChilds = resTreeGroup[i + 1][temp];\n            if (!nextLevelChilds) {\n              continue;\n            }\n            let colSpan = 0;\n            for (const nextLevelChild of nextLevelChilds) {\n              if (!this.parent.activeViewOptions.group.byGroupID || this.parent.activeViewOptions.group.byGroupID && nextLevelChild.resourceData[nextLevelChild.resource.groupIDField] === currentLevelChild.resourceData[currentLevelChild.resource.idField]) {\n                colSpan += nextLevelChild.colSpan;\n              }\n            }\n            currentLevelChild.colSpan = colSpan;\n          }\n          currentLevelChild.groupIndex = temp;\n          temp++;\n          headerLevels[currentLevelChild.resourceLevelIndex] = headerLevels[currentLevelChild.resourceLevelIndex] || [];\n          headerLevels[currentLevelChild.resourceLevelIndex].push(currentLevelChild);\n        }\n      }\n    }\n    this.lastResourceLevel = headerLevels.slice(-1)[0] || [];\n    if (!this.parent.activeViewOptions.group.byDate) {\n      let index = 0;\n      for (const lastLevelResource of this.lastResourceLevel) {\n        for (let i = 0; i < lastLevelResource.colSpan; i++) {\n          lastColumnDates[index].groupIndex = lastLevelResource.groupIndex;\n          index++;\n        }\n      }\n      headerLevels.push(lastColumnDates);\n      return headerLevels;\n    }\n    const dateHeaderLevels = [];\n    const levels = extend([], headerLevels, null, true);\n    let dateColSpan = 0;\n    for (const firstRowTd of levels[0]) {\n      dateColSpan += firstRowTd.colSpan;\n    }\n    const datesColumn = [];\n    for (const headerDate of headerDates) {\n      headerDate.colSpan = dateColSpan;\n      datesColumn.push(headerDate);\n      const resGroup = extend([], levels, null, true);\n      for (let k = 0, length = resGroup.length; k < length; k++) {\n        if (k === resGroup.length - 1) {\n          for (const resTd of resGroup[k]) {\n            resTd.date = headerDate.date;\n            resTd.workDays = headerDate.workDays;\n            resTd.startHour = this.parent.getStartEndTime(resTd.resourceData[resTd.resource.startHourField]) || headerDate.startHour;\n            resTd.endHour = this.parent.getStartEndTime(resTd.resourceData[resTd.resource.endHourField]) || headerDate.endHour;\n          }\n        }\n        if (!dateHeaderLevels[k]) {\n          dateHeaderLevels[k] = [];\n        }\n        dateHeaderLevels[k] = dateHeaderLevels[k].concat(resGroup[k]);\n      }\n    }\n    dateHeaderLevels.unshift(datesColumn);\n    return dateHeaderLevels;\n  }\n  setResourceValues(eventObj, groupIndex) {\n    const setValues = (index, field, value) => {\n      if (this.resourceCollection[index].allowMultiple && this.parent.activeViewOptions.group.allowGroupEdit) {\n        eventObj[field] = [value];\n      } else {\n        eventObj[field] = value;\n      }\n    };\n    if (groupIndex === void 0) {\n      groupIndex = this.parent.uiStateValues.isGroupAdaptive ? this.parent.uiStateValues.groupIndex : this.parent.activeCellsData.groupIndex;\n    }\n    if (this.parent.activeViewOptions.group.resources.length > 0 && !isNullOrUndefined(groupIndex)) {\n      const groupOrder = this.lastResourceLevel[groupIndex].groupOrder;\n      for (let index = 0; index < this.resourceCollection.length; index++) {\n        setValues(index, this.resourceCollection[index].field, groupOrder[index]);\n      }\n    } else if (this.parent.resourceCollection.length > 0) {\n      for (let index = 0; index < this.resourceCollection.length; index++) {\n        const data = this.resourceCollection[index].dataSource[0];\n        if (data) {\n          setValues(index, this.resourceCollection[index].field, data[this.resourceCollection[index].idField]);\n        }\n      }\n    }\n  }\n  getResourceColor(eventObj, groupOrder) {\n    const colorFieldIndex = !isNullOrUndefined(groupOrder) && this.colorIndex > groupOrder.length - 1 ? groupOrder.length - 1 : this.colorIndex;\n    const resource = this.resourceCollection[colorFieldIndex];\n    if (isNullOrUndefined(groupOrder) && this.parent.activeViewOptions.group.allowGroupEdit && resource.allowMultiple) {\n      return undefined;\n    }\n    const id = isNullOrUndefined(groupOrder) ? eventObj[resource.field] : groupOrder[colorFieldIndex];\n    const data = this.filterData(resource.dataSource, resource.idField, id);\n    if (data.length > 0) {\n      return data[0][resource.colorField];\n    }\n    return undefined;\n  }\n  getCssClass(eventObj) {\n    const resource = this.resourceCollection.slice(-1)[0];\n    if (this.parent.activeViewOptions.group.allowGroupEdit && resource.allowMultiple) {\n      return undefined;\n    }\n    const data = this.filterData(resource.dataSource, resource.idField, eventObj[resource.field]);\n    if (data.length > 0) {\n      return data[0][resource.cssClassField];\n    }\n    return undefined;\n  }\n  getResourceRenderDates() {\n    // eslint-disable-next-line prefer-spread\n    const resourceDates = [].concat.apply([], this.lastResourceLevel.map(e => e.renderDates));\n    const removeDuplicateDates = dateColl => dateColl.filter((date, index, dates) => dates.map(dateObj => dateObj.getTime()).indexOf(date.getTime()) === index);\n    const renderDates = removeDuplicateDates(resourceDates);\n    renderDates.sort((a, b) => a.getTime() - b.getTime());\n    return renderDates;\n  }\n  filterData(dataSource, field, value) {\n    return dataSource.filter(data => data[field] === value);\n  }\n  getResourceData(eventObj, index, groupEditIndex) {\n    if (this.parent.activeViewOptions.group.allowGroupEdit) {\n      const resourceObj = {};\n      for (const groupIndex of groupEditIndex) {\n        const resourceLevel = this.lastResourceLevel[groupIndex].groupOrder;\n        for (let level = 0, length = resourceLevel.length; level < length; level++) {\n          const fieldName = this.resourceCollection[level].field;\n          if (isNullOrUndefined(resourceObj[fieldName])) {\n            resourceObj[fieldName] = [];\n          }\n          resourceObj[fieldName].push(resourceLevel[level]);\n        }\n      }\n      eventObj = extend(eventObj, resourceObj);\n    } else {\n      for (let level = 0, length = this.resourceCollection.length; level < length; level++) {\n        if (this.lastResourceLevel[index]) {\n          eventObj[this.resourceCollection[level].field] = this.lastResourceLevel[index].groupOrder[level];\n        }\n      }\n    }\n  }\n  addResource(resources, name, index) {\n    const resourceCollection = resources instanceof Array ? resources : [resources];\n    for (const resource of this.parent.resourceCollection) {\n      if (resource.name === name) {\n        resourceCollection.forEach((addObj, i) => new DataManager({\n          json: resource.dataSource\n        }).insert(addObj, null, null, index + i));\n        break;\n      }\n    }\n    this.refreshLayout(true);\n  }\n  removeResource(resourceId, name) {\n    const resourceCollection = resourceId instanceof Array ? resourceId : [resourceId];\n    for (const resource of this.parent.resourceCollection) {\n      if (resource.name === name) {\n        resourceCollection.forEach(removeObj => new DataManager({\n          json: resource.dataSource\n        }).remove(resource.idField, removeObj));\n        break;\n      }\n    }\n    this.refreshLayout(true);\n  }\n  getIndexFromResourceId(id, name, resourceData, event, parentField) {\n    name = name || this.parent.resourceCollection.slice(-1)[0].name;\n    if (isNullOrUndefined(resourceData)) {\n      resourceData = this.resourceCollection.filter(e => e.name === name)[0];\n      if (isNullOrUndefined(resourceData)) {\n        return null;\n      }\n    }\n    const resource = resourceData.dataSource.filter(e => {\n      if (event && e[resourceData.idField] === id) {\n        if (e[resourceData.groupIDField] === event[parentField]) {\n          return e[resourceData.idField] === id;\n        }\n        return null;\n      } else {\n        return e[resourceData.idField] === id;\n      }\n    })[0];\n    return this.lastResourceLevel.map(e => e.resourceData).indexOf(resource);\n  }\n  resourceExpand(id, name, hide) {\n    const resource = this.parent.resourceCollection.filter(e => {\n      if (e.name === name) {\n        return e;\n      }\n      return null;\n    })[0];\n    let index = 0;\n    const resourceData = resource.dataSource.filter(e => e[resource.idField] === id)[0];\n    if (!this.parent.activeViewOptions.group.byGroupID) {\n      index = this.getIndexFromResourceId(id, name, resource);\n    } else {\n      index = this.lastResourceLevel.map(e => e.resourceData).indexOf(resourceData);\n    }\n    const target = this.parent.element.querySelector('.' + RESOURCE_COLUMN_WRAP_CLASS + ' ' + `[data-group-index=\"${index}\"]` + ' ' + '.' + RESOURCE_TREE_ICON_CLASS);\n    if (target) {\n      if (target.classList.contains(RESOURCE_EXPAND_CLASS) && !hide) {\n        target.click();\n      } else if (target.classList.contains(RESOURCE_COLLAPSE_CLASS) && hide) {\n        target.click();\n      }\n    }\n  }\n  resourceScroll(id, name) {\n    if (this.parent.isAdaptive || ['Agenda', 'MonthAgenda'].indexOf(this.parent.currentView) > -1) {\n      return;\n    }\n    const levelName = name || this.parent.resourceCollection.slice(-1)[0].name;\n    let levelIndex = this.parent.resourceCollection.length - 1;\n    const resource = this.parent.resourceCollection.filter((e, index) => {\n      if (e.name === levelName) {\n        levelIndex = index;\n        return e;\n      }\n      return null;\n    })[0];\n    const scrollElement = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS);\n    let index = 0;\n    if (this.parent.activeView.isTimelineView()) {\n      if (!this.parent.activeViewOptions.group.byGroupID) {\n        index = this.getIndexFromResourceId(id, levelName, resource);\n      } else {\n        const resourceData = resource.dataSource.filter(e => e[resource.idField] === id)[0];\n        index = this.lastResourceLevel.map(e => e.resourceData).indexOf(resourceData);\n      }\n      if (this.parent.virtualScrollModule) {\n        const virtual = this.parent.element.querySelector('.' + VIRTUAL_TRACK_CLASS);\n        const averageRowHeight = Math.round(virtual.offsetHeight / this.expandedResources.length);\n        if (this.parent.rowAutoHeight) {\n          scrollElement.scrollTop = 0;\n          this.parent.virtualScrollModule.virtualScrolling();\n        }\n        scrollElement.scrollTop = index * averageRowHeight - (this.parent.virtualScrollModule.bufferCount - 1) * averageRowHeight;\n        this.parent.virtualScrollModule.virtualScrolling();\n        if (this.parent.rowAutoHeight) {\n          const td = this.parent.element.querySelector(`.${WORK_CELLS_CLASS}[data-group-index=\"${index}\"]`);\n          if (td && !td.parentElement.classList.contains(HIDDEN_CLASS)) {\n            scrollElement.scrollTop = scrollElement.scrollTop < td.offsetTop ? td.offsetTop : scrollElement.scrollTop + td.offsetTop;\n          }\n        } else {\n          scrollElement.scrollTop = index * averageRowHeight;\n        }\n      } else {\n        const td = this.parent.element.querySelector(`.${WORK_CELLS_CLASS}[data-group-index=\"${index}\"]`);\n        if (td && !td.parentElement.classList.contains(HIDDEN_CLASS)) {\n          scrollElement.scrollTop = td.offsetTop;\n        }\n      }\n    } else {\n      if (!this.parent.activeViewOptions.group.byGroupID) {\n        index = this.getIndexFromResourceId(id, levelName, resource);\n      } else {\n        if (levelName === this.parent.resourceCollection.slice(-1)[0].name) {\n          index = this.lastResourceLevel.map(e => e.resourceData[resource.idField]).indexOf(id);\n        } else {\n          index = resource.dataSource.map(e => e[resource.idField]).indexOf(id);\n        }\n      }\n      const offsetTarget = this.parent.element.querySelector(`.${HEADER_ROW_CLASS}:nth-child(${levelIndex + 1})`);\n      const offset = [].slice.call(offsetTarget.children).map(node => node.offsetLeft);\n      scrollElement.scrollLeft = offset[index];\n    }\n  }\n  destroy() {\n    this.parent.off(documentClick, this.documentClick);\n    if (this.treeViewObj) {\n      this.treeViewObj.destroy();\n      this.treeViewObj = null;\n    }\n    if (this.treePopup) {\n      this.treePopup.destroy();\n      this.treePopup = null;\n      remove(this.parent.element.querySelector('.' + RESOURCE_TREE_POPUP));\n      remove(this.parent.element.querySelector('.' + RESOURCE_TREE_POPUP_OVERLAY));\n    }\n    const resToolBarEle = this.parent.element.querySelector('.' + RESOURCE_TOOLBAR_CONTAINER);\n    if (resToolBarEle) {\n      remove(resToolBarEle);\n    }\n  }\n}\nvar __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Represents the Schedule component that displays a list of events scheduled against specific date and timings,\n * thus helping us to plan and manage it properly.\n * ```html\n * <div id=\"schedule\"></div>\n * ```\n * ```typescript\n * <script>\n *   var scheduleObj = new Schedule();\n *   scheduleObj.appendTo(\"#schedule\");\n * </script>\n * ```\n */\nlet Schedule = /*#__PURE__*/(() => {\n  let Schedule = class Schedule extends Component {\n    /**\n     * Constructor for creating the Schedule widget\n     *\n     * @param {ScheduleModel} options Accepts the schedule model properties to initiate the rendering\n     * @param {string | HTMLElement} element Accepts the DOM element reference\n     */\n    constructor(options, element) {\n      super(options, element);\n    }\n    /**\n     * Core method that initializes the control rendering.\n     *\n     * @returns {void}\n     * @private\n     */\n    render() {\n      const addClasses = [];\n      const removeClasses = [];\n      addClasses.push(ROOT);\n      if (this.enableRtl) {\n        addClasses.push(RTL);\n      } else {\n        removeClasses.push(RTL);\n      }\n      if (this.isAdaptive) {\n        addClasses.push(DEVICE_CLASS);\n      } else {\n        removeClasses.push(DEVICE_CLASS);\n      }\n      if (this.allowMultiDrag) {\n        addClasses.push(MULTI_DRAG);\n      } else {\n        removeClasses.push(MULTI_DRAG);\n      }\n      if (this.cssClass) {\n        const cssClass = this.cssClass.split(' ');\n        for (const cls of cssClass) {\n          addClasses.push(cls);\n        }\n      }\n      classList(this.element, addClasses, removeClasses);\n      this.validateDate();\n      createSpinner({\n        target: this.element\n      });\n      this.scrollModule = new Scroll(this);\n      this.scrollModule.setWidth();\n      this.scrollModule.setHeight();\n      this.renderModule = new Render(this);\n      this.eventBase = new EventBase(this);\n      this.workCellAction = new WorkCellInteraction(this);\n      if (this.allowKeyboardInteraction) {\n        this.keyboardInteractionModule = new KeyboardInteraction(this);\n      }\n      this.inlineModule = new InlineEdit(this);\n      this.initializeDataModule();\n      this.renderTableContainer();\n      this.activeViewOptions = this.getActiveViewOptions();\n      this.initializeResources();\n      this.wireEvents();\n    }\n    renderTableContainer() {\n      if (!this.element.querySelector('.' + TABLE_CONTAINER_CLASS)) {\n        this.element.appendChild(this.createElement('div', {\n          className: TABLE_CONTAINER_CLASS\n        }));\n      }\n    }\n    /**\n     * Method to render react templates\n     *\n     * @returns {void}\n     * @private\n     */\n    renderTemplates() {\n      if (this.isReact) {\n        this.renderReactTemplates();\n      }\n    }\n    /**\n     * Method to reset react templates\n     *\n     * @param {string[]} templates Accepts the template ID\n     * @returns {void}\n     * @private\n     */\n    resetTemplates(templates) {\n      if (this.isAngular || this.isReact) {\n        this.clearTemplate(templates);\n      }\n    }\n    initializeResources(isSetModel = false) {\n      if (this.resources.length > 0) {\n        this.resourceBase = new ResourceBase(this);\n        this.resourceBase.bindResourcesData(isSetModel);\n      } else {\n        this.resourceBase = null;\n        this.resourceCollection = [];\n        this.renderElements(isSetModel);\n      }\n    }\n    /**\n     * Method to render the layout elements\n     *\n     * @param {boolean} isLayoutOnly Accepts the boolean value to render layout or not\n     * @returns {void}\n     * @private\n     */\n    renderElements(isLayoutOnly) {\n      if (isLayoutOnly) {\n        this.initializeView(this.currentView);\n        this.eventWindow.refresh();\n        return;\n      }\n      this.destroyHeaderModule();\n      if (this.showHeaderBar) {\n        this.headerModule = new HeaderRenderer(this);\n      }\n      this.renderTableContainer();\n      if (Browser.isDevice || Browser.isTouch) {\n        this.scheduleTouchModule = new ScheduleTouch(this);\n      }\n      this.initializeView(this.currentView);\n      this.destroyPopups();\n      if (!this.isPrinting) {\n        this.initializePopups();\n      }\n    }\n    validateDate(selectedDate = this.selectedDate) {\n      // persist the selected date value\n      let date = selectedDate instanceof Date ? new Date(selectedDate.getTime()) : new Date(selectedDate);\n      const minDate = this.minDate instanceof Date ? new Date(this.minDate.getTime()) : new Date(this.minDate);\n      const maxDate = this.maxDate instanceof Date ? new Date(this.maxDate.getTime()) : new Date(this.maxDate);\n      if (minDate <= maxDate) {\n        if (date < minDate) {\n          date = minDate;\n        }\n        if (date > maxDate) {\n          date = maxDate;\n        }\n        this.setProperties({\n          selectedDate: new Date('' + date),\n          minDate: new Date('' + minDate),\n          maxDate: new Date('' + maxDate)\n        }, true);\n        if (this.eventWindow) {\n          this.eventWindow.updateMinMaxDateToEditor();\n        }\n      } else {\n        throw Error('minDate should be equal or less than maxDate');\n      }\n    }\n    getViewIndex(viewName) {\n      for (let item = 0; item < this.viewCollections.length; item++) {\n        const checkIndex = this.viewCollections[item].option;\n        if (checkIndex === viewName) {\n          return item;\n        }\n      }\n      return -1;\n    }\n    setViewOptions(isModuleLoad = false) {\n      this.viewOptions = {};\n      this.viewCollections = [];\n      let viewName;\n      let selectedView;\n      const prevIndex = this.viewIndex;\n      let count = 0;\n      this.viewIndex = -1;\n      for (const view of this.views) {\n        const isOptions = typeof view === 'string' ? false : true;\n        if (typeof view === 'string') {\n          viewName = view;\n          if (this.currentView === viewName) {\n            selectedView = viewName;\n            this.viewIndex = count;\n          }\n        } else {\n          viewName = view.option;\n          if (view.isSelected) {\n            selectedView = viewName;\n            this.viewIndex = count;\n          }\n        }\n        const obj = extend({\n          option: viewName\n        }, isOptions ? view : {});\n        const fieldViewName = viewName.charAt(0).toLowerCase() + viewName.slice(1);\n        obj.cellHeaderTemplateName = obj.cellHeaderTemplate ? obj.option : '';\n        obj.dateHeaderTemplateName = obj.dateHeaderTemplate ? obj.option : '';\n        obj.cellTemplateName = obj.cellTemplate ? obj.option : '';\n        obj.dayHeaderTemplateName = obj.dayHeaderTemplate ? obj.option : '';\n        obj.monthHeaderTemplateName = obj.monthHeaderTemplate ? obj.option : '';\n        obj.resourceHeaderTemplateName = obj.resourceHeaderTemplate ? obj.option : '';\n        obj.headerIndentTemplateName = obj.headerIndentTemplate ? obj.option : '';\n        obj.eventTemplateName = obj.eventTemplate ? obj.option : '';\n        if (!isNullOrUndefined(obj.firstDayOfWeek) && obj.firstDayOfWeek === 0) {\n          delete obj.firstDayOfWeek;\n        }\n        if (!isNullOrUndefined(obj.interval) && obj.interval === 1) {\n          delete obj.interval;\n        }\n        this.viewCollections.push(obj);\n        if (isNullOrUndefined(this.viewOptions[fieldViewName])) {\n          this.viewOptions[fieldViewName] = [obj];\n        } else {\n          this.viewOptions[fieldViewName].push(obj);\n        }\n        count++;\n      }\n      if (!isModuleLoad && selectedView) {\n        this.setProperties({\n          currentView: selectedView\n        }, true);\n      }\n      if (this.viewIndex === -1) {\n        const currentIndex = this.getViewIndex(this.currentView);\n        this.viewIndex = typeof this.views[0] !== 'string' && !isNullOrUndefined(prevIndex) && prevIndex !== -1 ? prevIndex : currentIndex === -1 ? 0 : currentIndex;\n      }\n    }\n    getActiveViewOptions() {\n      const timeScale = {\n        enable: this.timeScale.enable,\n        interval: this.timeScale.interval,\n        slotCount: this.timeScale.slotCount,\n        majorSlotTemplate: this.timeScale.majorSlotTemplate,\n        minorSlotTemplate: this.timeScale.minorSlotTemplate\n      };\n      const isYearView = this.viewCollections[this.viewIndex].option.indexOf('Year') > -1;\n      const group = {\n        byDate: isYearView ? false : this.group.byDate,\n        byGroupID: this.group.byGroupID,\n        allowGroupEdit: this.group.allowGroupEdit,\n        resources: this.group.resources,\n        headerTooltipTemplate: this.group.headerTooltipTemplate,\n        enableCompactView: this.group.enableCompactView\n      };\n      const workDays = this.viewCollections[this.viewIndex].workDays ? [] : this.workDays;\n      const scheduleOptions = {\n        dateFormat: this.dateFormat,\n        endHour: this.endHour,\n        isSelected: false,\n        option: null,\n        readonly: this.readonly,\n        startHour: this.startHour,\n        allowVirtualScrolling: false,\n        cellHeaderTemplate: this.cellHeaderTemplate,\n        dayHeaderTemplate: this.dayHeaderTemplate,\n        monthHeaderTemplate: this.monthHeaderTemplate,\n        cellTemplate: this.cellTemplate,\n        eventTemplate: this.eventSettings.template,\n        dateHeaderTemplate: this.dateHeaderTemplate,\n        resourceHeaderTemplate: this.resourceHeaderTemplate,\n        headerIndentTemplate: this.headerIndentTemplate,\n        firstMonthOfYear: this.firstMonthOfYear,\n        firstDayOfWeek: this.firstDayOfWeek,\n        workDays: workDays,\n        monthsCount: this.monthsCount,\n        showWeekend: this.showWeekend,\n        showWeekNumber: this.showWeekNumber,\n        displayName: null,\n        interval: 1,\n        timeScale: timeScale,\n        timeFormat: this.internalTimeFormat,\n        group: group,\n        headerRows: this.headerRows,\n        orientation: 'Horizontal',\n        numberOfWeeks: 0,\n        displayDate: null\n      };\n      const viewOptions = this.viewCollections[this.viewIndex];\n      const viewsData = extend(scheduleOptions, viewOptions, undefined, true);\n      if (this.firstDayOfWeek !== 0 && viewOptions.firstDayOfWeek && this.firstDayOfWeek !== viewOptions.firstDayOfWeek) {\n        viewsData.firstDayOfWeek = this.firstDayOfWeek;\n      }\n      if (viewsData.displayDate) {\n        viewsData.displayDate = viewsData.displayDate instanceof Date ? new Date(viewsData.displayDate.getTime()) : new Date(viewsData.displayDate);\n      }\n      return viewsData;\n    }\n    initializeDataModule() {\n      this.eventFields = {\n        id: this.eventSettings.fields.id,\n        isBlock: this.eventSettings.fields.isBlock,\n        subject: this.eventSettings.fields.subject.name,\n        startTime: this.eventSettings.fields.startTime.name,\n        endTime: this.eventSettings.fields.endTime.name,\n        startTimezone: this.eventSettings.fields.startTimezone.name,\n        endTimezone: this.eventSettings.fields.endTimezone.name,\n        location: this.eventSettings.fields.location.name,\n        description: this.eventSettings.fields.description.name,\n        isAllDay: this.eventSettings.fields.isAllDay.name,\n        recurrenceID: this.eventSettings.fields.recurrenceID.name,\n        recurrenceRule: this.eventSettings.fields.recurrenceRule.name,\n        recurrenceException: this.eventSettings.fields.recurrenceException.name,\n        isReadonly: this.eventSettings.fields.isReadonly,\n        followingID: this.eventSettings.fields.followingID\n      };\n      this.setEditorTitles();\n      this.dataModule = new Data(this.eventSettings.dataSource, this.eventSettings.query);\n      this.crudModule = new Crud(this);\n    }\n    setEditorTitles() {\n      this.editorTitles = {\n        subject: this.eventSettings.fields.subject.title || this.localeObj.getConstant('title'),\n        startTime: this.eventSettings.fields.startTime.title || this.localeObj.getConstant('start'),\n        endTime: this.eventSettings.fields.endTime.title || this.localeObj.getConstant('end'),\n        isAllDay: this.eventSettings.fields.isAllDay.title || this.localeObj.getConstant('allDay'),\n        startTimezone: this.eventSettings.fields.startTimezone.title || this.localeObj.getConstant('startTimezone'),\n        endTimezone: this.eventSettings.fields.endTimezone.title || this.localeObj.getConstant('endTimezone'),\n        location: this.eventSettings.fields.location.title || this.localeObj.getConstant('location'),\n        description: this.eventSettings.fields.description.title || this.localeObj.getConstant('description'),\n        recurrenceRule: this.eventSettings.fields.recurrenceRule.title || this.localeObj.getConstant('repeat')\n      };\n    }\n    initializeView(viewName) {\n      this.showSpinner();\n      this.activeViewOptions = this.getActiveViewOptions();\n      if (this.resourceBase) {\n        this.resourceBase.setResourceCollection();\n      }\n      this.initializeTemplates();\n      this.renderModule.render(viewName);\n    }\n    initializeTemplates() {\n      this.cellHeaderTemplateFn = this.templateParser(this.activeViewOptions.cellHeaderTemplate);\n      this.dayHeaderTemplateFn = this.templateParser(this.activeViewOptions.dayHeaderTemplate);\n      this.monthHeaderTemplateFn = this.templateParser(this.activeViewOptions.monthHeaderTemplate);\n      this.cellTemplateFn = this.templateParser(this.activeViewOptions.cellTemplate);\n      this.dateHeaderTemplateFn = this.templateParser(this.activeViewOptions.dateHeaderTemplate);\n      this.majorSlotTemplateFn = this.templateParser(this.activeViewOptions.timeScale.majorSlotTemplate);\n      this.minorSlotTemplateFn = this.templateParser(this.activeViewOptions.timeScale.minorSlotTemplate);\n      this.appointmentTemplateFn = this.templateParser(this.activeViewOptions.eventTemplate);\n      this.resourceHeaderTemplateFn = this.templateParser(this.activeViewOptions.resourceHeaderTemplate);\n      this.headerIndentTemplateFn = this.templateParser(this.activeViewOptions.headerIndentTemplate);\n      this.headerTooltipTemplateFn = this.templateParser(this.activeViewOptions.group.headerTooltipTemplate);\n      this.eventTooltipTemplateFn = this.templateParser(this.eventSettings.tooltipTemplate);\n      this.editorTemplateFn = this.templateParser(this.editorTemplate);\n      this.quickInfoTemplatesHeaderFn = this.templateParser(this.quickInfoTemplates.header);\n      this.quickInfoTemplatesContentFn = this.templateParser(this.quickInfoTemplates.content);\n      this.quickInfoTemplatesFooterFn = this.templateParser(this.quickInfoTemplates.footer);\n    }\n    initializePopups() {\n      this.eventWindow = new EventWindow(this);\n      this.quickPopup = new QuickPopups(this);\n    }\n    /**\n     * Method to get day names\n     *\n     * @param {string} type Accepts the day name\n     * @returns {string[]} Returns the collection of day names\n     * @private\n     */\n    getDayNames(type) {\n      const culShortNames = [];\n      let cldrObj;\n      let nameSpace = '';\n      if (this.locale === 'en' || this.locale === 'en-US') {\n        nameSpace = 'days.stand-alone.';\n        cldrObj = getValue(nameSpace + type, getDefaultDateObject(this.getCalendarMode()));\n      } else {\n        nameSpace = 'main.' + '' + this.locale + '.dates.calendars.' + this.getCalendarMode() + '.days.format.' + type;\n        cldrObj = getValue(nameSpace, cldrData);\n      }\n      for (const obj of Object.keys(cldrObj)) {\n        culShortNames.push(getValue(obj, cldrObj));\n      }\n      return culShortNames;\n    }\n    setCldrTimeFormat() {\n      if (!isNullOrUndefined(this.timeFormat)) {\n        this.internalTimeFormat = this.timeFormat;\n        return;\n      }\n      if (this.locale === 'en' || this.locale === 'en-US') {\n        this.internalTimeFormat = getValue('timeFormats.short', getDefaultDateObject(this.getCalendarMode()));\n      } else {\n        this.internalTimeFormat = getValue('main.' + '' + this.locale + '.dates.calendars.' + this.getCalendarMode() + '.timeFormats.short', cldrData);\n      }\n    }\n    /**\n     * Method to get calendar mode\n     *\n     * @returns {string} Returns the calendar mode\n     * @private\n     */\n    getCalendarMode() {\n      return this.calendarMode.toLowerCase();\n    }\n    /**\n     * Method to get time in string\n     *\n     * @param {Date} date Accepts the date object\n     * @returns {string} Returns the time in string\n     * @private\n     */\n    getTimeString(date) {\n      const time = this.globalize.formatDate(date, {\n        format: this.activeViewOptions.timeFormat,\n        type: 'time',\n        calendar: this.getCalendarMode()\n      });\n      return time.toLocaleUpperCase();\n    }\n    /**\n     * Method to get  date object\n     *\n     * @param {Date} date Accepts the date object\n     * @returns {Date} Returns the date object\n     * @private\n     */\n    getDateTime(date) {\n      return date instanceof Date ? new Date(date.getTime()) : new Date(date);\n    }\n    setCalendarMode() {\n      if (this.calendarMode === 'Islamic') {\n        this.calendarUtil = new Islamic();\n      } else {\n        this.calendarUtil = new Gregorian();\n      }\n    }\n    /**\n     * Method to change the current view\n     *\n     * @param {View} view Accepts the view name\n     * @param {Event} event Accepts the event object\n     * @param {boolean} muteOnChange Accepts the value to enable or disable mute on change\n     * @param {number} index Accepts the index value\n     * @returns {void}\n     * @private\n     */\n    changeView(view, event, muteOnChange, index) {\n      if (isNullOrUndefined(index)) {\n        index = this.getViewIndex(view);\n      }\n      if (!muteOnChange && index === this.viewIndex && this.currentView === view || index < 0) {\n        return;\n      }\n      this.viewIndex = index;\n      let args = {\n        requestType: 'viewNavigate',\n        cancel: false,\n        event: event\n      };\n      this.trigger(actionBegin, args, actionArgs => {\n        if (!actionArgs.cancel) {\n          const navArgs = {\n            action: 'view',\n            cancel: false,\n            currentDate: this.selectedDate,\n            previousView: this.currentView,\n            currentView: view,\n            viewIndex: this.viewIndex\n          };\n          this.trigger(navigating, navArgs, navigationArgs => {\n            if (!navigationArgs.cancel) {\n              this.viewIndex = navigationArgs.viewIndex;\n              this.setProperties({\n                currentView: view\n              }, true);\n              if (this.headerModule) {\n                this.headerModule.updateActiveView();\n                this.headerModule.setCalendarDate(this.selectedDate);\n                this.headerModule.setCalendarView();\n              }\n              this.initializeView(this.currentView);\n              this.animateLayout();\n              args = {\n                requestType: 'viewNavigate',\n                cancel: false,\n                event: event\n              };\n              this.trigger(actionComplete, args);\n            }\n          });\n        }\n      });\n    }\n    /**\n     * Method to change the view date\n     *\n     * @param {Date} selectedDate Accepts the selected date\n     * @param {Event} event Accepts the event object\n     * @returns {void}\n     * @private\n     */\n    changeDate(selectedDate, event) {\n      let args = {\n        requestType: 'dateNavigate',\n        cancel: false,\n        event: event\n      };\n      this.trigger(actionBegin, args, actionArgs => {\n        if (!actionArgs.cancel) {\n          const navArgs = {\n            action: 'date',\n            cancel: false,\n            previousDate: this.selectedDate,\n            currentDate: selectedDate\n          };\n          this.trigger(navigating, navArgs, navigationArgs => {\n            if (!navigationArgs.cancel) {\n              this.uiStateValues.isInitial = this.activeView.isTimelineView() ? true : this.uiStateValues.isInitial;\n              this.validateDate(navigationArgs.currentDate);\n              if (this.headerModule) {\n                this.headerModule.setCalendarDate(navigationArgs.currentDate);\n              }\n              this.initializeView(this.currentView);\n              this.animateLayout();\n              args = {\n                requestType: 'dateNavigate',\n                cancel: false,\n                event: event\n              };\n              this.trigger(actionComplete, args);\n            }\n          });\n        }\n      });\n    }\n    /**\n     * Method to validate min and max date\n     *\n     * @param {Date} date Accepts the date object\n     * @returns {boolean} Returns the boolean result to validate the min and max date\n     * @private\n     */\n    isMinMaxDate(date = this.selectedDate) {\n      return date.getTime() >= this.minDate.getTime() && date.getTime() <= this.maxDate.getTime();\n    }\n    /**\n     * Method to validate the selected date\n     *\n     * @param {Date} date Accepts the date object\n     * @returns {boolean} Returns the boolean value for given date is selected date or not\n     * @private\n     */\n    isSelectedDate(date) {\n      return date.setHours(0, 0, 0, 0) === new Date('' + this.selectedDate).setHours(0, 0, 0, 0);\n    }\n    /**\n     * Method to get the current time\n     *\n     * @param {Date} date Accepts the date object\n     * @returns {Date} Returns the date object after performing the timezone conversion\n     * @private\n     */\n    getCurrentTime(date = new Date()) {\n      if (this.timezone) {\n        return this.tzModule.convert(date, this.tzModule.getLocalTimezoneName(), this.timezone);\n      }\n      return date;\n    }\n    /** Method to get navigate view\n     *\n     * @returns {View} Return the navigate view name\n     * @private\n     */\n    getNavigateView() {\n      if (this.activeView.isTimelineView()) {\n        return this.currentView === 'TimelineMonth' || this.currentView === 'TimelineYear' ? 'TimelineDay' : 'Agenda';\n      }\n      return 'Day';\n    }\n    animateLayout() {\n      if (!this.activeView.element) {\n        return;\n      }\n      new Animation({\n        duration: 600,\n        name: 'FadeIn',\n        timingFunction: 'easeIn'\n      }).animate(this.activeView.element);\n    }\n    /**\n     * To provide the array of modules needed for control rendering\n     *\n     * @returns {ModuleDeclaration[]} Returns the declared modules\n     * @private\n     */\n    requiredModules() {\n      const modules = [];\n      this.setViewOptions(true);\n      for (let view of Object.keys(this.viewOptions)) {\n        view = view === 'timelineDay' || view === 'timelineWeek' || view === 'timelineWorkWeek' ? 'timelineViews' : view;\n        modules.push({\n          member: view,\n          args: [this]\n        });\n      }\n      if (this.allowDragAndDrop) {\n        modules.push({\n          member: 'dragAndDrop',\n          args: [this]\n        });\n      }\n      if (this.allowResizing) {\n        modules.push({\n          member: 'resize',\n          args: [this]\n        });\n      }\n      modules.push({\n        member: 'excelExport',\n        args: [this]\n      });\n      modules.push({\n        member: 'iCalendarExport',\n        args: [this]\n      });\n      modules.push({\n        member: 'iCalendarImport',\n        args: [this]\n      });\n      modules.push({\n        member: 'print',\n        args: [this]\n      });\n      return modules;\n    }\n    /**\n     * Initializes the values of private members.\n     *\n     * @returns {void}\n     * @private\n     */\n    preRender() {\n      this.isAdaptive = Browser.isDevice || isIPadDevice();\n      this.globalize = new Internationalization(this.locale);\n      this.tzModule = new Timezone();\n      if (this && isNullOrUndefined(this.uiStateValues) || !this.enablePersistence) {\n        this.uiStateValues = {\n          expand: false,\n          isInitial: true,\n          left: 0,\n          top: 0,\n          isGroupAdaptive: false,\n          isIgnoreOccurrence: false,\n          groupIndex: 0,\n          action: false,\n          isBlock: false,\n          isCustomMonth: true,\n          isResize: false\n        };\n      }\n      this.activeCellsData = {\n        startTime: this.getCurrentTime(),\n        endTime: this.getCurrentTime(),\n        isAllDay: false\n      };\n      this.activeEventData = {\n        event: undefined,\n        element: undefined\n      };\n      this.getDefaultLocale();\n      this.localeObj = new L10n(this.getModuleName(), this.defaultLocale, this.locale);\n      this.setCldrTimeFormat();\n      this.setCalendarMode();\n      this.eventsData = [];\n      this.eventsProcessed = [];\n      this.blockData = [];\n      this.blockProcessed = [];\n      this.resourceCollection = [];\n      this.currentAction = null;\n      this.selectedElements = [];\n      this.setViewOptions();\n    }\n    getDefaultLocale() {\n      this.defaultLocale = {\n        day: 'Day',\n        week: 'Week',\n        workWeek: 'Work Week',\n        month: 'Month',\n        year: 'Year',\n        agenda: 'Agenda',\n        weekAgenda: 'Week Agenda',\n        workWeekAgenda: 'Work Week Agenda',\n        monthAgenda: 'Month Agenda',\n        today: 'Today',\n        noEvents: 'No events',\n        emptyContainer: 'There are no events scheduled on this day.',\n        allDay: 'All day',\n        start: 'Start',\n        end: 'End',\n        more: 'more',\n        close: 'Close',\n        cancel: 'Cancel',\n        noTitle: '(No Title)',\n        delete: 'Delete',\n        deleteEvent: 'Delete Event',\n        deleteMultipleEvent: 'Delete Multiple Events',\n        selectedItems: 'Items selected',\n        deleteSeries: 'Entire Series',\n        edit: 'Edit',\n        editSeries: 'Entire Series',\n        editEvent: 'Edit Event',\n        createEvent: 'Create',\n        subject: 'Subject',\n        addTitle: 'Add title',\n        moreDetails: 'More Details',\n        save: 'Save',\n        editContent: 'How would you like to change the appointment in the series?',\n        deleteContent: 'Are you sure you want to delete this event?',\n        deleteMultipleContent: 'Are you sure you want to delete the selected events?',\n        newEvent: 'New Event',\n        title: 'Title',\n        location: 'Location',\n        description: 'Description',\n        timezone: 'Timezone',\n        startTimezone: 'Start Timezone',\n        endTimezone: 'End Timezone',\n        repeat: 'Repeat',\n        saveButton: 'Save',\n        cancelButton: 'Cancel',\n        deleteButton: 'Delete',\n        recurrence: 'Recurrence',\n        wrongPattern: 'The recurrence pattern is not valid.',\n        seriesChangeAlert: 'Do you want to cancel the changes made to specific ' + 'instances of this series and match it to the whole series again?',\n        createError: 'The duration of the event must be shorter than how frequently it occurs. ' + 'Shorten the duration, or change the recurrence pattern in the recurrence event editor.',\n        sameDayAlert: 'Two occurrences of the same event cannot occur on the same day.',\n        occurenceAlert: 'Cannot reschedule an occurrence of the recurring appointment if it skips over ' + 'a later occurrence of the same appointment.',\n        editRecurrence: 'Edit Recurrence',\n        repeats: 'Repeats',\n        alert: 'Alert',\n        startEndError: 'The selected end date occurs before the start date.',\n        invalidDateError: 'The entered date value is invalid.',\n        blockAlert: 'Events cannot be scheduled within the blocked time range.',\n        ok: 'Ok',\n        yes: 'Yes',\n        no: 'No',\n        occurrence: 'Occurrence',\n        series: 'Series',\n        previous: 'Previous',\n        next: 'Next',\n        timelineDay: 'Timeline Day',\n        timelineWeek: 'Timeline Week',\n        timelineWorkWeek: 'Timeline Work Week',\n        timelineMonth: 'Timeline Month',\n        timelineYear: 'Timeline Year',\n        editFollowingEvent: 'Following Events',\n        deleteTitle: 'Delete Event',\n        editTitle: 'Edit Event',\n        beginFrom: 'Begin From',\n        endAt: 'Ends At',\n        expandAllDaySection: 'Expand-all-day-section',\n        collapseAllDaySection: 'Collapse-all-day-section',\n        searchTimezone: 'Search Timezone',\n        noRecords: 'No records found'\n      };\n    }\n    wireEvents() {\n      EventHandler.add(window, 'resize', this.onScheduleResize, this);\n      EventHandler.add(window, 'orientationchange', this.onScheduleResize, this);\n      EventHandler.add(document, Browser.touchStartEvent, this.onDocumentClick, this);\n    }\n    /**\n     * Method to remove selected class\n     *\n     * @returns {void}\n     * @private\n     */\n    removeSelectedClass() {\n      const selectedCells = this.getSelectedElements();\n      for (const cell of selectedCells) {\n        cell.setAttribute('aria-selected', 'false');\n        cell.removeAttribute('tabindex');\n      }\n      removeClass(selectedCells, SELECTED_CELL_CLASS);\n    }\n    /**\n     * Method to add selected class\n     *\n     * @param {HTMLTableCellElement[]} cells Accepts the collection of elements\n     * @param {HTMLTableCellElement} focusCell Accepts the focus element\n     * @param {boolean} isPreventScroll Accepts the boolean value to prevent scroll\n     * @returns {void}\n     * @private\n     */\n    addSelectedClass(cells, focusCell, isPreventScroll) {\n      for (const cell of cells) {\n        cell.setAttribute('aria-selected', 'true');\n      }\n      addClass(cells, SELECTED_CELL_CLASS);\n      if (focusCell) {\n        focusCell.setAttribute('tabindex', '0');\n        focusCell.focus({\n          preventScroll: isPreventScroll || false\n        });\n      }\n    }\n    /**\n     * Method to select cell\n     *\n     * @param {HTMLElement | HTMLTableCellElement} element Accepts the select element\n     * @returns {void}\n     * @private\n     */\n    selectCell(element) {\n      this.removeSelectedClass();\n      this.addSelectedClass([element], element);\n    }\n    /**\n     * Method to get all day row element\n     *\n     * @returns {Element} Returns the all day row element\n     * @private\n     */\n    getAllDayRow() {\n      return this.element.querySelector('.' + ALLDAY_ROW_CLASS);\n    }\n    /**\n     * Method to get content table element\n     *\n     * @returns {HTMLElement} Returns the content table element\n     * @private\n     */\n    getContentTable() {\n      return this.activeView.element.querySelector('.' + CONTENT_TABLE_CLASS + ' tbody');\n    }\n    /**\n     * Method to get all content table rows\n     *\n     * @returns {HTMLElement[]} Returns the content table rows\n     * @private\n     */\n    getTableRows() {\n      return [].slice.call(this.element.querySelectorAll('.' + CONTENT_TABLE_CLASS + ' tbody tr:not(.' + HIDDEN_CLASS + ')'));\n    }\n    /**\n     * Method to get work cell elements\n     *\n     * @returns {Element[]} Returns the all work cell elements\n     * @private\n     */\n    getWorkCellElements() {\n      return [].slice.call(this.element.querySelectorAll('.' + WORK_CELLS_CLASS));\n    }\n    /**\n     * Method to get the index from date collection\n     *\n     * @param {Date[]} collection Accepts the collections of date\n     * @param {Date} date Accepts the date object\n     * @returns {number} Returns the index compared date with date collections\n     * @private\n     */\n    getIndexOfDate(collection, date) {\n      return collection.map(Number).indexOf(+date);\n    }\n    /**\n     * Method to find all day cell\n     *\n     * @param {Element} td Accepts the DOM Element\n     * @returns {boolean} Returns the boolean value\n     * @private\n     */\n    isAllDayCell(td) {\n      if (['Month', 'TimelineMonth', 'TimelineYear', 'MonthAgenda'].indexOf(this.currentView) > -1 || td.classList.contains(ALLDAY_CELLS_CLASS) || td.classList.contains(HEADER_CELLS_CLASS) || !this.activeViewOptions.timeScale.enable) {\n        return true;\n      }\n      if (this.activeView.isTimelineView() && this.activeViewOptions.headerRows.length > 0 && this.activeViewOptions.headerRows.slice(-1)[0].option !== 'Hour') {\n        return true;\n      }\n      return false;\n    }\n    /**\n     * Method to get date from element\n     *\n     * @param {Element} td Accepts the DOM element\n     * @returns {Date} Returns the date object\n     * @private\n     */\n    getDateFromElement(td) {\n      let dateString;\n      if (!isNullOrUndefined(td)) {\n        dateString = td.getAttribute('data-date');\n      }\n      if (!isNullOrUndefined(dateString)) {\n        const dateInMS = parseInt(dateString, 10);\n        const date = new Date(dateInMS);\n        return date;\n      }\n      return undefined;\n    }\n    /**\n     * Method to get target element from given selector\n     *\n     * @param {string} selector Accepts the element selector\n     * @param {number} left Accepts the pageX value\n     * @param {number} top Accepts the pageY value\n     * @returns {Element[]} Returns the collection of elements based on the given selector\n     * @private\n     */\n    getTargetElement(selector, left, top) {\n      const element = document.elementFromPoint(left, top);\n      let targetElement;\n      if (element) {\n        targetElement = element.closest(selector);\n      }\n      return targetElement ? [targetElement] : null;\n    }\n    /**\n     * Method to process cell header template\n     *\n     * @returns {CallbackFunction} Returns the callback function\n     * @private\n     */\n    getCellHeaderTemplate() {\n      return this.cellHeaderTemplateFn;\n    }\n    /**\n     * Method to process cell header template in year view.\n     *\n     * @returns {CallbackFunction} Returns the callback function\n     * @private\n     */\n    getDayHeaderTemplate() {\n      return this.dayHeaderTemplateFn;\n    }\n    /**\n     * Method to process cell header template in year view.\n     *\n     * @returns {CallbackFunction} Returns the callback function\n     * @private\n     */\n    getMonthHeaderTemplate() {\n      return this.monthHeaderTemplateFn;\n    }\n    /**\n     * Method to process cell template\n     *\n     * @returns {CallbackFunction} Returns the callback function\n     * @private\n     */\n    getCellTemplate() {\n      return this.cellTemplateFn;\n    }\n    /**\n     * Method to process date header template\n     *\n     * @returns {CallbackFunction} Returns the callback function\n     * @private\n     */\n    getDateHeaderTemplate() {\n      return this.dateHeaderTemplateFn;\n    }\n    /**\n     * Method to process major slot template\n     *\n     * @returns {CallbackFunction} Returns the callback function\n     * @private\n     */\n    getMajorSlotTemplate() {\n      return this.majorSlotTemplateFn;\n    }\n    /**\n     * Method to process minor slot template\n     *\n     * @returns {CallbackFunction} Returns the callback function\n     * @private\n     */\n    getMinorSlotTemplate() {\n      return this.minorSlotTemplateFn;\n    }\n    /**\n     * Method to process appointment template\n     *\n     * @returns {CallbackFunction} Returns the callback function\n     * @private\n     */\n    getAppointmentTemplate() {\n      return this.appointmentTemplateFn;\n    }\n    /**\n     * Method to process appointment tooltip template\n     *\n     * @returns {CallbackFunction} Returns the callback function\n     * @private\n     */\n    getEventTooltipTemplate() {\n      return this.eventTooltipTemplateFn;\n    }\n    /**\n     * Method to process header tooltip template\n     *\n     * @returns {CallbackFunction} Returns the callback function\n     * @private\n     */\n    getHeaderTooltipTemplate() {\n      return this.headerTooltipTemplateFn;\n    }\n    /**\n     * Method to process editor template\n     *\n     * @returns {CallbackFunction} Returns the callback function\n     * @private\n     */\n    getEditorTemplate() {\n      return this.editorTemplateFn;\n    }\n    /**\n     * Method to process quick info header template\n     *\n     * @returns {CallbackFunction} Returns the callback function\n     * @private\n     */\n    getQuickInfoTemplatesHeader() {\n      return this.quickInfoTemplatesHeaderFn;\n    }\n    /**\n     * Method to process quick info content template\n     *\n     * @returns {CallbackFunction} Returns the callback function\n     * @private\n     */\n    getQuickInfoTemplatesContent() {\n      return this.quickInfoTemplatesContentFn;\n    }\n    /**\n     * Method to process quick info footer template\n     *\n     * @returns {CallbackFunction} Returns the callback function\n     * @private\n     */\n    getQuickInfoTemplatesFooter() {\n      return this.quickInfoTemplatesFooterFn;\n    }\n    /**\n     * Method to process resource header template\n     *\n     * @returns {CallbackFunction} Returns the callback function\n     * @private\n     */\n    getResourceHeaderTemplate() {\n      return this.resourceHeaderTemplateFn;\n    }\n    /**\n     * Method to process indent template\n     *\n     * @returns {CallbackFunction} Returns the callback function\n     * @private\n     */\n    getHeaderIndentTemplate() {\n      return this.headerIndentTemplateFn;\n    }\n    /**\n     * Method to get dynamic CSS properties\n     *\n     * @returns {ScrollCss} Returns the CSS properties dynamically\n     * @private\n     */\n    getCssProperties() {\n      const cssProps = {\n        border: this.enableRtl ? 'borderLeftWidth' : 'borderRightWidth',\n        padding: this.enableRtl ? 'paddingLeft' : 'paddingRight',\n        rtlBorder: this.enableRtl ? 'borderRightWidth' : 'borderLeftWidth',\n        rtlPadding: this.enableRtl ? 'paddingRight' : 'paddingLeft'\n      };\n      return cssProps;\n    }\n    /**\n     * Method to remove new event element in adaptive mode\n     *\n     * @returns {void}\n     * @private\n     */\n    removeNewEventElement() {\n      const eventClone = this.element.querySelector('.' + NEW_EVENT_CLASS);\n      if (!isNullOrUndefined(eventClone)) {\n        remove(eventClone);\n      }\n    }\n    /**\n     * Method to get start end time from string\n     *\n     * @param {string} startEndTime Accepts the start end time string value\n     * @returns {Date} Returns the date object\n     * @private\n     */\n    getStartEndTime(startEndTime) {\n      if (!isNullOrUndefined(startEndTime) && startEndTime !== '') {\n        const startEndDate = resetTime(this.getCurrentTime());\n        const timeString = startEndTime.split(':');\n        if (timeString.length === 2) {\n          startEndDate.setHours(parseInt(timeString[0], 10), parseInt(timeString[1], 10), 0);\n        }\n        return startEndDate;\n      }\n      return null;\n    }\n    onDocumentClick(args) {\n      this.notify(documentClick, {\n        event: args\n      });\n    }\n    onScheduleResize() {\n      if (isNullOrUndefined(this.activeView) || (this.isAdaptive || isMobile()) && document.activeElement && document.activeElement.classList.contains(SUBJECT_CLASS)) {\n        return;\n      }\n      if (this.activeViewOptions.timeScale.enable && this.activeView) {\n        this.activeView.highlightCurrentTime();\n      }\n      if (this.quickPopup) {\n        this.quickPopup.onClosePopup();\n      }\n      if (this.currentView === 'Month' || this.currentView !== 'Agenda' && this.currentView !== 'MonthAgenda' && !this.activeViewOptions.timeScale.enable || this.activeView.isTimelineView()) {\n        this.uiStateValues.isResize = true;\n        this.activeView.resetColWidth();\n        this.notify(scrollUiUpdate, {\n          cssProperties: this.getCssProperties(),\n          isPreventScrollUpdate: true\n        });\n        this.refreshEvents(false);\n        this.uiStateValues.isResize = false;\n      } else {\n        this.notify(contentReady, {});\n      }\n    }\n    /**\n     * Method to process the templates\n     *\n     * @param {string} template Accepts the template in string\n     * @returns {CallbackFunction} Returns the callback function\n     * @private\n     */\n    templateParser(template) {\n      if (template) {\n        try {\n          if (document.querySelectorAll(template).length) {\n            return compile(document.querySelector(template).innerHTML.trim());\n          }\n        } catch (error) {\n          return compile(template);\n        }\n      }\n      return undefined;\n    }\n    /**\n     * Method to generate the announcement string\n     *\n     * @param {Object} event Accepts the event object\n     * @param {string} subject Accepts the subject text\n     * @returns {string} Returns the announcement string\n     * @private\n     */\n    getAnnouncementString(event, subject) {\n      let resourceName;\n      if (this.quickPopup && this.activeViewOptions.group.resources.length > 0) {\n        const constantText = '\"s event - ';\n        resourceName = this.quickPopup.getResourceText({\n          event: event\n        }, 'event') + constantText;\n      }\n      const recordSubject = subject || event[this.eventFields.subject] || this.eventSettings.fields.subject.default;\n      const skeleton = 'full';\n      const startDateText = this.globalize.formatDate(event[this.eventFields.startTime], {\n        type: 'dateTime',\n        skeleton: skeleton,\n        calendar: this.getCalendarMode()\n      });\n      const endDateText = this.globalize.formatDate(event[this.eventFields.endTime], {\n        type: 'dateTime',\n        skeleton: skeleton,\n        calendar: this.getCalendarMode()\n      });\n      let announcementString = recordSubject + ' ' + this.localeObj.getConstant('beginFrom') + ' ' + startDateText + ' ' + this.localeObj.getConstant('endAt') + ' ' + endDateText;\n      if (resourceName) {\n        announcementString = resourceName + ' ' + announcementString;\n      }\n      return announcementString;\n    }\n    /**\n     * Method to process the element boundary validation\n     *\n     * @param {number} pageY Accepts the pageY value\n     * @param {number} pageX Accepts the pageX value\n     * @returns {ResizeEdges} Returns the boundary validation object\n     * @private\n     */\n    boundaryValidation(pageY, pageX) {\n      const autoScrollDistance = 30;\n      const scrollEdges = {\n        left: false,\n        right: false,\n        top: false,\n        bottom: false\n      };\n      const viewBoundaries = this.element.querySelector('.' + CONTENT_WRAP_CLASS).getBoundingClientRect();\n      if (pageY < viewBoundaries.top + autoScrollDistance + window.pageYOffset && pageY > viewBoundaries.top + window.pageYOffset) {\n        scrollEdges.top = true;\n      }\n      if (pageY > viewBoundaries.bottom - autoScrollDistance + window.pageYOffset && pageY < viewBoundaries.bottom + window.pageYOffset) {\n        scrollEdges.bottom = true;\n      }\n      if (pageX < viewBoundaries.left + autoScrollDistance + window.pageXOffset && pageX > viewBoundaries.left + window.pageXOffset) {\n        scrollEdges.left = true;\n      }\n      if (pageX > viewBoundaries.right - autoScrollDistance + window.pageXOffset && pageX < viewBoundaries.right + window.pageXOffset) {\n        scrollEdges.right = true;\n      }\n      return scrollEdges;\n    }\n    /**\n     * Method to get the week number.\n     *\n     * @param {Date[]} dates Accepts the date collections\n     * @returns {number} Returns the week number\n     * @private\n     */\n    getWeekNumberContent(dates) {\n      let weekNumber;\n      if (this.weekRule === 'FirstDay') {\n        const weekNumberDate = getWeekLastDate(dates.slice(-1)[0], this.firstDayOfWeek);\n        weekNumber = this.globalize.formatNumber(getWeekNumber(weekNumberDate));\n      } else if (this.weekRule === 'FirstFourDayWeek') {\n        const weekFirstDate = getWeekFirstDate(dates.slice(-1)[0], this.firstDayOfWeek);\n        const weekLastDate = getWeekLastDate(dates.slice(-1)[0], this.firstDayOfWeek);\n        const weekMidDate = getWeekMiddleDate(weekFirstDate, weekLastDate);\n        weekNumber = this.globalize.formatNumber(getWeekNumber(weekMidDate));\n      } else if (this.weekRule === 'FirstFullWeek') {\n        const weekFirstDate = getWeekFirstDate(dates.slice(-1)[0], this.firstDayOfWeek);\n        weekNumber = this.globalize.formatNumber(getWeekNumber(weekFirstDate));\n      }\n      return weekNumber;\n    }\n    /**\n     * Method to render the header indent template.\n     *\n     * @param {TdData} data Accepts the td data\n     * @param {Element} td Accepts the td element\n     * @returns {void}\n     * @private\n     */\n    renderHeaderIndentTemplate(data, td) {\n      if (this.activeViewOptions.headerIndentTemplate) {\n        const scheduleId = this.element.id + '_';\n        const viewName = this.activeViewOptions.headerIndentTemplateName;\n        const templateId = scheduleId + viewName + 'headerIndentTemplate';\n        const indentTemplate = [].slice.call(this.getHeaderIndentTemplate()(data, this, 'headerIndentTemplate', templateId, false));\n        append(indentTemplate, td);\n      }\n    }\n    unWireEvents() {\n      EventHandler.remove(window, 'resize', this.onScheduleResize);\n      EventHandler.remove(window, 'orientationchange', this.onScheduleResize);\n      EventHandler.remove(document, Browser.touchStartEvent, this.onDocumentClick);\n    }\n    /**\n     * Core method to return the component name.\n     *\n     * @returns {string} Returns the module name\n     * @private\n     */\n    getModuleName() {\n      return 'schedule';\n    }\n    /**\n     * Returns the properties to be maintained in the persisted state.\n     *\n     * @returns {string} Returns the persistance data\n     * @private\n     */\n    getPersistData() {\n      return this.addOnPersist(['currentView', 'selectedDate', 'scrollTop', 'scrollLeft']);\n    }\n    /**\n     * Called internally, if any of the property value changed.\n     *\n     * @returns {void}\n     * @private\n     */\n    onPropertyChanged(newProp, oldProp) {\n      if (this.isReact && isNullOrUndefined(this.activeView)) {\n        return;\n      }\n      const state = {\n        isRefresh: false,\n        isResource: false,\n        isDate: false,\n        isView: false,\n        isLayout: false,\n        isDataManager: false\n      };\n      for (const prop of Object.keys(newProp)) {\n        switch (prop) {\n          case 'views':\n            this.setViewOptions();\n            if (this.headerModule) {\n              this.headerModule.updateItems();\n            }\n            state.isView = true;\n            break;\n          case 'currentView':\n            state.isView = true;\n            break;\n          case 'minDate':\n          case 'maxDate':\n          case 'selectedDate':\n            state.isDate = true;\n            break;\n          case 'dateFormat':\n            this.activeViewOptions = this.getActiveViewOptions();\n            if (this.headerModule) {\n              this.headerModule.updateDateRange(this.activeView.getDateRangeText());\n            }\n            break;\n          case 'showHeaderBar':\n            this.destroyHeaderModule();\n            if (newProp.showHeaderBar) {\n              this.headerModule = new HeaderRenderer(this);\n              this.headerModule.updateDateRange(this.activeView.getDateRangeText());\n            }\n            this.notify(scrollUiUpdate, {\n              cssProperties: this.getCssProperties()\n            });\n            if (this.activeView.isTimelineView()) {\n              this.refreshEvents(false);\n            }\n            break;\n          case 'showWeekend':\n          case 'workDays':\n          case 'startHour':\n          case 'endHour':\n          case 'workHours':\n          case 'readonly':\n          case 'headerRows':\n          case 'showWeekNumber':\n          case 'rowAutoHeight':\n            state.isLayout = true;\n            break;\n          case 'locale':\n          case 'calendarMode':\n            this.globalize = new Internationalization(this.locale);\n            this.localeObj = new L10n(this.getModuleName(), this.defaultLocale, this.locale);\n            this.setCldrTimeFormat();\n            this.setCalendarMode();\n            state.isRefresh = true;\n            break;\n          case 'firstDayOfWeek':\n            this.activeViewOptions.firstDayOfWeek = newProp.firstDayOfWeek;\n            if (this.eventWindow) {\n              this.eventWindow.refreshRecurrenceEditor();\n            }\n            state.isLayout = true;\n            break;\n          case 'showTimeIndicator':\n            if (this.activeViewOptions.timeScale.enable && this.activeView) {\n              this.activeView.highlightCurrentTime();\n            }\n            break;\n          case 'cellHeaderTemplate':\n            this.activeViewOptions.cellHeaderTemplate = newProp.cellHeaderTemplate;\n            this.cellHeaderTemplateFn = this.templateParser(this.activeViewOptions.cellHeaderTemplate);\n            state.isLayout = true;\n            break;\n          case 'cellTemplate':\n            this.activeViewOptions.cellTemplate = newProp.cellTemplate;\n            this.cellTemplateFn = this.templateParser(this.activeViewOptions.cellTemplate);\n            state.isLayout = true;\n            break;\n          case 'dateHeaderTemplate':\n            this.activeViewOptions.dateHeaderTemplate = newProp.dateHeaderTemplate;\n            this.dateHeaderTemplateFn = this.templateParser(this.activeViewOptions.dateHeaderTemplate);\n            state.isLayout = true;\n            break;\n          case 'dayHeaderTemplate':\n            this.activeViewOptions.dayHeaderTemplate = newProp.dayHeaderTemplate;\n            this.dayHeaderTemplateFn = this.templateParser(this.activeViewOptions.dayHeaderTemplate);\n            state.isLayout = true;\n            break;\n          case 'monthHeaderTemplate':\n            this.activeViewOptions.monthHeaderTemplate = newProp.monthHeaderTemplate;\n            this.monthHeaderTemplateFn = this.templateParser(this.activeViewOptions.monthHeaderTemplate);\n            state.isLayout = true;\n            break;\n          case 'resourceHeaderTemplate':\n            this.activeViewOptions.resourceHeaderTemplate = newProp.resourceHeaderTemplate;\n            this.resourceHeaderTemplateFn = this.templateParser(this.activeViewOptions.resourceHeaderTemplate);\n            state.isLayout = true;\n            break;\n          case 'timezone':\n            this.eventBase.timezonePropertyChange(oldProp.timezone);\n            this.headerModule.setCalendarTimezone();\n            break;\n          case 'enableRtl':\n            this.setRtlClass();\n            state.isRefresh = true;\n            break;\n          default:\n            this.extendedPropertyChange(prop, newProp, oldProp, state);\n            break;\n        }\n      }\n      this.propertyChangeAction(state);\n    }\n    propertyChangeAction(state) {\n      if (state.isRefresh) {\n        this.refresh();\n      } else if (state.isResource) {\n        this.initializeResources(true);\n      } else if (state.isView) {\n        this.changeView(this.currentView, null, true);\n      } else if (state.isDate) {\n        this.changeDate(this.selectedDate);\n      } else if (state.isLayout) {\n        this.initializeView(this.currentView);\n      } else if (state.isDataManager && this.crudModule) {\n        if (this.dragAndDropModule) {\n          this.dragAndDropModule.actionObj.action = '';\n          removeClass([this.element], EVENT_ACTION_CLASS);\n        }\n        this.crudModule.refreshDataManager();\n      }\n    }\n    allDayRowScrollUpdate() {\n      const dateHeader = this.element.querySelector('.' + DATE_HEADER_WRAP_CLASS);\n      const allDayRow = this.element.querySelector('.' + ALLDAY_ROW_CLASS);\n      if (this.height === 'auto' || !this.enableAllDayScroll) {\n        addClass([dateHeader], ALLDAY_APPOINTMENT_AUTO);\n        if (dateHeader.classList.contains(ALLDAY_APPOINTMENT_SCROLL)) {\n          removeClass([dateHeader], ALLDAY_APPOINTMENT_SCROLL);\n        }\n        if (this.uiStateValues.expand) {\n          const allDayCells = [].slice.call(this.element.querySelectorAll('.' + ALLDAY_CELLS_CLASS));\n          allDayCells[0].style.height = allDayRow.style.height ? allDayRow.style.height : allDayCells[1].style.height;\n        }\n      } else {\n        if (dateHeader.classList.contains(ALLDAY_APPOINTMENT_AUTO)) {\n          removeClass([dateHeader], ALLDAY_APPOINTMENT_AUTO);\n        }\n        this.eventBase.allDayExpandScroll(dateHeader);\n      }\n      if (!this.uiStateValues.expand) {\n        allDayRow.style.height = '';\n      }\n    }\n    extendedPropertyChange(prop, newProp, oldProp, state) {\n      switch (prop) {\n        case 'width':\n        case 'height':\n        case 'enableAllDayScroll':\n          if (['Day', 'Week', 'WorkWeek'].indexOf(this.currentView) > -1) {\n            this.allDayRowScrollUpdate();\n          }\n          this.notify(uiUpdate, {\n            module: 'scroll',\n            properties: {\n              width: newProp.width,\n              height: newProp.height\n            }\n          });\n          break;\n        case 'cssClass':\n          if (oldProp.cssClass) {\n            removeClass([this.element], oldProp.cssClass.split(' '));\n          }\n          if (newProp.cssClass) {\n            addClass([this.element], newProp.cssClass.split(' '));\n          }\n          break;\n        case 'hideEmptyAgendaDays':\n        case 'agendaDaysCount':\n          this.activeViewOptions = this.getActiveViewOptions();\n          state.isView = true;\n          break;\n        case 'eventSettings':\n          this.onEventSettingsPropertyChanged(newProp.eventSettings, oldProp.eventSettings, state);\n          break;\n        case 'allowKeyboardInteraction':\n          if (this.keyboardInteractionModule) {\n            this.keyboardInteractionModule.destroy();\n            this.keyboardInteractionModule = null;\n          }\n          if (newProp.allowKeyboardInteraction) {\n            this.keyboardInteractionModule = new KeyboardInteraction(this);\n          }\n          break;\n        case 'timezoneDataSource':\n          if (this.eventWindow) {\n            this.eventWindow.refresh();\n          }\n          break;\n        case 'editorTemplate':\n          if (!isNullOrUndefined(this.editorTemplate)) {\n            this.editorTemplateFn = this.templateParser(this.editorTemplate);\n          }\n          if (this.eventWindow) {\n            this.eventWindow.setDialogContent();\n          }\n          break;\n        case 'quickInfoTemplates':\n          if (this.quickInfoTemplates.header) {\n            this.quickInfoTemplatesHeaderFn = this.templateParser(this.quickInfoTemplates.header);\n          }\n          if (this.quickInfoTemplates.content) {\n            this.quickInfoTemplatesContentFn = this.templateParser(this.quickInfoTemplates.content);\n          }\n          if (this.quickInfoTemplates.footer) {\n            this.quickInfoTemplatesFooterFn = this.templateParser(this.quickInfoTemplates.footer);\n          }\n          break;\n        case 'group':\n          this.onGroupSettingsPropertyChanged(newProp.group, oldProp.group, state);\n          break;\n        case 'resources':\n          state.isResource = true;\n          break;\n        case 'timeScale':\n          this.activeViewOptions.timeScale.interval = newProp.timeScale.interval || this.activeViewOptions.timeScale.interval;\n          this.activeViewOptions.timeScale.slotCount = newProp.timeScale.slotCount || this.activeViewOptions.timeScale.slotCount;\n          if (this.eventWindow) {\n            this.eventWindow.refreshDateTimePicker();\n          }\n          state.isLayout = true;\n          break;\n        case 'allowDragAndDrop':\n        case 'allowResizing':\n        case 'eventDragArea':\n          this.refreshEvents(false);\n          break;\n        case 'weekRule':\n          state.isLayout = true;\n          break;\n        case 'firstMonthOfYear':\n          this.activeViewOptions.firstMonthOfYear = newProp.firstMonthOfYear;\n          this.viewIndex = this.activeView.viewIndex;\n          state.isLayout = true;\n          break;\n        case 'monthsCount':\n          this.activeViewOptions.monthsCount = newProp.monthsCount;\n          this.viewIndex = this.activeView.viewIndex;\n          state.isLayout = true;\n          break;\n        case 'timeFormat':\n          this.internalTimeFormat = newProp.timeFormat || this.activeViewOptions.timeFormat;\n          if (this.eventWindow) {\n            this.eventWindow.refreshDateTimePicker();\n          }\n          state.isLayout = true;\n          break;\n        case 'enableAdaptiveUI':\n          if (this.showHeaderBar && this.headerModule) {\n            this.destroyHeaderModule();\n            this.headerModule = new HeaderRenderer(this);\n            this.headerModule.updateDateRange(this.activeView.getDateRangeText());\n          }\n          state.isLayout = true;\n          break;\n        case 'headerIndentTemplate':\n          this.activeViewOptions.headerIndentTemplate = newProp.headerIndentTemplate;\n          this.headerIndentTemplateFn = this.templateParser(this.activeViewOptions.headerIndentTemplate);\n          state.isLayout = true;\n          break;\n      }\n    }\n    setRtlClass() {\n      if (this.enableRtl) {\n        addClass([this.element], 'e-rtl');\n      } else {\n        removeClass([this.element], 'e-rtl');\n      }\n    }\n    onGroupSettingsPropertyChanged(newProp, oldProp, state) {\n      for (const prop of Object.keys(newProp)) {\n        if (prop === 'headerTooltipTemplate') {\n          this.headerTooltipTemplateFn = this.templateParser(newProp[prop]);\n        } else {\n          state.isLayout = true;\n          if (this.eventWindow) {\n            this.eventWindow.refresh();\n          }\n        }\n      }\n    }\n    onEventSettingsPropertyChanged(newProp, oldProp, state) {\n      for (const prop of Object.keys(newProp)) {\n        switch (prop) {\n          case 'dataSource':\n          case 'query':\n          case 'fields':\n            this.initializeDataModule();\n            state.isDataManager = true;\n            break;\n          case 'template':\n            this.activeViewOptions.eventTemplate = newProp.template;\n            this.appointmentTemplateFn = this.templateParser(this.activeViewOptions.eventTemplate);\n            state.isDataManager = true;\n            break;\n          case 'enableTooltip':\n            if (this.eventTooltip) {\n              this.eventTooltip.destroy();\n              this.eventTooltip = null;\n            }\n            if (newProp.enableTooltip) {\n              this.eventTooltip = new EventTooltip(this);\n            }\n            break;\n          case 'tooltipTemplate':\n            this.eventTooltipTemplateFn = this.templateParser(this.eventSettings.tooltipTemplate);\n            break;\n          case 'resourceColorField':\n            if (this.resourceBase) {\n              this.resourceBase.setResourceCollection();\n            }\n            state.isDataManager = true;\n            break;\n          case 'editFollowingEvents':\n            if (this.quickPopup) {\n              this.quickPopup.refreshQuickDialog();\n            }\n            break;\n          case 'allowAdding':\n          case 'allowEditing':\n          case 'allowDeleting':\n            if (this.showHeaderBar && this.headerModule) {\n              this.headerModule.updateAddIcon();\n            }\n            if (this.eventWindow) {\n              this.eventWindow.refresh();\n            }\n            break;\n          case 'spannedEventPlacement':\n          case 'minimumEventDuration':\n          case 'enableMaxHeight':\n          case 'enableIndicator':\n            this.refreshEvents(false);\n            break;\n          case 'ignoreWhitespace':\n            state.isLayout = true;\n            break;\n        }\n      }\n    }\n    destroyHeaderModule() {\n      if (this.headerModule) {\n        this.headerModule.destroy();\n        this.headerModule = null;\n      }\n    }\n    destroyPopups() {\n      if (this.quickPopup) {\n        this.quickPopup.destroy();\n        this.quickPopup = null;\n      }\n      if (this.eventWindow) {\n        this.eventWindow.destroy();\n        this.eventWindow = null;\n      }\n    }\n    /**\n     * Allows to show the spinner on schedule at the required scenarios.\n     *\n     * @function showSpinner\n     * @returns {void}\n     */\n    showSpinner() {\n      showSpinner(this.element);\n    }\n    /**\n     * When the spinner is shown manually using `showSpinner` method, it can be hidden using this `hideSpinner` method.\n     *\n     * @function hideSpinner\n     * @returns {void}\n     */\n    hideSpinner() {\n      hideSpinner(this.element);\n    }\n    /**\n     * Sets different working hours on the required working days by accepting the required start and end time as well as the date collection\n     *  as its parameters.\n     *\n     * @function setWorkHours\n     * @param {Date} dates Collection of dates on which the given start and end hour range needs to be applied.\n     * @param {string} start Defines the work start hour.\n     * @param {string} end Defines the work end hour.\n     * @param {number} groupIndex Defines the resource index from last level.\n     * @returns {void}\n     */\n    setWorkHours(dates, start, end, groupIndex) {\n      let cells = [];\n      cells = this.getWorkHourCells(dates, start, end, groupIndex);\n      addClass(cells, WORK_HOURS_CLASS);\n    }\n    /**\n     * Removes or resets different working hours on the required working days by accepting the required start and end time as well as the\n     * date collection as its parameters.\n     * if no parameters has been passed to this function, it will remove all the work hours.\n     *\n     * @param {Date} dates Collection of dates on which the given start and end hour range need to be applied.\n     * @param {string} start Defines the work start hour.\n     * @param {string} end Defines the work end hour.\n     * @param {number} groupIndex Defines the resource index from last level.\n     * @returns {void}\n     */\n    resetWorkHours(dates = this.activeView.renderDates, start, end, groupIndex) {\n      if (dates && start && end) {\n        const cells = this.getWorkHourCells(dates, start, end, groupIndex);\n        removeClass(cells, WORK_HOURS_CLASS);\n      } else {\n        const workHourCells = [].slice.call(this.element.querySelectorAll('.' + WORK_HOURS_CLASS));\n        removeClass(workHourCells, WORK_HOURS_CLASS);\n      }\n    }\n    getWorkHourCells(dates, start, end, groupIndex) {\n      if (['Agenda', 'MonthAgenda', 'Month', 'TimelineMonth'].indexOf(this.currentView) > -1) {\n        return [];\n      }\n      let startHour = this.getStartEndTime(start);\n      let endHour = this.getStartEndTime(end);\n      const tableEle = this.getContentTable();\n      if (isNullOrUndefined(startHour) || isNullOrUndefined(endHour) || !tableEle) {\n        return [];\n      }\n      startHour.setMilliseconds(0);\n      endHour.setMilliseconds(0);\n      const viewStartHour = this.activeView.getStartHour();\n      if (startHour < viewStartHour) {\n        startHour = viewStartHour;\n      }\n      const viewEndHour = this.activeView.getEndHour();\n      if (endHour > viewEndHour) {\n        endHour = viewEndHour;\n      }\n      const msMajorInterval = this.activeViewOptions.timeScale.interval * MS_PER_MINUTE;\n      const msInterval = msMajorInterval / this.activeViewOptions.timeScale.slotCount;\n      let startIndex = Math.round((startHour.getTime() - viewStartHour.getTime()) / msInterval);\n      let endIndex = Math.ceil((endHour.getTime() - viewStartHour.getTime()) / msInterval);\n      const tempStartIndex = startIndex;\n      const tempEndIndex = endIndex;\n      const cells = [];\n      for (let date of dates) {\n        date = this.getDateTime(date);\n        resetTime(date);\n        let renderDates = this.activeView.renderDates;\n        if (!isNullOrUndefined(groupIndex) && this.resourceBase && !this.activeView.isTimelineView()) {\n          renderDates = this.resourceBase.lastResourceLevel[groupIndex].renderDates;\n        }\n        const colIndex = this.getIndexOfDate(renderDates, date);\n        if (colIndex >= 0) {\n          if (this.activeView.isTimelineView()) {\n            const slotsPerDay = Math.round((viewEndHour.getTime() - viewStartHour.getTime()) / msInterval);\n            startIndex = tempStartIndex + colIndex * slotsPerDay;\n            endIndex = tempEndIndex + colIndex * slotsPerDay;\n          }\n          for (let i = startIndex; i < endIndex; i++) {\n            if (this.activeView.isTimelineView()) {\n              const rowIndex = !isNullOrUndefined(groupIndex) ? groupIndex : 0;\n              cells.push(tableEle.rows[rowIndex].cells[i]);\n            } else {\n              if (!isNullOrUndefined(groupIndex)) {\n                const selector = '.' + WORK_CELLS_CLASS + '[data-group-index=\"' + groupIndex + '\"]';\n                const tds = [].slice.call(tableEle.rows[i].querySelectorAll(selector));\n                cells.push(tds[colIndex]);\n              } else {\n                cells.push(tableEle.rows[i].cells[colIndex]);\n              }\n            }\n          }\n        }\n      }\n      return cells;\n    }\n    /**\n     * Retrieves the start and end time information of the specific cell element.\n     *\n     * @function getCellDetails\n     * @param {Element | Element[]} tdCol Accepts the single or collection of elements.\n     * @returns {CellClickEventArgs} Object An object holding the startTime, endTime and all-day information along with the target HTML element will be returned.\n     */\n    getCellDetails(tdCol) {\n      const td = tdCol instanceof Array ? tdCol : [tdCol];\n      const firstTd = getElement(td[0]);\n      const lastTd = getElement(td.slice(-1)[0]);\n      const startTime = this.getDateFromElement(firstTd);\n      let endTime = this.getDateFromElement(lastTd);\n      if (isNullOrUndefined(startTime) || isNullOrUndefined(endTime)) {\n        return undefined;\n      }\n      const endDateFromColSpan = this.activeView.isTimelineView() && !isNullOrUndefined(lastTd.getAttribute('colSpan')) && this.headerRows.length > 0;\n      const duration = endDateFromColSpan ? parseInt(lastTd.getAttribute('colSpan'), 10) : 1;\n      if (!this.activeViewOptions.timeScale.enable || endDateFromColSpan || lastTd.classList.contains(ALLDAY_CELLS_CLASS) || lastTd.classList.contains(HEADER_CELLS_CLASS)) {\n        endTime = addDays(new Date(endTime.getTime()), duration);\n      } else {\n        endTime = this.activeView.getEndDateFromStartDate(endTime);\n      }\n      const data = {\n        startTime: startTime,\n        endTime: endTime,\n        isAllDay: this.isAllDayCell(firstTd),\n        element: tdCol\n      };\n      const groupIndex = firstTd.getAttribute('data-group-index');\n      if (!isNullOrUndefined(groupIndex)) {\n        data.groupIndex = parseInt(groupIndex, 10);\n      }\n      return data;\n    }\n    /**\n     * Retrieves the selected cell elements.\n     *\n     * @function getSelectedElements\n     * @returns {Element[]} The elements of currently selected cells will be returned.\n     */\n    getSelectedElements() {\n      return [].slice.call(this.element.querySelectorAll('.' + SELECTED_CELL_CLASS));\n    }\n    /**\n     * To get the resource collection\n     *\n     * @function getResourceCollections\n     * @returns {ResourcesModel[]} Returns the resource collections\n     */\n    getResourceCollections() {\n      return this.resourceCollection;\n    }\n    /**\n     * To set the resource collection\n     *\n     * @function setResourceCollections\n     * @param {ResourcesModel[]} resourceCol Accepts the resource collections in ResourcesModel type\n     * @returns {void}\n     */\n    setResourceCollections(resourceCol) {\n      this.setProperties({\n        resources: resourceCol\n      }, false);\n    }\n    /**\n     * Current View could be change based on the provided parameters.\n     *\n     * @function changeCurrentView\n     * @param {View} viewName Accept the view in the viewCollections.\n     * @param {number} viewIndex Accept the viewIndex in the viewCollections.\n     * @returns {void}\n     */\n    changeCurrentView(viewName, viewIndex) {\n      let index = this.getViewIndex(viewName);\n      const view = viewName.charAt(0).toLowerCase() + viewName.slice(1);\n      const viewOptions = this.viewOptions[view];\n      if (viewOptions) {\n        index = this.viewCollections.indexOf(viewOptions[viewIndex || 0]);\n      }\n      if (index === -1 || index === this.viewIndex) {\n        return;\n      }\n      this.changeView(viewName, null, null, index);\n    }\n    /**\n     * Return the current view Index.\n     *\n     * @function getCurrentViewIndex\n     * @returns {number} Returns the view index\n     */\n    getCurrentViewIndex() {\n      return this.viewIndex;\n    }\n    /**\n     * Retrieves the resource details based on the provided resource index.\n     *\n     * @param {number} index index of the resources at the last level.\n     * @returns {ResourceDetails} Object An object holding the details of resource and resourceData.\n     */\n    getResourcesByIndex(index) {\n      if (this.resourceBase && this.resourceBase.lastResourceLevel) {\n        if (index < 0 || index >= this.resourceBase.lastResourceLevel.length) {\n          return undefined;\n        }\n        const data = this.resourceBase.lastResourceLevel[index];\n        const groupData = {};\n        this.resourceBase.setResourceValues(groupData, index);\n        return {\n          resource: data.resource,\n          resourceData: data.resourceData,\n          groupData: groupData\n        };\n      }\n      return undefined;\n    }\n    /**\n     * This method allows to expand the resource that available on the scheduler.\n     *\n     * @function expandResource\n     * @param {string | number} resourceId Accepts the resource id in either string or number type\n     * @param {string} name Accepts the name of the resource collection\n     * @returns {void}\n     */\n    expandResource(resourceId, name) {\n      if (this.activeView.isTimelineView() && this.resourceBase && this.resourceCollection.length > 1) {\n        this.resourceBase.resourceExpand(resourceId, name, false);\n      }\n    }\n    /**\n     * This method allows to collapse the resource that available on the scheduler.\n     *\n     * @function collapseResource\n     * @param {string | number} resourceId Accepts the resource id in either string or number type\n     * @param {string} name Accepts the name of the resource collection\n     * @returns {void}\n     */\n    collapseResource(resourceId, name) {\n      if (this.activeView.isTimelineView() && this.resourceBase && this.resourceCollection.length > 1) {\n        this.resourceBase.resourceExpand(resourceId, name, true);\n      }\n    }\n    /**\n     * Scrolls the Schedule content area to the specified time.\n     *\n     * @function scrollTo\n     * @param {string} hour Accepts the time value in the skeleton format of 'Hm'.\n     * @param {Date} scrollDate Accepts the date object value.\n     * @returns {void}\n     */\n    scrollTo(hour, scrollDate) {\n      if (this.activeView.scrollToDate && isNullOrUndefined(hour) && scrollDate) {\n        this.activeView.scrollToDate(scrollDate);\n      } else if (this.activeView.scrollToHour) {\n        this.activeView.scrollToHour(hour, scrollDate);\n      }\n    }\n    /**\n     * This method allows scroll to the position of the any resources that available on the scheduler.\n     * This method is applicable for without Agenda and Month agenda views of the schedule.\n     *\n     * @function scrollToResource\n     * @param {string | number} resourceId Accepts the resource id in either string or number type\n     * @param {string} groupName Accepts the name of the resource collection\n     * @returns {void}\n     */\n    scrollToResource(resourceId, groupName) {\n      if (this.resourceBase && this.resourceBase.lastResourceLevel) {\n        this.resourceBase.resourceScroll(resourceId, groupName);\n      }\n    }\n    /**\n     * Exports the Scheduler events to a calendar (.ics) file. By default, the calendar is exported with a file name `Calendar.ics`.\n     * To change this file name on export, pass the custom string value as `fileName` to get the file downloaded with this provided name.\n     *\n     * @function exportToICalendar\n     * @param {string} fileName Accepts the string value.\n     * @param {Object[]} customData Accepts the collection of objects.\n     * @returns {void}\n     */\n    exportToICalendar(fileName, customData) {\n      if (this.iCalendarExportModule) {\n        this.iCalendarExportModule.initializeCalendarExport(fileName, customData);\n      } else {\n        throw Error('Inject ICalendarExport module');\n      }\n    }\n    /**\n     * Imports the events from an .ics file downloaded from any of the calendars like Google or Outlook into the Scheduler.\n     * This method accepts the blob object or string format of an .ics file to be imported as a mandatory argument.\n     *\n     * @function importICalendar\n     * @param {Blob | string} fileContent Accepts the file object or string format of an .ics file.\n     * @returns {void}\n     */\n    importICalendar(fileContent) {\n      if (this.iCalendarImportModule) {\n        this.iCalendarImportModule.initializeCalendarImport(fileContent);\n      } else {\n        throw Error('Inject ICalendarImport module');\n      }\n    }\n    /**\n     * Adds the newly created event into the Schedule dataSource.\n     *\n     * @function addEvent\n     * @param {Object | Object[]} data Single or collection of event objects to be added into Schedule.\n     * @returns {void}\n     */\n    addEvent(data) {\n      this.crudModule.addEvent(data);\n    }\n    /**\n     * Allows the Scheduler events data to be exported as an Excel file either in .xlsx or .csv file formats.\n     * By default, the whole event collection bound to the Scheduler gets exported as an Excel file.\n     * To export only the specific events of Scheduler, you need to pass the custom data collection as\n     * a parameter to this `exportToExcel` method. This method accepts the export options as arguments such as fileName,\n     * exportType, fields, customData, and includeOccurrences. The `fileName` denotes the name to be given for the exported\n     * file and the `exportType` allows you to set the format of an Excel file to be exported either as .xlsx or .csv.\n     * The custom or specific field collection of event dataSource to be exported can be provided through `fields` option\n     * and the custom data collection can be exported by passing them through the `customData` option. There also exists\n     * option to export each individual instances of the recurring events to an Excel file, by setting true or false to the\n     * `includeOccurrences` option, denoting either to include or exclude the occurrences as separate instances on an exported Excel file.\n     *\n     * @function exportToExcel\n     * @param {ExportOptions} excelExportOptions The export options to be set before start with exporting the Scheduler events to an Excel file.\n     * @returns {void}\n     */\n    exportToExcel(excelExportOptions) {\n      if (this.excelExportModule) {\n        this.excelExportModule.initializeExcelExport(excelExportOptions);\n      } else {\n        throw Error('Inject ExcelExport module');\n      }\n    }\n    /**\n     * Method allows to print the scheduler.\n     *\n     * @function print\n     * @param {ScheduleModel} printOptions The export options to be set before start with exporting\n     * the Scheduler events to the print window.\n     * @returns {void}\n     */\n    print(printOptions) {\n      if (this.printModule) {\n        this.printModule.print(printOptions);\n      } else {\n        throw Error('Inject Print module');\n      }\n    }\n    /**\n     * Updates the changes made in the event object by passing it as an parameter into the dataSource.\n     *\n     * @function saveEvent\n     * @param {Object | Object[]} data Single or collection of event objects to be saved into Schedule.\n     * @param {CurrentAction} currentAction Denotes the action that takes place either for editing occurrence or series.\n     *  The valid current action names are `EditOccurrence` or `EditSeries`.\n     * @returns {void}\n     */\n    saveEvent(data, currentAction) {\n      this.crudModule.saveEvent(data, currentAction);\n    }\n    /**\n     * Deletes the events based on the provided ID or event collection in the argument list.\n     *\n     * @function deleteEvent\n     * @param {string | number | Object | Object[]} id Accepts the ID as string or number type or single or collection of the event object which needs to be removed from the Schedule.\n     * @param {CurrentAction} currentAction Denotes the delete action that takes place either on occurrence or series events.\n     *  The valid current action names are `Delete`, `DeleteOccurrence` or `DeleteSeries`.\n     * @returns {void}\n     */\n    deleteEvent(id, currentAction) {\n      this.crudModule.deleteEvent(id, currentAction);\n    }\n    /**\n     * Retrieves the entire collection of events bound to the Schedule.\n     *\n     * @function getEvents\n     * @param {Date} startDate Accepts the start date.\n     * @param {Date} endDate Accepts te end date.\n     * @param {boolean} includeOccurrences Accepts the boolean value to process the occurrence from recurrence series.\n     * @returns {Object[]} Returns the collection of event objects from the Schedule.\n     */\n    getEvents(startDate, endDate, includeOccurrences) {\n      let eventCollections = [];\n      if (includeOccurrences) {\n        eventCollections = this.eventBase.getProcessedEvents();\n      } else {\n        eventCollections = this.eventsData;\n      }\n      if (startDate) {\n        startDate = this.getDateTime(startDate);\n      }\n      if (endDate) {\n        endDate = this.getDateTime(endDate);\n      }\n      eventCollections = this.eventBase.filterEventsByRange(eventCollections, startDate, endDate);\n      return eventCollections;\n    }\n    /**\n     * Retrieves the entire collection of block events bound to the Schedule.\n     *\n     * @function getBlockEvents\n     * @param {Date} startDate Accepts the start date.\n     * @param {Date} endDate Accepts te end date.\n     * @param {boolean} includeOccurrences Accepts the boolean value to process the occurrence from recurrence series.\n     * @returns {Object[]} Returns the collection of block event objects from the Schedule.\n     */\n    getBlockEvents(startDate, endDate, includeOccurrences) {\n      let eventCollections = [];\n      if (includeOccurrences) {\n        eventCollections = this.eventBase.getProcessedEvents(this.blockData);\n      } else {\n        eventCollections = this.blockData;\n      }\n      if (startDate) {\n        startDate = this.getDateTime(startDate);\n      }\n      if (endDate) {\n        endDate = this.getDateTime(endDate);\n      }\n      eventCollections = this.eventBase.filterEventsByRange(eventCollections, startDate, endDate);\n      return eventCollections;\n    }\n    /**\n     * Retrieves the occurrences of a single recurrence event based on the provided parent ID.\n     *\n     * @function getOccurrencesByID\n     * @param {number} eventID ID of the parent recurrence data from which the occurrences are fetched.\n     * @returns {Object[]} Returns the collection of occurrence event objects.\n     */\n    getOccurrencesByID(eventID) {\n      return this.eventBase.getOccurrencesByID(eventID);\n    }\n    /**\n     * Retrieves all the occurrences that lies between the specific start and end time range.\n     *\n     * @function getOccurrencesByRange\n     * @param {Date} startTime Denotes the start time range.\n     * @param {Date} endTime Denotes the end time range.\n     * @returns {Object[]} Returns the collection of occurrence event objects that lies between the provided start and end time.\n     */\n    getOccurrencesByRange(startTime, endTime) {\n      startTime = this.getDateTime(startTime);\n      endTime = this.getDateTime(endTime);\n      return this.eventBase.getOccurrencesByRange(startTime, endTime);\n    }\n    /**\n     * Retrieves the dates that lies on active view of Schedule.\n     *\n     * @function getCurrentViewDates\n     * @returns {Date[]} Returns the collection of dates.\n     */\n    getCurrentViewDates() {\n      return this.activeView ? this.activeView.renderDates : [];\n    }\n    /**\n     * Set the recurrence editor instance from custom editor template.\n     *\n     * @function setRecurrenceEditor\n     * @param {RecurrenceEditor} recurrenceEditor instance has passed to fetch the instance in event window.\n     * @returns {void}\n     */\n    setRecurrenceEditor(recurrenceEditor) {\n      this.eventWindow.setRecurrenceEditor(recurrenceEditor);\n    }\n    /**\n     * Get the maximum id of an event.\n     *\n     * @function getEventMaxID\n     * @returns {number | string} Returns the maximum ID from scheduler data collections.\n     */\n    getEventMaxID() {\n      return this.eventBase.getEventMaxID();\n    }\n    /**\n     * Get deleted occurrences from given recurrence series.\n     *\n     * @function getDeletedOccurrences\n     * @param {string | number | Object} recurrenceData Accepts the parent ID of the event object or parent event object\n     * @returns {Object[]} Returns the collection of deleted occurrence events.\n     */\n    getDeletedOccurrences(recurrenceData) {\n      return this.eventBase.getDeletedOccurrences(recurrenceData);\n    }\n    /**\n     * Retrieves the events that lies on the current date range of the active view of Schedule.\n     *\n     * @function getCurrentViewEvents\n     * @returns {Object[]} Returns the collection of events.\n     */\n    getCurrentViewEvents() {\n      return this.eventsProcessed;\n    }\n    /**\n     * Refreshes the event dataSource. This method may be useful when the events alone in the schedule needs to be re-rendered.\n     *\n     * @function refreshEvents\n     * @param {boolean} isRemoteRefresh Accepts the boolean to refresh data from remote or local\n     * @returns {void}\n     */\n    refreshEvents(isRemoteRefresh = true) {\n      if (this.dragAndDropModule) {\n        this.dragAndDropModule.actionObj.action = '';\n        removeClass([this.element], EVENT_ACTION_CLASS);\n      }\n      if (isRemoteRefresh) {\n        this.crudModule.refreshDataManager();\n      } else {\n        if (this.activeViewOptions && this.activeViewOptions.eventTemplate) {\n          let templateNames = ['eventTemplate'];\n          if (this.crudModule && this.crudModule.crudObj.isCrudAction && ['Agenda', 'MonthAgenda', 'Year', 'TimelineYear'].indexOf(this.currentView) === -1) {\n            templateNames = [];\n            for (let i = 0, len = this.crudModule.crudObj.sourceEvent.length; i < len; i++) {\n              templateNames.push('eventTemplate_' + this.crudModule.crudObj.sourceEvent[i].groupIndex);\n              if (this.crudModule.crudObj.targetEvent[i] && this.crudModule.crudObj.sourceEvent[i].groupIndex !== this.crudModule.crudObj.targetEvent[i].groupIndex) {\n                templateNames.push('eventTemplate_' + this.crudModule.crudObj.targetEvent[i].groupIndex);\n              }\n            }\n          }\n          this.resetTemplates(templateNames);\n        }\n        const eventsData = this.eventsData || [];\n        const blockData = this.blockData || [];\n        const data = eventsData.concat(blockData);\n        this.notify(dataReady, {\n          processedData: this.eventBase ? this.eventBase.processData(data) : []\n        });\n      }\n    }\n    /**\n     * Method to refresh the given Schedule templates\n     *\n     * @param {string} templateName Accepts the template name\n     * @returns {void}\n     */\n    refreshTemplates(templateName) {\n      if (templateName) {\n        this.resetTemplates([templateName]);\n      } else {\n        this.resetTemplates();\n      }\n      switch (templateName) {\n        case 'eventTemplate':\n          this.appointmentTemplateFn = this.templateParser(this.activeViewOptions.eventTemplate);\n          this.refreshEvents(false);\n          break;\n        case 'dateHeaderTemplate':\n          this.dateHeaderTemplateFn = this.templateParser(this.activeViewOptions.dateHeaderTemplate);\n          this.activeView.refreshHeader();\n          break;\n        case 'resourceHeaderTemplate':\n          this.resourceHeaderTemplateFn = this.templateParser(this.activeViewOptions.resourceHeaderTemplate);\n          if (this.activeView.isTimelineView()) {\n            this.activeView.refreshResourceHeader();\n          } else {\n            this.activeView.refreshHeader();\n          }\n          break;\n        case 'quickInfoTemplates':\n          if (this.quickPopup) {\n            this.quickPopup.destroy();\n            this.quickPopup = null;\n          }\n          this.quickPopup = new QuickPopups(this);\n          this.quickInfoTemplatesHeaderFn = this.templateParser(this.quickInfoTemplates.header);\n          this.quickInfoTemplatesContentFn = this.templateParser(this.quickInfoTemplates.content);\n          this.quickInfoTemplatesFooterFn = this.templateParser(this.quickInfoTemplates.footer);\n          break;\n        case 'editorTemplate':\n          if (this.eventWindow) {\n            this.eventWindow.destroy();\n            this.eventWindow = null;\n          }\n          this.eventWindow = new EventWindow(this);\n          this.editorTemplateFn = this.templateParser(this.editorTemplate);\n          break;\n        case 'tooltipTemplate':\n        case 'headerTooltipTemplate':\n          if (this.eventTooltip) {\n            this.eventTooltip.destroy();\n            this.eventTooltip = null;\n          }\n          this.eventTooltip = new EventTooltip(this);\n          this.eventTooltipTemplateFn = this.templateParser(this.eventSettings.tooltipTemplate);\n          this.headerTooltipTemplateFn = this.templateParser(this.activeViewOptions.group.headerTooltipTemplate);\n          break;\n        default:\n          this.initializeView(this.currentView);\n          break;\n      }\n    }\n    /**\n     * Refreshes the Schedule layout without re-render.\n     *\n     * @function refreshLayout\n     * @returns {void}\n     */\n    refreshLayout() {\n      this.onScheduleResize();\n      if (this.headerModule) {\n        this.headerModule.refresh();\n      }\n      if (this.eventWindow) {\n        this.eventWindow.refresh();\n      }\n    }\n    /**\n     * To retrieve the appointment object from element.\n     *\n     * @function getEventDetails\n     * @param {Element} element Denotes the event UI element on the Schedule.\n     * @returns {Object} Returns the event details.\n     */\n    getEventDetails(element) {\n      element = getElement(element);\n      const guid = element.getAttribute('data-guid');\n      if (guid) {\n        return this.eventBase.getEventByGuid(guid);\n      }\n      return {};\n    }\n    /**\n     * To check whether the given time range slots are available for event creation or already occupied by other events.\n     *\n     * @function isSlotAvailable\n     * @param {Date | Object} startTime Denotes the start time of the slot.\n     * @param {Date} endTime Denotes the end time of the slot.\n     * @param {number} groupIndex Defines the resource index from last level.\n     * @returns {boolean} Returns true, if the slot that lies in the provided time range does not contain any other events.\n     */\n    isSlotAvailable(startTime, endTime, groupIndex) {\n      let eventStart;\n      let eventEnd;\n      let eventObj = this.activeEventData.event;\n      if (startTime instanceof Date || typeof startTime === 'string') {\n        eventStart = startTime;\n        eventEnd = endTime;\n      } else {\n        eventObj = startTime;\n        eventStart = startTime[this.eventFields.startTime];\n        eventEnd = startTime[this.eventFields.endTime];\n        if (this.resourceBase) {\n          groupIndex = this.eventBase.getGroupIndexFromEvent(startTime);\n        }\n      }\n      if (isNullOrUndefined(eventStart) || isNullOrUndefined(eventEnd)) {\n        return true;\n      }\n      eventStart = this.getDateTime(eventStart);\n      eventEnd = this.getDateTime(eventEnd);\n      let eventCollection = this.eventBase.filterEvents(eventStart, eventEnd);\n      if (!isNullOrUndefined(groupIndex) && this.resourceBase && this.resourceBase.lastResourceLevel.length > 0) {\n        eventCollection = this.eventBase.filterEventsByResource(this.resourceBase.lastResourceLevel[groupIndex], eventCollection);\n      }\n      if (eventObj) {\n        if (eventObj.Guid) {\n          eventCollection = eventCollection.filter(event => event.Guid !== eventObj.Guid);\n        } else {\n          eventCollection = eventCollection.filter(event => event[this.eventFields.id] !== eventObj[this.eventFields.id]);\n        }\n      }\n      return eventCollection.length > 0 ? false : true;\n    }\n    /**\n     * To manually open the event editor on specific time or on certain events.\n     *\n     * @function openEditor\n     * @param {Object} data It can be either cell data or event data.\n     * @param {CurrentAction} action Defines the action for which the editor needs to be opened such as either for new event creation or\n     *  for editing of existing events. The applicable action names that can be used here are `Add`, `Save`, `EditOccurrence`\n     *  and `EditSeries`.\n     * @param {boolean} isEventData It allows to decide whether the editor needs to be opened with the clicked cell details or with the\n     *  passed event details.\n     * @param {number} repeatType It opens the editor with the recurrence options based on the provided repeat type.\n     * @returns {void}\n     */\n    openEditor(data, action, isEventData, repeatType) {\n      if (action === 'Add' && !isEventData) {\n        data.startTime = this.getDateTime(data.startTime);\n        data.endTime = this.getDateTime(data.endTime);\n        if (!isNullOrUndefined(data.element)) {\n          data.element = getElement(data.element);\n        }\n      } else {\n        data[this.eventFields.startTime] = this.getDateTime(data[this.eventFields.startTime]);\n        data[this.eventFields.endTime] = this.getDateTime(data[this.eventFields.endTime]);\n      }\n      this.currentAction = action;\n      if (action !== 'Add') {\n        this.activeEventData.event = data;\n      }\n      this.eventWindow.openEditor(data, action, isEventData, repeatType);\n    }\n    /**\n     * To manually close the event editor window\n     *\n     * @function closeEditor\n     * @returns {void}\n     */\n    closeEditor() {\n      if (this.eventWindow) {\n        this.eventWindow.dialogClose();\n      }\n    }\n    /**\n     * To manually close the quick info popup\n     *\n     * @function closeQuickInfoPopup\n     * @returns {void}\n     */\n    closeQuickInfoPopup() {\n      if (this.quickPopup) {\n        this.quickPopup.quickPopupHide(true);\n      }\n    }\n    /**\n     * Select the resource based on group index in mobile mode.\n     *\n     * @param {number} groupIndex Defines the resource index based on last level.\n     * @returns {void}\n     */\n    selectResourceByIndex(groupIndex) {\n      if (this.resourceBase && this.uiStateValues.isGroupAdaptive) {\n        this.resourceBase.selectResourceByIndex(groupIndex);\n      }\n    }\n    /**\n     * Select the resources to the based on id.\n     *\n     * @param {string | number} id id of the resource defined in resources collection.\n     * @param {string} name Name of the resource defined in resources collection.\n     * @returns {number} Returns the group index\n     */\n    getIndexFromResourceId(id, name) {\n      if (this.resourceBase) {\n        return this.resourceBase.getIndexFromResourceId(id, name);\n      }\n      return null;\n    }\n    /**\n     * Adds the resources to the specified index.\n     *\n     * @param {Object | Object[]} resources Accepts the resource data in single or collection of data.\n     * @param {string} name Name of the resource defined in resources collection.\n     * @param {number} index Index or position where the resource should be added.\n     * @returns {void}\n     */\n    addResource(resources, name, index) {\n      this.resourceBase.addResource(resources, name, index);\n    }\n    /**\n     * Removes the specified resource.\n     *\n     * @param {string | string[] | number | number[]} resourceId Specifies the resource id to be removed.\n     * @param {string} name Specifies the resource name from which the id should be referred.\n     * @returns {void}\n     */\n    removeResource(resourceId, name) {\n      this.resourceBase.removeResource(resourceId, name);\n    }\n    /**\n     * Destroys the Schedule component.\n     *\n     * @function destroy\n     * @returns {void}\n     */\n    destroy() {\n      if (this.eventTooltip) {\n        this.eventTooltip.destroy();\n        this.eventTooltip = null;\n      }\n      this.destroyPopups();\n      this.hideSpinner();\n      this.unWireEvents();\n      this.destroyHeaderModule();\n      if (this.eventTooltip) {\n        this.eventTooltip.destroy();\n        this.eventTooltip = null;\n      }\n      if (this.eventBase) {\n        this.eventBase.destroy();\n        this.eventBase = null;\n      }\n      if (this.workCellAction) {\n        this.workCellAction.destroy();\n        this.workCellAction = null;\n      }\n      if (this.inlineModule) {\n        this.inlineModule.destroy();\n        this.inlineModule = null;\n      }\n      if (this.keyboardInteractionModule) {\n        this.keyboardInteractionModule.destroy();\n        this.keyboardInteractionModule = null;\n      }\n      if (this.scrollModule) {\n        this.scrollModule.destroy();\n        this.scrollModule = null;\n      }\n      if (this.printModule) {\n        this.printModule.destroy();\n      }\n      if (this.activeView) {\n        this.resetTemplates();\n        this.activeView.removeEventListener();\n        this.activeView.destroy();\n        this.activeView = null;\n      }\n      if (this.scheduleTouchModule) {\n        this.scheduleTouchModule.destroy();\n        this.scheduleTouchModule = null;\n      }\n      if (this.crudModule) {\n        this.crudModule.destroy();\n        this.crudModule = null;\n      }\n      if (this.dataModule) {\n        this.dataModule.destroy();\n        this.dataModule = null;\n      }\n      super.destroy();\n      const modules = ['dayModule', 'weekModule', 'workWeekModule', 'monthModule', 'monthAgendaModule', 'yearModule', 'agendaModule', 'timelineViewsModule', 'timelineMonthModule', 'timelineYearModule', 'resizeModule', 'dragAndDropModule', 'excelExportModule', 'printModule', 'iCalendarExportModule', 'iCalendarImportModule', 'tzModule', 'eventsData', 'eventsProcessed', 'blockData', 'blockProcessed', 'uiStateValues', 'viewCollections', 'viewOptions', 'defaultLocale', 'localeObj', 'selectedElements', 'resourceCollection', 'editorTitles', 'eventFields', 'activeViewOptions', 'activeEventData', 'activeCellsData', 'renderModule'];\n      for (const module of modules) {\n        this[module] = null;\n      }\n      removeChildren(this.element);\n      let removeClasses = [ROOT, RTL, DEVICE_CLASS, MULTI_DRAG];\n      if (this.cssClass) {\n        removeClasses = removeClasses.concat(this.cssClass.split(' '));\n      }\n      removeClass([this.element], removeClasses);\n    }\n  };\n  __decorate([Property('auto')], Schedule.prototype, \"width\", void 0);\n  __decorate([Property('auto')], Schedule.prototype, \"height\", void 0);\n  __decorate([Property(true)], Schedule.prototype, \"showHeaderBar\", void 0);\n  __decorate([Property(true)], Schedule.prototype, \"showTimeIndicator\", void 0);\n  __decorate([Property('Week')], Schedule.prototype, \"currentView\", void 0);\n  __decorate([Property(['Day', 'Week', 'WorkWeek', 'Month', 'Agenda'])], Schedule.prototype, \"views\", void 0);\n  __decorate([Property(new Date())], Schedule.prototype, \"selectedDate\", void 0);\n  __decorate([Property(new Date(1900, 0, 1))], Schedule.prototype, \"minDate\", void 0);\n  __decorate([Property(new Date(2099, 11, 31))], Schedule.prototype, \"maxDate\", void 0);\n  __decorate([Property()], Schedule.prototype, \"dateFormat\", void 0);\n  __decorate([Property('Gregorian')], Schedule.prototype, \"calendarMode\", void 0);\n  __decorate([Property(true)], Schedule.prototype, \"showWeekend\", void 0);\n  __decorate([Property(0)], Schedule.prototype, \"firstDayOfWeek\", void 0);\n  __decorate([Property('FirstDay')], Schedule.prototype, \"weekRule\", void 0);\n  __decorate([Property([1, 2, 3, 4, 5])], Schedule.prototype, \"workDays\", void 0);\n  __decorate([Property(12)], Schedule.prototype, \"monthsCount\", void 0);\n  __decorate([Property('00:00')], Schedule.prototype, \"startHour\", void 0);\n  __decorate([Property('24:00')], Schedule.prototype, \"endHour\", void 0);\n  __decorate([Property(null)], Schedule.prototype, \"timeFormat\", void 0);\n  __decorate([Property(false)], Schedule.prototype, \"enableAllDayScroll\", void 0);\n  __decorate([Property(false)], Schedule.prototype, \"enableAdaptiveUI\", void 0);\n  __decorate([Property(true)], Schedule.prototype, \"allowResizing\", void 0);\n  __decorate([Complex({}, WorkHours)], Schedule.prototype, \"workHours\", void 0);\n  __decorate([Complex({}, TimeScale)], Schedule.prototype, \"timeScale\", void 0);\n  __decorate([Property(true)], Schedule.prototype, \"allowKeyboardInteraction\", void 0);\n  __decorate([Property(true)], Schedule.prototype, \"allowDragAndDrop\", void 0);\n  __decorate([Property()], Schedule.prototype, \"dateHeaderTemplate\", void 0);\n  __decorate([Property()], Schedule.prototype, \"cellHeaderTemplate\", void 0);\n  __decorate([Property()], Schedule.prototype, \"dayHeaderTemplate\", void 0);\n  __decorate([Property()], Schedule.prototype, \"monthHeaderTemplate\", void 0);\n  __decorate([Property()], Schedule.prototype, \"cellTemplate\", void 0);\n  __decorate([Property(false)], Schedule.prototype, \"readonly\", void 0);\n  __decorate([Property(true)], Schedule.prototype, \"showQuickInfo\", void 0);\n  __decorate([Property(false)], Schedule.prototype, \"allowInline\", void 0);\n  __decorate([Property(true)], Schedule.prototype, \"allowMultiCellSelection\", void 0);\n  __decorate([Property(true)], Schedule.prototype, \"allowMultiRowSelection\", void 0);\n  __decorate([Property(false)], Schedule.prototype, \"quickInfoOnSelectionEnd\", void 0);\n  __decorate([Property(false)], Schedule.prototype, \"showWeekNumber\", void 0);\n  __decorate([Property(false)], Schedule.prototype, \"rowAutoHeight\", void 0);\n  __decorate([Property(false)], Schedule.prototype, \"allowMultiDrag\", void 0);\n  __decorate([Property(0)], Schedule.prototype, \"firstMonthOfYear\", void 0);\n  __decorate([Property()], Schedule.prototype, \"editorTemplate\", void 0);\n  __decorate([Complex({}, QuickInfoTemplates)], Schedule.prototype, \"quickInfoTemplates\", void 0);\n  __decorate([Property(7)], Schedule.prototype, \"agendaDaysCount\", void 0);\n  __decorate([Property(true)], Schedule.prototype, \"hideEmptyAgendaDays\", void 0);\n  __decorate([Property(true)], Schedule.prototype, \"enableRecurrenceValidation\", void 0);\n  __decorate([Property()], Schedule.prototype, \"timezone\", void 0);\n  __decorate([Complex({}, EventSettings)], Schedule.prototype, \"eventSettings\", void 0);\n  __decorate([Property(timezoneData)], Schedule.prototype, \"timezoneDataSource\", void 0);\n  __decorate([Property()], Schedule.prototype, \"resourceHeaderTemplate\", void 0);\n  __decorate([Property()], Schedule.prototype, \"headerIndentTemplate\", void 0);\n  __decorate([Complex({}, Group)], Schedule.prototype, \"group\", void 0);\n  __decorate([Collection([], Resources)], Schedule.prototype, \"resources\", void 0);\n  __decorate([Collection([], HeaderRows)], Schedule.prototype, \"headerRows\", void 0);\n  __decorate([Property()], Schedule.prototype, \"cssClass\", void 0);\n  __decorate([Property()], Schedule.prototype, \"eventDragArea\", void 0);\n  __decorate([Event()], Schedule.prototype, \"created\", void 0);\n  __decorate([Event()], Schedule.prototype, \"destroyed\", void 0);\n  __decorate([Event()], Schedule.prototype, \"cellClick\", void 0);\n  __decorate([Event()], Schedule.prototype, \"cellDoubleClick\", void 0);\n  __decorate([Event()], Schedule.prototype, \"moreEventsClick\", void 0);\n  __decorate([Event()], Schedule.prototype, \"hover\", void 0);\n  __decorate([Event()], Schedule.prototype, \"select\", void 0);\n  __decorate([Event()], Schedule.prototype, \"actionBegin\", void 0);\n  __decorate([Event()], Schedule.prototype, \"actionComplete\", void 0);\n  __decorate([Event()], Schedule.prototype, \"actionFailure\", void 0);\n  __decorate([Event()], Schedule.prototype, \"navigating\", void 0);\n  __decorate([Event()], Schedule.prototype, \"renderCell\", void 0);\n  __decorate([Event()], Schedule.prototype, \"eventClick\", void 0);\n  __decorate([Event()], Schedule.prototype, \"eventRendered\", void 0);\n  __decorate([Event()], Schedule.prototype, \"dataBinding\", void 0);\n  __decorate([Event()], Schedule.prototype, \"popupOpen\", void 0);\n  __decorate([Event()], Schedule.prototype, \"popupClose\", void 0);\n  __decorate([Event()], Schedule.prototype, \"dragStart\", void 0);\n  __decorate([Event()], Schedule.prototype, \"drag\", void 0);\n  __decorate([Event()], Schedule.prototype, \"dragStop\", void 0);\n  __decorate([Event()], Schedule.prototype, \"resizeStart\", void 0);\n  __decorate([Event()], Schedule.prototype, \"resizing\", void 0);\n  __decorate([Event()], Schedule.prototype, \"resizeStop\", void 0);\n  __decorate([Event()], Schedule.prototype, \"dataBound\", void 0);\n  Schedule = __decorate([NotifyPropertyChanges], Schedule);\n\n  /* eslint-disable @typescript-eslint/no-explicit-any */\n  /**\n   * Base class for the common drag and resize related actions\n   */\n  return Schedule;\n})();\nclass ActionBase {\n  constructor(parent) {\n    this.daysVariation = 0;\n    this.parent = parent;\n    this.actionObj = {\n      X: 0,\n      Y: 0,\n      groupIndex: 0,\n      cellWidth: 0,\n      cellHeight: 0,\n      slotInterval: 0,\n      interval: 0,\n      actionIndex: 0,\n      cloneElement: [],\n      originalElement: [],\n      action: null,\n      isAllDay: null,\n      excludeSelectors: null,\n      index: 0,\n      navigationInterval: null,\n      scrollInterval: null\n    };\n    this.scrollArgs = {\n      element: null,\n      width: 0,\n      height: 0\n    };\n    this.resizeEdges = {\n      left: false,\n      right: false,\n      top: false,\n      bottom: false\n    };\n    this.scrollEdges = {\n      left: false,\n      right: false,\n      top: false,\n      bottom: false\n    };\n  }\n  getChangedData(multiData) {\n    const eventObj = extend({}, this.actionObj.event, null, true);\n    eventObj[this.parent.eventFields.startTime] = this.actionObj.start;\n    eventObj[this.parent.eventFields.endTime] = this.actionObj.end;\n    if (!isNullOrUndefined(this.actionObj.isAllDay)) {\n      eventObj[this.parent.eventFields.isAllDay] = this.actionObj.isAllDay;\n    }\n    if (this.parent.activeViewOptions.group.resources.length > 0) {\n      const originalElement = this.getOriginalElement(this.actionObj.element);\n      if (originalElement) {\n        let indexCol = originalElement.map(element => parseInt(element.getAttribute('data-group-index'), 10));\n        if (indexCol.indexOf(this.actionObj.groupIndex) === -1 || !isNullOrUndefined(multiData) && multiData.length > 0) {\n          const cloneIndex = parseInt(this.actionObj.clone.getAttribute('data-group-index'), 10);\n          indexCol = indexCol.filter(index => index !== cloneIndex);\n          indexCol.push(this.actionObj.groupIndex);\n          if (multiData && multiData.length > 0) {\n            multiData.forEach(data => {\n              this.parent.resourceBase.getResourceData(data, this.actionObj.groupIndex, indexCol);\n            });\n          } else {\n            this.parent.resourceBase.getResourceData(eventObj, this.actionObj.groupIndex, indexCol);\n          }\n        }\n      }\n    }\n    return eventObj;\n  }\n  saveChangedData(eventArgs, isMultiSelect = false) {\n    this.parent.activeEventData.event = this.actionObj.event;\n    this.parent.currentAction = 'Save';\n    let currentAction;\n    let eventsCollection = [eventArgs.data];\n    if (isMultiSelect) {\n      eventsCollection = eventArgs.selectedData;\n    }\n    for (const eventObj of eventsCollection) {\n      const isSameResource = this.parent.activeViewOptions.group.resources.length > 0 ? parseInt(this.actionObj.element.getAttribute('data-group-index'), 10) === this.actionObj.groupIndex : true;\n      if (+eventObj[this.parent.eventFields.startTime] === +this.actionObj.event[this.parent.eventFields.startTime] && +eventObj[this.parent.eventFields.endTime] === +this.actionObj.event[this.parent.eventFields.endTime] && isSameResource) {\n        return;\n      }\n      if (eventObj[this.parent.eventFields.recurrenceRule]) {\n        const eveId = eventObj[this.parent.eventFields.recurrenceID] || eventObj[this.parent.eventFields.id];\n        if (eventObj[this.parent.eventFields.id] === eventObj[this.parent.eventFields.recurrenceID]) {\n          eventObj[this.parent.eventFields.id] = this.parent.eventBase.getEventMaxID();\n          currentAction = 'EditOccurrence';\n        }\n        if (this.parent.enableRecurrenceValidation && this.parent.eventWindow.editOccurrenceValidation(eveId, eventObj, this.actionObj.event)) {\n          return;\n        }\n      } else {\n        currentAction = null;\n      }\n      if (eventObj[this.parent.eventFields.startTimezone] || eventObj[this.parent.eventFields.endTimezone]) {\n        this.parent.eventBase.timezoneConvert(eventObj);\n      }\n      this.parent.crudModule.saveEvent(eventObj, currentAction);\n    }\n  }\n  calculateIntervalTime(date) {\n    const intervalTime = new Date(+date);\n    intervalTime.setMinutes(Math.floor(intervalTime.getMinutes() / this.actionObj.interval) * this.actionObj.interval);\n    return intervalTime;\n  }\n  getContentAreaDimension() {\n    const viewElement = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS);\n    let trElement = [].slice.call(viewElement.querySelector('tr').children);\n    if (!this.parent.activeView.isTimelineView() && this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.isAdaptive && !this.parent.enableAdaptiveUI) {\n      trElement = this.getResourceElements(trElement);\n    }\n    const leftOffset = trElement[0].getBoundingClientRect();\n    const rightOffset = trElement.slice(-1)[0].getBoundingClientRect();\n    const viewDimension = {\n      bottom: viewElement.scrollHeight - 5,\n      left: this.parent.enableRtl ? rightOffset.left : leftOffset.left,\n      right: this.parent.enableRtl ? leftOffset.right : rightOffset.right,\n      top: 0,\n      leftOffset: this.parent.enableRtl ? rightOffset.right : leftOffset.right,\n      rightOffset: this.parent.enableRtl ? leftOffset.left : rightOffset.left\n    };\n    return viewDimension;\n  }\n  getPageCoordinates(e) {\n    const eventArgs = e.event;\n    return eventArgs && eventArgs.changedTouches ? eventArgs.changedTouches[0] : e.changedTouches ? e.changedTouches[0] : eventArgs || e;\n  }\n  getIndex(index) {\n    const contentElements = [].slice.call(this.parent.getContentTable().querySelector('tr').children);\n    const indexes = {\n      minIndex: 0,\n      maxIndex: contentElements.length - 1\n    };\n    if (this.actionObj.action === 'resize' && this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive && !this.parent.activeView.isTimelineView()) {\n      const groupElements = this.getResourceElements(contentElements);\n      indexes.minIndex = groupElements[0].cellIndex;\n      indexes.maxIndex = groupElements.slice(-1)[0].cellIndex;\n    }\n    if (index < indexes.minIndex) {\n      index = indexes.minIndex;\n    }\n    if (index > indexes.maxIndex) {\n      index = indexes.maxIndex;\n    }\n    return index;\n  }\n  updateTimePosition(date, multiData) {\n    let index = 0;\n    for (const cloneElement of this.actionObj.cloneElement) {\n      const timeElement = cloneElement.querySelector('.' + APPOINTMENT_TIME);\n      if (timeElement) {\n        let startTime = this.actionObj.start;\n        let endTime = this.actionObj.end;\n        if (multiData && multiData.length > 0) {\n          startTime = multiData[index][this.parent.eventFields.startTime];\n          endTime = multiData[index][this.parent.eventFields.endTime];\n        }\n        timeElement.innerHTML = this.parent.getTimeString(startTime) + ' - ' + this.parent.getTimeString(endTime);\n      }\n      index++;\n    }\n    if (!this.parent.activeViewOptions.timeScale.enable || !this.parent.isAdaptive || this.parent.currentView === 'Month' || this.parent.currentView === 'TimelineMonth') {\n      return;\n    }\n    let timeIndicator = this.parent.element.querySelector('.' + CLONE_TIME_INDICATOR_CLASS);\n    if (!timeIndicator) {\n      timeIndicator = createElement('div', {\n        className: CLONE_TIME_INDICATOR_CLASS\n      });\n      const wrapperClass = this.parent.activeView.isTimelineView() ? DATE_HEADER_WRAP_CLASS : TIME_CELLS_WRAP_CLASS;\n      this.parent.element.querySelector('.' + wrapperClass).appendChild(timeIndicator);\n    }\n    timeIndicator.innerHTML = this.parent.getTimeString(date);\n    let offsetValue = 0;\n    if (this.parent.activeView.isTimelineView()) {\n      if (this.parent.enableRtl) {\n        const rightValue = parseInt(this.actionObj.clone.style.right, 10);\n        offsetValue = this.actionObj.action === 'drag' || this.resizeEdges.left ? rightValue + this.actionObj.clone.offsetWidth : rightValue;\n        timeIndicator.style.right = formatUnit(offsetValue);\n      } else {\n        const leftValue = parseInt(this.actionObj.clone.style.left, 10);\n        offsetValue = this.actionObj.action === 'drag' || this.resizeEdges.left ? leftValue : leftValue + this.actionObj.clone.offsetWidth;\n        timeIndicator.style.left = formatUnit(offsetValue);\n      }\n    } else {\n      offsetValue = this.actionObj.action === 'drag' || this.resizeEdges.top ? this.actionObj.clone.offsetTop : this.actionObj.clone.offsetTop + this.actionObj.clone.offsetHeight;\n      timeIndicator.style.top = formatUnit(offsetValue);\n    }\n  }\n  getResourceElements(table) {\n    return table.filter(element => parseInt(element.getAttribute('data-group-index'), 10) === this.actionObj.groupIndex);\n  }\n  getOriginalElement(element) {\n    let originalElement;\n    const guid = element.getAttribute('data-guid');\n    const isMorePopup = element.offsetParent && element.offsetParent.classList.contains(MORE_EVENT_POPUP_CLASS);\n    if (isMorePopup || this.parent.activeView.isTimelineView()) {\n      originalElement = [].slice.call(this.parent.element.querySelectorAll('[data-guid=\"' + guid + '\"]'));\n    } else {\n      const tr = closest(element, 'tr');\n      if (tr) {\n        originalElement = [].slice.call(tr.querySelectorAll('[data-guid=\"' + guid + '\"]'));\n      }\n    }\n    return originalElement;\n  }\n  createCloneElement(element) {\n    const cloneWrapper = createElement('div', {\n      innerHTML: element.outerHTML\n    });\n    const cloneElement = cloneWrapper.children[0];\n    const cloneClassLists = [CLONE_ELEMENT_CLASS];\n    cloneClassLists.push(this.actionObj.action === 'drag' ? DRAG_CLONE_CLASS : RESIZE_CLONE_CLASS);\n    if (this.parent.currentView === 'Month' || this.parent.currentView === 'TimelineMonth') {\n      cloneClassLists.push(MONTH_CLONE_ELEMENT_CLASS);\n    }\n    addClass([cloneElement], cloneClassLists);\n    addClass([element], EVENT_ACTION_CLASS);\n    if (!isNullOrUndefined(element.parentElement)) {\n      element.parentElement.appendChild(cloneElement);\n    }\n    cloneElement.style.width = formatUnit(cloneElement.offsetWidth - 2);\n    const dragElement = document.querySelector(this.parent.eventDragArea);\n    if (this.parent.eventDragArea && this.actionObj.action === 'drag' && dragElement) {\n      dragElement.appendChild(cloneElement);\n    }\n    setStyleAttribute(cloneElement, {\n      border: '0px'\n    });\n    return cloneElement;\n  }\n  removeCloneElementClasses() {\n    let elements = this.actionObj.originalElement;\n    if (this.parent.currentView === 'Month' || this.parent.currentView === 'TimelineYear' || this.parent.currentView === 'Day' || this.parent.currentView === 'Week' || this.parent.currentView === 'WorkWeek') {\n      elements = [].slice.call(this.parent.element.querySelectorAll('.' + EVENT_ACTION_CLASS));\n    }\n    removeClass(elements, EVENT_ACTION_CLASS);\n  }\n  removeCloneElement() {\n    this.actionObj.originalElement = [];\n    const dynamicEle = [].slice.call(this.parent.element.querySelectorAll('.e-dynamic-clone'));\n    for (const cloneEle of dynamicEle) {\n      remove(cloneEle);\n    }\n    for (const cloneElement of this.actionObj.cloneElement) {\n      if (!isNullOrUndefined(cloneElement.parentNode)) {\n        remove(cloneElement);\n      }\n    }\n    this.actionObj.cloneElement = [];\n    const timeIndicator = this.parent.element.querySelector('.' + CLONE_TIME_INDICATOR_CLASS);\n    if (timeIndicator) {\n      remove(timeIndicator);\n    }\n  }\n  getCursorElement(e) {\n    const pages = this.getPageCoordinates(e);\n    return document.elementFromPoint(pages.clientX, pages.clientY);\n  }\n  autoScroll() {\n    const parent = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS);\n    const yIsScrollable = parent.offsetHeight <= parent.scrollHeight;\n    const xIsScrollable = parent.offsetWidth <= parent.scrollWidth;\n    const yInBounds = yIsScrollable && parent.scrollTop >= 0 && parent.scrollTop + parent.offsetHeight <= parent.scrollHeight;\n    let xInBounds = xIsScrollable && parent.scrollLeft >= 0 && parent.scrollLeft + parent.offsetWidth <= parent.scrollWidth;\n    if (this.actionObj.action === 'resize' && this.scrollEdges.right && parent.scrollLeft + parent.offsetWidth > parent.scrollWidth) {\n      const tdCollections = [].slice.call(this.parent.getContentTable().querySelector('tr').children).length - 1;\n      const cellIndex = Math.ceil((this.actionObj.clone.offsetLeft + this.actionObj.clone.offsetWidth) / this.actionObj.cellWidth);\n      xInBounds = cellIndex === tdCollections;\n    }\n    if (yInBounds && (this.scrollEdges.top || this.scrollEdges.bottom)) {\n      parent.scrollTop += this.scrollEdges.top ? -this.actionObj.scroll.scrollBy : this.actionObj.scroll.scrollBy;\n      if (this.actionObj.action === 'resize') {\n        if (parent.scrollHeight !== parent.offsetHeight + parent.scrollTop && parent.scrollTop > 0) {\n          this.actionObj.Y += this.scrollEdges.top ? this.actionObj.scroll.scrollBy : -this.actionObj.scroll.scrollBy;\n        }\n      }\n    }\n    if (xInBounds && (this.scrollEdges.left || this.scrollEdges.right)) {\n      parent.scrollLeft += this.scrollEdges.left ? -this.actionObj.scroll.scrollBy : this.actionObj.scroll.scrollBy;\n      if (this.actionObj.action === 'resize') {\n        if (parent.scrollWidth !== parent.offsetWidth + parent.scrollLeft && parent.scrollLeft > 0) {\n          this.actionObj.X += this.scrollEdges.left ? this.actionObj.scroll.scrollBy : -this.actionObj.scroll.scrollBy;\n        }\n      }\n    }\n  }\n  autoScrollValidation() {\n    if (!this.actionObj.scroll.enable) {\n      return false;\n    }\n    const res = this.parent.boundaryValidation(this.actionObj.pageY, this.actionObj.pageX);\n    this.scrollEdges = res;\n    return res.bottom || res.top || res.left || res.right;\n  }\n  actionClass(type) {\n    if (type === 'addClass') {\n      addClass([this.parent.element], EVENT_ACTION_CLASS);\n    } else {\n      removeClass([this.parent.element], EVENT_ACTION_CLASS);\n    }\n  }\n  updateScrollPosition(e) {\n    if (this.actionObj.scroll.enable && isNullOrUndefined(this.actionObj.scrollInterval)) {\n      this.actionObj.scrollInterval = window.setInterval(() => {\n        if (this.autoScrollValidation() && !this.actionObj.clone.classList.contains(ALLDAY_APPOINTMENT_CLASS)) {\n          if (this.parent.activeView.isTimelineView() && this.parent.activeViewOptions.group.resources.length > 0 && this.actionObj.groupIndex < 0) {\n            return;\n          }\n          this.autoScroll();\n          if (this.actionObj.action === 'drag') {\n            this.parent.dragAndDropModule.updateDraggingDateTime(e);\n          } else {\n            this.parent.resizeModule.updateResizingDirection(e);\n          }\n        }\n      }, this.actionObj.scroll.timeDelay);\n    }\n  }\n  updateOriginalElement(cloneElement) {\n    let query = '[data-id=\"' + cloneElement.getAttribute('data-id') + '\"]';\n    if (this.parent.activeViewOptions.group.resources.length > 0) {\n      query = query.concat('[data-group-index = \"' + cloneElement.getAttribute('data-group-index') + '\"]');\n    }\n    const elements = [].slice.call(this.parent.element.querySelectorAll(query));\n    addClass(elements, EVENT_ACTION_CLASS);\n    const eventWrappers = [].slice.call(this.parent.element.querySelectorAll('.' + CLONE_ELEMENT_CLASS));\n    removeClass(eventWrappers, EVENT_ACTION_CLASS);\n  }\n  getUpdatedEvent(startTime, endTime, eventObj) {\n    const event = JSON.parse(JSON.stringify(eventObj));\n    event[this.parent.eventFields.startTime] = startTime;\n    event[this.parent.eventFields.endTime] = endTime;\n    return event;\n  }\n  dynamicYearlyEventsRendering(event, isResize = false) {\n    let appWidth = this.actionObj.cellWidth - 7;\n    if (isResize && (this.resizeEdges.left || this.resizeEdges.right)) {\n      appWidth = this.actionObj.cellWidth * event.count;\n    }\n    if (!isResize && this.parent.activeViewOptions.orientation === 'Horizontal' && this.parent.activeViewOptions.group.resources.length === 0) {\n      const eventObj = this.yearEvent.isSpannedEvent(event, event[this.parent.eventFields.startTime]);\n      if (eventObj[this.parent.eventFields.startTime].getTime() === eventObj[this.parent.eventFields.endTime].getTime()) {\n        eventObj.isSpanned.count = 1;\n      }\n      appWidth = eventObj.isSpanned.count * this.actionObj.cellWidth;\n    }\n    const appointmentElement = this.createAppointmentElement(this.actionObj.groupIndex, event[this.parent.eventFields.subject]);\n    appointmentElement.setAttribute('drag', 'true');\n    addClass([appointmentElement], CLONE_ELEMENT_CLASS);\n    setStyleAttribute(appointmentElement, {\n      'width': appWidth + 'px',\n      'border': '0px',\n      'pointer-events': 'none',\n      'position': 'absolute',\n      'overflow': 'hidden',\n      'padding': '3px'\n    });\n    if (this.actionObj.clone.style.backgroundColor !== '') {\n      setStyleAttribute(appointmentElement, {\n        'backgroundColor': this.actionObj.clone.style.backgroundColor\n      });\n    }\n    const date = resetTime(event[this.parent.eventFields.startTime]).getTime();\n    let query = '.' + WORK_CELLS_CLASS + '[data-date=\"' + date + '\"]';\n    if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {\n      query = '.' + WORK_CELLS_CLASS + '[data-date=\"' + date + '\"][data-group-index=\"' + this.actionObj.groupIndex + '\"]';\n    }\n    const cellTd = this.parent.element.querySelector(query);\n    if (isNullOrUndefined(cellTd)) {\n      return;\n    }\n    if (isResize) {\n      const dateHeader = cellTd.querySelector('.' + DATE_HEADER_CLASS);\n      let appHeight = this.actionObj.cellHeight * event.count - (dateHeader ? dateHeader.offsetHeight : 0) - 7;\n      if (this.resizeEdges.right || this.resizeEdges.left) {\n        appHeight = parseInt(this.actionObj.clone.style.height, 10);\n      }\n      setStyleAttribute(appointmentElement, {\n        'height': appHeight + 'px'\n      });\n    }\n    this.renderDynamicElement(cellTd, appointmentElement, true);\n    this.actionObj.cloneElement.push(appointmentElement);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  renderDynamicElement(cellTd, element, isAppointment = false) {\n    if (cellTd.querySelector('.' + APPOINTMENT_WRAPPER_CLASS)) {\n      cellTd.querySelector('.' + APPOINTMENT_WRAPPER_CLASS).appendChild(element);\n    } else {\n      const wrapper = createElement('div', {\n        className: APPOINTMENT_WRAPPER_CLASS\n      });\n      wrapper.appendChild(element);\n      cellTd.appendChild(wrapper);\n    }\n  }\n  createAppointmentElement(resIndex, innerText) {\n    const appointmentWrapper = createElement('div', {\n      className: APPOINTMENT_CLASS,\n      innerHTML: innerText\n    });\n    if (this.parent.activeViewOptions.group.resources.length > 0) {\n      appointmentWrapper.setAttribute('data-group-index', resIndex.toString());\n    }\n    return appointmentWrapper;\n  }\n  dynamicEventsRendering(event) {\n    let dateRender = this.parent.activeView.renderDates;\n    let workCells = [].slice.call(this.parent.element.querySelectorAll('.' + WORK_CELLS_CLASS));\n    let workDays = this.parent.activeViewOptions.workDays;\n    let groupOrder;\n    if (this.parent.activeViewOptions.group.resources.length > 0) {\n      const resources = this.parent.resourceBase.lastResourceLevel.filter(res => res.groupIndex === this.actionObj.groupIndex);\n      dateRender = resources[0].renderDates;\n      const elementSelector = `.${WORK_CELLS_CLASS}[data-group-index=\"${this.actionObj.groupIndex}\"]`;\n      workCells = [].slice.call(this.parent.element.querySelectorAll(elementSelector));\n      workDays = resources[0].workDays;\n      groupOrder = resources[0].groupOrder;\n    }\n    this.monthEvent.dateRender = dateRender;\n    this.monthEvent.getSlotDates(workDays);\n    if (this.resizeEdges.left || this.resizeEdges.right) {\n      const eventWrappers = [].slice.call(this.parent.element.querySelectorAll('.' + CLONE_ELEMENT_CLASS));\n      for (const wrapper of eventWrappers) {\n        remove(wrapper);\n      }\n    }\n    const spannedEvents = this.monthEvent.splitEvent(event, dateRender);\n    for (const event of spannedEvents) {\n      const day = this.parent.getIndexOfDate(dateRender, resetTime(event[this.monthEvent.fields.startTime]));\n      const diffInDays = event.data.count;\n      const appWidth = diffInDays * this.actionObj.cellWidth - 7;\n      const appointmentElement = this.monthEvent.createAppointmentElement(event, this.actionObj.groupIndex, true);\n      appointmentElement.setAttribute('drag', 'true');\n      addClass([appointmentElement], CLONE_ELEMENT_CLASS);\n      this.monthEvent.applyResourceColor(appointmentElement, event, 'backgroundColor', groupOrder);\n      setStyleAttribute(appointmentElement, {\n        'width': appWidth + 'px',\n        'border': '0px',\n        'pointer-events': 'none'\n      });\n      const cellTd = workCells[day];\n      if (cellTd && isNullOrUndefined(this.parent.eventDragArea)) {\n        this.monthEvent.renderElement(cellTd, appointmentElement, true);\n        this.actionObj.cloneElement.push(appointmentElement);\n      }\n    }\n  }\n  destroy() {\n    if (!this.parent || this.parent && this.parent.isDestroyed) {\n      return;\n    }\n    this.actionObj = {};\n    this.scrollArgs = {};\n    this.resizeEdges = {\n      left: false,\n      right: false,\n      top: false,\n      bottom: false\n    };\n    this.scrollEdges = {\n      left: false,\n      right: false,\n      top: false,\n      bottom: false\n    };\n  }\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Schedule events resize actions\n */\nclass Resize extends ActionBase {\n  wireResizeEvent(element) {\n    const resizeElement = [].slice.call(element.querySelectorAll('.' + EVENT_RESIZE_CLASS));\n    for (const element of resizeElement) {\n      EventHandler.add(element, Browser.touchStartEvent, this.resizeStart, this);\n    }\n  }\n  resizeHelper() {\n    if (this.parent.activeViewOptions.group.resources.length > 0 && this.parent.activeViewOptions.group.allowGroupEdit) {\n      for (let i = 0, len = this.actionObj.originalElement.length; i < len; i++) {\n        const cloneElement = this.createCloneElement(this.actionObj.originalElement[i]);\n        this.actionObj.cloneElement[i] = cloneElement;\n        if (this.actionObj.element === this.actionObj.originalElement[i]) {\n          this.actionObj.clone = cloneElement;\n        }\n      }\n    } else {\n      if (this.actionObj.element) {\n        this.actionObj.clone = this.createCloneElement(this.actionObj.element);\n      }\n      this.actionObj.cloneElement = [this.actionObj.clone];\n      this.actionObj.originalElement = [this.actionObj.element];\n    }\n  }\n  resizeStart(e) {\n    this.actionObj.action = 'resize';\n    this.actionObj.slotInterval = this.parent.activeViewOptions.timeScale.interval / this.parent.activeViewOptions.timeScale.slotCount;\n    this.actionObj.interval = this.actionObj.slotInterval;\n    const resizeTarget = closest(e.target, '.' + EVENT_RESIZE_CLASS);\n    this.actionObj.element = closest(resizeTarget, '.' + APPOINTMENT_CLASS);\n    this.actionObj.event = this.parent.eventBase.getEventByGuid(this.actionObj.element.getAttribute('data-guid'));\n    const eventObj = extend({}, this.actionObj.event, null, true);\n    const resizeArgs = {\n      cancel: false,\n      data: eventObj,\n      element: this.actionObj.element,\n      event: e,\n      interval: this.actionObj.interval,\n      scroll: {\n        enable: true,\n        scrollBy: 30,\n        timeDelay: 100\n      }\n    };\n    this.parent.trigger(resizeStart, resizeArgs, resizeEventArgs => {\n      if (resizeEventArgs.cancel) {\n        return;\n      }\n      this.actionClass('addClass');\n      this.parent.uiStateValues.action = true;\n      this.resizeEdges = {\n        left: resizeTarget.classList.contains(LEFT_RESIZE_HANDLER),\n        right: resizeTarget.classList.contains(RIGHT_RESIZE_HANDLER),\n        top: resizeTarget.classList.contains(TOP_RESIZE_HANDLER),\n        bottom: resizeTarget.classList.contains(BOTTOM_RESIZE_HANDLER)\n      };\n      this.actionObj.groupIndex = this.parent.uiStateValues.isGroupAdaptive ? this.parent.uiStateValues.groupIndex : 0;\n      const workCell = this.parent.element.querySelector('.' + WORK_CELLS_CLASS).getBoundingClientRect();\n      this.actionObj.cellWidth = workCell.width;\n      this.actionObj.cellHeight = workCell.height;\n      const hRows = this.parent.activeViewOptions.headerRows.map(row => row.option);\n      if (this.parent.activeView.isTimelineView() && hRows.length > 0 && ['Date', 'Hour'].indexOf(hRows.slice(-1)[0]) < 0) {\n        const tr = this.parent.getContentTable().querySelector('tr');\n        let noOfDays = 0;\n        const tdCollections = [].slice.call(tr.children);\n        for (const td of tdCollections) {\n          noOfDays += parseInt(td.getAttribute('colspan'), 10);\n        }\n        const trRect = tr.getBoundingClientRect();\n        this.actionObj.cellWidth = trRect.width / noOfDays;\n        this.actionObj.cellHeight = trRect.height;\n      }\n      const pages = this.getPageCoordinates(e);\n      this.actionObj.X = pages.pageX;\n      this.actionObj.Y = pages.pageY;\n      this.actionObj.groupIndex = parseInt(this.actionObj.element.getAttribute('data-group-index') || '0', 10);\n      this.actionObj.interval = resizeEventArgs.interval;\n      this.actionObj.scroll = resizeEventArgs.scroll;\n      this.actionObj.start = new Date(eventObj[this.parent.eventFields.startTime].getTime());\n      this.actionObj.end = new Date(eventObj[this.parent.eventFields.endTime].getTime());\n      this.actionObj.originalElement = this.getOriginalElement(this.actionObj.element);\n      if (this.parent.currentView === 'Month') {\n        this.daysVariation = -1;\n        this.monthEvent = new MonthEvent(this.parent);\n      }\n      const viewElement = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS);\n      this.scrollArgs = {\n        element: viewElement,\n        width: viewElement.scrollWidth,\n        height: viewElement.scrollHeight\n      };\n      EventHandler.add(document, Browser.touchMoveEvent, this.resizing, this);\n      EventHandler.add(document, Browser.touchEndEvent, this.resizeStop, this);\n    });\n  }\n  resizing(e) {\n    if (this.parent.quickPopup) {\n      this.parent.quickPopup.quickPopupHide();\n    }\n    if (this.parent.element.querySelectorAll('.' + RESIZE_CLONE_CLASS).length === 0) {\n      this.resizeHelper();\n    }\n    if (!isNullOrUndefined(e.target) && e.target.classList.contains(DISABLE_DATES)) {\n      return;\n    }\n    const pages = this.getPageCoordinates(e);\n    this.actionObj.pageX = pages.pageX;\n    this.actionObj.pageY = pages.pageY;\n    this.updateScrollPosition(e);\n    this.updateResizingDirection(e);\n    const eventObj = extend({}, this.actionObj.event, null, true);\n    const resizeArgs = {\n      cancel: false,\n      data: eventObj,\n      element: this.actionObj.element,\n      event: e,\n      startTime: this.actionObj.start,\n      endTime: this.actionObj.end\n    };\n    if (this.parent.group.resources.length > 0) {\n      resizeArgs.groupIndex = this.actionObj.groupIndex;\n    }\n    this.parent.trigger(resizing, resizeArgs);\n  }\n  updateResizingDirection(e) {\n    if (this.parent.currentView === 'Month' || this.parent.currentView === 'TimelineYear') {\n      this.monthResizing();\n      return;\n    }\n    const resizeValidation = this.resizeValidation(e);\n    if (this.resizeEdges.left) {\n      if (resizeValidation) {\n        const leftStyles = this.getLeftRightStyles(e, true);\n        if (parseInt(leftStyles.width, 10) < 1) {\n          return;\n        }\n        for (const cloneElement of this.actionObj.cloneElement) {\n          setStyleAttribute(cloneElement, leftStyles);\n          addClass([cloneElement], LEFT_RESIZE_HANDLER);\n        }\n      }\n      this.horizontalResizing(!this.parent.enableRtl);\n    }\n    if (this.resizeEdges.right) {\n      if (resizeValidation) {\n        const rightStyles = this.getLeftRightStyles(e, false);\n        if (parseInt(rightStyles.width, 10) < 1) {\n          return;\n        }\n        for (const cloneElement of this.actionObj.cloneElement) {\n          setStyleAttribute(cloneElement, rightStyles);\n          addClass([cloneElement], RIGHT_RESIZE_HANDLER);\n        }\n      }\n      this.horizontalResizing(this.parent.enableRtl);\n    }\n    if (this.resizeEdges.top) {\n      if (resizeValidation) {\n        const topStyles = this.getTopBottomStyles(e, true);\n        if (parseInt(topStyles.height, 10) < 1) {\n          return;\n        }\n        for (const cloneElement of this.actionObj.cloneElement) {\n          setStyleAttribute(cloneElement, topStyles);\n          addClass([cloneElement], TOP_RESIZE_HANDLER);\n        }\n      }\n      this.verticalResizing(true);\n    }\n    if (this.resizeEdges.bottom) {\n      if (resizeValidation) {\n        const bottomStyles = this.getTopBottomStyles(e, false);\n        if (parseInt(bottomStyles.height, 10) < 1) {\n          return;\n        }\n        for (const cloneElement of this.actionObj.cloneElement) {\n          setStyleAttribute(cloneElement, bottomStyles);\n          addClass([cloneElement], BOTTOM_RESIZE_HANDLER);\n        }\n      }\n      this.verticalResizing(false);\n    }\n  }\n  monthResizing() {\n    this.removeCloneElement();\n    if (isNullOrUndefined(this.actionObj.pageX) || isNullOrUndefined(this.actionObj.pageY)) {\n      return;\n    }\n    const td = document.elementFromPoint(this.actionObj.pageX, this.actionObj.pageY);\n    if (isNullOrUndefined(td)) {\n      return;\n    }\n    const resizeTime = this.parent.getDateFromElement(td);\n    const isSameCell = this.parent.activeViewOptions.group.resources.length > 0 ? parseInt(td.getAttribute('data-group-index'), 10) === this.actionObj.groupIndex : true;\n    let startTime = new Date(this.actionObj.event[this.parent.eventFields.startTime].getTime());\n    let endTime = new Date(this.actionObj.event[this.parent.eventFields.endTime].getTime());\n    if (!this.parent.enableRtl && this.resizeEdges.left || this.parent.enableRtl && this.resizeEdges.right || this.resizeEdges.top) {\n      startTime = resizeTime;\n    } else if (!this.parent.enableRtl && this.resizeEdges.right || this.parent.enableRtl && this.resizeEdges.left || this.resizeEdges.bottom) {\n      endTime = addDays(resizeTime, 1);\n    }\n    if (isSameCell && startTime < endTime) {\n      this.actionObj.start = startTime;\n      this.actionObj.end = endTime;\n      const event = this.getUpdatedEvent(this.actionObj.start, this.actionObj.end, this.actionObj.event);\n      if (this.parent.currentView === 'TimelineYear') {\n        this.yearEventsRendering(event);\n      } else {\n        this.dynamicEventsRendering(event);\n      }\n      this.updateOriginalElement(this.actionObj.clone);\n    }\n  }\n  yearEventsRendering(event) {\n    const eventWrappers = [].slice.call(this.parent.element.querySelectorAll('.' + CLONE_ELEMENT_CLASS));\n    for (const wrapper of eventWrappers) {\n      remove(wrapper);\n    }\n    let endDate = new Date(event[this.parent.eventFields.endTime]);\n    let monthDiff = 0;\n    if (this.parent.activeViewOptions.group.resources.length === 0) {\n      monthDiff = this.getMonthDiff(event[this.parent.eventFields.startTime], addDays(endDate, -1));\n    }\n    for (let i = 0; i <= monthDiff; i++) {\n      let eventObj;\n      if (this.parent.activeViewOptions.group.resources.length === 0) {\n        eventObj = this.getEventCount(event, this.actionObj.start.getMonth() + i);\n      } else {\n        eventObj = extend({}, event, null, true);\n        endDate = this.resizeEdges.left || this.resizeEdges.right ? addDays(endDate, -1) : endDate;\n        eventObj.count = this.getMonthDiff(event[this.parent.eventFields.startTime], endDate) + 1;\n      }\n      this.dynamicYearlyEventsRendering(eventObj, true);\n    }\n  }\n  getMonthDiff(startDate, endDate) {\n    let months;\n    months = (endDate.getFullYear() - startDate.getFullYear()) * 12;\n    months -= startDate.getMonth();\n    months += endDate.getMonth();\n    return months <= 0 ? 0 : months;\n  }\n  getEventCount(eventObj, month) {\n    const eventData = extend({}, eventObj, null, true);\n    const eventStart = eventData[this.parent.eventFields.startTime];\n    const eventEnd = eventData[this.parent.eventFields.endTime];\n    const monthStart = new Date(this.parent.selectedDate.getFullYear(), month, 1);\n    const monthEnd = addDays(new Date(this.parent.selectedDate.getFullYear(), month + 1, 0), 1);\n    let count = 1;\n    if (eventStart.getTime() < monthStart.getTime()) {\n      eventData[this.parent.eventFields.startTime] = monthStart;\n    }\n    if (eventEnd.getTime() > monthEnd.getTime()) {\n      eventData[this.parent.eventFields.endTime] = monthEnd;\n    }\n    if (this.parent.activeViewOptions.group.resources.length === 0) {\n      count = Math.ceil((eventData[this.parent.eventFields.endTime].getTime() - eventData[this.parent.eventFields.startTime].getTime()) / MS_PER_DAY);\n    }\n    eventData.count = count;\n    return eventData;\n  }\n  resizeStop(e) {\n    EventHandler.remove(document, Browser.touchMoveEvent, this.resizing);\n    EventHandler.remove(document, Browser.touchEndEvent, this.resizeStop);\n    clearInterval(this.actionObj.scrollInterval);\n    this.actionObj.scrollInterval = null;\n    this.removeCloneElementClasses();\n    this.removeCloneElement();\n    this.actionClass('removeClass');\n    this.parent.uiStateValues.action = false;\n    const resizeArgs = {\n      cancel: false,\n      data: this.getChangedData(),\n      element: this.actionObj.element,\n      event: e\n    };\n    this.parent.trigger(resizeStop, resizeArgs, resizeEventArgs => {\n      if (resizeEventArgs.cancel) {\n        return;\n      }\n      if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.rowAutoHeight && !this.parent.activeViewOptions.group.allowGroupEdit && !this.parent.virtualScrollModule && this.parent.activeViewOptions.group.byGroupID) {\n        this.parent.crudModule.crudObj.sourceEvent = [this.parent.resourceBase.lastResourceLevel[parseInt(resizeEventArgs.element.getAttribute('data-group-index'), 10)]];\n        this.parent.crudModule.crudObj.targetEvent = this.parent.crudModule.crudObj.sourceEvent;\n        this.parent.crudModule.crudObj.isCrudAction = true;\n      }\n      this.saveChangedData(resizeEventArgs);\n    });\n  }\n  verticalResizing(isTop) {\n    let offsetValue = this.actionObj.clone.offsetTop;\n    if (!isTop) {\n      offsetValue += this.actionObj.clone.offsetHeight;\n    }\n    const minutes = offsetValue / this.actionObj.cellHeight * this.actionObj.slotInterval;\n    const element = this.actionObj.clone.offsetParent;\n    if (isNullOrUndefined(element)) {\n      return;\n    }\n    const resizeTime = resetTime(this.parent.getDateFromElement(element));\n    resizeTime.setHours(this.parent.activeView.getStartHour().getHours());\n    resizeTime.setMinutes(minutes + this.parent.activeView.getStartHour().getMinutes());\n    if (isTop) {\n      this.actionObj.start = this.calculateIntervalTime(resizeTime);\n    } else {\n      this.actionObj.end = this.calculateIntervalTime(resizeTime);\n    }\n    this.updateTimePosition(resizeTime);\n  }\n  horizontalResizing(isLeft) {\n    const eventStart = new Date(this.actionObj.event[this.parent.eventFields.startTime].getTime());\n    const eventEnd = new Date(this.actionObj.event[this.parent.eventFields.endTime].getTime());\n    let resizeTime;\n    let isDateHeader = false;\n    let headerName = this.parent.currentView;\n    const isTimeViews = ['TimelineDay', 'TimelineWeek', 'TimelineWorkWeek'].indexOf(this.parent.currentView) > -1;\n    const isTimelineMonth = this.parent.currentView === 'TimelineMonth';\n    const isWithoutScale = isTimelineMonth || isTimeViews && !this.parent.activeViewOptions.timeScale.enable;\n    if (this.parent.activeView.isTimelineView()) {\n      const tr = this.parent.getContentTable().querySelector('tr');\n      if (this.parent.activeViewOptions.headerRows.length > 0) {\n        const rows = this.parent.activeViewOptions.headerRows.map(row => row.option);\n        headerName = rows.slice(-1)[0];\n        if (isTimelineMonth && headerName === 'Hour') {\n          headerName = rows.slice(-2)[0] || 'Month';\n        }\n      }\n      resizeTime = isLeft ? eventStart : eventEnd;\n      let cellIndex = 0;\n      const tdCollections = [].slice.call(tr.children);\n      let isLastCell = false;\n      const pixelsPerMinute = this.actionObj.cellWidth / (this.parent.activeViewOptions.timeScale.interval / this.parent.activeViewOptions.timeScale.slotCount);\n      let offset = parseFloat(this.parent.enableRtl ? this.actionObj.clone.style.right : this.actionObj.clone.style.left);\n      offset = Math.round(offset / pixelsPerMinute) * pixelsPerMinute;\n      if (['Year', 'Month', 'Week', 'Date'].indexOf(headerName) !== -1) {\n        let noOfDays = 0;\n        for (const td of tdCollections) {\n          noOfDays += parseInt(td.getAttribute('colspan'), 10);\n        }\n        let offsetValue = this.parent.enableRtl ? parseInt(this.actionObj.clone.style.right, 10) : parseInt(this.actionObj.clone.style.left, 10);\n        offsetValue = Math.round(offsetValue / this.actionObj.cellWidth) * this.actionObj.cellWidth;\n        if (!isLeft) {\n          offsetValue += this.actionObj.clone.getBoundingClientRect().width - this.actionObj.cellWidth;\n        }\n        cellIndex = Math.floor(offsetValue / Math.floor(tr.getBoundingClientRect().width / noOfDays));\n        isDateHeader = isTimeViews && headerName === 'Date';\n        cellIndex = isLeft ? cellIndex : isTimelineMonth ? cellIndex + 1 : cellIndex;\n        isLastCell = cellIndex === tdCollections.length;\n        cellIndex = cellIndex < 0 ? 0 : cellIndex >= noOfDays ? noOfDays - 1 : cellIndex;\n      } else {\n        const cellWidth = this.actionObj.cellWidth;\n        cellIndex = isLeft ? Math.floor(offset / this.actionObj.cellWidth) : Math.ceil((offset + (this.actionObj.clone.getBoundingClientRect().width - cellWidth)) / this.actionObj.cellWidth);\n        if (this.parent.enableRtl) {\n          let cellOffsetWidth = 0;\n          if (headerName === 'TimelineMonth' || !this.parent.activeViewOptions.timeScale.enable && !isTimelineMonth) {\n            cellOffsetWidth = this.actionObj.cellWidth;\n          }\n          const offsetWidth = Math.floor(offset / this.actionObj.cellWidth) * this.actionObj.cellWidth + (isLeft ? 0 : this.actionObj.clone.getBoundingClientRect().width - cellOffsetWidth);\n          cellIndex = Math.floor(offsetWidth / this.actionObj.cellWidth);\n        }\n        isLastCell = cellIndex === tdCollections.length;\n        cellIndex = this.getIndex(cellIndex);\n      }\n      let resizeDate;\n      if (['Year', 'Month', 'Week', 'Date'].indexOf(headerName) !== -1) {\n        resizeDate = new Date(this.parent.activeView.renderDates[cellIndex].getTime());\n      } else {\n        resizeDate = this.parent.getDateFromElement(tr.children[cellIndex]);\n      }\n      if (['TimelineMonth', 'Year', 'Month', 'Week', 'Date'].indexOf(headerName) !== -1 || !this.parent.activeViewOptions.timeScale.enable) {\n        resizeTime = new Date(resizeDate.setHours(resizeTime.getHours(), resizeTime.getMinutes(), resizeTime.getSeconds()));\n      } else {\n        if (!isLeft) {\n          offset += this.actionObj.clone.getBoundingClientRect().width;\n        }\n        let spanMinutes = Math.ceil(this.actionObj.slotInterval / this.actionObj.cellWidth * (offset - Math.floor(offset / this.actionObj.cellWidth) * this.actionObj.cellWidth));\n        spanMinutes = isLastCell || !isLeft && spanMinutes === 0 ? this.actionObj.slotInterval : spanMinutes;\n        resizeTime = new Date(resizeDate.getTime());\n        resizeTime.setMinutes(resizeTime.getMinutes() + spanMinutes);\n        this.updateTimePosition(resizeTime);\n      }\n    } else {\n      const cloneIndex = closest(this.actionObj.clone, 'td').cellIndex;\n      const originalWidth = Math.ceil((isLeft ? this.actionObj.element.getBoundingClientRect().width : 0) / this.actionObj.cellWidth) * this.actionObj.cellWidth;\n      const noOfDays = Math.ceil((this.actionObj.clone.getBoundingClientRect().width - originalWidth) / this.actionObj.cellWidth);\n      const tr = closest(this.actionObj.clone, 'tr');\n      let dayIndex = isLeft ? cloneIndex - noOfDays : cloneIndex + noOfDays - 1;\n      dayIndex = this.getIndex(dayIndex);\n      resizeTime = this.parent.getDateFromElement(tr.children[dayIndex]);\n      if (isLeft) {\n        resizeTime.setHours(eventStart.getHours(), eventStart.getMinutes(), eventStart.getSeconds());\n      } else {\n        resizeTime.setHours(eventEnd.getHours(), eventEnd.getMinutes(), eventEnd.getSeconds());\n      }\n    }\n    if (isLeft) {\n      if (eventEnd.getTime() - resizeTime.getTime() <= 0) {\n        resizeTime = isWithoutScale ? resetTime(eventEnd) : eventStart;\n      }\n      this.actionObj.start = this.parent.activeViewOptions.timeScale.enable ? this.calculateIntervalTime(resizeTime) : resizeTime;\n    } else {\n      const isTimeScaleViews = isTimeViews && this.parent.activeViewOptions.timeScale.enable;\n      let resizeEnd = (!isTimeScaleViews || isDateHeader || isTimeViews && ['Week', 'Month', 'Year'].indexOf(headerName) > -1) && resizeTime.getHours() === 0 && resizeTime.getMinutes() === 0 ? addDays(resizeTime, 1) : resizeTime;\n      if (isWithoutScale && resizeEnd.getTime() - eventStart.getTime() <= 0) {\n        resizeEnd = addDays(resetTime(eventStart), 1);\n      }\n      this.actionObj.end = this.parent.activeViewOptions.timeScale.enable && this.parent.currentView !== 'Month' ? this.calculateIntervalTime(resizeEnd) : resizeEnd;\n    }\n  }\n  getTopBottomStyles(e, isTop) {\n    const viewElement = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS);\n    const slotInterval = this.actionObj.cellHeight / this.actionObj.slotInterval * this.actionObj.interval;\n    let clnHeight = isTop ? this.actionObj.element.offsetHeight + (this.actionObj.Y - this.actionObj.pageY) : this.actionObj.element.offsetHeight + (this.actionObj.pageY - this.actionObj.Y);\n    let clnTop = isTop ? this.actionObj.element.offsetTop - (this.actionObj.Y - this.actionObj.pageY) : this.actionObj.clone.offsetTop;\n    clnHeight = clnTop < 0 ? this.actionObj.clone.offsetHeight : this.actionObj.clone.offsetTop + this.actionObj.clone.offsetHeight > this.scrollArgs.height ? this.actionObj.clone.offsetHeight : clnHeight;\n    clnTop = clnTop < 0 ? 0 : clnTop;\n    clnTop = isTop ? Math.floor(clnTop / slotInterval) * slotInterval : clnTop;\n    clnHeight = clnTop + clnHeight >= viewElement.scrollHeight ? viewElement.scrollHeight - clnTop : Math.ceil(clnHeight / slotInterval) * slotInterval;\n    const styles = {\n      height: formatUnit(clnHeight < this.actionObj.cellHeight ? Math.floor(clnHeight / slotInterval) * slotInterval : clnHeight),\n      top: formatUnit(clnHeight < this.actionObj.cellHeight && isTop ? Math.ceil(clnTop / slotInterval) * slotInterval : clnTop),\n      left: '0px',\n      right: '0px',\n      width: '100%'\n    };\n    return styles;\n  }\n  getLeftRightStyles(e, isLeft) {\n    const styles = {};\n    const isTimelineView = this.parent.activeView.isTimelineView();\n    const isTimeViews = ['TimelineDay', 'TimelineWeek', 'TimelineWorkWeek'].indexOf(this.parent.currentView) > -1 && this.parent.activeViewOptions.timeScale.enable;\n    const slotInterval = this.actionObj.cellWidth / this.actionObj.slotInterval * this.actionObj.interval;\n    const pageWidth = isLeft ? this.actionObj.X - this.actionObj.pageX : this.actionObj.pageX - this.actionObj.X;\n    const targetWidth = isTimelineView ? this.actionObj.element.getBoundingClientRect().width / this.actionObj.cellWidth * this.actionObj.cellWidth : this.parent.currentView === 'Month' ? this.actionObj.element.getBoundingClientRect().width : Math.ceil(this.actionObj.element.getBoundingClientRect().width / this.actionObj.cellWidth) * this.actionObj.cellWidth;\n    let offsetWidth = targetWidth + Math.ceil(pageWidth / this.actionObj.cellWidth) * this.actionObj.cellWidth;\n    const left = this.parent.enableRtl ? parseInt(this.actionObj.element.style.right, 10) : this.actionObj.clone.offsetLeft;\n    if (isTimeViews) {\n      offsetWidth = targetWidth + Math.ceil(pageWidth / slotInterval) * slotInterval;\n      offsetWidth = Math.round((left + offsetWidth) / slotInterval) * slotInterval - left;\n      this.actionObj.event[this.parent.eventFields.isAllDay] = false;\n    }\n    let width = !isLeft && offsetWidth + this.actionObj.clone.offsetLeft > this.scrollArgs.width ? this.actionObj.clone.getBoundingClientRect().width : offsetWidth < this.actionObj.cellWidth ? offsetWidth : offsetWidth;\n    if (this.parent.enableRtl) {\n      let rightValue = isTimelineView ? parseInt(this.actionObj.element.style.right, 10) : -(offsetWidth - this.actionObj.cellWidth);\n      rightValue = isTimelineView ? rightValue : isLeft ? 0 : rightValue > 0 ? 0 : rightValue;\n      if (isTimelineView && !isLeft) {\n        rightValue = Math.ceil((this.actionObj.element.offsetLeft + (this.actionObj.element.getBoundingClientRect().width + (this.actionObj.pageX - this.actionObj.X))) / slotInterval) * slotInterval;\n        rightValue = rightValue < 0 ? Math.abs(rightValue) : -rightValue;\n      }\n      rightValue = rightValue >= this.scrollArgs.width ? this.scrollArgs.width - this.actionObj.cellWidth : rightValue;\n      styles.right = formatUnit(rightValue);\n      width = width + rightValue > this.scrollArgs.width ? this.actionObj.clone.getBoundingClientRect().width : width;\n    } else {\n      let offsetLeft = isLeft ? this.actionObj.element.offsetLeft - (this.actionObj.X - this.actionObj.pageX) : this.parent.enableRtl ? this.actionObj.element.offsetLeft : 0;\n      if (isTimelineView) {\n        offsetLeft = isLeft ? offsetLeft : parseInt(this.actionObj.clone.style.left, 10);\n        if (this.parent.enableRtl) {\n          offsetLeft = !isLeft ? this.actionObj.pageX < this.actionObj.X - this.actionObj.clone.getBoundingClientRect().width ? parseInt(this.actionObj.clone.style.right, 10) : offsetLeft : offsetLeft;\n        } else {\n          offsetLeft = isLeft ? this.actionObj.pageX > this.actionObj.X + this.actionObj.clone.getBoundingClientRect().width && this.actionObj.clone.getBoundingClientRect().width === this.actionObj.cellWidth ? parseInt(this.actionObj.clone.style.left, 10) : offsetLeft : offsetLeft;\n        }\n      }\n      const leftValue = offsetLeft;\n      offsetLeft = isTimelineView ? isTimeViews ? isLeft ? Math.floor(offsetLeft / slotInterval) * slotInterval : offsetLeft : Math.floor(offsetLeft / this.actionObj.cellWidth) * this.actionObj.cellWidth : Math.ceil(Math.abs(offsetLeft) / this.actionObj.cellWidth) * this.actionObj.cellWidth;\n      if (offsetLeft < 0) {\n        offsetLeft = 0;\n        width = this.actionObj.clone.getBoundingClientRect().width;\n      }\n      const cloneWidth = Math.ceil(this.actionObj.clone.getBoundingClientRect().width / this.actionObj.cellWidth) * this.actionObj.cellWidth;\n      if (isLeft) {\n        styles.left = formatUnit(isTimelineView ? offsetLeft : isLeft ? leftValue < 0 ? -offsetLeft : Math.ceil((targetWidth - cloneWidth) / this.actionObj.cellWidth) * this.actionObj.cellWidth : offsetLeft);\n      }\n    }\n    styles.width = formatUnit(width);\n    return styles;\n  }\n  resizeValidation(e) {\n    const pages = this.getPageCoordinates(e);\n    const viewDimension = this.getContentAreaDimension();\n    const isTimeScale = this.parent.activeView.isTimelineView() && this.parent.activeViewOptions.timeScale.enable;\n    let cellWidth = this.actionObj.cellWidth;\n    let resizeValidation = false;\n    if (this.resizeEdges.left) {\n      if (pages.pageX < viewDimension.leftOffset && pages.pageX >= viewDimension.left && isTimeScale) {\n        cellWidth = 0;\n      }\n      resizeValidation = pages.pageX - cellWidth >= viewDimension.left;\n    }\n    if (this.resizeEdges.right) {\n      if (pages.pageX > viewDimension.rightOffset && pages.pageX <= viewDimension.right && isTimeScale) {\n        cellWidth = 0;\n      }\n      resizeValidation = pages.pageX + cellWidth <= viewDimension.right;\n    }\n    if (this.resizeEdges.top) {\n      resizeValidation = this.actionObj.clone.offsetTop >= viewDimension.top;\n    }\n    if (this.resizeEdges.bottom) {\n      resizeValidation = this.actionObj.clone.offsetTop + this.actionObj.clone.offsetHeight <= this.scrollArgs.height;\n    }\n    return resizeValidation;\n  }\n  /**\n   * Get module name\n   *\n   * @returns {string} Returns the module name..\n   */\n  getModuleName() {\n    return 'resize';\n  }\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst EVENT_GAP$2 = 2;\n/**\n * Year view events render\n */\nclass YearEvent extends TimelineEvent {\n  constructor(parent) {\n    super(parent, 'day');\n    this.isResource = false;\n  }\n  renderAppointments() {\n    if (this.parent.dragAndDropModule) {\n      this.parent.dragAndDropModule.setDragArea();\n    }\n    this.fields = this.parent.eventFields;\n    const elementSelector = this.parent.currentView === 'Year' ? '.' + APPOINTMENT_CLASS : '.' + APPOINTMENT_WRAPPER_CLASS + ',.' + MORE_INDICATOR_CLASS;\n    const eventWrappers = [].slice.call(this.parent.element.querySelectorAll(elementSelector));\n    for (const wrapper of eventWrappers) {\n      remove(wrapper);\n    }\n    this.renderedEvents = [];\n    if (this.parent.currentView === 'Year') {\n      this.yearViewEvents();\n    } else {\n      this.removeCellHeight();\n      if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {\n        this.isResource = true;\n        this.timelineResourceEvents();\n      } else {\n        this.timelineYearViewEvents();\n      }\n    }\n    this.parent.renderTemplates();\n    this.parent.notify(contentReady, {});\n  }\n  yearViewEvents() {\n    const months = this.getMonths();\n    for (const month of months) {\n      const queryString = `.e-month-calendar:nth-child(${months.indexOf(month) + 1}) td.e-work-cells`;\n      const workCells = [].slice.call(this.parent.element.querySelectorAll(queryString));\n      const monthDate = new Date(this.parent.selectedDate.getFullYear(), month, 1);\n      const monthStart = this.parent.calendarUtil.getMonthStartDate(new Date(monthDate.getTime()));\n      const monthEnd = this.parent.calendarUtil.getMonthEndDate(new Date(monthDate.getTime()));\n      let startDate = getWeekFirstDate(monthStart, this.parent.firstDayOfWeek);\n      const endDate = addDays(getWeekLastDate(monthEnd, this.parent.firstDayOfWeek), 1);\n      for (let index = 0; startDate.getTime() < endDate.getTime(); index++) {\n        const start = resetTime(new Date(startDate.getTime()));\n        const end = addDays(new Date(start.getTime()), 1);\n        const filterEvents = this.parent.eventBase.filterEvents(start, end);\n        if (filterEvents.length > 0) {\n          const workCell = workCells[index];\n          if (workCell) {\n            workCell.appendChild(createElement('div', {\n              className: APPOINTMENT_CLASS\n            }));\n          }\n        }\n        startDate = addDays(new Date(startDate.getTime()), 1);\n      }\n    }\n  }\n  timelineYearViewEvents() {\n    const workCell = this.parent.element.querySelector('.' + WORK_CELLS_CLASS);\n    this.cellWidth = workCell.offsetWidth;\n    this.cellHeader = getOuterHeight(workCell.querySelector('.' + DATE_HEADER_CLASS));\n    const eventTable = this.parent.element.querySelector('.' + EVENT_TABLE_CLASS);\n    this.eventHeight = getElementHeightFromClass(eventTable, APPOINTMENT_CLASS);\n    const wrapperCollection = [].slice.call(this.parent.element.querySelectorAll('.' + APPOINTMENT_CONTAINER_CLASS));\n    const months = this.getMonths();\n    for (let row = 0; row < months.length; row++) {\n      const wrapper = wrapperCollection[row];\n      let td = row + 1;\n      const eventWrapper = createElement('div', {\n        className: APPOINTMENT_WRAPPER_CLASS\n      });\n      wrapper.appendChild(eventWrapper);\n      let monthStart = new Date(this.parent.selectedDate.getFullYear(), months[row], 1);\n      const monthEnd = new Date(monthStart.getFullYear(), monthStart.getMonth() + 1, 0);\n      let dayIndex = monthStart.getDay();\n      const isSpannedCollection = [];\n      if (this.parent.activeViewOptions.orientation === 'Horizontal') {\n        this.renderedEvents = [];\n      }\n      while (monthStart.getTime() <= monthEnd.getTime()) {\n        let leftValue;\n        let rightValue;\n        if (this.parent.activeViewOptions.orientation === 'Vertical') {\n          const wrapper = wrapperCollection[dayIndex];\n          td = dayIndex + 1;\n          let eventWrapper = wrapper.querySelector('.' + APPOINTMENT_WRAPPER_CLASS);\n          if (!eventWrapper) {\n            eventWrapper = createElement('div', {\n              className: APPOINTMENT_WRAPPER_CLASS\n            });\n            wrapper.appendChild(eventWrapper);\n          }\n          if (this.parent.enableRtl) {\n            rightValue = row * this.cellWidth;\n          } else {\n            leftValue = row * this.cellWidth;\n          }\n        } else {\n          if (this.parent.enableRtl) {\n            rightValue = (dayIndex + monthStart.getDate() - 1) * this.cellWidth;\n          } else {\n            leftValue = (dayIndex + monthStart.getDate() - 1) * this.cellWidth;\n          }\n        }\n        const rowTd = this.parent.element.querySelector(`.e-content-wrap tr:nth-child(${td}) td`);\n        this.cellHeight = rowTd.offsetHeight;\n        const dayStart = resetTime(new Date(monthStart.getTime()));\n        const dayEnd = addDays(new Date(dayStart.getTime()), 1);\n        let resource;\n        if (this.parent.uiStateValues.isGroupAdaptive) {\n          resource = this.parent.resourceBase.lastResourceLevel[this.parent.uiStateValues.groupIndex];\n        }\n        let dayEvents = this.parent.eventBase.filterEvents(dayStart, dayEnd, undefined, resource);\n        dayEvents = this.parent.eventBase.sortByDateTime(dayEvents);\n        for (let index = 0, count = dayEvents.length; index < count; index++) {\n          const eventData = extend({}, dayEvents[index], null, true);\n          this.updateSpannedEvents(eventData, dayStart, dayEnd);\n          const overlapIndex = this.getIndex(dayStart);\n          eventData.Index = overlapIndex;\n          const availedHeight = this.cellHeader + this.eventHeight * (overlapIndex + 1) + EVENT_GAP$2 + this.moreIndicatorHeight;\n          const appArea = this.cellHeight - this.cellHeader - this.moreIndicatorHeight;\n          const renderedAppCount = Math.floor(appArea / (this.eventHeight + EVENT_GAP$2));\n          const moreIndicatorCount = count - renderedAppCount <= 0 ? 1 : count - renderedAppCount;\n          if (this.parent.activeViewOptions.orientation === 'Horizontal') {\n            const isRendered = this.renderedEvents.filter(eventObj => eventObj.Guid === eventData.Guid);\n            const isSpanned = isSpannedCollection.filter(eventObj => eventObj.Guid === eventData.Guid);\n            if (isRendered.length > 0 && isRendered[0].MoreIndicator || isSpanned.length > 0 && isSpanned[0].MoreIndicator) {\n              const moreIndex = this.parent.activeViewOptions.orientation === 'Horizontal' ? row : dayIndex;\n              this.renderMoreIndicator(eventWrapper, moreIndicatorCount, dayStart, moreIndex, leftValue, rightValue);\n              continue;\n            } else if (isRendered.length > 0 || isSpanned.length > 0) {\n              continue;\n            }\n          }\n          const isRowAutoHeight = this.parent.rowAutoHeight && this.parent.activeViewOptions.orientation === 'Horizontal';\n          if (isRowAutoHeight || this.cellHeight > availedHeight) {\n            this.renderEvent(eventWrapper, eventData, row, leftValue, rightValue, monthStart, dayIndex);\n            this.updateCellHeight(rowTd, availedHeight);\n            isSpannedCollection.push(eventData);\n          } else {\n            const moreIndex = this.parent.activeViewOptions.orientation === 'Horizontal' ? row : dayIndex;\n            this.renderMoreIndicator(eventWrapper, moreIndicatorCount, dayStart, moreIndex, leftValue, rightValue);\n            if (this.parent.activeViewOptions.orientation === 'Horizontal') {\n              eventData.MoreIndicator = true;\n              this.renderedEvents.push(eventData);\n              isSpannedCollection.push(eventData);\n            }\n          }\n        }\n        monthStart = addDays(new Date(monthStart.getTime()), 1);\n        if (this.parent.activeViewOptions.orientation === 'Vertical') {\n          dayIndex++;\n          this.renderedEvents = [];\n        }\n      }\n    }\n  }\n  updateSpannedEvents(eventObj, dayStart, dayEnd) {\n    const isLeftRightResize = this.isResource && this.parent.activeViewOptions.orientation === 'Vertical' || !this.isResource && this.parent.activeViewOptions.orientation === 'Horizontal';\n    const data = {\n      isLeft: true,\n      isRight: true,\n      isBottom: true,\n      isTop: true\n    };\n    if (dayStart.getTime() <= eventObj[this.fields.startTime].getTime()) {\n      if (isLeftRightResize) {\n        data.isLeft = false;\n      } else {\n        data.isTop = false;\n      }\n    }\n    if (dayEnd.getTime() >= eventObj[this.fields.endTime].getTime() || isLeftRightResize && !this.isResource && addDays(dayEnd, -1).getMonth() === eventObj[this.fields.endTime].getMonth()) {\n      if (isLeftRightResize) {\n        data.isRight = false;\n      } else {\n        data.isBottom = false;\n      }\n    }\n    eventObj.data = data;\n  }\n  timelineResourceEvents() {\n    const workCell = this.parent.element.querySelector('.' + WORK_CELLS_CLASS);\n    this.cellWidth = workCell.offsetWidth;\n    this.cellHeader = 0;\n    const eventTable = this.parent.element.querySelector('.' + EVENT_TABLE_CLASS);\n    this.eventHeight = getElementHeightFromClass(eventTable, APPOINTMENT_CLASS);\n    const wrapperCollection = [].slice.call(this.parent.element.querySelectorAll('.' + APPOINTMENT_CONTAINER_CLASS));\n    const resources = this.parent.uiStateValues.isGroupAdaptive ? [this.parent.resourceBase.lastResourceLevel[this.parent.uiStateValues.groupIndex]] : this.parent.resourceBase.lastResourceLevel;\n    const months = this.getMonths();\n    if (this.parent.activeViewOptions.orientation === 'Horizontal') {\n      for (let month = 0; month < months.length; month++) {\n        const monthStart = new Date(this.parent.selectedDate.getFullYear(), months[month], 1);\n        for (let i = 0, len = resources.length; i < len; i++) {\n          this.renderedEvents = [];\n          this.renderResourceEvent(wrapperCollection[month], resources[i], month, i, monthStart);\n        }\n      }\n    } else {\n      for (let i = 0, len = resources.length; i < len; i++) {\n        this.renderedEvents = [];\n        for (let month = 0; month < months.length; month++) {\n          const monthStart = new Date(this.parent.selectedDate.getFullYear(), months[month], 1);\n          this.renderResourceEvent(wrapperCollection[i], resources[i], month, i, monthStart);\n        }\n      }\n    }\n  }\n  renderResourceEvent(wrapper, resource, month, index, monthStart) {\n    const eventWrapper = createElement('div', {\n      className: APPOINTMENT_WRAPPER_CLASS\n    });\n    wrapper.appendChild(eventWrapper);\n    const monthEnd = addDays(lastDateOfMonth(new Date(monthStart.getTime())), 1);\n    const eventDatas = this.parent.eventBase.filterEvents(monthStart, monthEnd, undefined, resource);\n    const rowIndex = this.parent.activeViewOptions.orientation === 'Vertical' ? index : month;\n    const td = this.parent.element.querySelector(`.e-content-wrap tr:nth-child(${rowIndex + 1}) td`);\n    this.cellHeight = td.offsetHeight;\n    this.groupOrder = resource.groupOrder;\n    for (let a = 0; a < eventDatas.length; a++) {\n      const data = eventDatas[a];\n      let overlapIndex;\n      const eventData = extend({}, data, null, true);\n      if (this.parent.activeViewOptions.group.resources.length > 0) {\n        const eventObj = this.isSpannedEvent(eventData, monthStart);\n        overlapIndex = this.getIndex(eventObj[this.fields.startTime]);\n        eventData.Index = overlapIndex;\n      } else {\n        overlapIndex = this.getIndex(eventData[this.fields.startTime]);\n        eventData.Index = overlapIndex;\n      }\n      const availedHeight = this.cellHeader + this.eventHeight * (a + 1) + EVENT_GAP$2 + this.moreIndicatorHeight;\n      const leftValue = this.parent.activeViewOptions.orientation === 'Vertical' ? month * this.cellWidth : index * this.cellWidth;\n      if (this.parent.rowAutoHeight || this.cellHeight > availedHeight) {\n        this.renderEvent(eventWrapper, eventData, month, leftValue, leftValue, monthStart, index);\n        this.updateCellHeight(td, availedHeight);\n      } else {\n        const moreIndex = this.parent.activeViewOptions.orientation === 'Horizontal' ? month : index;\n        this.renderMoreIndicator(eventWrapper, eventDatas.length - a, monthStart, moreIndex, leftValue, leftValue, index);\n        if (this.parent.activeViewOptions.orientation === 'Horizontal') {\n          for (let i = index; i < eventDatas.length; i++) {\n            this.renderedEvents.push(extend({}, eventDatas[i], {\n              Index: overlapIndex + i\n            }, true));\n          }\n        }\n        break;\n      }\n    }\n  }\n  // eslint-disable-next-line max-len\n  renderEvent(wrapper, eventData, row, left, right, monthDate, rowIndex) {\n    const eventObj = this.isSpannedEvent(eventData, monthDate);\n    const wrap = this.createEventElement(eventObj);\n    let width;\n    let index;\n    if (eventObj.isSpanned.count === 1) {\n      const endTime = addDays(eventObj[this.fields.endTime], -1);\n      eventObj[this.fields.endTime] = endTime > eventObj[this.fields.startTime] ? endTime : eventObj[this.fields.endTime];\n    }\n    if (eventObj[this.fields.startTime] > eventObj[this.fields.endTime]) {\n      return;\n    }\n    if (this.parent.activeViewOptions.orientation === 'Horizontal') {\n      index = row + 1;\n      if (eventObj[this.fields.startTime].getTime() === eventObj[this.fields.endTime].getTime()) {\n        eventObj.isSpanned.count = 1;\n      }\n      width = eventObj.isSpanned.count * this.cellWidth;\n    } else {\n      index = rowIndex + 1;\n      width = this.cellWidth;\n    }\n    const rowTd = this.parent.element.querySelector(`.e-content-wrap tr:nth-child(${index}) td`);\n    const top = rowTd.offsetTop + this.cellHeader + this.eventHeight * eventObj.Index + EVENT_GAP$2;\n    setStyleAttribute(wrap, {\n      'width': width + 'px',\n      'height': this.eventHeight + 'px',\n      'left': left + 'px',\n      'right': right + 'px',\n      'top': top + 'px'\n    });\n    const args = {\n      data: eventObj,\n      element: wrap,\n      cancel: false,\n      type: 'event'\n    };\n    this.parent.trigger(eventRendered, args, eventArgs => {\n      if (!eventArgs.cancel) {\n        wrapper.appendChild(wrap);\n        this.wireAppointmentEvents(wrap, eventObj);\n        if (this.parent.activeViewOptions.group.resources.length > 0) {\n          this.renderedEvents.push(extend({}, eventObj, null, true));\n        } else if (this.parent.activeViewOptions.orientation === 'Vertical') {\n          this.renderedEvents.push(extend({}, eventObj, null, true));\n        } else if ((eventObj.isSpanned.isRight || eventObj.isSpanned.isLeft) && this.parent.activeViewOptions.orientation === 'Horizontal' || !eventObj.isSpanned.isRight) {\n          this.renderedEvents.push(extend({}, eventObj, null, true));\n        }\n      }\n    });\n  }\n  // eslint-disable-next-line max-len\n  renderMoreIndicator(wrapper, count, startDate, row, left, right, index) {\n    if (this.parent.activeViewOptions.group.resources.length === 0 && wrapper.querySelector('[data-start-date=\"' + startDate.getTime() + '\"]')) {\n      return;\n    }\n    let endDate;\n    if (this.parent.activeViewOptions.group.resources.length > 0) {\n      endDate = addDays(lastDateOfMonth(new Date(startDate.getTime())), 1);\n    } else {\n      endDate = addDays(new Date(startDate.getTime()), 1);\n    }\n    const moreIndicator = this.getMoreIndicatorElement(count, startDate, endDate);\n    const rowTr = this.parent.element.querySelector(`.e-content-wrap tr:nth-child(${row + 1})`);\n    const top = rowTr.offsetTop + (this.cellHeight - this.moreIndicatorHeight);\n    left = Math.floor(left / this.cellWidth) * this.cellWidth;\n    right = Math.floor(right / this.cellWidth) * this.cellWidth;\n    setStyleAttribute(moreIndicator, {\n      'width': this.cellWidth + 'px',\n      'left': left + 'px',\n      'right': right + 'px',\n      'top': top + 'px'\n    });\n    if (!isNullOrUndefined(index)) {\n      moreIndicator.setAttribute('data-group-index', index.toString());\n    }\n    wrapper.appendChild(moreIndicator);\n    EventHandler.add(moreIndicator, 'click', this.moreIndicatorClick, this);\n  }\n  createEventElement(record) {\n    const eventSubject = record[this.fields.subject] || this.parent.eventSettings.fields.subject.default || this.parent.localeObj.getConstant('addTitle');\n    const eventWrapper = createElement('div', {\n      className: APPOINTMENT_CLASS,\n      attrs: {\n        'data-id': 'Appointment_' + record[this.fields.id],\n        'data-guid': record.Guid,\n        'role': 'button',\n        'tabindex': '0',\n        'aria-readonly': this.parent.eventBase.getReadonlyAttribute(record),\n        'aria-selected': 'false',\n        'aria-grabbed': 'true',\n        'aria-label': this.parent.getAnnouncementString(record)\n      }\n    });\n    if (this.cssClass) {\n      addClass([eventWrapper], this.cssClass);\n    }\n    if (record[this.fields.isReadonly]) {\n      addClass([eventWrapper], READ_ONLY);\n    }\n    if (this.parent.activeViewOptions.group.resources.length > 0) {\n      const resIndex = this.getGroupIndexFromEvent(record);\n      eventWrapper.setAttribute('data-group-index', resIndex.toString());\n    }\n    let templateElement = [];\n    const eventObj = extend({}, record, null, true);\n    if (this.parent.activeViewOptions.eventTemplate) {\n      const templateId = this.parent.element.id + '_' + this.parent.activeViewOptions.eventTemplateName + 'eventTemplate';\n      templateElement = this.parent.getAppointmentTemplate()(eventObj, this.parent, 'eventTemplate', templateId, false);\n    } else {\n      const locationEle = record[this.fields.location] || this.parent.eventSettings.fields.location.default || '';\n      const subjectEle = createElement('div', {\n        className: SUBJECT_CLASS,\n        innerHTML: eventSubject + (locationEle ? ';&nbsp' + locationEle : '')\n      });\n      const startTimeEle = createElement('div', {\n        className: APPOINTMENT_TIME + (this.parent.isAdaptive ? ' ' + DISABLE_CLASS : ''),\n        innerHTML: this.parent.getTimeString(eventObj[this.fields.startTime])\n      });\n      const endTimeEle = createElement('div', {\n        className: APPOINTMENT_TIME + (this.parent.isAdaptive ? ' ' + DISABLE_CLASS : ''),\n        innerHTML: this.parent.getTimeString(eventObj[this.fields.endTime])\n      });\n      addClass([subjectEle], 'e-text-center');\n      if (record[this.fields.isAllDay]) {\n        templateElement = [subjectEle];\n      } else if (!eventObj.isLeft && !eventObj.isRight) {\n        templateElement = [startTimeEle, subjectEle, endTimeEle];\n      } else {\n        if (!eventObj.isLeft) {\n          templateElement.push(startTimeEle);\n        }\n        templateElement.push(subjectEle);\n        if (!eventObj.isRight) {\n          templateElement.push(endTimeEle);\n        }\n      }\n    }\n    const appointmentDetails = createElement('div', {\n      className: APPOINTMENT_DETAILS\n    });\n    append(templateElement, appointmentDetails);\n    eventWrapper.appendChild(appointmentDetails);\n    this.renderResizeHandler(eventWrapper, record.data, record[this.fields.isReadonly]);\n    this.applyResourceColor(eventWrapper, eventObj, 'backgroundColor', this.groupOrder);\n    return eventWrapper;\n  }\n  isSpannedEvent(eventObj, monthDate) {\n    const monthStart = new Date(monthDate.getFullYear(), monthDate.getMonth(), 1);\n    const monthEnd = addDays(new Date(monthDate.getFullYear(), monthDate.getMonth() + 1, 0), 1);\n    const eventData = extend({}, eventObj, null, true);\n    const eventStart = eventData[this.fields.startTime];\n    const eventEnd = eventData[this.fields.endTime];\n    const isSpanned = {\n      isLeft: false,\n      isRight: false,\n      count: 1\n    };\n    if (this.isResource) {\n      this.updateSpannedEvents(eventObj, monthStart, monthEnd);\n    }\n    if (eventStart.getTime() < monthStart.getTime()) {\n      eventData[this.fields.startTime] = monthStart;\n      isSpanned.isLeft = true;\n    }\n    if (eventEnd.getTime() > monthEnd.getTime()) {\n      eventData[this.fields.endTime] = monthEnd;\n      isSpanned.isRight = true;\n    }\n    if (this.parent.activeViewOptions.group.resources.length === 0) {\n      let end = resetTime(eventData[this.fields.endTime]).getTime();\n      const start = resetTime(eventData[this.fields.startTime]).getTime();\n      if (eventObj[this.fields.isAllDay] && end === eventObj[this.fields.endTime].getTime() || isSpanned.isRight) {\n        end = addDays(new Date(end), -1).getTime();\n      }\n      isSpanned.count = Math.ceil((end - start) / MS_PER_DAY) + 1;\n    }\n    eventData.isSpanned = isSpanned;\n    if (resetTime(eventStart).getTime() < resetTime(this.parent.minDate).getTime()) {\n      eventData[this.fields.startTime] = this.parent.minDate;\n    }\n    if (resetTime(eventEnd).getTime() > resetTime(this.parent.maxDate).getTime()) {\n      eventData[this.fields.endTime] = this.parent.maxDate;\n    }\n    return eventData;\n  }\n  getOverlapEvents(date, appointments) {\n    const appointmentsList = [];\n    let dateStart;\n    let dateEnd;\n    if (this.parent.activeViewOptions.group.resources.length > 0) {\n      const monthStart = this.parent.calendarUtil.getMonthStartDate(new Date(date.getTime()));\n      const monthEnd = addDays(this.parent.calendarUtil.getMonthEndDate(new Date(date.getTime())), -1);\n      dateStart = resetTime(new Date(monthStart.getTime())).getTime();\n      dateEnd = resetTime(new Date(monthEnd.getTime())).getTime();\n    } else {\n      if (this.parent.rowAutoHeight) {\n        dateStart = resetTime(new Date(date.getTime())).getTime();\n        dateEnd = addDays(resetTime(new Date(date.getTime())), 1).getTime();\n      } else {\n        dateStart = dateEnd = resetTime(new Date(date.getTime())).getTime();\n      }\n    }\n    for (const app of appointments) {\n      const appStart = new Date(app[this.fields.startTime].getTime());\n      const appEnd = new Date(app[this.fields.endTime].getTime());\n      if (this.parent.activeViewOptions.orientation === 'Vertical' && this.parent.activeViewOptions.group.resources.length > 0) {\n        if (resetTime(appStart).getTime() >= dateStart && resetTime(appEnd).getTime() <= dateEnd) {\n          appointmentsList.push(app);\n        }\n      } else {\n        const timeCondition = app[this.fields.isAllDay] ? resetTime(appEnd).getTime() > dateStart : resetTime(appEnd).getTime() >= dateStart;\n        if (resetTime(appStart).getTime() <= dateStart && timeCondition || resetTime(appStart).getTime() >= dateStart && resetTime(appEnd).getTime() <= dateEnd) {\n          appointmentsList.push(app);\n        }\n      }\n    }\n    return appointmentsList;\n  }\n  getMonths() {\n    // eslint-disable-next-line prefer-spread\n    return Array.apply(null, {\n      length: this.parent.monthsCount\n    }).map((value, index) => this.parent.firstMonthOfYear + index);\n  }\n  removeCellHeight() {\n    const elementSelector = `.${MONTH_HEADER_WRAPPER} tbody tr,.${RESOURCE_COLUMN_TABLE_CLASS} tbody tr,.${CONTENT_TABLE_CLASS} tbody tr`;\n    const rows = [].slice.call(this.element.querySelectorAll(elementSelector));\n    for (const row of rows) {\n      row.firstElementChild.style.height = '';\n    }\n  }\n  destroy() {\n    super.destroy();\n    this.parent = null;\n  }\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst MINUTES_PER_DAY = 1440;\n/**\n * Schedule events drag actions\n */\nclass DragAndDrop extends ActionBase {\n  constructor() {\n    super(...arguments);\n    this.widthUptoCursorPoint = 0;\n    this.heightUptoCursorPoint = 0;\n    this.cursorPointIndex = 0;\n    this.isHeaderRows = false;\n    this.isTimelineDayProcess = false;\n    this.widthPerMinute = 0;\n    this.heightPerMinute = 0;\n    this.minDiff = 0;\n    this.isStepDragging = false;\n    this.isMorePopupOpened = false;\n    this.isAllDayDrag = false;\n    this.isMultiSelect = false;\n    this.multiData = [];\n    this.updatedData = [];\n    this.swagData = [];\n    this.startTime = 0;\n    this.isAllDayTarget = false;\n    this.targetTd = null;\n    this.isCursorAhead = false;\n  }\n  wireDragEvent(element) {\n    new Draggable(element, {\n      abort: '.' + EVENT_RESIZE_CLASS,\n      clone: true,\n      isDragScroll: true,\n      enableTapHold: this.parent.isAdaptive,\n      enableTailMode: this.parent.eventDragArea ? true : false,\n      cursorAt: this.parent.eventDragArea ? {\n        left: -20,\n        top: -20\n      } : {\n        left: 0,\n        top: 0\n      },\n      dragArea: this.dragArea,\n      dragStart: this.dragStart.bind(this),\n      drag: this.drag.bind(this),\n      dragStop: this.dragStop.bind(this),\n      enableAutoScroll: false,\n      helper: this.dragHelper.bind(this),\n      queryPositionInfo: this.dragPosition.bind(this)\n    });\n  }\n  setDragArea() {\n    const dragElement = document.querySelector(this.parent.eventDragArea);\n    this.dragArea = this.parent.eventDragArea && dragElement ? dragElement : this.parent.element.querySelector('.' + CONTENT_TABLE_CLASS);\n  }\n  dragHelper(e) {\n    this.setDragActionDefaultValues();\n    this.actionObj.element = e.element;\n    this.actionObj.action = 'drag';\n    let elements = [];\n    if (!this.parent.allowMultiDrag || isNullOrUndefined(this.parent.selectedElements) || this.parent.selectedElements.length === 0 || this.parent.selectedElements.length > 0 && this.parent.selectedElements.indexOf(this.actionObj.element) === -1) {\n      elements = [e.element];\n    } else {\n      elements = this.parent.selectedElements;\n      this.isMultiSelect = true;\n    }\n    elements.forEach(ele => {\n      const cloneElement = this.createCloneElement(ele);\n      if (ele.getAttribute('data-guid') === this.actionObj.element.getAttribute('data-guid')) {\n        this.actionObj.clone = cloneElement;\n        if (!this.parent.eventDragArea && this.parent.currentView !== 'Month' && this.parent.activeViewOptions.timeScale.enable && !this.parent.activeView.isTimelineView() && !this.actionObj.element.classList.contains(ALLDAY_APPOINTMENT_CLASS)) {\n          setStyleAttribute(this.actionObj.clone, {\n            cursor: 'move',\n            left: '0%',\n            right: '0%',\n            width: '100%'\n          });\n        }\n        this.actionObj.clone.style.top = formatUnit(this.actionObj.element.offsetTop);\n      }\n      this.actionObj.cloneElement.push(cloneElement);\n      this.actionObj.originalElement.push(ele);\n    });\n    return this.actionObj.clone;\n  }\n  dragPosition(e) {\n    if (this.parent.eventDragArea) {\n      return {\n        left: e.left,\n        top: e.top\n      };\n    }\n    const cellHeight = this.actionObj.cellHeight / this.actionObj.slotInterval * this.actionObj.interval;\n    let leftValue = formatUnit(0);\n    if (this.parent.currentView === 'Month') {\n      leftValue = e.left;\n    }\n    let cloneRight;\n    if (this.isStepDragging) {\n      cloneRight = Math.ceil(this.actionObj.clone.getBoundingClientRect().right) + this.actionObj.interval;\n    } else {\n      cloneRight = this.actionObj.clone.getBoundingClientRect().right;\n    }\n    const dragArea = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS);\n    const contentWrapRight = dragArea.getBoundingClientRect().right;\n    if (this.parent.activeView.isTimelineView() && this.parent.currentView !== 'TimelineYear' && !this.parent.enableRtl && this.actionObj.pageX > cloneRight && !this.isMorePopupOpened && !(this.actionObj.pageX > contentWrapRight)) {\n      this.isCursorAhead = true;\n    }\n    if (this.parent.activeView.isTimelineView()) {\n      leftValue = formatUnit(this.actionObj.clone.offsetLeft);\n    }\n    let topValue;\n    if (this.parent.activeView.isTimelineView() || !this.parent.timeScale.enable || !isNullOrUndefined(this.actionObj.clone.offsetParent) && this.actionObj.clone.offsetParent.classList.contains(MORE_EVENT_POPUP_CLASS)) {\n      topValue = formatUnit(this.actionObj.clone.offsetTop);\n    } else if (this.parent.currentView === 'Month') {\n      topValue = formatUnit(0);\n    } else if (this.actionObj.clone.classList.contains(ALLDAY_APPOINTMENT_CLASS)) {\n      topValue = formatUnit(this.parent.element.querySelector('.' + ALLDAY_ROW_CLASS).offsetTop);\n      setStyleAttribute(this.actionObj.clone, {\n        width: formatUnit(Math.ceil(this.actionObj.clone.offsetWidth / this.actionObj.cellWidth) * this.actionObj.cellWidth),\n        right: this.parent.enableRtl && formatUnit(0)\n      });\n    } else {\n      if (this.actionObj.element.classList.contains(ALLDAY_APPOINTMENT_CLASS) && !this.actionObj.clone.classList.contains(ALLDAY_APPOINTMENT_CLASS)) {\n        setStyleAttribute(this.actionObj.clone, {\n          height: formatUnit(this.actionObj.cellHeight),\n          width: formatUnit(this.actionObj.cellWidth - 1),\n          pointerEvents: 'none'\n        });\n      }\n      let top = parseInt(e.top, 10);\n      top = top < 0 ? 0 : top;\n      topValue = formatUnit(Math.ceil(top / cellHeight) * cellHeight);\n      const scrollHeight = this.parent.element.querySelector('.e-content-wrap').scrollHeight;\n      const cloneBottom = parseInt(topValue, 10) + this.actionObj.clone.offsetHeight;\n      if (cloneBottom > scrollHeight) {\n        topValue = parseInt(topValue, 10) - (cloneBottom - scrollHeight) + 'px';\n      }\n    }\n    return {\n      left: leftValue,\n      top: topValue\n    };\n  }\n  setDragActionDefaultValues() {\n    this.actionObj.action = 'drag';\n    this.actionObj.isAllDay = null;\n    this.actionObj.slotInterval = this.parent.activeViewOptions.timeScale.interval / this.parent.activeViewOptions.timeScale.slotCount;\n    this.actionObj.interval = this.actionObj.slotInterval;\n    const workCell = this.parent.element.querySelector('.' + WORK_CELLS_CLASS);\n    this.actionObj.cellWidth = workCell.offsetWidth;\n    this.actionObj.cellHeight = workCell.offsetHeight;\n  }\n  dragStart(e) {\n    const eventGuid = this.actionObj.element.getAttribute('data-guid');\n    this.actionObj.event = this.parent.eventBase.getEventByGuid(eventGuid);\n    const eventObj = extend({}, this.actionObj.event, null, true);\n    if (!isNullOrUndefined(eventObj)) {\n      this.startTime = eventObj[this.parent.eventFields.startTime].getTime();\n    }\n    const dragArgs = {\n      cancel: false,\n      data: eventObj,\n      selectedData: this.getSelectedData(),\n      event: e,\n      excludeSelectors: null,\n      element: this.actionObj.element,\n      interval: this.actionObj.interval,\n      navigation: {\n        enable: false,\n        timeDelay: 2000\n      },\n      scroll: {\n        enable: true,\n        scrollBy: 30,\n        timeDelay: 100\n      }\n    };\n    this.parent.trigger(dragStart, dragArgs, dragEventArgs => {\n      if (dragEventArgs.cancel || !isNullOrUndefined(this.actionObj.element) && isNullOrUndefined(this.actionObj.element.parentElement)) {\n        const dragObj = this.actionObj.element.ej2_instances[0];\n        if (!isNullOrUndefined(dragObj)) {\n          dragObj.intDestroy(e.event);\n        }\n        this.actionObj.action = '';\n        this.removeCloneElementClasses();\n        this.removeCloneElement();\n        return;\n      }\n      this.actionClass('addClass');\n      this.parent.uiStateValues.action = true;\n      this.actionObj.start = eventObj[this.parent.eventFields.startTime];\n      this.actionObj.end = eventObj[this.parent.eventFields.endTime];\n      this.actionObj.groupIndex = parseInt(this.actionObj.element.getAttribute('data-group-index') || '0', 10);\n      this.actionObj.interval = dragEventArgs.interval;\n      this.actionObj.navigation = dragEventArgs.navigation;\n      this.actionObj.scroll = dragEventArgs.scroll;\n      this.actionObj.excludeSelectors = dragEventArgs.excludeSelectors;\n      const viewElement = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS);\n      this.scrollArgs = {\n        element: viewElement,\n        width: viewElement.scrollWidth,\n        height: viewElement.scrollHeight\n      };\n      this.widthPerMinute = this.actionObj.cellWidth / this.actionObj.slotInterval * this.actionObj.interval;\n      this.heightPerMinute = this.actionObj.cellHeight / this.actionObj.slotInterval * this.actionObj.interval;\n      this.widthUptoCursorPoint = 0;\n      this.heightUptoCursorPoint = 0;\n      this.cursorPointIndex = -1;\n      this.isHeaderRows = false;\n      this.isTimelineDayProcess = false;\n      this.minDiff = 0;\n      this.isMorePopupOpened = false;\n      this.daysVariation = -1;\n      this.isAllDayTarget = this.actionObj.clone.classList.contains(ALLDAY_APPOINTMENT_CLASS);\n      if ((this.parent.activeView.isTimelineView() || !this.parent.timeScale.enable) && this.parent.currentView !== 'TimelineYear') {\n        if (!isNullOrUndefined(this.actionObj.clone.offsetParent) && this.actionObj.clone.offsetParent.classList.contains(MORE_EVENT_POPUP_CLASS)) {\n          this.isMorePopupOpened = true;\n        }\n        this.actionObj.pageX = e.event.pageX;\n        const rows = this.parent.activeViewOptions.headerRows;\n        this.isHeaderRows = rows.length > 0 && rows[rows.length - 1].option !== 'Hour' && rows[rows.length - 1].option !== 'Date';\n        this.isTimelineDayProcess = !this.parent.activeViewOptions.timeScale.enable || this.isHeaderRows || this.parent.currentView === 'TimelineMonth' || rows.length > 0 && rows[rows.length - 1].option === 'Date';\n        this.isStepDragging = !this.isTimelineDayProcess && this.actionObj.slotInterval !== this.actionObj.interval;\n        if (this.isTimelineDayProcess) {\n          this.timelineEventModule = new TimelineEvent(this.parent, 'day');\n        } else {\n          this.timelineEventModule = new TimelineEvent(this.parent, 'hour');\n        }\n      }\n      if (this.parent.currentView === 'TimelineYear') {\n        this.yearEvent = new YearEvent(this.parent);\n      }\n      if (this.parent.currentView === 'Month') {\n        this.startTime = resetTime(new Date(this.startTime)).getTime();\n        this.updateOriginalElement(this.actionObj.clone);\n        this.monthEvent = new MonthEvent(this.parent);\n      }\n      if (this.parent.currentView === 'Day' || this.parent.currentView === 'Week' || this.parent.currentView === 'WorkWeek') {\n        this.verticalEvent = new VerticalEvent(this.parent);\n        this.verticalEvent.initializeValues();\n        const splitEvents = this.splitEvent(this.actionObj.event);\n        splitEvents.forEach(event => {\n          let query = `.e-day-wrapper[data-date=\"${resetTime(event[this.parent.eventFields.startTime]).getTime()}\"]`;\n          if (this.parent.activeViewOptions.group.resources.length > 0) {\n            query = query.concat('[data-group-index = \"' + this.actionObj.groupIndex + '\"]');\n          }\n          const appWrap = this.parent.element.querySelector(query);\n          if (appWrap) {\n            const appEle = appWrap.querySelector('[data-id=\"' + this.actionObj.clone.getAttribute('data-id') + '\"]');\n            if (appEle) {\n              addClass([appEle], EVENT_ACTION_CLASS);\n            }\n          }\n        });\n      }\n    });\n  }\n  getSelectedData() {\n    if (this.isMultiSelect && this.multiData.length === 0 && this.parent.selectedElements.length > 0) {\n      for (const element of this.parent.selectedElements) {\n        const eventGuid = element.getAttribute('data-guid');\n        const data = this.parent.eventBase.getEventByGuid(eventGuid);\n        this.multiData.push(extend({}, data, null, true));\n      }\n    }\n    return this.multiData;\n  }\n  drag(e) {\n    if (this.parent.quickPopup) {\n      this.parent.quickPopup.quickPopupHide(true);\n    }\n    if (!isNullOrUndefined(e.target) && e.target.classList.contains(DISABLE_DATES)) {\n      return;\n    }\n    const eventObj = extend({}, this.actionObj.event, null, true);\n    const eventArgs = this.getPageCoordinates(e);\n    this.actionObj.Y = this.actionObj.pageY = eventArgs.pageY;\n    this.actionObj.X = this.actionObj.pageX = eventArgs.pageX;\n    this.actionObj.target = e.target;\n    this.widthUptoCursorPoint = this.widthUptoCursorPoint === 0 ? Math.ceil(Math.abs(this.actionObj.clone.getBoundingClientRect().left - this.actionObj.X) / this.widthPerMinute) * this.widthPerMinute : this.widthUptoCursorPoint;\n    this.widthUptoCursorPoint = this.isMorePopupOpened ? this.actionObj.cellWidth : this.widthUptoCursorPoint;\n    this.heightUptoCursorPoint = this.heightUptoCursorPoint === 0 ? Math.ceil(Math.abs(this.actionObj.clone.getBoundingClientRect().top - this.actionObj.Y) / this.heightPerMinute) * this.heightPerMinute : this.heightUptoCursorPoint;\n    this.isAllDayDrag = this.parent.activeViewOptions.timeScale.enable ? this.actionObj.clone.classList.contains(ALLDAY_APPOINTMENT_CLASS) : this.actionObj.event[this.parent.eventFields.isAllDay];\n    if (this.isStepDragging && this.minDiff === 0) {\n      this.calculateMinutesDiff(eventObj);\n    }\n    if ((this.parent.currentView === 'Month' || this.isAllDayDrag) && this.daysVariation < 0) {\n      const date = this.parent.getDateFromElement(this.actionObj.target);\n      if (!isNullOrUndefined(date)) {\n        const currentDate = resetTime(date);\n        const startDate = resetTime(new Date(eventObj[this.parent.eventFields.startTime].getTime()));\n        this.daysVariation = (currentDate.getTime() - startDate.getTime()) / MS_PER_DAY;\n      } else {\n        this.daysVariation = 0;\n      }\n    } else {\n      this.daysVariation = 0;\n    }\n    if (this.parent.eventDragArea) {\n      const targetElement = eventArgs.target;\n      this.actionObj.clone.style.top = formatUnit(targetElement.offsetTop);\n      this.actionObj.clone.style.left = formatUnit(targetElement.offsetLeft);\n      const currentTarget = closest(targetElement, '.' + ROOT);\n      if (!currentTarget) {\n        this.actionObj.clone.style.height = '';\n        this.actionObj.clone.style.width = '';\n      } else {\n        if (!(this.parent.currentView === 'Week' || this.parent.currentView === 'WorkWeek' || this.parent.currentView === 'Day')) {\n          this.actionObj.clone.style.width = formatUnit(this.actionObj.element.offsetWidth);\n        }\n      }\n    }\n    this.updateScrollPosition(e);\n    this.updateNavigatingPosition(e);\n    this.updateDraggingDateTime(e);\n    const dragArgs = {\n      data: eventObj,\n      event: e,\n      element: this.actionObj.element,\n      startTime: this.actionObj.start,\n      endTime: this.actionObj.end,\n      selectedData: this.updatedData\n    };\n    if (this.parent.group.resources.length > 0) {\n      dragArgs.groupIndex = this.actionObj.groupIndex;\n    }\n    this.parent.trigger(drag, dragArgs);\n  }\n  calculateMinutesDiff(eventObj) {\n    if (this.parent.enableRtl) {\n      this.minDiff = (this.actionObj.clone.offsetWidth - this.widthUptoCursorPoint) / this.widthPerMinute * this.actionObj.interval;\n    } else {\n      this.minDiff = this.widthUptoCursorPoint / this.widthPerMinute * this.actionObj.interval;\n    }\n    const startDate = eventObj[this.parent.eventFields.startTime];\n    const startTime = this.parent.activeView.renderDates[0];\n    const startEndHours = getStartEndHours(startTime, this.parent.activeView.getStartHour(), this.parent.activeView.getEndHour());\n    if (startEndHours.startHour.getTime() > startDate.getTime()) {\n      this.minDiff = this.minDiff + (startEndHours.startHour.getTime() - startDate.getTime()) / MS_PER_MINUTE;\n    }\n  }\n  dragStop(e) {\n    this.isCursorAhead = false;\n    this.removeCloneElementClasses();\n    this.removeCloneElement();\n    clearInterval(this.actionObj.navigationInterval);\n    this.actionObj.navigationInterval = null;\n    clearInterval(this.actionObj.scrollInterval);\n    this.actionObj.scrollInterval = null;\n    this.actionClass('removeClass');\n    this.parent.uiStateValues.action = false;\n    this.actionObj.action = null;\n    if (this.isAllowDrop(e)) {\n      return;\n    }\n    const target = !e.target.classList.contains('e-work-cells') && this.parent.cellTemplate ? closest(e.target, '.e-work-cells') : e.target;\n    const dragArgs = {\n      cancel: false,\n      data: this.getChangedData(this.updatedData),\n      selectedData: this.updatedData,\n      event: e,\n      element: this.actionObj.element,\n      target: target\n    };\n    this.parent.trigger(dragStop, dragArgs, dragEventArgs => {\n      if (dragEventArgs.cancel) {\n        return;\n      }\n      if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.activeViewOptions.group.allowGroupEdit && !this.parent.rowAutoHeight && !this.parent.virtualScrollModule && this.parent.activeViewOptions.group.byGroupID) {\n        this.parent.crudModule.crudObj.isCrudAction = true;\n        this.parent.crudModule.crudObj.sourceEvent = [this.parent.resourceBase.lastResourceLevel[parseInt(dragArgs.element.getAttribute('data-group-index'), 10)]];\n        const currentGroupIndex = parseInt(dragArgs.target.getAttribute('data-group-index'), 10) || this.actionObj.groupIndex;\n        this.parent.crudModule.crudObj.targetEvent = [this.parent.resourceBase.lastResourceLevel[currentGroupIndex]];\n      }\n      this.saveChangedData(dragEventArgs, this.isMultiSelect);\n    });\n    this.updatedData = [];\n    this.multiData = [];\n    this.isMultiSelect = false;\n    this.parent.selectedElements = [];\n  }\n  updateNavigatingPosition(e) {\n    if (this.actionObj.navigation.enable) {\n      let currentDate = this.parent.getCurrentTime();\n      if (isNullOrUndefined(this.actionObj.navigationInterval)) {\n        this.actionObj.navigationInterval = window.setInterval(() => {\n          if (currentDate) {\n            const crtDate = this.parent.getCurrentTime();\n            const end = crtDate.getSeconds();\n            let start = currentDate.getSeconds() + this.actionObj.navigation.timeDelay / 1000;\n            start = start >= 60 ? start - 60 : start;\n            if (start === end) {\n              currentDate = this.parent.getCurrentTime();\n              this.viewNavigation(e);\n              this.updateDraggingDateTime(e);\n            }\n          }\n        }, this.actionObj.navigation.timeDelay);\n      }\n    }\n  }\n  updateDraggingDateTime(e) {\n    if (!isNullOrUndefined(this.actionObj.clone.offsetParent) && this.actionObj.clone.offsetParent.classList.contains(MORE_EVENT_POPUP_CLASS)) {\n      this.morePopupEventDragging(e);\n    } else if (this.parent.activeView.isTimelineView() && this.parent.currentView !== 'TimelineYear') {\n      this.timelineEventModule.dateRender = this.parent.activeView.renderDates;\n      this.timelineEventModule.cellWidth = this.actionObj.cellWidth;\n      this.timelineEventModule.getSlotDates();\n      this.actionObj.cellWidth = this.isHeaderRows ? this.timelineEventModule.cellWidth : this.actionObj.cellWidth;\n      this.calculateTimelineTime(e);\n    } else {\n      if (this.parent.currentView === 'Month' || this.parent.currentView === 'TimelineYear') {\n        this.calculateVerticalDate(e);\n      } else {\n        this.calculateVerticalTime(e);\n      }\n    }\n  }\n  navigationWrapper() {\n    if (!this.parent.activeView.isTimelineView()) {\n      if (this.parent.currentView === 'Month' || !this.parent.timeScale.enable) {\n        const outerWrapperCls = [].slice.call(this.parent.element.querySelectorAll('.' + WORK_CELLS_CLASS));\n        this.actionObj.index = this.parent.activeView.renderDates.length < this.actionObj.index ? this.parent.activeView.renderDates.length - 1 : this.actionObj.index;\n        let targetWrapper = outerWrapperCls[this.actionObj.index].querySelector('.' + APPOINTMENT_WRAPPER_CLASS);\n        if (!targetWrapper) {\n          targetWrapper = createElement('div', {\n            className: APPOINTMENT_WRAPPER_CLASS\n          });\n          outerWrapperCls[this.actionObj.index].appendChild(targetWrapper);\n        }\n        targetWrapper.appendChild(this.actionObj.clone);\n      } else {\n        const wrapperClass = this.actionObj.clone.classList.contains(ALLDAY_APPOINTMENT_CLASS) ? '.' + ALLDAY_APPOINTMENT_WRAPPER_CLASS : '.' + APPOINTMENT_WRAPPER_CLASS;\n        this.parent.element.querySelectorAll(wrapperClass).item(this.actionObj.index).appendChild(this.actionObj.clone);\n        if (wrapperClass === '.' + ALLDAY_APPOINTMENT_WRAPPER_CLASS) {\n          const elementHeight = this.getAllDayEventHeight();\n          const event = [].slice.call(this.parent.element.querySelectorAll('.' + ALLDAY_CELLS_CLASS + ':first-child'));\n          if (event[0].offsetHeight < elementHeight) {\n            for (const e of event) {\n              e.style.height = (elementHeight + 2) / 12 + 'em';\n            }\n          }\n          this.actionObj.clone.style.height = formatUnit(elementHeight);\n        }\n        this.actionObj.height = parseInt(this.actionObj.clone.style.height, 10);\n      }\n    } else {\n      let outWrapper;\n      if (this.parent.activeViewOptions.group.resources.length > 0) {\n        outWrapper = this.parent.element.querySelectorAll('.e-appointment-container:not(.e-hidden)').item(this.actionObj.index);\n      } else {\n        outWrapper = this.parent.element.querySelector('.' + APPOINTMENT_CONTAINER_CLASS);\n      }\n      if (!isNullOrUndefined(outWrapper)) {\n        let tarWrapper = outWrapper.querySelector('.' + APPOINTMENT_WRAPPER_CLASS);\n        if (!tarWrapper) {\n          tarWrapper = createElement('div', {\n            className: APPOINTMENT_WRAPPER_CLASS\n          });\n          outWrapper.appendChild(tarWrapper);\n        }\n        this.actionObj.cloneElement.forEach(ele => {\n          tarWrapper.appendChild(ele);\n        });\n      }\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  viewNavigation(e) {\n    let navigationType;\n    const dragArea = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS);\n    if (dragArea && (!this.scrollEdges.top && !this.scrollEdges.bottom || closest(this.actionObj.clone, '.' + ALLDAY_APPOINTMENT_WRAPPER_CLASS))) {\n      if (dragArea.scrollLeft === 0 && Math.round(this.actionObj.X) <= Math.round(dragArea.getBoundingClientRect().left + this.actionObj.cellWidth + window.pageXOffset)) {\n        navigationType = this.parent.enableRtl ? 'next' : 'previous';\n      } else if (Math.round(dragArea.scrollLeft) + dragArea.clientWidth === dragArea.scrollWidth && Math.round(this.actionObj.X) >= Math.round(dragArea.getBoundingClientRect().right - this.actionObj.cellWidth + window.pageXOffset)) {\n        navigationType = this.parent.enableRtl ? 'previous' : 'next';\n      }\n      if (navigationType) {\n        this.parent.changeDate(this.parent.activeView.getNextPreviousDate(navigationType));\n      }\n    }\n  }\n  morePopupEventDragging(e) {\n    if (isNullOrUndefined(e.target) || e.target && isNullOrUndefined(closest(e.target, 'td'))) {\n      return;\n    }\n    const eventObj = extend({}, this.actionObj.event, null, true);\n    const eventDuration = eventObj[this.parent.eventFields.endTime].getTime() - eventObj[this.parent.eventFields.startTime].getTime();\n    const td = closest(e.target, 'td');\n    if (this.parent.currentView === 'TimelineYear' && !td.classList.contains('e-work-cells')) {\n      return;\n    }\n    const dragStart$$1 = this.parent.getDateFromElement(td);\n    const dragEnd = new Date(dragStart$$1.getTime());\n    dragEnd.setMilliseconds(eventDuration);\n    if (this.parent.activeViewOptions.group.resources.length > 0) {\n      this.actionObj.groupIndex = parseInt(td.getAttribute('data-group-index'), 10);\n    }\n    this.actionObj.start = new Date(dragStart$$1.getTime());\n    this.actionObj.end = new Date(dragEnd.getTime());\n    this.actionObj.clone.style.top = formatUnit(td.offsetParent.offsetTop);\n    this.actionObj.clone.style.left = formatUnit(td.offsetLeft);\n    this.actionObj.clone.style.width = formatUnit(td.offsetWidth);\n    let eventContainer = td;\n    let eventWrapper;\n    if (this.parent.activeView.isTimelineView()) {\n      const rowIndex = closest(td, 'tr').rowIndex;\n      eventContainer = this.parent.element.querySelectorAll('.e-appointment-container').item(rowIndex);\n    }\n    eventWrapper = eventContainer.querySelector('.' + APPOINTMENT_WRAPPER_CLASS);\n    if (!eventWrapper) {\n      eventWrapper = createElement('div', {\n        className: APPOINTMENT_WRAPPER_CLASS\n      });\n      eventContainer.appendChild(eventWrapper);\n    }\n    this.appendCloneElement(eventWrapper);\n  }\n  calculateVerticalTime(e) {\n    if (isNullOrUndefined(this.actionObj.target) || this.actionObj.target && isNullOrUndefined(closest(this.actionObj.target, 'tr')) || !closest(this.actionObj.target, 'td').classList.contains(WORK_CELLS_CLASS) && !closest(this.actionObj.target, 'td').classList.contains(ALLDAY_CELLS_CLASS)) {\n      return;\n    }\n    if (this.parent.activeViewOptions.timeScale.enable) {\n      this.swapDragging(e);\n    }\n    const dragArea = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS);\n    const eventObj = extend({}, this.actionObj.event, null, true);\n    const eventStart = eventObj[this.parent.eventFields.startTime];\n    const eventEnd = eventObj[this.parent.eventFields.endTime];\n    const eventDuration = eventEnd.getTime() - eventStart.getTime();\n    let offsetTop = Math.floor(parseInt(this.actionObj.clone.style.top, 10) / this.actionObj.cellHeight) * this.actionObj.cellHeight;\n    offsetTop = offsetTop < 0 ? 0 : offsetTop;\n    if (this.scrollEdges.top || this.scrollEdges.bottom) {\n      offsetTop = this.scrollEdges.top ? dragArea.scrollTop - this.heightUptoCursorPoint + this.actionObj.cellHeight + window.pageYOffset : dragArea.scrollTop + dragArea.offsetHeight - this.actionObj.clone.offsetHeight + window.pageYOffset + (this.actionObj.clone.offsetHeight - this.heightUptoCursorPoint);\n      offsetTop = Math.round(offsetTop / this.actionObj.cellHeight) * this.actionObj.cellHeight;\n      this.actionObj.clone.style.top = formatUnit(offsetTop);\n    }\n    const rowIndex = this.parent.activeViewOptions.timeScale.enable ? offsetTop / this.actionObj.cellHeight : 0;\n    const heightPerMinute = this.actionObj.cellHeight / this.actionObj.slotInterval;\n    const diffInMinutes = parseInt(this.actionObj.clone.style.top, 10) - offsetTop;\n    let tr;\n    if (this.isAllDayDrag) {\n      tr = this.parent.element.querySelector('.' + ALLDAY_ROW_CLASS);\n    } else {\n      const trCollections = [].slice.call(this.parent.getContentTable().querySelectorAll('tr'));\n      tr = trCollections[rowIndex];\n    }\n    let index;\n    if (closest(this.actionObj.target, 'td').classList.contains(WORK_CELLS_CLASS) || closest(this.actionObj.target, 'td').classList.contains(ALLDAY_CELLS_CLASS)) {\n      index = closest(this.actionObj.target, 'td').cellIndex;\n    }\n    const colIndex = isNullOrUndefined(index) ? closest(this.actionObj.clone, 'td').cellIndex : index;\n    this.actionObj.index = colIndex;\n    if (isNullOrUndefined(tr)) {\n      return;\n    }\n    const td = tr.children[colIndex];\n    if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {\n      this.actionObj.groupIndex = parseInt(td.getAttribute('data-group-index'), 10);\n    }\n    let dragStart$$1;\n    let dragEnd;\n    if (this.parent.activeViewOptions.timeScale.enable && !this.isAllDayDrag) {\n      this.appendCloneElement(this.getEventWrapper(colIndex));\n      dragStart$$1 = this.parent.getDateFromElement(td);\n      dragStart$$1.setMinutes(dragStart$$1.getMinutes() + diffInMinutes / heightPerMinute);\n      dragEnd = new Date(dragStart$$1.getTime());\n      if (this.actionObj.element.classList.contains(ALLDAY_APPOINTMENT_CLASS)) {\n        dragEnd.setMinutes(dragEnd.getMinutes() + this.actionObj.slotInterval);\n      } else {\n        dragEnd.setMilliseconds(eventDuration);\n      }\n    } else {\n      dragStart$$1 = this.parent.getDateFromElement(td);\n      dragStart$$1.setDate(dragStart$$1.getDate() - this.daysVariation);\n      dragStart$$1.setHours(eventStart.getHours(), eventStart.getMinutes(), eventStart.getSeconds());\n      dragEnd = new Date(dragStart$$1.getTime());\n      dragEnd.setMilliseconds(eventDuration);\n      if (!this.actionObj.element.classList.contains(ALLDAY_APPOINTMENT_CLASS) && this.actionObj.clone.classList.contains(ALLDAY_APPOINTMENT_CLASS)) {\n        dragEnd = addDays(resetTime(dragEnd), 1);\n      }\n      this.updateAllDayEvents(dragStart$$1, dragEnd, this.parent.activeViewOptions.group.byDate ? colIndex : undefined);\n    }\n    this.actionObj.start = new Date(+dragStart$$1);\n    this.actionObj.end = new Date(+dragEnd);\n    const event = this.getUpdatedEvent(this.actionObj.start, this.actionObj.end, this.actionObj.event);\n    const dynamicWrappers = [].slice.call(this.parent.element.querySelectorAll('.e-dynamic-clone'));\n    for (const wrapper of dynamicWrappers) {\n      remove(wrapper);\n    }\n    if (this.multiData.length > 0) {\n      if (this.isAllDayTarget && this.isAllDayDrag && !isNullOrUndefined(this.actionObj.isAllDay) && !this.actionObj.isAllDay) {\n        const targetCellTime = parseInt(closest(this.actionObj.target, 'td').getAttribute('data-date'), 10);\n        this.multiData.forEach(data => {\n          this.swagData.push(extend({}, data, null, true));\n          if (data[this.parent.eventFields.isAllDay]) {\n            data[this.parent.eventFields.startTime] = new Date(data[this.parent.eventFields.startTime].getTime() + (targetCellTime - this.startTime));\n            const startTime = new Date(data[this.parent.eventFields.startTime]);\n            const endTime = new Date(startTime.setMinutes(startTime.getMinutes() + this.actionObj.slotInterval));\n            data[this.parent.eventFields.endTime] = endTime;\n            data[this.parent.eventFields.isAllDay] = false;\n          }\n        });\n        this.startTime = targetCellTime;\n      }\n      if (this.isAllDayTarget && this.isAllDayDrag && !isNullOrUndefined(this.actionObj.isAllDay) && this.actionObj.isAllDay && this.swagData.length > 0) {\n        this.multiData = this.swagData;\n        this.swagData = [];\n        const eventObj = extend({}, this.actionObj.event, null, true);\n        this.startTime = eventObj[this.parent.eventFields.startTime].getTime();\n      }\n      const startTimeDiff = event[this.parent.eventFields.startTime].getTime() - this.startTime;\n      for (let index = 0; index < this.multiData.length; index++) {\n        this.updatedData[index] = this.updateMultipleData(this.multiData[index], startTimeDiff);\n        const dayIndex = this.getDayIndex(this.updatedData[index]);\n        if (dayIndex >= 0) {\n          const wrapper = this.getEventWrapper(dayIndex, this.updatedData[index][this.parent.eventFields.isAllDay]);\n          this.appendCloneElement(wrapper, this.actionObj.cloneElement[index]);\n          this.updateEventHeight(this.updatedData[index], index, dayIndex);\n        } else {\n          if (!isNullOrUndefined(this.actionObj.cloneElement[index].parentNode)) {\n            remove(this.actionObj.cloneElement[index]);\n          }\n        }\n      }\n    } else {\n      this.updateEventHeight(event);\n    }\n    this.updateTimePosition(this.actionObj.start, this.updatedData);\n  }\n  splitEvent(event) {\n    const eventFields = this.parent.eventFields;\n    const eventData = [];\n    const startTime = event[eventFields.startTime];\n    const endTime = event[eventFields.endTime];\n    if (resetTime(new Date(startTime.getTime())) < resetTime(new Date(endTime.getTime()))) {\n      let startReferenceDate = resetTime(new Date(startTime.getTime()));\n      let endReferenceDate = new Date(startReferenceDate.getTime());\n      for (let i = 0; startReferenceDate < new Date(endTime.getTime()); i++) {\n        endReferenceDate = new Date(endReferenceDate.setDate(startReferenceDate.getDate() + 1));\n        const eventObj = extend({}, event, null, true);\n        eventObj[eventFields.startTime] = new Date(startReferenceDate);\n        eventObj[eventFields.endTime] = new Date(endReferenceDate);\n        startReferenceDate = new Date(startReferenceDate.setDate(startReferenceDate.getDate() + 1));\n        eventData.push(eventObj);\n      }\n      const index = eventData.length - 1;\n      eventData[0][eventFields.startTime] = startTime;\n      eventData[index][eventFields.endTime] = endTime;\n    } else {\n      eventData.push(event);\n    }\n    return eventData;\n  }\n  updateMultipleData(data, timeDifference) {\n    const eventObj = extend({}, data, null, true);\n    if (!isNullOrUndefined(this.actionObj.isAllDay) && this.parent.activeViewOptions.timeScale.enable && (this.isAllDayTarget && eventObj[this.parent.eventFields.isAllDay] || !this.isAllDayTarget && !eventObj[this.parent.eventFields.isAllDay])) {\n      eventObj[this.parent.eventFields.isAllDay] = this.actionObj.isAllDay;\n    }\n    const endTimeDiff = eventObj[this.parent.eventFields.endTime].getTime() - eventObj[this.parent.eventFields.startTime].getTime();\n    if (eventObj[this.parent.eventFields.isAllDay]) {\n      const differInDays = Math.ceil(timeDifference / (1000 * 3600 * 24));\n      const day = Math.ceil(endTimeDiff / (1000 * 3600 * 24));\n      const startTime = new Date(eventObj[this.parent.eventFields.startTime]);\n      eventObj[this.parent.eventFields.startTime] = resetTime(new Date(startTime.setDate(startTime.getDate() + differInDays)));\n      eventObj[this.parent.eventFields.endTime] = addDays(eventObj[this.parent.eventFields.startTime], day);\n    } else {\n      eventObj[this.parent.eventFields.startTime] = new Date(eventObj[this.parent.eventFields.startTime].getTime() + timeDifference);\n      eventObj[this.parent.eventFields.endTime] = new Date(eventObj[this.parent.eventFields.startTime].getTime() + endTimeDiff);\n    }\n    return eventObj;\n  }\n  getDayIndex(event) {\n    const eventObj = extend({}, event, null, true);\n    const startTime = resetTime(eventObj[this.parent.eventFields.startTime]).getTime();\n    let query = '';\n    let wrapper = DAY_WRAPPER_CLASS;\n    if (this.parent.activeViewOptions.timeScale.enable && eventObj[this.parent.eventFields.isAllDay]) {\n      wrapper = ALLDAY_APPOINTMENT_WRAPPER_CLASS;\n    } else {\n      wrapper = WORK_CELLS_CLASS;\n    }\n    query = '.' + wrapper + '[data-date=\"' + startTime + '\"]';\n    if (this.parent.activeViewOptions.group.resources.length > 0) {\n      query = query + '[data-group-index=\"' + this.actionObj.groupIndex + '\"]';\n    }\n    this.targetTd = this.parent.element.querySelector(query);\n    if (isNullOrUndefined(this.targetTd)) {\n      return -1;\n    }\n    return this.targetTd.cellIndex;\n  }\n  updateEventHeight(event, index, colIndex) {\n    this.verticalEvent.initializeValues();\n    let datesCount = 0;\n    if (!this.parent.uiStateValues.isGroupAdaptive) {\n      for (let i = 0; i < this.actionObj.groupIndex; i++) {\n        datesCount = datesCount + this.verticalEvent.dateRender[i].length;\n      }\n    }\n    const indexGroup = this.parent.uiStateValues.isGroupAdaptive ? datesCount : this.actionObj.groupIndex;\n    const target = this.parent.activeViewOptions.group.byDate && !isNullOrUndefined(this.parent.getDateFromElement(this.actionObj.target)) ? true : false;\n    if (target || !this.parent.activeViewOptions.group.byDate) {\n      let dynamicIndex = -1;\n      let dayIndex = !this.parent.activeViewOptions.group.byDate ? isNullOrUndefined(index) ? this.actionObj.index - datesCount : colIndex - datesCount : this.parent.getIndexOfDate(this.verticalEvent.dateRender[indexGroup], resetTime(\n      // eslint-disable-next-line max-len\n      this.parent.getDateFromElement(isNullOrUndefined(index) ? this.actionObj.target : this.targetTd)));\n      const splitEvents = this.splitEvent(event);\n      const events = this.parent.eventBase.isAllDayAppointment(event) || splitEvents.length > 2 || this.parent.eventSettings.spannedEventPlacement !== 'TimeSlot' ? [event] : splitEvents;\n      for (let i = 0; i < events.length; i++) {\n        if (i > 0) {\n          let filterQuery = `.e-day-wrapper[data-date=\"${resetTime(events[i][this.parent.eventFields.startTime]).getTime()}\"]`;\n          if (this.parent.activeViewOptions.group.resources.length > 0) {\n            filterQuery = filterQuery.concat('[data-group-index = \"' + this.actionObj.groupIndex + '\"]');\n          }\n          const appWrap = this.parent.element.querySelector(filterQuery);\n          if (appWrap) {\n            dayIndex = dayIndex + 1;\n            dynamicIndex = appWrap.cellIndex;\n          } else {\n            dayIndex = -1;\n          }\n        }\n        if (dayIndex >= 0) {\n          const record = this.verticalEvent.isSpannedEvent(events[i], dayIndex, indexGroup);\n          const eStart = record[this.verticalEvent.fields.startTime];\n          const eEnd = record[this.verticalEvent.fields.endTime];\n          let appHeight = this.parent.activeViewOptions.timeScale.enable ? this.verticalEvent.getHeight(eStart, eEnd) : this.actionObj.element.offsetHeight;\n          let topValue = this.parent.activeViewOptions.timeScale.enable ? this.verticalEvent.getTopValue(eStart, dayIndex, indexGroup) : this.actionObj.element.offsetTop;\n          if (isNullOrUndefined(index)) {\n            if (i === 0) {\n              this.actionObj.clone.style.top = formatUnit(topValue);\n              this.actionObj.clone.style.height = formatUnit(appHeight);\n            } else {\n              this.renderSpannedEvents(record, dynamicIndex, topValue, appHeight);\n            }\n          } else {\n            let appWidth = this.actionObj.cellWidth;\n            if (event[this.parent.eventFields.isAllDay]) {\n              topValue = this.parent.element.querySelector('.' + ALLDAY_ROW_CLASS).offsetTop;\n              appHeight = this.getAllDayEventHeight();\n              const timeDiff = event[this.parent.eventFields.endTime].getTime() - event[this.parent.eventFields.startTime].getTime();\n              const allDayDifference = Math.ceil(timeDiff / (1000 * 3600 * 24));\n              if (allDayDifference >= 0) {\n                appWidth = allDayDifference * this.actionObj.cellWidth;\n              }\n            }\n            if (this.actionObj.cloneElement[index]) {\n              if (i === 0) {\n                this.actionObj.cloneElement[index].style.top = formatUnit(topValue);\n                this.actionObj.cloneElement[index].style.height = formatUnit(appHeight);\n                this.actionObj.cloneElement[index].style.width = formatUnit(appWidth);\n                this.actionObj.cloneElement[index].style.left = formatUnit(0);\n              } else {\n                this.renderSpannedEvents(record, dynamicIndex, topValue, appHeight);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  renderSpannedEvents(record, index, top, height) {\n    const startTime = record[this.parent.eventFields.startTime].getTime();\n    const endTime = record[this.parent.eventFields.endTime].getTime();\n    if (startTime !== endTime) {\n      const appointmentElement = this.verticalEvent.createAppointmentElement(record, false, record.isSpanned, this.actionObj.groupIndex);\n      addClass([appointmentElement], [CLONE_ELEMENT_CLASS, 'e-dynamic-clone']);\n      setStyleAttribute(appointmentElement, {\n        'width': '100%',\n        'height': height + 'px',\n        'top': top + 'px',\n        'border': '0px'\n      });\n      const appointmentWrap = [].slice.call(this.parent.element.querySelectorAll('.' + APPOINTMENT_WRAPPER_CLASS));\n      appointmentWrap[index].appendChild(appointmentElement);\n    }\n  }\n  getRenderedDates() {\n    let renderDates = this.parent.activeView.renderDates;\n    this.parent.eventBase.slots.push(...this.parent.activeView.renderDates.map(date => +date));\n    if (this.parent.activeViewOptions.group.resources.length > 0) {\n      this.parent.eventBase.slots = [];\n      const resources = this.parent.resourceBase.lastResourceLevel.filter(res => res.groupIndex === this.actionObj.groupIndex);\n      renderDates = resources[0].renderDates;\n      this.parent.eventBase.slots.push(...renderDates.map(date => +date));\n    }\n    return renderDates;\n  }\n  updateAllDayEvents(startDate, endDate, colIndex) {\n    this.parent.eventBase.slots = [];\n    const event = this.getUpdatedEvent(startDate, endDate, this.actionObj.event);\n    const renderDates = this.getRenderedDates();\n    const events = this.parent.eventBase.splitEvent(event, renderDates);\n    let query = `.e-all-day-cells[data-date=\"${events[0][this.parent.eventFields.startTime].getTime()}\"]`;\n    if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {\n      query = query.concat('[data-group-index = \"' + this.actionObj.groupIndex + '\"]');\n    }\n    const cell = [].slice.call(this.parent.element.querySelectorAll(query));\n    if (cell.length > 0 || !isNullOrUndefined(colIndex)) {\n      const cellIndex = !isNullOrUndefined(colIndex) ? colIndex : cell[0].cellIndex;\n      this.appendCloneElement(this.getEventWrapper(cellIndex));\n      // eslint-disable-next-line max-len\n      this.actionObj.clone.style.width = formatUnit(events[0].data.count * this.actionObj.cellWidth);\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  swapDragging(e) {\n    const colIndex = closest(this.actionObj.target, 'td').cellIndex;\n    if (closest(this.actionObj.target, '.' + DATE_HEADER_WRAP_CLASS) && !closest(this.actionObj.clone, '.' + ALLDAY_APPOINTMENT_WRAPPER_CLASS)) {\n      addClass([this.actionObj.clone], ALLDAY_APPOINTMENT_CLASS);\n      this.appendCloneElement(this.getEventWrapper(colIndex));\n      this.actionObj.isAllDay = true;\n      const eventHeight = this.getAllDayEventHeight();\n      const allDayElement = [].slice.call(this.parent.element.querySelectorAll('.' + ALLDAY_CELLS_CLASS + ':first-child'));\n      if (allDayElement[0].offsetHeight < eventHeight) {\n        for (const element of allDayElement) {\n          element.style.height = (eventHeight + 2) / 12 + 'em';\n        }\n      }\n      setStyleAttribute(this.actionObj.clone, {\n        width: formatUnit(this.actionObj.cellWidth),\n        height: formatUnit(eventHeight),\n        top: formatUnit(this.parent.element.querySelector('.' + ALLDAY_ROW_CLASS).offsetTop)\n      });\n    }\n    if (closest(this.actionObj.target, '.' + WORK_CELLS_CLASS) && !closest(this.actionObj.clone, '.' + DAY_WRAPPER_CLASS)) {\n      removeClass([this.actionObj.clone], ALLDAY_APPOINTMENT_CLASS);\n      this.appendCloneElement(this.getEventWrapper(colIndex));\n      this.actionObj.isAllDay = false;\n      // eslint-disable-next-line max-len\n      const height = this.actionObj.element.offsetHeight === 0 ? this.actionObj.height : this.actionObj.element.offsetHeight;\n      setStyleAttribute(this.actionObj.clone, {\n        left: formatUnit(0),\n        height: formatUnit(height),\n        width: formatUnit(this.actionObj.cellWidth)\n      });\n    }\n  }\n  calculateVerticalDate(e) {\n    if (isNullOrUndefined(e.target) || e.target && isNullOrUndefined(closest(e.target, 'tr')) || e.target && e.target.tagName === 'DIV') {\n      return;\n    }\n    const eventObj = extend({}, this.actionObj.event, null, true);\n    if (isNullOrUndefined(this.parent.eventDragArea)) {\n      this.removeCloneElement();\n    }\n    const eventDuration = eventObj[this.parent.eventFields.endTime].getTime() - eventObj[this.parent.eventFields.startTime].getTime();\n    let td = closest(this.actionObj.target, 'td');\n    if (!isNullOrUndefined(td)) {\n      const tr = td.parentElement;\n      this.actionObj.index = tr.rowIndex * tr.children.length + td.cellIndex;\n      const workCells = [].slice.call(this.parent.element.querySelectorAll('.' + WORK_CELLS_CLASS));\n      td = workCells[this.actionObj.index];\n      const currentDate = this.parent.getDateFromElement(td);\n      if (!isNullOrUndefined(currentDate)) {\n        if (this.parent.activeViewOptions.group.resources.length > 0) {\n          this.actionObj.groupIndex = parseInt(td.getAttribute('data-group-index'), 10);\n        }\n        const timeString = new Date(currentDate.setDate(currentDate.getDate() - this.daysVariation));\n        let dragStart$$1 = new Date(timeString.getTime());\n        let dragEnd = new Date(dragStart$$1.getTime());\n        const startTimeDiff = eventObj[this.parent.eventFields.startTime].getTime() - resetTime(new Date(+eventObj[this.parent.eventFields.startTime])).getTime();\n        dragStart$$1 = new Date(dragStart$$1.getTime() + startTimeDiff);\n        dragEnd = new Date(dragStart$$1.getTime() + eventDuration);\n        this.actionObj.start = new Date(dragStart$$1.getTime());\n        this.actionObj.end = new Date(dragEnd.getTime());\n      }\n    }\n    const event = this.getUpdatedEvent(this.actionObj.start, this.actionObj.end, this.actionObj.event);\n    const eventWrappers = [].slice.call(this.parent.element.querySelectorAll('.' + CLONE_ELEMENT_CLASS));\n    for (const wrapper of eventWrappers) {\n      remove(wrapper);\n    }\n    if (this.multiData && this.multiData.length > 0) {\n      const startTime = resetTime(new Date(event[this.parent.eventFields.startTime]));\n      let startTimeDiff = startTime.getTime() - this.startTime;\n      if (this.parent.currentView === 'TimelineYear' && this.parent.group.resources.length > 0) {\n        startTimeDiff = (startTime.getFullYear() - new Date(this.startTime).getFullYear()) * 12;\n        startTimeDiff -= new Date(this.startTime).getMonth();\n        startTimeDiff += startTime.getMonth();\n      }\n      for (let index = 0; index < this.multiData.length; index++) {\n        this.updatedData[index] = this.updateMultipleVerticalDate(this.multiData[index], startTimeDiff);\n        if (this.parent.currentView === 'TimelineYear') {\n          this.dynamicYearlyEventsRendering(this.updatedData[index]);\n        } else {\n          this.dynamicEventsRendering(this.updatedData[index]);\n        }\n      }\n    } else {\n      if (this.parent.currentView === 'TimelineYear') {\n        this.dynamicYearlyEventsRendering(event);\n      } else {\n        this.dynamicEventsRendering(event);\n      }\n    }\n  }\n  updateMultipleVerticalDate(data, timeDifference) {\n    const eventObj = extend({}, data, null, true);\n    const eventDuration = eventObj[this.parent.eventFields.endTime].getTime() - eventObj[this.parent.eventFields.startTime].getTime();\n    const startDate = new Date(eventObj[this.parent.eventFields.startTime]);\n    if (this.parent.currentView === 'TimelineYear' && this.parent.group.resources.length > 0) {\n      eventObj[this.parent.eventFields.startTime] = new Date(startDate.setMonth(startDate.getMonth() + timeDifference));\n    } else {\n      const differInDays = Math.ceil(timeDifference / MS_PER_DAY);\n      eventObj[this.parent.eventFields.startTime] = new Date(startDate.setDate(startDate.getDate() + differInDays));\n    }\n    eventObj[this.parent.eventFields.endTime] = new Date(eventObj[this.parent.eventFields.startTime].getTime() + eventDuration);\n    return eventObj;\n  }\n  calculateTimelineTime(e) {\n    const eventObj = extend({}, this.actionObj.event, null, true);\n    const eventDuration = eventObj[this.parent.eventFields.endTime].getTime() - eventObj[this.parent.eventFields.startTime].getTime();\n    let offsetLeft = this.parent.enableRtl ? Math.abs(this.actionObj.clone.offsetLeft) - this.actionObj.clone.offsetWidth : parseInt(this.actionObj.clone.style.left, 10);\n    offsetLeft = Math.floor(offsetLeft / this.actionObj.cellWidth) * this.actionObj.cellWidth;\n    let rightOffset;\n    if (this.parent.enableRtl) {\n      rightOffset = Math.abs(parseInt(this.actionObj.clone.style.right, 10));\n      this.actionObj.clone.style.right = formatUnit(rightOffset);\n    }\n    offsetLeft = this.getOffsetValue(offsetLeft, rightOffset);\n    const colIndex = this.getColumnIndex(offsetLeft);\n    const dragArea = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS);\n    const contentWrapRight = dragArea.getBoundingClientRect().right;\n    const cursorDrag = this.parent.activeView.isTimelineView() && !this.parent.enableRtl && this.actionObj.pageX > this.actionObj.clone.getBoundingClientRect().right && !this.isMorePopupOpened && !(this.actionObj.pageX > contentWrapRight);\n    const leftVal = this.parent.eventDragArea ? dragArea.scrollLeft - dragArea.offsetLeft : 0;\n    if ((this.isCursorAhead || cursorDrag) && !this.isStepDragging) {\n      this.isCursorAhead = true;\n    }\n    let cloneIndex = Math.floor((this.actionObj.pageX - this.actionObj.clone.getBoundingClientRect().left + leftVal) / this.actionObj.cellWidth);\n    if (this.parent.enableRtl) {\n      cloneIndex = Math.abs(Math.floor((this.actionObj.pageX - this.actionObj.clone.getBoundingClientRect().right) / this.actionObj.cellWidth)) - 1;\n    }\n    if (this.cursorPointIndex < 0) {\n      this.cursorIndex(e, eventObj, offsetLeft, cloneIndex);\n    }\n    const tr = this.parent.getContentTable().querySelector('tr');\n    let index = this.getCursorCurrentIndex(colIndex, cloneIndex, tr);\n    index = index < 0 ? 0 : index;\n    let eventStart = this.isHeaderRows ? new Date(this.timelineEventModule.dateRender[index].getTime()) : this.parent.getDateFromElement(tr.children[index]);\n    if (this.isStepDragging) {\n      const widthDiff = this.getWidthDiff(tr, index);\n      if (widthDiff !== 0) {\n        const timeDiff = Math.round(widthDiff / this.widthPerMinute);\n        eventStart.setMinutes(eventStart.getMinutes() + timeDiff * this.actionObj.interval);\n        if (this.isCursorAhead || cursorDrag) {\n          eventStart.setMilliseconds(-eventDuration);\n        } else {\n          eventStart.setMinutes(eventStart.getMinutes() - this.minDiff);\n        }\n      } else {\n        eventStart = this.actionObj.start;\n      }\n    } else {\n      if (this.isCursorAhead || cursorDrag) {\n        eventStart.setMinutes(eventStart.getMinutes() + (this.isTimelineDayProcess ? MINUTES_PER_DAY : this.actionObj.slotInterval));\n        eventStart.setMilliseconds(-eventDuration);\n      } else {\n        eventStart.setMinutes(eventStart.getMinutes() - this.cursorPointIndex * (this.isTimelineDayProcess ? MINUTES_PER_DAY : this.actionObj.slotInterval));\n      }\n    }\n    eventStart = this.calculateIntervalTime(eventStart);\n    if (this.isTimelineDayProcess) {\n      const eventSrt = eventObj[this.parent.eventFields.startTime];\n      eventStart.setHours(eventSrt.getHours(), eventSrt.getMinutes(), eventSrt.getSeconds());\n    }\n    if (this.parent.eventDragArea) {\n      const targetDate = this.parent.getDateFromElement(e.target);\n      if (!isNullOrUndefined(targetDate)) {\n        if (!this.parent.activeViewOptions.timeScale.enable || this.parent.currentView === 'TimelineMonth') {\n          const eventSrt = eventObj[this.parent.eventFields.startTime];\n          eventStart = new Date(targetDate.setHours(eventSrt.getHours(), eventSrt.getMinutes(), eventSrt.getSeconds()));\n        } else {\n          eventStart = targetDate;\n        }\n      }\n    }\n    const eventEnd = new Date(eventStart.getTime());\n    eventEnd.setMilliseconds(eventDuration);\n    let eventsData = [this.getUpdatedEvent(eventStart, eventEnd, this.actionObj.event)];\n    if (this.multiData.length > 0) {\n      const startTimeDiff = eventsData[0][this.parent.eventFields.startTime].getTime() - this.startTime;\n      for (let i = 0; i < this.multiData.length; i++) {\n        this.updatedData[i] = this.updateMultipleData(this.multiData[i], startTimeDiff);\n      }\n      eventsData = this.updatedData;\n    }\n    for (let dataIndex = 0; dataIndex < eventsData.length; dataIndex++) {\n      const events = this.timelineEventModule.splitEvent(eventsData[dataIndex], this.timelineEventModule.dateRender);\n      const eventData = events[0].data;\n      const startTime = this.timelineEventModule.getStartTime(events[0], eventData);\n      const endTime = this.timelineEventModule.getEndTime(events[0], eventData);\n      // eslint-disable-next-line max-len\n      const width = this.timelineEventModule.getEventWidth(startTime, endTime, eventObj[this.parent.eventFields.isAllDay], eventData.count);\n      // eslint-disable-next-line max-len\n      let day = this.parent.getIndexOfDate(this.timelineEventModule.dateRender, resetTime(new Date(startTime.getTime())));\n      day = day < 0 ? 0 : day;\n      const left = this.timelineEventModule.getPosition(startTime, endTime, eventObj[this.parent.eventFields.isAllDay], day);\n      const cloneElement = this.multiData.length > 0 ? this.actionObj.cloneElement[dataIndex] : this.actionObj.clone;\n      if (this.parent.enableRtl) {\n        cloneElement.style.right = formatUnit(left);\n      } else {\n        cloneElement.style.left = formatUnit(left);\n      }\n      if (!this.isMorePopupOpened) {\n        cloneElement.style.width = formatUnit(width);\n      }\n      if (this.parent.activeViewOptions.group.resources.length > 0) {\n        this.calculateResourceGroupingPosition(e, cloneElement);\n      }\n      this.actionObj.start = new Date(eventStart.getTime());\n      this.actionObj.end = new Date(eventEnd.getTime());\n      this.updateTimePosition(this.actionObj.start, this.updatedData);\n    }\n  }\n  getOffsetValue(offsetLeft, rightOffset) {\n    if (this.scrollEdges.left || this.scrollEdges.right) {\n      const viewEle = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS);\n      if (this.parent.enableRtl) {\n        rightOffset = viewEle.offsetWidth - viewEle.scrollLeft;\n        if (this.scrollEdges.right) {\n          rightOffset = rightOffset - viewEle.offsetWidth + this.actionObj.clone.offsetWidth - (this.actionObj.clone.offsetWidth - this.widthUptoCursorPoint);\n        } else {\n          rightOffset = rightOffset + this.widthUptoCursorPoint;\n          if (rightOffset - this.widthUptoCursorPoint >= viewEle.scrollWidth) {\n            this.actionObj.clone.style.width = formatUnit(this.actionObj.clone.offsetWidth - this.widthUptoCursorPoint + this.actionObj.cellWidth);\n            rightOffset = viewEle.scrollLeft - viewEle.scrollWidth;\n          }\n        }\n        this.actionObj.clone.style.left = formatUnit(rightOffset);\n      } else {\n        if (this.scrollEdges.left) {\n          offsetLeft = viewEle.scrollLeft - this.widthUptoCursorPoint + this.actionObj.cellWidth;\n          if (viewEle.scrollLeft + viewEle.offsetWidth >= viewEle.offsetWidth) {\n            viewEle.scrollLeft = viewEle.scrollLeft - 1;\n          } else if (this.actionObj.clone.offsetLeft === 0) {\n            offsetLeft = viewEle.scrollLeft;\n          }\n        } else {\n          offsetLeft = viewEle.scrollLeft + viewEle.offsetWidth - this.actionObj.clone.offsetWidth + (this.actionObj.clone.offsetWidth - this.widthUptoCursorPoint);\n        }\n        offsetLeft = offsetLeft < 0 ? 0 : offsetLeft;\n        this.actionObj.clone.style.left = formatUnit(offsetLeft);\n      }\n    }\n    return offsetLeft;\n  }\n  getWidthDiff(tr, index) {\n    const pages = this.scrollArgs.element.getBoundingClientRect();\n    if (pages.left <= this.actionObj.pageX && pages.right >= this.actionObj.pageX) {\n      const targetLeft = tr.children[index].offsetLeft;\n      const pageX = this.actionObj.pageX - pages.left;\n      if (this.parent.enableRtl) {\n        return targetLeft + this.actionObj.cellWidth - (this.scrollArgs.element.scrollLeft + pageX);\n      } else {\n        return this.scrollArgs.element.scrollLeft + pageX - targetLeft;\n      }\n    }\n    return 0;\n  }\n  getColumnIndex(offsetLeft) {\n    const index = Math.floor(offsetLeft / this.actionObj.cellWidth);\n    if (this.isHeaderRows) {\n      return index;\n    }\n    return this.getIndex(index);\n  }\n  getCursorCurrentIndex(colIndex, cloneIndex, tr) {\n    const index = colIndex + cloneIndex;\n    if (this.isHeaderRows) {\n      const dateLength = Math.floor(tr.offsetWidth / this.actionObj.cellWidth);\n      return index > dateLength - 1 ? dateLength - 1 : index;\n    }\n    return index > tr.children.length - 1 ? tr.children.length - 1 : index;\n  }\n  cursorIndex(e, event, left, index) {\n    const td = closest(e.target, '.e-work-cells');\n    if (!isNullOrUndefined(td) && !this.isMorePopupOpened) {\n      let targetDate = this.parent.getDateFromElement(td);\n      if (this.isHeaderRows) {\n        const currentIndex = Math.floor(left / this.actionObj.cellWidth);\n        targetDate = new Date(this.timelineEventModule.dateRender[currentIndex + index].getTime());\n      }\n      const timeDiff = targetDate.getTime() - event[this.parent.eventFields.startTime].getTime();\n      if (this.isTimelineDayProcess) {\n        this.cursorPointIndex = Math.abs(Math.ceil(timeDiff / MS_PER_DAY));\n      } else {\n        const widthDiff = Math.floor(timeDiff / MS_PER_MINUTE / (this.actionObj.slotInterval / this.actionObj.cellWidth));\n        this.cursorPointIndex = Math.floor(widthDiff / this.actionObj.cellWidth);\n        this.cursorPointIndex = this.cursorPointIndex < 0 ? 0 : this.cursorPointIndex;\n      }\n    } else {\n      this.cursorPointIndex = 0;\n    }\n  }\n  calculateResourceGroupingPosition(e, cloneElement) {\n    const dragArea = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS);\n    const trCollection = [].slice.call(this.parent.element.querySelectorAll('.e-content-wrap .e-content-table tr:not(.e-hidden)'));\n    let translateY = getTranslateY(dragArea.querySelector('table'));\n    translateY = isNullOrUndefined(translateY) ? 0 : translateY;\n    const rowHeight = this.parent.rowAutoHeight ? ~~(dragArea.querySelector('table').offsetHeight / trCollection.length) : this.actionObj.cellHeight;\n    let rowIndex = Math.floor(Math.floor(this.actionObj.Y + (dragArea.scrollTop - translateY - (window.scrollY || window.pageYOffset)) - dragArea.getBoundingClientRect().top) / rowHeight);\n    rowIndex = rowIndex < 0 ? 0 : rowIndex > trCollection.length - 1 ? trCollection.length - 1 : rowIndex;\n    this.actionObj.index = rowIndex;\n    const eventContainer = this.parent.element.querySelectorAll('.e-appointment-container:not(.e-hidden)').item(rowIndex);\n    let eventWrapper = eventContainer.querySelector('.' + APPOINTMENT_WRAPPER_CLASS);\n    if (!eventWrapper) {\n      eventWrapper = createElement('div', {\n        className: APPOINTMENT_WRAPPER_CLASS\n      });\n      eventContainer.appendChild(eventWrapper);\n    }\n    this.appendCloneElement(eventWrapper, cloneElement);\n    const td = closest(this.actionObj.target, 'td');\n    this.actionObj.groupIndex = td && !isNaN(parseInt(td.getAttribute('data-group-index'), 10)) ? parseInt(td.getAttribute('data-group-index'), 10) : this.actionObj.groupIndex;\n    let top = trCollection[rowIndex].getBoundingClientRect().height * rowIndex;\n    if (this.parent.rowAutoHeight) {\n      const cursorElement = this.getCursorElement(e);\n      if (cursorElement) {\n        top = cursorElement.classList.contains(WORK_CELLS_CLASS) ? cursorElement.offsetTop : cursorElement.offsetParent.classList.contains(APPOINTMENT_CLASS) ? cursorElement.offsetParent.offsetTop : top;\n      }\n    }\n    cloneElement.style.top = formatUnit(top);\n  }\n  appendCloneElement(element, cloneElement = null) {\n    cloneElement = isNullOrUndefined(cloneElement) ? this.actionObj.clone : cloneElement;\n    const dragElement = document.querySelector(this.parent.eventDragArea);\n    if (this.parent.eventDragArea && dragElement) {\n      dragElement.appendChild(cloneElement);\n    } else {\n      element.appendChild(cloneElement);\n    }\n  }\n  getEventWrapper(index, isAllDayDrag) {\n    let eventWrapper;\n    if (isNullOrUndefined(isAllDayDrag)) {\n      isAllDayDrag = this.actionObj.clone.classList.contains(ALLDAY_APPOINTMENT_CLASS);\n    }\n    if (this.parent.activeViewOptions.timeScale.enable) {\n      const wrapperClass = isAllDayDrag ? '.' + ALLDAY_APPOINTMENT_WRAPPER_CLASS : '.' + APPOINTMENT_WRAPPER_CLASS;\n      eventWrapper = this.parent.element.querySelectorAll(wrapperClass).item(index);\n    } else {\n      const targetWrapper = this.parent.element.querySelectorAll('.' + WORK_CELLS_CLASS).item(index);\n      eventWrapper = targetWrapper.querySelector('.' + APPOINTMENT_WRAPPER_CLASS);\n      if (!eventWrapper) {\n        eventWrapper = createElement('div', {\n          className: APPOINTMENT_WRAPPER_CLASS\n        });\n        targetWrapper.appendChild(eventWrapper);\n      }\n    }\n    return eventWrapper;\n  }\n  getAllDayEventHeight() {\n    const eventWrapper = createElement('div', {\n      className: APPOINTMENT_CLASS\n    });\n    this.parent.element.querySelector('.' + ALLDAY_APPOINTMENT_WRAPPER_CLASS).appendChild(eventWrapper);\n    const eventHeight = eventWrapper.offsetHeight;\n    remove(eventWrapper);\n    return eventHeight;\n  }\n  isAllowDrop(e) {\n    if (!this.actionObj.excludeSelectors) {\n      return false;\n    }\n    const dropSelectors = this.actionObj.excludeSelectors.split(',');\n    let isAllowDrop = false;\n    for (const selector of dropSelectors) {\n      if (e.target.classList.contains(selector)) {\n        isAllowDrop = true;\n        break;\n      }\n    }\n    return isAllowDrop;\n  }\n  /**\n   * Get module name.\n   *\n   * @returns {string} Returns the module name\n   */\n  getModuleName() {\n    return 'dragAndDrop';\n  }\n}\n\n/**\n * view base\n */\nclass ViewBase {\n  /**\n   * Constructor\n   *\n   * @param {Schedule} parent Accepts the schedule instance\n   */\n  constructor(parent) {\n    this.parent = parent;\n  }\n  isTimelineView() {\n    return this.parent.currentView.indexOf('Timeline') !== -1;\n  }\n  getContentRows() {\n    return [];\n  }\n  refreshHeader() {\n    // Method to refresh the date header\n  }\n  refreshResourceHeader() {\n    remove(this.element.querySelector('tbody').lastElementChild.firstElementChild);\n    const resTd = createElement('td');\n    resTd.appendChild(this.parent.resourceBase.createResourceColumn());\n    prepend([resTd], this.element.querySelector('tbody').lastElementChild);\n    this.parent.notify(contentReady, {});\n  }\n  getDayName(date) {\n    return this.parent.getDayNames('abbreviated')[date.getDay()];\n  }\n  getDate(date) {\n    return this.parent.globalize.formatDate(date, {\n      format: 'd',\n      calendar: this.parent.getCalendarMode()\n    });\n  }\n  getTime(date) {\n    if (this.parent.isAdaptive) {\n      if (this.parent.activeViewOptions.timeFormat === 'HH:mm' || this.parent.activeViewOptions.timeFormat === 'HH.mm') {\n        return this.parent.globalize.formatDate(date, {\n          format: 'H',\n          calendar: this.parent.getCalendarMode()\n        });\n      }\n      return this.parent.globalize.formatDate(date, {\n        skeleton: 'h',\n        calendar: this.parent.getCalendarMode()\n      });\n    }\n    return this.parent.getTimeString(date);\n  }\n  getTimelineDate(date) {\n    const text = this.parent.globalize.formatDate(date, {\n      skeleton: 'MMMd',\n      calendar: this.parent.getCalendarMode()\n    }) + ', ' + this.parent.getDayNames('wide')[date.getDay()];\n    return capitalizeFirstWord(text, 'multiple');\n  }\n  createEventTable(trCount) {\n    const eventTable = createElement('div', {\n      className: EVENT_TABLE_CLASS\n    });\n    append(this.getEventRows(trCount), eventTable);\n    return eventTable;\n  }\n  getEventRows(trCount) {\n    const eventRows = [];\n    let eventContainer;\n    for (let row = 0; row < trCount; row++) {\n      eventContainer = createElement('div', {\n        className: APPOINTMENT_CONTAINER_CLASS\n      });\n      if (this.parent.resourceBase && !this.parent.uiStateValues.isGroupAdaptive && this.parent.resourceBase.renderedResources) {\n        eventContainer.setAttribute('data-group-index', this.parent.resourceBase.renderedResources[row].groupIndex.toString());\n      }\n      eventRows.push(eventContainer);\n    }\n    return eventRows;\n  }\n  collapseRows(wrap) {\n    if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {\n      this.parent.resourceBase.hideResourceRows(wrap.querySelector('tbody'));\n      this.parent.resourceBase.hideResourceRows(wrap.querySelector('.' + EVENT_TABLE_CLASS));\n    }\n  }\n  createTableLayout(className) {\n    const clsName = className || '';\n    const table = createElement('table', {\n      className: SCHEDULE_TABLE_CLASS + ' ' + clsName,\n      attrs: {\n        role: 'table'\n      }\n    });\n    const tbody = createElement('tbody');\n    table.appendChild(tbody);\n    return table;\n  }\n  createColGroup(table, lastRow) {\n    let length = lastRow.length;\n    if (lastRow[0] && lastRow[0].colSpan) {\n      length = lastRow.map(value => value.colSpan).reduce((prev, next) => prev + next);\n    }\n    const colGroupEle = createElement('colgroup');\n    for (let i = 0; i < length; i++) {\n      colGroupEle.appendChild(createElement('col'));\n    }\n    prepend([colGroupEle], table);\n  }\n  getScrollXIndent(content) {\n    return content.offsetHeight - content.clientHeight > 0 ? getScrollBarWidth() : 0;\n  }\n  scrollTopPanel(target) {\n    this.getDatesHeaderElement().firstElementChild.scrollLeft = target.scrollLeft;\n  }\n  scrollHeaderLabels(target) {\n    const headerTable = this.element.querySelector('.e-date-header-wrap table');\n    const colWidth = headerTable.offsetWidth / headerTable.querySelectorAll('colgroup col').length;\n    const applyLeft = (headerCells, isRtl) => {\n      let currentCell;\n      let tdLeft = 0;\n      let colSpan = 0;\n      const hiddenLeft = isRtl ? -target.scrollLeft : target.scrollLeft;\n      for (const cell of headerCells) {\n        colSpan += parseInt(cell.getAttribute('colSpan'), 10);\n        if (colSpan > Math.floor(hiddenLeft / colWidth)) {\n          currentCell = cell;\n          break;\n        }\n        tdLeft += cell.offsetWidth;\n      }\n      if (!isNullOrUndefined(currentCell)) {\n        currentCell.children[0].style[isRtl ? 'right' : 'left'] = hiddenLeft - tdLeft + 'px';\n      }\n    };\n    const classNames = ['.e-header-year-cell', '.e-header-month-cell', '.e-header-week-cell', '.e-header-cells'];\n    for (const className of classNames) {\n      const headerCells = [].slice.call(this.element.querySelectorAll(className));\n      if (headerCells.length > 0) {\n        for (const element of headerCells) {\n          element.children[0].style[this.parent.enableRtl ? 'right' : 'left'] = '';\n        }\n        applyLeft(headerCells, this.parent.enableRtl);\n      }\n    }\n  }\n  addAttributes(td, element) {\n    if (td.template) {\n      append(td.template, element);\n    }\n    if (td.colSpan) {\n      element.setAttribute('colspan', td.colSpan.toString());\n    }\n    if (td.className) {\n      addClass([element], td.className);\n    }\n  }\n  getHeaderBarHeight() {\n    let headerBarHeight = 2;\n    if (this.parent.headerModule) {\n      headerBarHeight += getOuterHeight(this.parent.headerModule.getHeaderElement());\n    }\n    if (this.parent.uiStateValues.isGroupAdaptive) {\n      const resHeader = this.parent.element.querySelector('.' + RESOURCE_HEADER_TOOLBAR);\n      if (resHeader) {\n        headerBarHeight += resHeader.offsetHeight;\n      }\n    }\n    return headerBarHeight;\n  }\n  renderPanel(type) {\n    if (type === PREVIOUS_PANEL_CLASS) {\n      prepend([this.element], this.parent.element.querySelector('.' + TABLE_CONTAINER_CLASS));\n    } else {\n      this.parent.element.querySelector('.' + TABLE_CONTAINER_CLASS).appendChild(this.element);\n    }\n  }\n  setPanel(panel) {\n    this.element = panel;\n  }\n  getPanel() {\n    return this.element;\n  }\n  getDatesHeaderElement() {\n    return this.element.querySelector('.' + DATE_HEADER_CONTAINER_CLASS);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  getDateSlots(renderDates, workDays) {\n    return []; // Here getDateSlots only need in vertical and month views\n  }\n\n  generateColumnLevels() {\n    return []; // Here generateColumnLevels only need in vertical and month views\n  }\n\n  getColumnLevels() {\n    return this.colLevels;\n  }\n  highlightCurrentTime() {\n    // Here showTimeIndicator functionalities\n  }\n  startDate() {\n    return this.renderDates[0];\n  }\n  endDate() {\n    return addDays(this.renderDates[this.renderDates.length - 1], 1);\n  }\n  getStartHour() {\n    let startHour = this.parent.getStartEndTime(this.parent.activeViewOptions.startHour);\n    if (isNullOrUndefined(startHour)) {\n      startHour = new Date(2000, 0, 0, 0);\n    }\n    return startHour;\n  }\n  getEndHour() {\n    let endHour = this.parent.getStartEndTime(this.parent.activeViewOptions.endHour);\n    if (isNullOrUndefined(endHour)) {\n      endHour = new Date(2000, 0, 0, 0);\n    }\n    return endHour;\n  }\n  isCurrentDate(date) {\n    return date.setHours(0, 0, 0, 0) === this.parent.getCurrentTime().setHours(0, 0, 0, 0);\n  }\n  isCurrentMonth(date) {\n    if (this.parent.activeViewOptions.displayDate || this.parent.activeViewOptions.numberOfWeeks > 0) {\n      return this.parent.activeView.getStartDate().getTime() <= this.parent.getCurrentTime().getTime() && this.parent.activeView.getEndDate().getTime() >= this.parent.getCurrentTime().getTime();\n    }\n    return date.getFullYear() === this.parent.getCurrentTime().getFullYear() && date.getMonth() === this.parent.getCurrentTime().getMonth();\n  }\n  isWorkDay(date, workDays = this.parent.activeViewOptions.workDays) {\n    if (workDays.indexOf(date.getDay()) >= 0) {\n      return true;\n    }\n    return false;\n  }\n  isWorkHour(date, startHour, endHour, workDays) {\n    if (isNullOrUndefined(startHour) || isNullOrUndefined(endHour)) {\n      return false;\n    }\n    startHour.setMilliseconds(0);\n    endHour.setMilliseconds(0);\n    return !(getDateInMs(date) < getDateInMs(startHour) || getDateInMs(date) >= getDateInMs(endHour) || !this.isWorkDay(date, workDays));\n  }\n  getRenderDates(workDays) {\n    const renderDates = [];\n    // Due to same code for vertical and time line, week & work week views, if condition has used\n    if (this.parent.currentView === 'Week' || this.parent.currentView === 'TimelineWeek') {\n      const selectedDate = resetTime(this.parent.selectedDate);\n      let start = getWeekFirstDate(selectedDate, this.parent.activeViewOptions.firstDayOfWeek);\n      for (let i = 0, length = WEEK_LENGTH * this.parent.activeViewOptions.interval; i < length; i++) {\n        if (this.parent.activeViewOptions.showWeekend) {\n          renderDates.push(start);\n        } else {\n          if (this.isWorkDay(start, workDays)) {\n            renderDates.push(start);\n          }\n        }\n        start = addDays(start, 1);\n      }\n    } else if (this.parent.currentView === 'WorkWeek' || this.parent.currentView === 'TimelineWorkWeek') {\n      let start = getWeekFirstDate(resetTime(this.parent.selectedDate), this.parent.activeViewOptions.firstDayOfWeek);\n      for (let i = 0, length = WEEK_LENGTH * this.parent.activeViewOptions.interval; i < length; i++) {\n        if (this.isWorkDay(start, workDays)) {\n          renderDates.push(start);\n        }\n        start = addDays(start, 1);\n      }\n    } else {\n      const dayCount = this.parent.currentView === 'Agenda' ? this.parent.agendaDaysCount : this.parent.activeViewOptions.interval;\n      let start = resetTime(this.parent.selectedDate);\n      do {\n        if (this.parent.activeViewOptions.showWeekend) {\n          renderDates.push(start);\n        } else {\n          if (this.isWorkDay(start, workDays)) {\n            renderDates.push(start);\n          }\n        }\n        start = addDays(start, 1);\n      } while (dayCount !== renderDates.length);\n    }\n    if (!workDays) {\n      this.renderDates = renderDates;\n    }\n    if (this.parent.headerModule) {\n      this.parent.headerModule.previousNextIconHandler();\n    }\n    return renderDates;\n  }\n  getNextPreviousDate(type) {\n    if (this.parent.currentView === 'Day' || this.parent.currentView === 'TimelineDay') {\n      if (this.parent.activeViewOptions.showWeekend) {\n        const daysCount = this.parent.activeViewOptions.interval;\n        return addDays(this.parent.selectedDate, type === 'next' ? daysCount : -daysCount);\n      } else {\n        let date;\n        if (type === 'next') {\n          date = addDays(this.renderDates.slice(-1)[0], 1);\n          while (!this.isWorkDay(date)) {\n            date = addDays(date, 1);\n          }\n        } else {\n          date = addDays(this.renderDates[0], -1);\n          let count = 0;\n          do {\n            if (this.isWorkDay(date)) {\n              count += 1;\n            }\n            if (this.parent.activeViewOptions.interval !== count) {\n              date = addDays(date, -1);\n            }\n          } while (this.parent.activeViewOptions.interval !== count);\n        }\n        return date;\n      }\n    }\n    const weekLength = type === 'next' ? WEEK_LENGTH : -WEEK_LENGTH;\n    return addDays(this.parent.selectedDate, weekLength * this.parent.activeViewOptions.interval);\n  }\n  getLabelText(view) {\n    const viewStr = view.charAt(0).toLowerCase() + view.substring(1);\n    return this.parent.localeObj.getConstant(viewStr) + ' of ' + capitalizeFirstWord(this.parent.globalize.formatDate(this.parent.selectedDate, {\n      skeleton: 'long',\n      calendar: this.parent.getCalendarMode()\n    }), 'single');\n  }\n  getDateRangeText() {\n    if (this.parent.isAdaptive) {\n      const formatDate = this.parent.activeViewOptions.dateFormat ? this.parent.activeViewOptions.dateFormat : 'MMMM y';\n      return capitalizeFirstWord(this.parent.globalize.formatDate(this.parent.selectedDate, {\n        format: formatDate,\n        calendar: this.parent.getCalendarMode()\n      }), 'single');\n    }\n    return this.formatDateRange(this.renderDates[0], this.renderDates[this.renderDates.length - 1]);\n  }\n  formatDateRange(startDate, endDate) {\n    const globalize = this.parent.globalize;\n    const mode = this.parent.getCalendarMode();\n    if (startDate === endDate) {\n      endDate = null;\n    }\n    if (!isNullOrUndefined(this.parent.activeViewOptions.dateFormat)) {\n      let text = '';\n      if (!endDate) {\n        text = globalize.formatDate(startDate, {\n          format: this.parent.activeViewOptions.dateFormat,\n          calendar: mode\n        });\n        return capitalizeFirstWord(text, 'multiple');\n      }\n      text = globalize.formatDate(startDate, {\n        format: this.parent.activeViewOptions.dateFormat,\n        calendar: mode\n      }) + ' - ' + globalize.formatDate(endDate, {\n        format: this.parent.activeViewOptions.dateFormat,\n        calendar: mode\n      });\n      return capitalizeFirstWord(text, 'multiple');\n    }\n    let formattedStr;\n    let longDateFormat;\n    if (this.parent.locale === 'en' || this.parent.locale === 'en-US') {\n      longDateFormat = getValue('dateFormats.long', getDefaultDateObject(mode));\n    } else {\n      longDateFormat = getValue('main.' + '' + this.parent.locale + '.dates.calendars.' + mode + '.dateFormats.long', cldrData);\n    }\n    if (!endDate) {\n      return capitalizeFirstWord(globalize.formatDate(startDate, {\n        format: longDateFormat,\n        calendar: mode\n      }), 'single');\n    }\n    const dateFormat = longDateFormat.trim().toLocaleLowerCase();\n    if (dateFormat.substr(0, 1) === 'd') {\n      if (startDate.getFullYear() === endDate.getFullYear()) {\n        if (startDate.getMonth() === endDate.getMonth()) {\n          formattedStr = globalize.formatDate(startDate, {\n            format: 'dd',\n            calendar: mode\n          }) + ' - ' + globalize.formatDate(endDate, {\n            format: 'dd MMMM yyyy',\n            calendar: mode\n          });\n        } else {\n          formattedStr = globalize.formatDate(startDate, {\n            format: 'dd MMM',\n            calendar: mode\n          }) + ' - ' + globalize.formatDate(endDate, {\n            format: 'dd MMM yyyy',\n            calendar: mode\n          });\n        }\n      } else {\n        formattedStr = globalize.formatDate(startDate, {\n          format: 'dd MMM yyyy',\n          calendar: mode\n        }) + ' - ' + globalize.formatDate(endDate, {\n          format: 'dd MMM yyyy',\n          calendar: mode\n        });\n      }\n    } else if (dateFormat.substr(0, 1) === 'm') {\n      if (startDate.getFullYear() === endDate.getFullYear()) {\n        if (startDate.getMonth() === endDate.getMonth()) {\n          formattedStr = globalize.formatDate(startDate, {\n            format: 'MMMM dd',\n            calendar: mode\n          }) + ' - ' + globalize.formatDate(endDate, {\n            format: 'dd, yyyy',\n            calendar: mode\n          });\n        } else {\n          formattedStr = globalize.formatDate(startDate, {\n            format: 'MMM dd',\n            calendar: mode\n          }) + ' - ' + globalize.formatDate(endDate, {\n            format: 'MMM dd, yyyy',\n            calendar: mode\n          });\n        }\n      } else {\n        formattedStr = globalize.formatDate(startDate, {\n          format: 'MMM dd, yyyy',\n          calendar: mode\n        }) + ' - ' + globalize.formatDate(endDate, {\n          format: 'MMM dd, yyyy',\n          calendar: mode\n        });\n      }\n    } else {\n      formattedStr = globalize.formatDate(startDate, {\n        format: longDateFormat,\n        calendar: mode\n      }) + ' - ' + globalize.formatDate(endDate, {\n        format: longDateFormat,\n        calendar: mode\n      });\n    }\n    return capitalizeFirstWord(formattedStr, 'multiple');\n  }\n  getMobileDateElement(date, className) {\n    const wrap = createElement('div', {\n      className: className,\n      innerHTML: '<div class=\"e-m-date\">' + this.parent.globalize.formatDate(date, {\n        format: 'd',\n        calendar: this.parent.getCalendarMode()\n      }) + '</div>' + '<div class=\"e-m-day\">' + capitalizeFirstWord(this.parent.globalize.formatDate(date, {\n        format: 'E',\n        calendar: this.parent.getCalendarMode()\n      }), 'single') + '</div>'\n    });\n    return wrap;\n  }\n  setResourceHeaderContent(tdElement, tdData, className = TEXT_ELLIPSIS) {\n    if (this.parent.activeViewOptions.resourceHeaderTemplate) {\n      const data = {\n        resource: tdData.resource,\n        resourceData: tdData.resourceData\n      };\n      const scheduleId = this.parent.element.id + '_';\n      const viewName = this.parent.activeViewOptions.resourceHeaderTemplateName;\n      const templateId = scheduleId + viewName + 'resourceHeaderTemplate';\n      const quickTemplate = [].slice.call(this.parent.getResourceHeaderTemplate()(data, this.parent, 'resourceHeaderTemplate', templateId, false));\n      append(quickTemplate, tdElement);\n    } else {\n      tdElement.appendChild(createElement('div', {\n        className: className,\n        innerHTML: tdData.resourceData[tdData.resource.textField]\n      }));\n    }\n  }\n  renderResourceMobileLayout() {\n    if (this.parent.resourceBase.lastResourceLevel && this.parent.resourceBase.lastResourceLevel.length <= 0) {\n      return;\n    }\n    this.parent.resourceBase.renderResourceHeader();\n    this.parent.resourceBase.renderResourceTree();\n  }\n  addAutoHeightClass(element) {\n    if (!this.parent.uiStateValues.isGroupAdaptive && this.parent.rowAutoHeight && this.isTimelineView() && this.parent.activeViewOptions.group.resources.length > 0) {\n      addClass([element], AUTO_HEIGHT);\n    }\n  }\n  getColElements() {\n    return [].slice.call(this.element.querySelectorAll('.' + CONTENT_WRAP_CLASS + ' col, .' + DATE_HEADER_WRAP_CLASS + ' col'));\n  }\n  setColWidth(content) {\n    if (this.isTimelineView()) {\n      const colElements = this.getColElements();\n      const contentBody = this.element.querySelector('.' + CONTENT_TABLE_CLASS + ' tbody');\n      const colWidth = contentBody.getBoundingClientRect().width / (colElements.length / 2);\n      colElements.forEach(col => setStyleAttribute(col, {\n        'width': formatUnit(colWidth)\n      }));\n      if (content.offsetHeight !== content.clientHeight) {\n        const resourceColumn = this.parent.element.querySelector('.' + RESOURCE_COLUMN_WRAP_CLASS);\n        if (!isNullOrUndefined(resourceColumn)) {\n          setStyleAttribute(resourceColumn, {\n            'height': formatUnit(content.clientHeight)\n          });\n        }\n      }\n      const cssClass = `.${HEADER_CELLS_CLASS},.${TIME_SLOT_CLASS},.${HEADER_WEEK_CELLS_CLASS},.${HEADER_MONTH_CELLS_CLASS},.${HEADER_YEAR_CELLS_CLASS}`;\n      const headerCellElements = [].slice.call(this.element.querySelectorAll(cssClass));\n      headerCellElements.forEach(ele => {\n        const colSpan = isNullOrUndefined(ele.getAttribute('colspan')) ? '1' : ele.getAttribute('colspan');\n        const headerCellColSpan = parseInt(colSpan, 10);\n        setStyleAttribute(ele, {\n          'width': formatUnit(colWidth * headerCellColSpan)\n        });\n      });\n    }\n  }\n  resetColWidth() {\n    const colElements = this.getColElements();\n    for (const col of colElements) {\n      col.style.width = '';\n    }\n  }\n  getContentAreaElement() {\n    return this.element.querySelector('.' + CONTENT_WRAP_CLASS);\n  }\n  wireExpandCollapseIconEvents() {\n    if (this.parent.resourceBase && this.parent.resourceBase.resourceCollection.length > 1) {\n      const treeIcons = [].slice.call(this.element.querySelectorAll('.' + RESOURCE_TREE_ICON_CLASS));\n      for (const icon of treeIcons) {\n        EventHandler.clearEvents(icon);\n        EventHandler.add(icon, 'click', this.parent.resourceBase.onTreeIconClick, this.parent.resourceBase);\n      }\n    }\n  }\n  scrollToDate(scrollDate) {\n    if (['Month', 'TimelineMonth'].indexOf(this.parent.currentView) === -1 || isNullOrUndefined(scrollDate)) {\n      return;\n    }\n    const scrollWrap = this.getContentAreaElement();\n    const tdDate = new Date(resetTime(new Date(+scrollDate)).getTime()).getTime();\n    const dateElement = scrollWrap.querySelector(`.${WORK_CELLS_CLASS}[data-date=\"${tdDate}\"]`);\n    if (this.parent.currentView === 'Month' && dateElement) {\n      scrollWrap.scrollTop = dateElement.offsetTop;\n    }\n    if (this.parent.currentView === 'TimelineMonth' && dateElement) {\n      if (!this.parent.enableRtl) {\n        scrollWrap.scrollLeft = dateElement.offsetLeft;\n      } else {\n        scrollWrap.scrollLeft = -(this.parent.getContentTable().offsetWidth - dateElement.offsetLeft - dateElement.offsetWidth);\n      }\n    }\n  }\n  setPersistence() {\n    if (this.parent.enablePersistence) {\n      const contentWrap = this.element.querySelector('.e-content-wrap');\n      if (!isNullOrUndefined(contentWrap)) {\n        this.parent.scrollLeft = contentWrap.scrollLeft;\n        this.parent.scrollTop = contentWrap.scrollTop;\n      }\n    }\n  }\n  retainScrollPosition() {\n    if (this.parent.enablePersistence) {\n      const conWrap = this.parent.element.querySelector('.e-content-wrap');\n      if (!isNullOrUndefined(conWrap) && !isNullOrUndefined(this.parent.scrollLeft) && !isNullOrUndefined(this.parent.scrollTop)) {\n        conWrap.scrollTop = this.parent.scrollTop;\n        conWrap.scrollLeft = this.parent.scrollLeft;\n      }\n    }\n  }\n  getViewStartDate() {\n    let startDate = this.renderDates[0];\n    if (this.parent.activeViewOptions.group.resources.length > 0 && this.parent.resourceBase.lastResourceLevel.length > 0) {\n      startDate = this.parent.resourceBase.getResourceRenderDates()[0];\n    }\n    return startDate;\n  }\n  getViewEndDate() {\n    let endDate = addDays(this.renderDates[this.renderDates.length - 1], 1);\n    if (this.parent.activeViewOptions.group.resources.length > 0 && this.parent.resourceBase.lastResourceLevel.length > 0) {\n      endDate = addDays(this.parent.resourceBase.getResourceRenderDates().slice(-1)[0], 1);\n    }\n    return endDate;\n  }\n  destroy() {\n    if (this.element && this.element.parentNode) {\n      remove(this.element);\n    }\n    this.element = null;\n    this.renderDates = null;\n    this.colLevels = null;\n  }\n}\n\n/**\n * vertical view\n */\nclass VerticalView extends ViewBase {\n  constructor(parent) {\n    super(parent);\n    this.viewClass = 'e-day-view';\n    this.isInverseTableSelect = true;\n    this.baseCssClass = 'e-vertical-view';\n    this.appointment = null;\n  }\n  getModuleName() {\n    return 'verticalView';\n  }\n  addEventListener() {\n    this.parent.on(scrollUiUpdate, this.scrollUiUpdate, this);\n    this.parent.on(dataReady, this.renderEvents, this);\n  }\n  removeEventListener() {\n    if (this.parent) {\n      this.parent.off(scrollUiUpdate, this.scrollUiUpdate);\n      this.parent.off(dataReady, this.renderEvents);\n    }\n  }\n  renderEvents() {\n    this.appointment = this.parent.activeViewOptions.timeScale.enable ? new VerticalEvent(this.parent) : new MonthEvent(this.parent);\n    this.appointment.renderAppointments();\n    this.parent.notify(eventsLoaded, {});\n  }\n  onContentScroll(e) {\n    this.parent.removeNewEventElement();\n    const target = e.target;\n    this.parent.notify(virtualScroll, e);\n    this.scrollLeftPanel(target);\n    this.scrollTopPanel(target);\n    if (!this.parent.isAdaptive) {\n      this.parent.uiStateValues.top = target.scrollTop;\n    }\n    this.parent.uiStateValues.left = target.scrollLeft;\n    if (!isNullOrUndefined(this.parent.quickPopup)) {\n      this.parent.quickPopup.quickPopupHide();\n    }\n    this.setPersistence();\n  }\n  onAdaptiveMove(e) {\n    if (this.parent.uiStateValues.action) {\n      e.preventDefault();\n    }\n  }\n  onAdaptiveScroll(e) {\n    if (this.parent && !this.parent.isDestroyed) {\n      this.parent.removeNewEventElement();\n      this.parent.uiStateValues.top = e.target.scrollTop;\n    }\n  }\n  scrollLeftPanel(target) {\n    const leftPanel = this.getLeftPanelElement();\n    if (!isNullOrUndefined(leftPanel)) {\n      leftPanel.scrollTop = target.scrollTop;\n    }\n  }\n  scrollUiUpdate(args) {\n    if (!this.parent) {\n      return;\n    }\n    const dateHeader = this.parent.element.querySelector('.' + DATE_HEADER_WRAP_CLASS);\n    const headerBarHeight = this.getHeaderBarHeight();\n    const timeCells = this.getLeftPanelElement();\n    const content = this.getScrollableElement();\n    const header = this.getDatesHeaderElement();\n    const scrollerHeight = this.parent.element.offsetHeight - headerBarHeight - header.offsetHeight;\n    this.setColWidth(content);\n    this.setContentHeight(content, timeCells, scrollerHeight);\n    const scrollBarWidth = getScrollBarWidth();\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    header.firstElementChild.style[args.cssProperties.rtlBorder] = '';\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    header.style[args.cssProperties.rtlPadding] = '';\n    const isDateHeaderScroll = this.parent.enableAllDayScroll ? !(content.offsetWidth - content.clientWidth <= dateHeader.offsetWidth - dateHeader.clientWidth && dateHeader.classList.contains('e-all-day-scroll')) : true;\n    if (content.offsetWidth - content.clientWidth > 0 && isDateHeaderScroll) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      header.firstElementChild.style[args.cssProperties.border] = scrollBarWidth > 0 ? '1px' : '0px';\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      header.style[args.cssProperties.padding] = scrollBarWidth > 0 ? scrollBarWidth - 1 + 'px' : '0px';\n    } else {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      header.firstElementChild.style[args.cssProperties.border] = '';\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      header.style[args.cssProperties.padding] = '';\n    }\n    if (!args.isPreventScrollUpdate) {\n      if (this.parent.uiStateValues.isInitial) {\n        this.scrollToWorkHour();\n        this.parent.uiStateValues.isInitial = false;\n      } else {\n        if (timeCells) {\n          timeCells.scrollTop = this.parent.uiStateValues.top;\n        }\n        content.scrollTop = this.parent.uiStateValues.top;\n        content.scrollLeft = this.parent.uiStateValues.left;\n      }\n    }\n    if (this.parent.activeViewOptions.timeScale.enable) {\n      this.highlightCurrentTime();\n    }\n    this.retainScrollPosition();\n  }\n  setContentHeight(element, leftPanelElement, height) {\n    if (this.parent.isAdaptive && !this.isTimelineView()) {\n      element.style.height = this.parent.height === 'auto' ? 'auto' : formatUnit(height);\n    } else {\n      if (!isNullOrUndefined(leftPanelElement)) {\n        leftPanelElement.style.height = this.parent.height === 'auto' ? 'auto' : formatUnit(height - this.getScrollXIndent(element));\n      }\n      element.style.height = this.parent.height === 'auto' ? 'auto' : formatUnit(height);\n    }\n  }\n  scrollToWorkHour() {\n    if (this.parent.workHours.highlight) {\n      const firstWorkHourCell = this.element.querySelector('.' + WORK_HOURS_CLASS);\n      if (firstWorkHourCell) {\n        this.getScrollableElement().scrollTop = firstWorkHourCell.offsetTop;\n        this.parent.uiStateValues.top = firstWorkHourCell.offsetTop;\n        this.parent.uiStateValues.left = 0;\n      }\n    }\n  }\n  scrollToHour(hour, scrollDate) {\n    const date = this.parent.getStartEndTime(hour);\n    if (isNullOrUndefined(date) || !isNullOrUndefined(scrollDate)) {\n      return;\n    }\n    this.getScrollableElement().scrollTop = this.getTopFromDateTime(date);\n  }\n  generateColumnLevels() {\n    const level = this.getDateSlots(this.renderDates, this.parent.activeViewOptions.workDays);\n    let columnLevels = [];\n    if (this.parent.activeViewOptions.group.resources.length > 0) {\n      columnLevels = this.parent.resourceBase.generateResourceLevels(level);\n      if (this.parent.uiStateValues.isGroupAdaptive && this.parent.resourceBase.lastResourceLevel.length > 0) {\n        const resourceLevel = this.parent.resourceBase.lastResourceLevel[this.parent.uiStateValues.groupIndex];\n        const resStartHour = resourceLevel.resourceData[resourceLevel.resource.startHourField];\n        const resEndHour = resourceLevel.resourceData[resourceLevel.resource.endHourField];\n        const dateSlots = this.getDateSlots(resourceLevel.renderDates, resourceLevel.workDays, resStartHour, resEndHour);\n        columnLevels = [dateSlots];\n      }\n    } else {\n      columnLevels.push(level);\n    }\n    this.colLevels = columnLevels;\n    return columnLevels;\n  }\n  // eslint-disable-next-line max-len\n  getDateSlots(renderDates, workDays, workStartHour = this.parent.workHours.start, workEndHour = this.parent.workHours.end) {\n    const dateCol = [];\n    const start = this.parent.getStartEndTime(workStartHour);\n    const end = this.parent.getStartEndTime(workEndHour);\n    for (const col of renderDates) {\n      const classList$$1 = [HEADER_CELLS_CLASS];\n      if (this.isCurrentDate(col)) {\n        classList$$1.push(CURRENT_DAY_CLASS);\n      }\n      dateCol.push({\n        date: col,\n        type: 'dateHeader',\n        className: classList$$1,\n        colSpan: 1,\n        workDays: workDays,\n        startHour: new Date(+start),\n        endHour: new Date(+end)\n      });\n    }\n    return dateCol;\n  }\n  isWorkHourRange(date) {\n    return this.getStartHour().getTime() <= date.getTime() && this.getEndHour().getTime() >= date.getTime();\n  }\n  highlightCurrentTime() {\n    if (this.parent.activeViewOptions.headerRows.length > 0 && this.parent.activeViewOptions.headerRows.slice(-1)[0].option !== 'Hour') {\n      return;\n    }\n    if (this.parent.showTimeIndicator && this.isWorkHourRange(this.parent.getCurrentTime())) {\n      const currentDateIndex = this.getCurrentTimeIndicatorIndex();\n      if (currentDateIndex.length > 0) {\n        const workCells = [].slice.call(this.element.querySelectorAll('.' + WORK_CELLS_CLASS));\n        if (workCells.length > 0) {\n          this.changeCurrentTimePosition();\n        }\n        if (isNullOrUndefined(this.currentTimeIndicatorTimer)) {\n          const currentDate = this.parent.getCurrentTime();\n          const interval = MS_PER_MINUTE - (currentDate.getSeconds() * 1000 + currentDate.getMilliseconds());\n          if (interval <= MS_PER_MINUTE - 1000) {\n            window.setTimeout(() => {\n              if (!isNullOrUndefined(this.currentTimeIndicatorTimer)) {\n                this.clearCurrentTimeIndicatorTimer();\n                this.changeCurrentTimePosition();\n                this.updateCurrentTimeIndicatorTimer();\n              }\n            }, interval);\n          }\n          this.updateCurrentTimeIndicatorTimer();\n        }\n      } else {\n        this.clearCurrentTimeIndicatorTimer();\n      }\n    } else {\n      this.clearCurrentTimeIndicatorTimer();\n    }\n  }\n  getCurrentTimeIndicatorIndex() {\n    const currentDateIndex = [];\n    if (!isNullOrUndefined(this.parent.resourceBase) && this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {\n      let count = 0;\n      for (const resource of this.parent.resourceBase.lastResourceLevel) {\n        const index = this.parent.getIndexOfDate(resource.renderDates, resetTime(this.parent.getCurrentTime()));\n        if (index >= 0) {\n          const resIndex = this.parent.activeViewOptions.group.byDate ? this.parent.resourceBase.lastResourceLevel.length * index + count : count + index;\n          currentDateIndex.push(resIndex);\n        }\n        count += this.parent.activeViewOptions.group.byDate ? 1 : resource.renderDates.length;\n      }\n    } else {\n      const renderDates = this.parent.uiStateValues.isGroupAdaptive && this.parent.resourceBase.lastResourceLevel.length > 0 ? this.parent.resourceBase.lastResourceLevel[this.parent.uiStateValues.groupIndex].renderDates : this.renderDates;\n      const index = this.parent.getIndexOfDate(renderDates, resetTime(this.parent.getCurrentTime()));\n      if (index >= 0) {\n        currentDateIndex.push(index);\n      }\n    }\n    return currentDateIndex;\n  }\n  clearCurrentTimeIndicatorTimer() {\n    if (!isNullOrUndefined(this.currentTimeIndicatorTimer)) {\n      window.clearInterval(this.currentTimeIndicatorTimer);\n      this.currentTimeIndicatorTimer = null;\n      this.removeCurrentTimeIndicatorElements();\n    }\n  }\n  updateCurrentTimeIndicatorTimer() {\n    this.currentTimeIndicatorTimer = window.setInterval(() => {\n      this.changeCurrentTimePosition();\n    }, MS_PER_MINUTE);\n  }\n  removeCurrentTimeIndicatorElements() {\n    const queryString = '.' + PREVIOUS_TIMELINE_CLASS + ',.' + CURRENT_TIMELINE_CLASS + ',.' + CURRENT_TIME_CLASS;\n    const timeIndicator = [].slice.call(this.element.querySelectorAll(queryString));\n    for (const indicator of timeIndicator) {\n      remove(indicator);\n    }\n  }\n  changeCurrentTimePosition() {\n    if (!this.parent || this.parent && this.parent.isDestroyed) {\n      return;\n    }\n    this.removeCurrentTimeIndicatorElements();\n    const currentDateIndex = this.getCurrentTimeIndicatorIndex();\n    const firstRow = this.parent.getContentTable().rows[0];\n    const top = this.getTopFromDateTime(this.parent.getCurrentTime());\n    const topInPx = formatUnit(top);\n    const rowIndex = Math.floor(top / firstRow.cells[0].offsetHeight);\n    const timeCellsWrap = this.getLeftPanelElement();\n    const timeTrs = [].slice.call(timeCellsWrap.querySelectorAll('tr'));\n    if (isNullOrUndefined(rowIndex) || isNaN(rowIndex) || rowIndex === timeTrs.length) {\n      return;\n    }\n    const curTimeWrap = [].slice.call(this.element.querySelectorAll('.' + TIMELINE_WRAPPER_CLASS));\n    for (let i = 0, length = currentDateIndex[0]; i < length; i++) {\n      curTimeWrap[i].appendChild(createElement('div', {\n        className: PREVIOUS_TIMELINE_CLASS,\n        styles: 'top:' + topInPx\n      }));\n    }\n    for (const day of currentDateIndex) {\n      curTimeWrap[day].appendChild(createElement('div', {\n        className: CURRENT_TIMELINE_CLASS,\n        styles: 'top:' + topInPx\n      }));\n    }\n    const currentTimeEle = createElement('div', {\n      innerHTML: this.parent.getTimeString(this.parent.getCurrentTime()),\n      className: CURRENT_TIME_CLASS,\n      styles: 'top:' + topInPx\n    });\n    if (rowIndex <= timeTrs.length) {\n      removeClass(timeCellsWrap.querySelectorAll('.' + HIDE_CHILDS_CLASS), HIDE_CHILDS_CLASS);\n      if (timeTrs[rowIndex]) {\n        addClass([timeTrs[rowIndex].lastElementChild], HIDE_CHILDS_CLASS);\n      }\n      prepend([currentTimeEle], timeCellsWrap);\n      currentTimeEle.style.top = formatUnit(currentTimeEle.offsetTop - currentTimeEle.offsetHeight / 2);\n    }\n  }\n  getTopFromDateTime(date) {\n    const startHour = this.getStartHour();\n    const diffInMinutes = (date.getHours() - startHour.getHours()) * 60 + (date.getMinutes() - startHour.getMinutes());\n    return diffInMinutes * this.getWorkCellHeight() * this.parent.activeViewOptions.timeScale.slotCount / this.parent.activeViewOptions.timeScale.interval;\n  }\n  getWorkCellHeight() {\n    return parseFloat(this.element.querySelector('.' + WORK_CELLS_CLASS).getBoundingClientRect().height.toFixed(2));\n  }\n  getTdContent(date, type, groupIndex) {\n    let cntEle;\n    const wrapper = createElement('div');\n    let templateName = '';\n    const templateId = this.parent.element.id + '_';\n    switch (type) {\n      case 'dateHeader':\n        if (this.parent.activeViewOptions.dateHeaderTemplate) {\n          templateName = 'dateHeaderTemplate';\n          const args = {\n            date: date,\n            type: type\n          };\n          const viewName = this.parent.activeViewOptions.dateHeaderTemplateName;\n          cntEle = [].slice.call(this.parent.getDateHeaderTemplate()(args, this.parent, templateName, templateId + viewName + templateName, false));\n        } else {\n          wrapper.innerHTML = this.parent.activeView.isTimelineView() ? `<span class=\"e-header-date e-navigate\">${this.getTimelineDate(date)}</span>` : `<div class=\"e-header-day\">${capitalizeFirstWord(this.getDayName(date), 'single')}</div>` + `<div class=\"e-header-date e-navigate\" role=\"link\">${this.getDate(date)}</div>`;\n          cntEle = [].slice.call(wrapper.childNodes);\n        }\n        break;\n      case 'majorSlot':\n        if (this.parent.activeViewOptions.timeScale.majorSlotTemplate) {\n          templateName = 'majorSlotTemplate';\n          const args = {\n            date: date,\n            type: type\n          };\n          cntEle = [].slice.call(this.parent.getMajorSlotTemplate()(args, this.parent, templateName, templateId + templateName, false));\n        } else {\n          wrapper.innerHTML = `<span>${this.getTime(date)}</span>`;\n          cntEle = [].slice.call(wrapper.childNodes);\n        }\n        break;\n      case 'minorSlot':\n        if (this.parent.activeViewOptions.timeScale.minorSlotTemplate) {\n          templateName = 'minorSlotTemplate';\n          const args = {\n            date: date,\n            type: type\n          };\n          cntEle = [].slice.call(this.parent.getMinorSlotTemplate()(args, this.parent, templateName, templateId + templateName, false));\n        } else {\n          cntEle = [].slice.call(wrapper.childNodes);\n        }\n        break;\n      case 'alldayCells':\n        if (this.parent.activeViewOptions.cellTemplate) {\n          const viewName = this.parent.activeViewOptions.cellTemplateName;\n          templateName = 'cellTemplate';\n          const args = {\n            date: date,\n            type: type,\n            groupIndex: groupIndex\n          };\n          cntEle = [].slice.call(this.parent.getCellTemplate()(args, this.parent, templateName, templateId + viewName + templateName, false));\n        }\n        break;\n    }\n    return cntEle;\n  }\n  refreshHeader() {\n    remove(this.element.querySelector('tbody tr'));\n    this.renderHeader();\n    this.parent.notify(contentReady, {});\n  }\n  renderLayout(type) {\n    this.setPanel(createElement('div', {\n      className: TABLE_WRAP_CLASS\n    }));\n    const clsList = [this.baseCssClass, this.viewClass];\n    clsList.push(type);\n    if (this.parent.activeViewOptions.group.byDate) {\n      clsList.push('e-by-date');\n    }\n    if (!this.parent.activeViewOptions.timeScale.enable) {\n      addClass([this.element], [TIMESCALE_DISABLE, this.viewClass]);\n    }\n    if (this.parent.activeViewOptions.allowVirtualScrolling) {\n      clsList.push(VIRTUAL_SCROLL_CLASS);\n    }\n    if (this.parent.rowAutoHeight && this.parent.eventSettings.ignoreWhitespace) {\n      clsList.push(IGNORE_WHITESPACE);\n    }\n    this.renderPanel(type);\n    addClass([this.element], clsList);\n    this.element.appendChild(this.createTableLayout(OUTER_TABLE_CLASS));\n    this.element.querySelector('table').setAttribute('role', 'presentation');\n    this.colLevels = this.generateColumnLevels();\n    this.renderHeader();\n    this.renderContent();\n    if (this.parent.uiStateValues.isGroupAdaptive && !this.parent.element.querySelector('.' + RESOURCE_TOOLBAR_CONTAINER)) {\n      this.renderResourceMobileLayout();\n    }\n    this.parent.notify(contentReady, {});\n  }\n  renderHeader() {\n    const tr = createElement('tr');\n    const dateTd = createElement('td');\n    dateTd.appendChild(this.renderDatesHeader());\n    if (this.parent.activeViewOptions.timeScale.enable) {\n      const indentTd = createElement('td', {\n        className: LEFT_INDENT_CLASS\n      });\n      indentTd.appendChild(this.renderLeftIndent());\n      tr.appendChild(indentTd);\n    }\n    tr.appendChild(dateTd);\n    prepend([tr], this.element.querySelector('tbody'));\n  }\n  renderContent() {\n    const tr = createElement('tr');\n    const workTd = createElement('td');\n    if (this.parent.isAdaptive) {\n      workTd.setAttribute('colspan', this.parent.activeViewOptions.timeScale.enable ? '2' : '1');\n      const scrollContainer = createElement('div', {\n        className: SCROLL_CONTAINER_CLASS\n      });\n      if (this.parent.activeViewOptions.timeScale.enable) {\n        scrollContainer.appendChild(this.renderTimeCells());\n      }\n      scrollContainer.appendChild(this.renderContentArea());\n      workTd.appendChild(scrollContainer);\n      EventHandler.add(scrollContainer, 'scroll', this.onAdaptiveScroll, this);\n      EventHandler.add(scrollContainer, Browser.touchMoveEvent, this.onAdaptiveMove, this);\n      tr.appendChild(workTd);\n    } else {\n      workTd.appendChild(this.renderContentArea());\n      if (this.parent.activeViewOptions.timeScale.enable) {\n        const timesTd = createElement('td');\n        timesTd.appendChild(this.renderTimeCells());\n        tr.appendChild(timesTd);\n      }\n      tr.appendChild(workTd);\n    }\n    this.element.querySelector('tbody').appendChild(tr);\n  }\n  renderLeftIndent() {\n    const wrap = createElement('div', {\n      className: LEFT_INDENT_WRAP_CLASS\n    });\n    const tbl = this.createTableLayout();\n    const trEle = createElement('tr');\n    const rowCount = this.colLevels.length;\n    let nth;\n    for (let i = 0; i < rowCount; i++) {\n      const ntr = trEle.cloneNode();\n      const data = {\n        className: [this.colLevels[i][0] && this.colLevels[i][0].className[0]],\n        type: 'emptyCells'\n      };\n      if (this.parent.activeViewOptions.showWeekNumber && data.className.indexOf(HEADER_CELLS_CLASS) !== -1) {\n        data.className.push(WEEK_NUMBER_CLASS);\n        const weekNo = this.parent.getWeekNumberContent(this.renderDates);\n        data.template = [createElement('span', {\n          innerHTML: '' + weekNo,\n          attrs: {\n            title: this.parent.localeObj.getConstant('week') + ' ' + weekNo\n          }\n        })];\n      }\n      nth = this.createTd(data);\n      this.parent.renderHeaderIndentTemplate(data, nth);\n      ntr.appendChild(nth);\n      tbl.querySelector('tbody').appendChild(ntr);\n    }\n    const ntr = trEle.cloneNode();\n    const appointmentExpandCollapse = createElement('div', {\n      attrs: {\n        'tabindex': '0',\n        'role': 'list',\n        title: this.parent.localeObj.getConstant('expandAllDaySection'),\n        'aria-disabled': 'false',\n        'aria-label': 'Expand section'\n      },\n      className: ALLDAY_APPOINTMENT_SECTION_CLASS + ' ' + APPOINTMENT_ROW_EXPAND_CLASS + ' ' + ICON + ' ' + DISABLE_CLASS\n    });\n    const data = {\n      className: [ALLDAY_CELLS_CLASS],\n      type: 'emptyCells'\n    };\n    nth = this.createTd(data);\n    nth.appendChild(appointmentExpandCollapse);\n    this.parent.renderHeaderIndentTemplate(data, nth);\n    ntr.appendChild(nth);\n    tbl.querySelector('tbody').appendChild(ntr);\n    wrap.appendChild(tbl);\n    return wrap;\n  }\n  renderDatesHeader() {\n    const container = createElement('div', {\n      className: DATE_HEADER_CONTAINER_CLASS\n    });\n    const wrap = createElement('div', {\n      className: DATE_HEADER_WRAP_CLASS\n    });\n    container.appendChild(wrap);\n    const tbl = this.createTableLayout();\n    const trEle = createElement('tr');\n    const rowCount = this.colLevels.length;\n    const lastLevel = this.colLevels[rowCount - 1];\n    for (let i = 0; i < rowCount; i++) {\n      const ntr = trEle.cloneNode();\n      addClass([ntr], HEADER_ROW_CLASS);\n      const level = this.colLevels[i];\n      for (let j = 0; j < level.length; j++) {\n        ntr.appendChild(this.createTd(level[j]));\n      }\n      tbl.querySelector('tbody').appendChild(ntr);\n    }\n    this.createAllDayRow(tbl, lastLevel);\n    this.createColGroup(tbl, lastLevel);\n    wrap.appendChild(tbl);\n    return container;\n  }\n  createAllDayRow(table, tdData) {\n    const ntr = createElement('tr');\n    addClass([ntr], ALLDAY_ROW_CLASS);\n    for (let j = 0; j < tdData.length; j++) {\n      const td = extend({}, tdData[j]);\n      td.className = [ALLDAY_CELLS_CLASS];\n      td.type = 'alldayCells';\n      const ntd = this.createTd(td);\n      ntd.setAttribute('data-date', td.date.getTime().toString());\n      if (!isNullOrUndefined(td.groupIndex)) {\n        ntd.setAttribute('data-group-index', '' + td.groupIndex);\n      } else if (this.parent.uiStateValues.isGroupAdaptive) {\n        ntd.setAttribute('data-group-index', '' + this.parent.uiStateValues.groupIndex);\n      }\n      this.wireCellEvents(ntd);\n      ntr.appendChild(ntd);\n    }\n    table.querySelector('tbody').appendChild(ntr);\n    const thead = createElement('thead');\n    thead.appendChild(this.createEventWrapper('allDay'));\n    prepend([thead], table);\n  }\n  createTd(td) {\n    const tdEle = createElement('td');\n    this.addAttributes(td, tdEle);\n    if (td.date && td.type) {\n      const ele = this.getTdContent(td.date, td.type, td.groupIndex);\n      if (ele && ele.length) {\n        append(ele, tdEle);\n      }\n    }\n    if (!this.parent.isMinMaxDate(resetTime(new Date('' + td.date)))) {\n      addClass([tdEle], DISABLE_DATES);\n    }\n    if (td.type === 'resourceHeader') {\n      this.setResourceHeaderContent(tdEle, td);\n    }\n    if (td.type === 'dateHeader' && td.className.indexOf(HEADER_CELLS_CLASS) >= 0) {\n      tdEle.setAttribute('data-date', td.date.getTime().toString());\n      if (!isNullOrUndefined(td.groupIndex)) {\n        tdEle.setAttribute('data-group-index', '' + td.groupIndex);\n      }\n      this.wireMouseEvents(tdEle);\n    }\n    const args = {\n      elementType: td.type,\n      element: tdEle,\n      date: td.date,\n      groupIndex: td.groupIndex\n    };\n    this.parent.trigger(renderCell, args);\n    return tdEle;\n  }\n  wireCellEvents(element) {\n    EventHandler.add(element, 'mousedown', this.parent.workCellAction.cellMouseDown, this.parent.workCellAction);\n    this.wireMouseEvents(element);\n  }\n  wireMouseEvents(element) {\n    EventHandler.add(element, 'click', this.parent.workCellAction.cellClick, this.parent.workCellAction);\n    if (!this.parent.isAdaptive) {\n      EventHandler.add(element, 'dblclick', this.parent.workCellAction.cellDblClick, this.parent.workCellAction);\n    }\n  }\n  renderTimeCells() {\n    const wrap = createElement('div', {\n      className: TIME_CELLS_WRAP_CLASS\n    });\n    const tbl = this.createTableLayout();\n    const trEle = createElement('tr');\n    const handler = r => {\n      r.type = r.first ? 'majorSlot' : 'minorSlot';\n      r.className = r.last ? [TIME_CELLS_CLASS, TIME_SLOT_CLASS] : [TIME_SLOT_CLASS];\n      const ntr = trEle.cloneNode();\n      const data = {\n        date: r.date,\n        type: r.type,\n        className: r.className\n      };\n      ntr.appendChild(this.createTd(data));\n      tbl.querySelector('tbody').appendChild(ntr);\n      return r;\n    };\n    this.getTimeSlotRows(handler);\n    wrap.appendChild(tbl);\n    return wrap;\n  }\n  renderContentArea() {\n    const wrap = createElement('div', {\n      className: CONTENT_WRAP_CLASS\n    });\n    const tbl = this.createTableLayout(CONTENT_TABLE_CLASS);\n    this.addAutoHeightClass(tbl);\n    this.renderContentTable(tbl);\n    this.createColGroup(tbl, this.colLevels.slice(-1)[0]);\n    wrap.appendChild(tbl);\n    this.wireCellEvents(tbl.querySelector('tbody'));\n    EventHandler.add(wrap, 'scroll', this.onContentScroll, this);\n    EventHandler.add(wrap, Browser.touchMoveEvent, this.onAdaptiveMove, this);\n    return wrap;\n  }\n  renderContentTable(table) {\n    const tr = createElement('tr', {\n      attrs: {\n        role: 'row'\n      }\n    });\n    const td = createElement('td', {\n      attrs: {\n        role: 'gridcell',\n        'aria-selected': 'false'\n      }\n    });\n    const tbody = table.querySelector('tbody');\n    const handler = r => {\n      const ntr = tr.cloneNode();\n      for (const tdData of this.colLevels[this.colLevels.length - 1]) {\n        const ntd = this.createContentTd(tdData, r, td);\n        ntr.appendChild(ntd);\n      }\n      tbody.appendChild(ntr);\n      return r;\n    };\n    this.getTimeSlotRows(handler);\n    this.renderContentTableHeader(table);\n  }\n  createContentTd(tdData, r, td) {\n    const ntd = td.cloneNode();\n    if (tdData.colSpan) {\n      ntd.setAttribute('colspan', tdData.colSpan.toString());\n    }\n    const clsName = this.getContentTdClass(r);\n    const cellDate = resetTime(tdData.date);\n    if (!this.parent.isMinMaxDate(cellDate)) {\n      clsName.push(DISABLE_DATES);\n    }\n    setTime(cellDate, getDateInMs(r.date));\n    let type = 'workCells';\n    if (tdData.className.indexOf(RESOURCE_PARENT_CLASS) !== -1) {\n      clsName.push(RESOURCE_GROUP_CELLS_CLASS);\n      type = 'resourceGroupCells';\n    }\n    if (this.parent.workHours.highlight && (this.parent.activeViewOptions.timeScale.enable && this.isWorkHour(cellDate, tdData.startHour, tdData.endHour, tdData.workDays) || !this.parent.activeViewOptions.timeScale.enable && this.isWorkDay(cellDate, tdData.workDays))) {\n      clsName.push(WORK_HOURS_CLASS);\n    }\n    addClass([ntd], clsName);\n    if (this.parent.activeViewOptions.cellTemplate) {\n      const args = {\n        date: cellDate,\n        type: type,\n        groupIndex: tdData.groupIndex\n      };\n      const scheduleId = this.parent.element.id + '_';\n      const viewName = this.parent.activeViewOptions.cellTemplateName;\n      const templateId = scheduleId + viewName + 'cellTemplate';\n      const tooltipTemplate = [].slice.call(this.parent.getCellTemplate()(args, this.parent, 'cellTemplate', templateId, false));\n      append(tooltipTemplate, ntd);\n    }\n    ntd.setAttribute('data-date', cellDate.getTime().toString());\n    if (!isNullOrUndefined(tdData.groupIndex) || this.parent.uiStateValues.isGroupAdaptive) {\n      const groupIndex = this.parent.uiStateValues.isGroupAdaptive ? this.parent.uiStateValues.groupIndex : tdData.groupIndex;\n      ntd.setAttribute('data-group-index', '' + groupIndex);\n    }\n    const args = {\n      elementType: type,\n      element: ntd,\n      date: cellDate,\n      groupIndex: tdData.groupIndex\n    };\n    this.parent.trigger(renderCell, args);\n    return ntd;\n  }\n  getContentTdClass(r) {\n    return r.last ? [WORK_CELLS_CLASS] : [WORK_CELLS_CLASS, ALTERNATE_CELLS_CLASS];\n  }\n  renderContentTableHeader(table) {\n    const thead = createElement('thead');\n    thead.appendChild(this.createEventWrapper());\n    if (this.parent.activeViewOptions.timeScale.enable) {\n      thead.appendChild(this.createEventWrapper('timeIndicator'));\n    }\n    prepend([thead], table);\n  }\n  createEventWrapper(type = '') {\n    const tr = createElement('tr');\n    const levels = this.colLevels.slice(-1)[0];\n    for (let i = 0, len = levels.length; i < len; i++) {\n      const col = levels[i];\n      const appointmentWrap = createElement('td', {\n        className: type === 'allDay' ? ALLDAY_APPOINTMENT_WRAPPER_CLASS : type === 'timeIndicator' ? TIMELINE_WRAPPER_CLASS : DAY_WRAPPER_CLASS,\n        attrs: {\n          'data-date': col.date.getTime().toString()\n        }\n      });\n      if (!isNullOrUndefined(col.groupIndex)) {\n        appointmentWrap.setAttribute('data-group-index', col.groupIndex.toString());\n      }\n      if (type === '') {\n        const innerWrapper = createElement('div', {\n          id: APPOINTMENT_WRAPPER_CLASS + '-' + i.toString(),\n          className: APPOINTMENT_WRAPPER_CLASS\n        });\n        appointmentWrap.appendChild(innerWrapper);\n      }\n      tr.appendChild(appointmentWrap);\n    }\n    return tr;\n  }\n  getScrollableElement() {\n    if (this.parent.isAdaptive && !this.isTimelineView()) {\n      return this.element.querySelector('.' + SCROLL_CONTAINER_CLASS);\n    } else {\n      return this.getContentAreaElement();\n    }\n  }\n  getLeftPanelElement() {\n    return this.element.querySelector('.' + TIME_CELLS_WRAP_CLASS);\n  }\n  getEndDateFromStartDate(start) {\n    const msMajorInterval = this.parent.activeViewOptions.timeScale.interval * MS_PER_MINUTE;\n    const msInterval = msMajorInterval / this.parent.activeViewOptions.timeScale.slotCount;\n    const end = new Date(start.getTime());\n    end.setMilliseconds(end.getMilliseconds() + msInterval);\n    return end;\n  }\n  getTimeSlotRows(handler) {\n    const rows = [];\n    const startHour = this.getStartHour();\n    const endHour = this.getEndHour();\n    const msMajorInterval = this.parent.activeViewOptions.timeScale.interval * MS_PER_MINUTE;\n    const msInterval = msMajorInterval / this.parent.activeViewOptions.timeScale.slotCount;\n    let length = Math.round(MS_PER_DAY / msInterval);\n    const msStartHour = startHour.getTime();\n    const msEndHour = endHour.getTime();\n    if (msStartHour !== msEndHour) {\n      length = Math.abs(msEndHour - msStartHour) / msInterval - (new Date(msEndHour).getTimezoneOffset() - new Date(msStartHour).getTimezoneOffset()) / (60 / this.parent.activeViewOptions.timeScale.slotCount);\n    }\n    if (!this.parent.activeViewOptions.timeScale.enable) {\n      length = 1;\n    }\n    const start = this.parent.getStartEndTime(this.parent.workHours.start);\n    const end = this.parent.getStartEndTime(this.parent.workHours.end);\n    for (let i = 0; i < length; i++) {\n      let dt = new Date(msStartHour + msInterval * i);\n      if (isDaylightSavingTime(dt) || new Date(msStartHour).getTimezoneOffset() !== dt.getTimezoneOffset()) {\n        const timeOffset = new Date(msStartHour).getTimezoneOffset() - dt.getTimezoneOffset();\n        dt = new Date(dt.getTime() - 1000 * 60 * timeOffset);\n      }\n      const majorTickDivider = i % (msMajorInterval / msInterval);\n      const row = {\n        date: new Date('' + dt),\n        startHour: start,\n        endHour: end,\n        first: majorTickDivider === 0,\n        middle: majorTickDivider < this.parent.activeViewOptions.timeScale.slotCount - 1,\n        last: majorTickDivider === this.parent.activeViewOptions.timeScale.slotCount - 1,\n        type: ''\n      };\n      if (handler) {\n        handler(row);\n      }\n      rows.push(row);\n    }\n    return rows;\n  }\n  destroy() {\n    if (!this.parent || this.parent && this.parent.isDestroyed) {\n      return;\n    }\n    this.clearCurrentTimeIndicatorTimer();\n    if (this.element) {\n      if (this.appointment) {\n        this.appointment.destroy();\n        this.appointment = null;\n      }\n      const contentScrollableEle = this.getContentAreaElement();\n      if (contentScrollableEle) {\n        EventHandler.remove(contentScrollableEle, 'scroll', this.onContentScroll);\n        EventHandler.remove(contentScrollableEle, Browser.touchMoveEvent, this.onAdaptiveMove);\n      }\n      if (this.parent.resourceBase) {\n        this.parent.resourceBase.destroy();\n      }\n      if (this.parent.scheduleTouchModule) {\n        this.parent.scheduleTouchModule.resetValues();\n      }\n      super.destroy();\n    }\n  }\n}\n\n/**\n * day view\n */\nclass Day extends VerticalView {\n  /**\n   * Constructor for day view\n   *\n   * @param {Schedule} parent Accepts the schedule instance\n   */\n  constructor(parent) {\n    super(parent);\n    this.viewClass = 'e-day-view';\n  }\n  /**\n   * Get module name.\n   *\n   * @returns {string} Returns the module name.\n   */\n  getModuleName() {\n    return 'day';\n  }\n}\n\n/**\n * week view\n */\nclass Week extends VerticalView {\n  /**\n   * Constructor for week view\n   *\n   * @param {Schedule} parent Accepts the schedule instance\n   */\n  constructor(parent) {\n    super(parent);\n    this.viewClass = 'e-week-view';\n  }\n  startDate() {\n    return this.getViewStartDate();\n  }\n  endDate() {\n    return this.getViewEndDate();\n  }\n  /**\n   * Get module name.\n   *\n   * @returns {string} Returns the module name.\n   */\n  getModuleName() {\n    return 'week';\n  }\n}\n\n/**\n * work week view\n */\nclass WorkWeek extends VerticalView {\n  /**\n   * Constructor for work week view\n   *\n   * @param {Schedule} parent Accepts the schedule instance\n   */\n  constructor(parent) {\n    super(parent);\n    this.viewClass = 'e-work-week-view';\n  }\n  startDate() {\n    return this.getViewStartDate();\n  }\n  endDate() {\n    return this.getViewEndDate();\n  }\n  /**\n   * Get module name.\n   *\n   * @returns {string} Returns the module name.\n   */\n  getModuleName() {\n    return 'workWeek';\n  }\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * month view\n */\nclass Month extends ViewBase {\n  constructor(parent) {\n    super(parent);\n    this.dayNameFormat = 'wide';\n    this.viewClass = 'e-month-view';\n    this.isInverseTableSelect = false;\n    this.monthEvent = null;\n    this.monthDates = {};\n  }\n  addEventListener() {\n    this.parent.on(scrollUiUpdate, this.onScrollUIUpdate, this);\n    this.parent.on(dataReady, this.onDataReady, this);\n    this.parent.on(cellClick, this.onCellClick, this);\n  }\n  removeEventListener() {\n    if (this.parent) {\n      this.parent.off(scrollUiUpdate, this.onScrollUIUpdate);\n      this.parent.off(dataReady, this.onDataReady);\n      this.parent.off(cellClick, this.onCellClick);\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  onDataReady(args) {\n    this.monthEvent = new MonthEvent(this.parent);\n    this.monthEvent.renderAppointments();\n    this.parent.notify(eventsLoaded, {});\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  onCellClick(event) {}\n  onContentScroll(e) {\n    this.parent.removeNewEventElement();\n    this.parent.notify(virtualScroll, e);\n    this.scrollTopPanel(e.target);\n    this.scrollLeftPanel(e.target);\n    this.setPersistence();\n  }\n  scrollLeftPanel(target) {\n    const leftPanel = this.getLeftPanelElement();\n    if (leftPanel) {\n      leftPanel.scrollTop = target.scrollTop;\n    }\n  }\n  getLeftPanelElement() {\n    return this.element.querySelector('.' + WEEK_NUMBER_WRAPPER_CLASS);\n  }\n  onScrollUIUpdate(args) {\n    const headerHeight = this.getHeaderBarHeight();\n    const header = this.getDatesHeaderElement();\n    const content = this.getContentAreaElement();\n    const height = this.parent.element.offsetHeight - headerHeight - header.offsetHeight;\n    const leftPanel = this.getLeftPanelElement();\n    if (this.parent.height !== 'auto') {\n      this.setContentHeight(content, leftPanel, height);\n    }\n    const scrollBarWidth = getScrollBarWidth();\n    header.firstElementChild.style[args.cssProperties.rtlBorder] = '';\n    header.style[args.cssProperties.rtlPadding] = '';\n    if (content.offsetWidth - content.clientWidth > 0) {\n      header.firstElementChild.style[args.cssProperties.border] = scrollBarWidth > 0 ? '1px' : '0px';\n      header.style[args.cssProperties.padding] = scrollBarWidth > 0 ? scrollBarWidth - 1 + 'px' : '0px';\n    } else {\n      header.firstElementChild.style[args.cssProperties.border] = '';\n      header.style[args.cssProperties.padding] = '';\n    }\n    this.setColWidth(content);\n    if (args.scrollPosition) {\n      if (leftPanel) {\n        leftPanel.scrollTop = args.scrollPosition.top;\n      }\n      content.scrollTop = args.scrollPosition.top;\n      content.scrollLeft = args.scrollPosition.left;\n    } else {\n      const headerCell = this.element.querySelector('.' + HEADER_CELLS_CLASS + '[data-date=\"' + this.parent.selectedDate.getTime().toString() + '\"]');\n      if (!isNullOrUndefined(headerCell)) {\n        content.scrollLeft = !this.parent.enableRtl ? headerCell.offsetLeft : -(this.parent.getContentTable().offsetWidth - headerCell.offsetLeft - headerCell.offsetWidth);\n      } else {\n        content.scrollLeft = 0;\n      }\n    }\n    this.retainScrollPosition();\n  }\n  setContentHeight(content, leftPanelElement, height) {\n    content.style.height = 'auto';\n    if (this.parent.currentView === 'Month') {\n      content.style.height = formatUnit(height);\n    }\n    if (leftPanelElement) {\n      if (this.parent.currentView === 'MonthAgenda') {\n        height = this.element.querySelector('.' + CONTENT_TABLE_CLASS).offsetHeight;\n      }\n      leftPanelElement.style.height = 'auto';\n      leftPanelElement.style.height = formatUnit(height - this.getScrollXIndent(content));\n    }\n  }\n  generateColumnLevels() {\n    let colLevels = [];\n    const level = this.getDateSlots(this.renderDates, this.parent.activeViewOptions.workDays);\n    if (this.parent.activeViewOptions.group.resources.length > 0) {\n      colLevels = this.parent.resourceBase.generateResourceLevels(level);\n      if (this.parent.currentView === 'MonthAgenda') {\n        colLevels = [level];\n      }\n      if (this.parent.uiStateValues.isGroupAdaptive && this.parent.resourceBase.lastResourceLevel.length > 0) {\n        const resourceLevel = this.parent.resourceBase.lastResourceLevel[this.parent.uiStateValues.groupIndex];\n        colLevels = [this.getDateSlots(resourceLevel.renderDates, resourceLevel.workDays)];\n      }\n    } else {\n      colLevels.push(level);\n    }\n    this.colLevels = colLevels;\n    return colLevels;\n  }\n  getDateSlots(renderDates, workDays) {\n    const count = this.parent.activeViewOptions.showWeekend ? WEEK_LENGTH : workDays.length;\n    const dateSlots = [];\n    const isCurrentMonth = this.isCurrentMonth(this.parent.selectedDate);\n    for (let col = 0; col < count; col++) {\n      const classList$$1 = [HEADER_CELLS_CLASS];\n      const currentDateIndex = renderDates.slice(0, count).map(date => date.getDay());\n      if (isCurrentMonth && currentDateIndex.indexOf(this.parent.getCurrentTime().getDay()) === col) {\n        classList$$1.push(CURRENT_DAY_CLASS);\n      }\n      dateSlots.push({\n        date: renderDates[col],\n        type: 'monthDay',\n        className: classList$$1,\n        colSpan: 1,\n        workDays: workDays\n      });\n    }\n    return dateSlots;\n  }\n  getDayNameFormat() {\n    if (this.parent.isAdaptive || this.parent.activeViewOptions.group.resources.length > 0) {\n      return 'abbreviated';\n    }\n    return 'wide';\n  }\n  renderLayout(type) {\n    this.dayNameFormat = this.getDayNameFormat();\n    this.setPanel(createElement('div', {\n      className: TABLE_WRAP_CLASS\n    }));\n    const clsList = [this.viewClass];\n    clsList.push(type);\n    if (this.parent.activeViewOptions.group.byDate) {\n      clsList.push('e-by-date');\n    }\n    if (this.parent.activeViewOptions.allowVirtualScrolling) {\n      clsList.push(VIRTUAL_SCROLL_CLASS);\n    }\n    if (this.parent.rowAutoHeight && this.parent.eventSettings.ignoreWhitespace) {\n      clsList.push(IGNORE_WHITESPACE);\n    }\n    addClass([this.element], clsList);\n    this.renderPanel(type);\n    this.element.appendChild(this.createTableLayout(OUTER_TABLE_CLASS));\n    this.element.querySelector('table').setAttribute('role', 'presentation');\n    this.colLevels = this.generateColumnLevels();\n    this.renderHeader();\n    this.renderContent();\n    const target = this.parent.currentView === 'MonthAgenda' ? this.parent.activeView.getPanel() : this.parent.element;\n    if (this.parent.uiStateValues.isGroupAdaptive && !target.querySelector('.' + RESOURCE_TOOLBAR_CONTAINER)) {\n      this.renderResourceMobileLayout();\n    }\n    this.parent.notify(contentReady, {});\n    if (this.parent.uiStateValues.isCustomMonth) {\n      this.parent.uiStateValues.isCustomMonth = false;\n    }\n  }\n  refreshHeader() {\n    remove(this.element.querySelector('tbody tr'));\n    this.renderHeader();\n    this.parent.notify(contentReady, {});\n  }\n  wireCellEvents(element) {\n    EventHandler.add(element, 'mousedown', this.parent.workCellAction.cellMouseDown, this.parent.workCellAction);\n    EventHandler.add(element, 'click', this.parent.workCellAction.cellClick, this.parent.workCellAction);\n    if (!this.parent.isAdaptive) {\n      EventHandler.add(element, 'dblclick', this.parent.workCellAction.cellDblClick, this.parent.workCellAction);\n    }\n  }\n  renderHeader() {\n    const tr = createElement('tr');\n    this.renderLeftIndent(tr);\n    const dateTd = createElement('td');\n    dateTd.appendChild(this.renderDatesHeader());\n    tr.appendChild(dateTd);\n    prepend([tr], this.element.querySelector('tbody'));\n  }\n  renderLeftIndent(tr) {\n    if (this.parent.activeViewOptions.showWeekNumber) {\n      tr.appendChild(createElement('td', {\n        className: 'e-left-indent'\n      }));\n    }\n  }\n  renderContent() {\n    const tr = createElement('tr');\n    if (this.parent.activeViewOptions.showWeekNumber) {\n      tr.appendChild(this.renderWeekNumberContent());\n    }\n    const workTd = createElement('td');\n    const wrap = createElement('div', {\n      className: CONTENT_WRAP_CLASS\n    });\n    const contentArea = this.renderContentArea();\n    if (this.parent.currentView === 'Month') {\n      wrap.appendChild(contentArea);\n    } else {\n      const monthAgendaWrapper = createElement('div', {\n        className: TABLE_CONTAINER_CLASS\n      });\n      monthAgendaWrapper.appendChild(contentArea);\n      wrap.appendChild(monthAgendaWrapper);\n    }\n    EventHandler.add(wrap, 'scroll', this.onContentScroll, this);\n    workTd.appendChild(wrap);\n    tr.appendChild(workTd);\n    this.element.querySelector('tbody').appendChild(tr);\n    this.renderAppointmentContainer();\n  }\n  renderWeekNumberContent() {\n    const dateCol = this.renderDates.map(date => new Date(+date));\n    const td = createElement('td');\n    const contentWrapper = createElement('div', {\n      className: WEEK_NUMBER_WRAPPER_CLASS\n    });\n    td.appendChild(contentWrapper);\n    const contentWrapTable = this.createTableLayout();\n    contentWrapper.appendChild(contentWrapTable);\n    const noOfDays = this.parent.activeViewOptions.showWeekend ? WEEK_LENGTH : this.parent.activeViewOptions.workDays.length;\n    for (let i = 0, length = this.renderDates.length / noOfDays; i < length; i++) {\n      const dates = dateCol.splice(0, noOfDays);\n      const weekNumber = this.parent.getWeekNumberContent(dates);\n      contentWrapTable.querySelector('tbody').appendChild(this.createWeekNumberElement(weekNumber));\n    }\n    return td;\n  }\n  renderAppointmentContainer() {\n    //Here needs to render mobile view appointment details on selected date\n  }\n  renderDatesHeader() {\n    const container = createElement('div', {\n      className: DATE_HEADER_CONTAINER_CLASS\n    });\n    const wrap = createElement('div', {\n      className: DATE_HEADER_WRAP_CLASS\n    });\n    container.appendChild(wrap);\n    const table = this.createTableLayout();\n    this.createColGroup(table, this.colLevels[this.colLevels.length - 1]);\n    const trEle = createElement('tr');\n    for (let i = 0; i < this.colLevels.length; i++) {\n      const level = this.colLevels[i];\n      const ntr = trEle.cloneNode();\n      for (let j = 0; j < level.length; j++) {\n        const td = level[j];\n        ntr.appendChild(this.createHeaderCell(td));\n      }\n      table.querySelector('tbody').appendChild(ntr);\n    }\n    wrap.appendChild(table);\n    return container;\n  }\n  createHeaderCell(td) {\n    const tdEle = createElement('td');\n    this.addAttributes(td, tdEle);\n    if (td.type === 'monthDay') {\n      const ele = createElement('span', {\n        innerHTML: capitalizeFirstWord(this.parent.getDayNames(this.dayNameFormat)[td.date.getDay()], 'single')\n      });\n      tdEle.appendChild(ele);\n    }\n    if (td.type === 'resourceHeader') {\n      this.setResourceHeaderContent(tdEle, td);\n    }\n    if (td.type === 'dateHeader') {\n      addClass([tdEle], DATE_HEADER_CLASS);\n      tdEle.setAttribute('data-date', td.date.getTime().toString());\n      if (this.parent.activeViewOptions.dateHeaderTemplate) {\n        const cellArgs = {\n          date: td.date,\n          type: td.type\n        };\n        const elementId = this.parent.element.id + '_';\n        const viewName = this.parent.activeViewOptions.dateHeaderTemplateName;\n        const templateId = elementId + viewName + 'dateHeaderTemplate';\n        const dateTemplate = [].slice.call(this.parent.getDateHeaderTemplate()(cellArgs, this.parent, 'dateHeaderTemplate', templateId, false));\n        if (dateTemplate && dateTemplate.length) {\n          append(dateTemplate, tdEle);\n        }\n      } else {\n        const ele = createElement('span', {\n          className: NAVIGATE_CLASS\n        });\n        const skeleton = 'full';\n        const title = this.parent.globalize.formatDate(td.date, {\n          skeleton: skeleton,\n          calendar: this.parent.getCalendarMode()\n        });\n        ele.setAttribute('title', capitalizeFirstWord(title, 'multiple'));\n        const innerText = this.parent.calendarUtil.isMonthStart(td.date) && !this.isCurrentDate(td.date) && !this.parent.isAdaptive ? this.parent.globalize.formatDate(td.date, {\n          format: 'MMM d',\n          calendar: this.parent.getCalendarMode()\n        }) : this.parent.globalize.formatDate(td.date, {\n          skeleton: 'd',\n          calendar: this.parent.getCalendarMode()\n        });\n        ele.innerHTML = capitalizeFirstWord(innerText, 'single');\n        tdEle.appendChild(ele);\n      }\n      this.wireCellEvents(tdEle);\n    }\n    const args = {\n      elementType: td.type,\n      element: tdEle,\n      date: td.date,\n      groupIndex: td.groupIndex\n    };\n    this.parent.trigger(renderCell, args);\n    return tdEle;\n  }\n  getContentSlots() {\n    if (!(this.colLevels[this.colLevels.length - 1] && this.colLevels[this.colLevels.length - 1][0])) {\n      return [];\n    }\n    const slotDatas = [];\n    const prepareSlots = (rowIndex, renderDate, resData, classList$$1) => {\n      const data = {\n        date: new Date(+renderDate),\n        groupIndex: resData.groupIndex,\n        workDays: resData.workDays,\n        type: 'monthCells',\n        className: classList$$1 || [WORK_CELLS_CLASS]\n      };\n      if (!slotDatas[rowIndex]) {\n        slotDatas[rowIndex] = [];\n      }\n      slotDatas[rowIndex].push(data);\n    };\n    const includeResource = this.parent.currentView !== 'MonthAgenda' && this.parent.activeViewOptions.group.resources.length > 0;\n    if (includeResource && !this.parent.uiStateValues.isGroupAdaptive && !this.parent.activeViewOptions.group.byDate) {\n      for (const res of this.colLevels[this.colLevels.length - 2]) {\n        const dates = res.renderDates.map(date => new Date(+date));\n        const count = this.parent.activeViewOptions.showWeekend ? WEEK_LENGTH : res.workDays.length;\n        for (let i = 0; i < res.renderDates.length / count; i++) {\n          const colDates = dates.splice(0, count);\n          for (const colDate of colDates) {\n            prepareSlots(i, colDate, res);\n          }\n        }\n      }\n    } else {\n      const dates = this.renderDates.map(date => new Date(+date));\n      const count = this.parent.activeViewOptions.showWeekend ? WEEK_LENGTH : this.parent.activeViewOptions.workDays.length;\n      for (let i = 0; i < this.renderDates.length / count; i++) {\n        const colDates = dates.splice(0, count);\n        for (const colDate of colDates) {\n          if (includeResource) {\n            const lastRow = this.colLevels[this.colLevels.length - 1];\n            const resourcesTd = lastRow.slice(0, lastRow.length / count);\n            for (let resIndex = 0; resIndex < resourcesTd.length; resIndex++) {\n              let clsList;\n              if (resIndex !== 0) {\n                clsList = [WORK_CELLS_CLASS, DISABLE_DATE];\n              }\n              prepareSlots(i, colDate, resourcesTd[resIndex], clsList);\n            }\n          } else {\n            prepareSlots(i, colDate, this.colLevels[this.colLevels.length - 1][0]);\n          }\n        }\n      }\n    }\n    return slotDatas;\n  }\n  updateClassList(data) {\n    if (!this.isCustomMonth() && this.isOtherMonth(data.date)) {\n      data.className.push(OTHERMONTH_CLASS);\n    }\n    if (!this.parent.isMinMaxDate(data.date)) {\n      data.className.push(DISABLE_DATES);\n    }\n    if (this.parent.currentView === 'MonthAgenda' && this.parent.isSelectedDate(data.date)) {\n      data.className.push(SELECTED_CELL_CLASS);\n    }\n  }\n  isOtherMonth(date) {\n    return date.getTime() < this.monthDates.start.getTime() || date.getTime() > this.monthDates.end.getTime();\n  }\n  renderContentArea() {\n    const tbl = this.createTableLayout(CONTENT_TABLE_CLASS);\n    this.addAutoHeightClass(tbl);\n    if (this.parent.currentView === 'TimelineMonth') {\n      this.createColGroup(tbl, this.colLevels[this.colLevels.length - 1]);\n    }\n    const monthDate = new Date(this.parent.selectedDate.getTime());\n    this.monthDates = {\n      start: this.parent.calendarUtil.firstDateOfMonth(monthDate),\n      end: this.parent.calendarUtil.lastDateOfMonth(addMonths(monthDate, this.parent.activeViewOptions.interval - 1))\n    };\n    const tBody = tbl.querySelector('tbody');\n    append(this.getContentRows(), tBody);\n    this.wireCellEvents(tBody);\n    return tbl;\n  }\n  getContentRows() {\n    const trows = [];\n    const tr = createElement('tr', {\n      attrs: {\n        role: 'row'\n      }\n    });\n    const td = createElement('td', {\n      attrs: {\n        role: 'gridcell',\n        'aria-selected': 'false'\n      }\n    });\n    const slotDatas = this.getContentSlots();\n    for (let row = 0; row < slotDatas.length; row++) {\n      const ntr = tr.cloneNode();\n      for (let col = 0; col < slotDatas[row].length; col++) {\n        const ntd = this.createContentTd(slotDatas[row][col], td);\n        ntr.appendChild(ntd);\n      }\n      trows.push(ntr);\n    }\n    return trows;\n  }\n  createContentTd(data, td) {\n    const ntd = td.cloneNode();\n    if (data.colSpan) {\n      ntd.setAttribute('colspan', data.colSpan.toString());\n    }\n    this.updateClassList(data);\n    let type = data.type;\n    if (data.className.indexOf(RESOURCE_PARENT_CLASS) !== -1) {\n      data.className.push(RESOURCE_GROUP_CELLS_CLASS);\n      type = 'resourceGroupCells';\n    }\n    if (this.parent.workHours.highlight && this.isWorkDay(data.date, data.workDays)) {\n      data.className.push(WORKDAY_CLASS);\n    }\n    if (this.isCurrentDate(data.date)) {\n      data.className.push(CURRENTDATE_CLASS);\n    }\n    addClass([ntd], data.className);\n    ntd.setAttribute('data-date', data.date.getTime().toString());\n    if (!isNullOrUndefined(data.groupIndex) || this.parent.uiStateValues.isGroupAdaptive) {\n      const groupIndex = this.parent.uiStateValues.isGroupAdaptive ? this.parent.uiStateValues.groupIndex : data.groupIndex;\n      ntd.setAttribute('data-group-index', '' + groupIndex);\n    }\n    this.renderDateHeaderElement(data, ntd);\n    if (this.parent.activeViewOptions.cellTemplate) {\n      const args = {\n        date: data.date,\n        type: type,\n        groupIndex: data.groupIndex\n      };\n      const scheduleId = this.parent.element.id + '_';\n      const viewName = this.parent.activeViewOptions.cellTemplateName;\n      const templateId = scheduleId + viewName + 'cellTemplate';\n      const cellTemplate = [].slice.call(this.parent.getCellTemplate()(args, this.parent, 'cellTemplate', templateId, false));\n      append(cellTemplate, ntd);\n    }\n    const args = {\n      elementType: type,\n      element: ntd,\n      date: data.date,\n      groupIndex: data.groupIndex\n    };\n    this.parent.trigger(renderCell, args);\n    return ntd;\n  }\n  renderDateHeaderElement(data, ntd) {\n    if (this.parent.currentView === 'TimelineMonth') {\n      return;\n    }\n    const dateHeader = createElement('div', {\n      className: DATE_HEADER_CLASS\n    });\n    if (this.parent.activeViewOptions.cellHeaderTemplate) {\n      const args = {\n        date: data.date,\n        type: data.type,\n        groupIndex: data.groupIndex\n      };\n      const scheduleId = this.parent.element.id + '_';\n      const viewName = this.parent.activeViewOptions.cellHeaderTemplateName;\n      const templateId = scheduleId + viewName + 'cellHeaderTemplate';\n      const cellHeaderTemplate = [].slice.call(this.parent.getCellHeaderTemplate()(args, this.parent, 'cellHeaderTemplate', templateId, false));\n      append(cellHeaderTemplate, dateHeader);\n    } else {\n      const innerText = this.parent.calendarUtil.isMonthStart(data.date) && !this.isCurrentDate(data.date) && !this.parent.isAdaptive ? this.parent.globalize.formatDate(data.date, {\n        format: 'MMM d',\n        calendar: this.parent.getCalendarMode()\n      }) : this.parent.globalize.formatDate(data.date, {\n        skeleton: 'd',\n        calendar: this.parent.getCalendarMode()\n      });\n      dateHeader.innerHTML = capitalizeFirstWord(innerText, 'single');\n    }\n    ntd.appendChild(dateHeader);\n    if (this.getModuleName() === 'month') {\n      addClass([dateHeader], NAVIGATE_CLASS);\n      const skeleton = 'full';\n      const announcementText = this.parent.globalize.formatDate(data.date, {\n        skeleton: skeleton,\n        calendar: this.parent.getCalendarMode()\n      });\n      dateHeader.setAttribute('aria-label', announcementText);\n    }\n  }\n  getMonthStart(currentDate) {\n    const useDisplayDate = this.parent.currentView === 'Month' && !isNullOrUndefined(this.parent.activeViewOptions.displayDate) && (this.parent.uiStateValues.isCustomMonth || this.isCustomRange());\n    const date = useDisplayDate ? this.parent.activeViewOptions.displayDate : !(this.parent.uiStateValues.isCustomMonth || this.isCustomRange()) && this.isCustomMonth() ? currentDate : this.parent.calendarUtil.firstDateOfMonth(currentDate);\n    const monthStart = getWeekFirstDate(date, this.parent.activeViewOptions.firstDayOfWeek);\n    return new Date(monthStart.getFullYear(), monthStart.getMonth(), monthStart.getDate());\n  }\n  getMonthEnd(currentDate) {\n    if (this.isCustomMonth()) {\n      const start = this.getMonthStart(currentDate);\n      const numberOfDays = WEEK_LENGTH * (this.parent.activeViewOptions.numberOfWeeks > 0 ? this.parent.activeViewOptions.numberOfWeeks : DEFAULT_WEEKS);\n      return addDays(start, numberOfDays - 1);\n    } else {\n      const endDate = addMonths(currentDate, this.parent.activeViewOptions.interval - 1);\n      const lastWeekOfMonth = getWeekFirstDate(this.parent.calendarUtil.lastDateOfMonth(endDate), this.parent.activeViewOptions.firstDayOfWeek);\n      return addDays(lastWeekOfMonth, WEEK_LENGTH - 1);\n    }\n  }\n  isCustomRange() {\n    const dates = this.parent.getCurrentViewDates();\n    if (dates && dates.length > 0) {\n      const selectedTime = resetTime(this.parent.selectedDate).getTime();\n      const weekFirstDate = getWeekFirstDate(dates[dates.length - 1], this.parent.activeViewOptions.firstDayOfWeek);\n      return !(selectedTime >= getWeekFirstDate(dates[0], this.parent.activeViewOptions.firstDayOfWeek).getTime() && selectedTime <= addDays(weekFirstDate, 6).getTime());\n    }\n    return false;\n  }\n  getRenderDates(workDays) {\n    const renderDates = [];\n    const currentDate = resetTime(this.parent.selectedDate);\n    let start = this.getMonthStart(currentDate);\n    const monthEnd = this.getMonthEnd(currentDate);\n    do {\n      if (this.parent.activeViewOptions.showWeekend) {\n        renderDates.push(start);\n      } else {\n        if (this.isWorkDay(start, workDays)) {\n          renderDates.push(start);\n        }\n      }\n      start = addDays(start, 1);\n      if (start.getHours() > 0) {\n        start = resetTime(start);\n      }\n    } while (start.getTime() <= monthEnd.getTime());\n    if (!workDays) {\n      this.renderDates = renderDates;\n    }\n    if (this.parent.headerModule) {\n      this.parent.headerModule.previousNextIconHandler();\n    }\n    return renderDates;\n  }\n  getNextPreviousDate(type) {\n    if (this.isCustomMonth()) {\n      const dates = this.parent.getCurrentViewDates();\n      const date = getWeekFirstDate(type === 'next' ? dates[dates.length - 1] : dates[0], this.parent.activeViewOptions.firstDayOfWeek);\n      return addDays(date, type === 'next' ? WEEK_LENGTH : -(this.parent.activeViewOptions.numberOfWeeks > 0 ? this.parent.activeViewOptions.numberOfWeeks : DEFAULT_WEEKS) * WEEK_LENGTH);\n    } else {\n      return addMonths(this.parent.selectedDate, (type === 'next' ? 1 : -1) * this.parent.activeViewOptions.interval);\n    }\n  }\n  getStartDate() {\n    return this.getMonthStart(this.parent.selectedDate);\n  }\n  getEndDate() {\n    return this.getMonthEnd(this.parent.selectedDate);\n  }\n  getEndDateFromStartDate(start) {\n    return addDays(new Date(start.getTime()), 1);\n  }\n  getDateRangeText() {\n    if (this.parent.isAdaptive || isNullOrUndefined(this.parent.activeViewOptions.dateFormat)) {\n      let startDate = this.parent.selectedDate;\n      let endDate;\n      let updateCustomRange = false;\n      if (this.isCustomMonth()) {\n        const dates = this.parent.getCurrentViewDates();\n        updateCustomRange = dates[0].getMonth() !== dates[dates.length - 1].getMonth() || dates[0].getFullYear() !== dates[dates.length - 1].getFullYear();\n        if (updateCustomRange) {\n          startDate = dates[0];\n          endDate = dates[dates.length - 1];\n        }\n      }\n      const isUpdateDateRange = this.parent.currentView !== 'Month' || !this.isCustomMonth();\n      if (this.parent.activeViewOptions.interval > 1 && isUpdateDateRange || updateCustomRange) {\n        endDate = endDate ? endDate : addMonths(lastDateOfMonth(startDate), this.parent.activeViewOptions.interval - 1);\n        if (startDate.getFullYear() === endDate.getFullYear()) {\n          const monthNames = this.parent.globalize.formatDate(startDate, {\n            format: 'MMMM',\n            calendar: this.parent.getCalendarMode()\n          }) + ' - ' + this.parent.globalize.formatDate(endDate, {\n            format: 'MMMM ',\n            calendar: this.parent.getCalendarMode()\n          }) + this.parent.globalize.formatDate(endDate, {\n            skeleton: 'y',\n            calendar: this.parent.getCalendarMode()\n          });\n          return capitalizeFirstWord(monthNames, 'single');\n        }\n        const text = this.parent.globalize.formatDate(startDate, {\n          format: 'MMMM',\n          calendar: this.parent.getCalendarMode()\n        }) + ' ' + startDate.getFullYear() + ' - ' + this.parent.globalize.formatDate(endDate, {\n          format: 'MMMM ',\n          calendar: this.parent.getCalendarMode()\n        }) + this.parent.globalize.formatDate(endDate, {\n          skeleton: 'y',\n          calendar: this.parent.getCalendarMode()\n        });\n        return capitalizeFirstWord(text, 'single');\n      }\n      const format = this.parent.activeViewOptions.dateFormat ? this.parent.activeViewOptions.dateFormat : 'MMMM y';\n      return capitalizeFirstWord(this.parent.globalize.formatDate(startDate, {\n        format: format,\n        calendar: this.parent.getCalendarMode()\n      }), 'single');\n    }\n    return this.formatDateRange(this.parent.selectedDate);\n  }\n  getLabelText(view) {\n    return this.parent.localeObj.getConstant(view) + ' of ' + capitalizeFirstWord(this.parent.globalize.formatDate(this.parent.selectedDate, {\n      format: 'MMMM y',\n      calendar: this.parent.getCalendarMode()\n    }), 'single');\n  }\n  createWeekNumberElement(text) {\n    const tr = createElement('tr');\n    const td = createElement('td', {\n      className: WEEK_NUMBER_CLASS,\n      attrs: {\n        'title': text ? this.parent.localeObj.getConstant('week') + ' ' + text : ''\n      },\n      innerHTML: text || ''\n    });\n    tr.appendChild(td);\n    const args = {\n      elementType: 'weekNumberCell',\n      element: td\n    };\n    this.parent.trigger(renderCell, args);\n    return tr;\n  }\n  unWireEvents() {\n    const contentScrollableEle = this.element.querySelector('.' + CONTENT_WRAP_CLASS);\n    if (contentScrollableEle) {\n      EventHandler.remove(contentScrollableEle, 'scroll', this.onContentScroll);\n    }\n  }\n  isCustomMonth() {\n    return this.parent.currentView === 'Month' && (!isNullOrUndefined(this.parent.activeViewOptions.displayDate) || this.parent.activeViewOptions.numberOfWeeks > 0);\n  }\n  getModuleName() {\n    return 'month';\n  }\n  destroy() {\n    if (!this.parent || this.parent && this.parent.isDestroyed) {\n      return;\n    }\n    if (this.element) {\n      if (this.monthEvent) {\n        this.monthEvent.destroy();\n        this.monthEvent = null;\n      }\n      this.unWireEvents();\n      if (this.parent.resourceBase) {\n        this.parent.resourceBase.destroy();\n      }\n      if (this.parent.scheduleTouchModule) {\n        this.parent.scheduleTouchModule.resetValues();\n      }\n      super.destroy();\n    }\n  }\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * year view\n */\nclass Year extends ViewBase {\n  constructor(parent) {\n    super(parent);\n    this.viewClass = 'e-year-view';\n    this.isInverseTableSelect = false;\n    this.yearEventModule = null;\n  }\n  getModuleName() {\n    return 'year';\n  }\n  renderLayout(className) {\n    if (this.parent.resourceBase) {\n      this.parent.resourceBase.generateResourceLevels([{\n        renderDates: this.parent.activeView.renderDates\n      }]);\n    }\n    this.setPanel(createElement('div', {\n      className: TABLE_WRAP_CLASS\n    }));\n    const viewTypeClass = this.parent.activeViewOptions.orientation === 'Horizontal' ? 'e-horizontal' : 'e-vertical';\n    addClass([this.element], [this.viewClass, viewTypeClass, className]);\n    this.renderPanel(className);\n    const calendarTable = this.createTableLayout(OUTER_TABLE_CLASS);\n    this.element.appendChild(calendarTable);\n    this.element.querySelector('table').setAttribute('role', 'presentation');\n    const calendarTBody = calendarTable.querySelector('tbody');\n    this.rowCount = this.getRowColumnCount('row');\n    this.columnCount = this.getRowColumnCount('column');\n    this.renderHeader(calendarTBody);\n    this.renderContent(calendarTBody);\n    if (this.parent.currentView !== 'Year' && this.parent.uiStateValues.isGroupAdaptive) {\n      this.generateColumnLevels();\n      this.renderResourceMobileLayout();\n    }\n    this.wireEvents(this.element.querySelector('.' + CONTENT_WRAP_CLASS), 'scroll');\n    this.parent.notify(contentReady, {});\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  renderHeader(headerWrapper) {}\n  renderContent(content) {\n    const tr = createElement('tr');\n    content.appendChild(tr);\n    const td = createElement('td');\n    tr.appendChild(td);\n    this.element.querySelector('tbody').appendChild(tr);\n    const contentWrapper = createElement('div', {\n      className: CONTENT_WRAP_CLASS\n    });\n    td.appendChild(contentWrapper);\n    const calendarTable = this.createTableLayout('e-calendar-table');\n    contentWrapper.appendChild(calendarTable);\n    const cTr = createElement('tr');\n    calendarTable.querySelector('tbody').appendChild(cTr);\n    const cTd = createElement('td');\n    cTr.appendChild(cTd);\n    const calendarWrapper = createElement('div', {\n      className: 'e-calendar-wrapper'\n    });\n    cTd.appendChild(calendarWrapper);\n    const months = this.getMonths();\n    for (const month of months) {\n      const currentMonth = new Date(this.parent.selectedDate.getFullYear(), month, 1);\n      const calendarElement = createElement('div', {\n        className: 'e-month-calendar e-calendar',\n        attrs: {\n          'data-role': 'calendar'\n        }\n      });\n      calendarElement.appendChild(this.renderCalendarHeader(currentMonth));\n      calendarElement.appendChild(this.renderCalendarContent(currentMonth));\n      calendarWrapper.appendChild(calendarElement);\n    }\n  }\n  renderCalendarHeader(currentDate) {\n    const headerWrapper = createElement('div', {\n      className: 'e-header e-month'\n    });\n    const headerContent = createElement('div', {\n      className: 'e-day e-title',\n      innerHTML: this.getMonthName(currentDate)\n    });\n    headerWrapper.appendChild(headerContent);\n    this.parent.trigger(renderCell, {\n      elementType: 'headerCells',\n      element: headerContent,\n      date: currentDate\n    });\n    return headerWrapper;\n  }\n  renderCalendarContent(currentDate) {\n    const dateCollection = this.getMonthDates(currentDate);\n    const contentWrapper = createElement('div', {\n      className: 'e-content e-month'\n    });\n    const contentTable = this.createTableLayout('e-calendar-table ' + CONTENT_TABLE_CLASS);\n    contentWrapper.appendChild(contentTable);\n    const thead = createElement('thead', {\n      className: 'e-week-header'\n    });\n    const tr = createElement('tr');\n    let currentWeek = getWeekFirstDate(firstDateOfMonth(currentDate), this.parent.firstDayOfWeek);\n    if (this.parent.activeViewOptions.showWeekNumber) {\n      tr.appendChild(createElement('th'));\n    }\n    for (let i = 0; i < WEEK_LENGTH; i++) {\n      tr.appendChild(createElement('th', {\n        innerHTML: this.parent.getDayNames('narrow')[currentWeek.getDay()]\n      }));\n      currentWeek = new Date(currentWeek.getTime() + MS_PER_DAY);\n    }\n    thead.appendChild(tr);\n    prepend([thead], contentTable);\n    const tbody = contentTable.querySelector('tbody');\n    while (dateCollection.length > 0) {\n      const weekDates = dateCollection.splice(0, WEEK_LENGTH);\n      const tr = createElement('tr', {\n        attrs: {\n          'role': 'row'\n        }\n      });\n      if (this.parent.activeViewOptions.showWeekNumber) {\n        const weekNumber = this.parent.getWeekNumberContent(weekDates);\n        const td = createElement('td', {\n          className: 'e-week-number',\n          attrs: {\n            'role': 'gridcell',\n            'title': this.parent.localeObj.getConstant('week') + ' ' + weekNumber\n          },\n          innerHTML: weekNumber\n        });\n        tr.appendChild(td);\n        this.parent.trigger(renderCell, {\n          elementType: 'weekNumberCells',\n          element: td\n        });\n      }\n      for (const date of weekDates) {\n        const td = createElement('td', {\n          className: 'e-cell ' + WORK_CELLS_CLASS,\n          attrs: {\n            'role': 'gridcell',\n            'aria-selected': 'false',\n            'data-date': date.getTime().toString()\n          }\n        });\n        const span = createElement('span', {\n          className: 'e-day',\n          innerHTML: this.parent.globalize.formatDate(date, {\n            skeleton: 'd',\n            calendar: this.parent.getCalendarMode()\n          }),\n          attrs: {\n            title: this.parent.globalize.formatDate(date, {\n              type: 'date',\n              skeleton: 'full'\n            })\n          }\n        });\n        td.appendChild(span);\n        let classList$$1 = [];\n        if (currentDate.getMonth() !== date.getMonth()) {\n          classList$$1.push(OTHERMONTH_CLASS);\n        }\n        if (this.isCurrentDate(date) && currentDate.getMonth() === date.getMonth()) {\n          classList$$1 = classList$$1.concat(['e-today', 'e-selected']);\n        }\n        if (classList$$1.length > 0) {\n          addClass([td], classList$$1);\n        }\n        tr.appendChild(td);\n        this.wireEvents(td, 'cell');\n        this.parent.trigger(renderCell, {\n          elementType: 'workCells',\n          element: td,\n          date: date\n        });\n      }\n      tbody.appendChild(tr);\n    }\n    return contentWrapper;\n  }\n  createTableColGroup(count) {\n    const colGroupEle = createElement('colgroup');\n    for (let i = 0; i < count; i++) {\n      colGroupEle.appendChild(createElement('col'));\n    }\n    return colGroupEle;\n  }\n  getMonthName(date) {\n    const month = this.parent.globalize.formatDate(date, {\n      format: this.parent.activeViewOptions.dateFormat || 'MMMM y',\n      calendar: this.parent.getCalendarMode()\n    });\n    return capitalizeFirstWord(month, 'multiple');\n  }\n  generateColumnLevels() {\n    let colLevels = [];\n    const level = this.getDateSlots([this.parent.selectedDate], this.parent.activeViewOptions.workDays);\n    if (this.parent.activeViewOptions.group.resources.length > 0) {\n      colLevels = this.parent.resourceBase.generateResourceLevels(level);\n      if (this.parent.uiStateValues.isGroupAdaptive) {\n        const resourceLevel = this.parent.resourceBase.lastResourceLevel[this.parent.uiStateValues.groupIndex];\n        colLevels = [this.getDateSlots([this.parent.selectedDate], resourceLevel.workDays)];\n      }\n    } else {\n      colLevels.push(level);\n    }\n    colLevels.pop();\n    this.colLevels = colLevels;\n    return colLevels;\n  }\n  // eslint-disable-next-line max-len\n  getDateSlots(renderDates, workDays, startHour = this.parent.workHours.start, endHour = this.parent.workHours.end) {\n    const dateCol = [{\n      date: renderDates[0],\n      type: 'dateHeader',\n      className: [HEADER_CELLS_CLASS],\n      colSpan: 1,\n      workDays: workDays,\n      startHour: new Date(+this.parent.globalize.parseDate(startHour, {\n        skeleton: 'Hm'\n      })),\n      endHour: new Date(+this.parent.globalize.parseDate(endHour, {\n        skeleton: 'Hm'\n      }))\n    }];\n    return dateCol;\n  }\n  getMonthDates(date) {\n    const startDate = getWeekFirstDate(firstDateOfMonth(date), this.parent.firstDayOfWeek);\n    const endDate = addDays(new Date(+startDate), 6 * WEEK_LENGTH);\n    const dateCollection = [];\n    for (let start = startDate; start.getTime() < endDate.getTime(); start = addDays(start, 1)) {\n      dateCollection.push(resetTime(new Date(start)));\n    }\n    return dateCollection;\n  }\n  getRowColumnCount(type) {\n    const months = this.getMonths();\n    const year = this.parent.selectedDate.getFullYear();\n    const monthDaysCount = [];\n    for (const month of months) {\n      monthDaysCount.push(new Date(year, month, 1).getDay() + new Date(year, month + 1, 0).getDate());\n    }\n    const maxCount = Math.max(...monthDaysCount);\n    let count;\n    if (type === 'row') {\n      count = this.parent.activeViewOptions.orientation === 'Horizontal' ? months.length : maxCount;\n    } else {\n      count = this.parent.activeViewOptions.orientation === 'Horizontal' ? maxCount : months.length;\n    }\n    return count;\n  }\n  isCurrentDate(date) {\n    return resetTime(new Date()).getTime() === resetTime(new Date(date.getTime())).getTime();\n  }\n  getMonths() {\n    // eslint-disable-next-line prefer-spread\n    return Array.apply(null, {\n      length: this.parent.activeViewOptions.monthsCount\n    }).map((value, index) => this.parent.firstMonthOfYear + index);\n  }\n  onCellClick(e) {\n    let target = closest(e.target, '.' + WORK_CELLS_CLASS);\n    const startDate = this.parent.getDateFromElement(target);\n    this.parent.activeCellsData = this.parent.getCellDetails(target);\n    const isPrevious = startDate.getTime() < this.getStartDate().getTime();\n    if (isPrevious || startDate.getTime() > this.getEndDate().getTime()) {\n      this.parent.changeDate(this.parent.activeView.getNextPreviousDate(isPrevious ? 'previous' : 'next'), e);\n      const activeDate = this.parent.activeCellsData.startTime.getTime();\n      const inRange = activeDate >= this.getStartDate().getTime() && activeDate <= this.getEndDate().getTime();\n      const dateAttr = inRange ? activeDate : (isPrevious ? this.getEndDate() : this.getStartDate()).getTime();\n      const selectedCell = this.parent.element.querySelector(':not(.' + OTHERMONTH_CLASS + ')[data-date=\"' + dateAttr + '\"]');\n      this.parent.selectCell(selectedCell);\n      this.parent.activeCellsData = this.parent.getCellDetails(selectedCell);\n    } else {\n      const endDate = addDays(new Date(startDate.getTime()), 1);\n      const filteredEvents = this.parent.eventBase.filterEvents(startDate, endDate);\n      const moreEventArgs = {\n        date: startDate,\n        event: filteredEvents,\n        element: e.target\n      };\n      if (target.classList.contains(OTHERMONTH_CLASS)) {\n        target = this.parent.element.querySelector(':not(.' + OTHERMONTH_CLASS + ')[data-date=\"' + target.getAttribute('data-date') + '\"]');\n      }\n      this.parent.activeCellsData = this.parent.getCellDetails(target);\n      this.parent.quickPopup.moreEventClick(moreEventArgs, endDate);\n    }\n  }\n  onContentScroll(e) {\n    const target = e.target;\n    const headerWrapper = this.getDatesHeaderElement();\n    if (headerWrapper) {\n      headerWrapper.firstElementChild.scrollLeft = target.scrollLeft;\n    }\n    const scrollTopSelector = `.${MONTH_HEADER_WRAPPER},.${RESOURCE_COLUMN_WRAP_CLASS}`;\n    const scrollTopElement = this.element.querySelector(scrollTopSelector);\n    if (scrollTopElement) {\n      scrollTopElement.scrollTop = target.scrollTop;\n    }\n    this.setPersistence();\n  }\n  onScrollUiUpdate(args) {\n    let height = this.parent.element.offsetHeight - this.getHeaderBarHeight();\n    const headerWrapper = this.element.querySelector('.' + DATE_HEADER_CONTAINER_CLASS);\n    if (headerWrapper) {\n      height -= headerWrapper.offsetHeight;\n    }\n    const contentWrapper = this.element.querySelector('.' + CONTENT_WRAP_CLASS);\n    if (contentWrapper) {\n      contentWrapper.style.height = formatUnit(height);\n    }\n    if (!this.parent.isAdaptive && headerWrapper) {\n      const scrollBarWidth = getScrollBarWidth();\n      if (contentWrapper.offsetWidth - contentWrapper.clientWidth > 0) {\n        headerWrapper.firstElementChild.style[args.cssProperties.border] = scrollBarWidth > 0 ? '1px' : '0px';\n        headerWrapper.style[args.cssProperties.padding] = scrollBarWidth > 0 ? scrollBarWidth - 1 + 'px' : '0px';\n      } else {\n        headerWrapper.firstElementChild.style[args.cssProperties.border] = '';\n        headerWrapper.style[args.cssProperties.padding] = '';\n      }\n    }\n    this.setColWidth(this.getContentAreaElement());\n    const leftPanelSelector = `.${MONTH_HEADER_WRAPPER},.${RESOURCE_COLUMN_WRAP_CLASS}`;\n    const leftPanelElement = this.element.querySelector(leftPanelSelector);\n    if (leftPanelElement) {\n      const isYScroll = contentWrapper.scrollWidth > contentWrapper.clientWidth;\n      leftPanelElement.style.height = formatUnit(height - (isYScroll ? 17 : 0));\n    }\n    this.retainScrollPosition();\n  }\n  getStartDate() {\n    return new Date(this.parent.selectedDate.getFullYear(), this.parent.firstMonthOfYear % 12, 1);\n  }\n  getEndDate() {\n    return addDays(addMonths(this.getStartDate(), this.parent.monthsCount), -1);\n  }\n  startDate() {\n    return this.parent.currentView === 'Year' ? getWeekFirstDate(this.getStartDate(), this.parent.firstDayOfWeek) : this.getStartDate();\n  }\n  endDate() {\n    return this.parent.currentView === 'Year' ? addDays(getWeekLastDate(this.getEndDate(), this.parent.firstDayOfWeek), 1) : this.getEndDate();\n  }\n  getEndDateFromStartDate(start) {\n    let date = new Date(start.getTime());\n    if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {\n      date = lastDateOfMonth(date);\n    }\n    return addDays(new Date(date.getTime()), 1);\n  }\n  getNextPreviousDate(type) {\n    return addYears(this.parent.selectedDate, type === 'next' ? 1 : -1);\n  }\n  getDateRangeText() {\n    const startDate = this.getStartDate();\n    const endDate = this.getEndDate();\n    if (startDate.getFullYear() !== endDate.getFullYear()) {\n      return this.parent.globalize.formatDate(startDate, {\n        skeleton: 'yMMM'\n      }) + ' - ' + this.parent.globalize.formatDate(endDate, {\n        skeleton: 'yMMM'\n      });\n    } else {\n      return this.parent.globalize.formatDate(this.parent.selectedDate, {\n        skeleton: 'y'\n      });\n    }\n  }\n  addEventListener() {\n    this.parent.on(scrollUiUpdate, this.onScrollUiUpdate, this);\n    this.parent.on(dataReady, this.onDataReady, this);\n  }\n  removeEventListener() {\n    if (this.parent) {\n      this.parent.off(scrollUiUpdate, this.onScrollUiUpdate);\n      this.parent.off(dataReady, this.onDataReady);\n    }\n  }\n  onDataReady(args) {\n    this.yearEventModule = new YearEvent(this.parent);\n    this.yearEventModule.renderAppointments();\n    this.parent.notify(eventsLoaded, args);\n  }\n  wireEvents(element, type) {\n    if (type === 'cell') {\n      if (this.parent.currentView !== 'TimelineYear') {\n        EventHandler.add(element, 'click', this.onCellClick, this);\n      } else {\n        EventHandler.add(element, 'mousedown', this.parent.workCellAction.cellMouseDown, this.parent.workCellAction);\n        EventHandler.add(element, 'click', this.parent.workCellAction.cellClick, this.parent.workCellAction);\n        if (!this.parent.isAdaptive) {\n          EventHandler.add(element, 'dblclick', this.parent.workCellAction.cellDblClick, this.parent.workCellAction);\n        }\n      }\n    } else {\n      EventHandler.add(element, 'scroll', this.onContentScroll, this);\n    }\n  }\n  destroy() {\n    if (!this.parent || this.parent && this.parent.isDestroyed) {\n      return;\n    }\n    if (this.element) {\n      const contentScroll = this.element.querySelector('.' + CONTENT_WRAP_CLASS);\n      if (contentScroll) {\n        EventHandler.remove(contentScroll, 'scroll', this.onContentScroll);\n      }\n      if (this.yearEventModule) {\n        this.yearEventModule.destroy();\n        this.yearEventModule = null;\n      }\n      if (this.parent.resourceBase) {\n        this.parent.resourceBase.destroy();\n      }\n      super.destroy();\n    }\n  }\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nclass AgendaBase extends ViewBase {\n  constructor(parent) {\n    super(parent);\n  }\n  // eslint-disable-next-line max-len\n  createAgendaContentElement(type, listData, aTd, groupOrder, groupIndex) {\n    let listElement;\n    const fieldMapping = this.parent.eventFields;\n    if (type === 'noEvents') {\n      const noEvents = [{\n        'subject': this.parent.localeObj.getConstant('noEvents')\n      }];\n      listElement = ListBase.createList(this.parent.createElement, noEvents, {\n        moduleName: 'agenda',\n        listClass: this.parent.activeView.viewClass,\n        itemClass: this.parent.activeView.viewClass,\n        template: '<div class=' + AGENDA_NO_EVENT_CLASS + '>${subject}</div>'\n      });\n    } else {\n      listElement = ListBase.createList(this.parent.createElement, listData, {\n        moduleName: 'agenda',\n        listClass: this.parent.activeView.viewClass,\n        itemClass: this.parent.activeView.viewClass\n      });\n      const listElements = [].slice.call(listElement.children);\n      listElements.forEach((element, li) => {\n        const appWrapper = createElement('div', {\n          className: APPOINTMENT_CLASS,\n          attrs: {\n            'data-id': 'Appointment_' + listData[li][this.parent.eventFields.id],\n            'data-guid': listData[li].Guid,\n            'role': 'button',\n            'tabindex': '0',\n            'aria-readonly': this.parent.eventBase.getReadonlyAttribute(listData[li]),\n            'aria-selected': 'false',\n            'aria-grabbed': 'true',\n            'aria-label': this.parent.getAnnouncementString(listData[li])\n          }\n        });\n        if (!isNullOrUndefined(groupIndex)) {\n          appWrapper.setAttribute('data-group-index', groupIndex.toString());\n        }\n        this.parent.eventBase.applyResourceColor(appWrapper, listData[li], 'borderColor', groupOrder);\n        let templateEle;\n        if (!isNullOrUndefined(this.parent.activeViewOptions.eventTemplate)) {\n          addClass([appWrapper], EVENT_TEMPLATE);\n          const scheduleId = this.parent.element.id + '_';\n          const viewName = this.parent.activeViewOptions.eventTemplateName;\n          const templateId = scheduleId + viewName + 'eventTemplate';\n          templateEle = this.parent.getAppointmentTemplate()(listData[li], this.parent, 'eventTemplate', templateId, false);\n          if (!isNullOrUndefined(listData[li][fieldMapping.recurrenceRule])) {\n            const iconClass = listData[li][fieldMapping.id] === listData[li][fieldMapping.recurrenceID] ? EVENT_RECURRENCE_ICON_CLASS : EVENT_RECURRENCE_EDIT_ICON_CLASS;\n            appWrapper.appendChild(createElement('div', {\n              className: ICON + ' ' + iconClass\n            }));\n          }\n        } else {\n          templateEle = this.createAppointment(listData[li]);\n        }\n        append([].slice.call(templateEle), appWrapper);\n        removeChildren(element);\n        element.appendChild(appWrapper);\n        const args = {\n          data: extend({}, listData[li], null, true),\n          element: element,\n          cancel: false\n        };\n        this.parent.trigger(eventRendered, args, eventArgs => {\n          if (eventArgs.cancel) {\n            remove(element);\n          }\n        });\n      });\n    }\n    aTd.appendChild(listElement);\n    if (this.parent.currentView === 'MonthAgenda' && this.parent.activeViewOptions.group.resources.length > 0 || this.parent.currentView === 'Agenda') {\n      addClass([aTd], AGENDA_DAY_BORDER_CLASS);\n    }\n    this.parent.renderTemplates();\n    return aTd;\n  }\n  createAppointment(event) {\n    const fieldMapping = this.parent.eventFields;\n    let eventSubject = event[fieldMapping.subject] || this.parent.eventSettings.fields.subject.default || this.parent.localeObj.getConstant('addTitle');\n    const eventLocation = event[fieldMapping.location] || this.parent.eventSettings.fields.location.default;\n    const appSubjectWrap = createElement('div', {\n      className: SUBJECT_WRAP\n    });\n    if (!isNullOrUndefined(eventLocation) && eventLocation !== '') {\n      eventSubject += ',';\n    }\n    appSubjectWrap.appendChild(createElement('div', {\n      className: SUBJECT_CLASS,\n      innerHTML: eventSubject\n    }));\n    if (!isNullOrUndefined(eventLocation) && eventLocation !== '') {\n      appSubjectWrap.appendChild(createElement('div', {\n        className: LOCATION_CLASS,\n        innerHTML: eventLocation\n      }));\n    }\n    if (!isNullOrUndefined(event[fieldMapping.recurrenceRule])) {\n      const iconClass = event[fieldMapping.id] === event[fieldMapping.recurrenceID] ? EVENT_RECURRENCE_ICON_CLASS : EVENT_RECURRENCE_EDIT_ICON_CLASS;\n      appSubjectWrap.appendChild(createElement('div', {\n        className: ICON + ' ' + iconClass\n      }));\n    }\n    const strDate = event[fieldMapping.startTime];\n    const endDate = event[fieldMapping.endTime];\n    const isAllDay = event[fieldMapping.isAllDay];\n    let allDayStr = this.parent.localeObj.getConstant('allDay');\n    const timeStr = this.parent.getTimeString(strDate) + ' - ' + this.parent.getTimeString(endDate);\n    if (!isNullOrUndefined(event.data)) {\n      const milliSeconds = endDate.getTimezoneOffset() !== strDate.getTimezoneOffset() ? endDate.getTime() - strDate.getTime() + 3600000 : endDate.getTime() - strDate.getTime();\n      const eventString = milliSeconds / MS_PER_DAY >= 1 ? allDayStr : timeStr;\n      allDayStr = eventString + ' (' + this.parent.localeObj.getConstant('day') + ' ' + event.data.index + '/' + event.data.count + ')';\n    }\n    const displayStr = !isNullOrUndefined(event.data) || isAllDay ? allDayStr : timeStr;\n    const appDateTime = createElement('div', {\n      className: DATE_TIME_CLASS,\n      innerHTML: displayStr\n    });\n    return [appSubjectWrap, appDateTime];\n  }\n  processAgendaEvents(events) {\n    let eventsProcessed = [];\n    if (isNullOrUndefined(events)) {\n      return eventsProcessed;\n    }\n    for (const event of events) {\n      const spanned = this.parent.eventBase.splitEventByDay(event);\n      eventsProcessed = eventsProcessed.concat(spanned.length > 1 ? spanned : event);\n    }\n    return eventsProcessed;\n  }\n  wireEventActions() {\n    const eventElement = [].slice.call(this.parent.element.querySelectorAll('.' + APPOINTMENT_CLASS));\n    for (const element of eventElement) {\n      this.parent.eventBase.wireAppointmentEvents(element, this.parent.getEventDetails(element), true);\n    }\n    const dateHeaderElement = [].slice.call(this.parent.element.querySelectorAll('.e-m-date'));\n    for (const element of dateHeaderElement) {\n      EventHandler.add(element, 'click', this.parent.agendaModule.dayNavigationClick, this);\n    }\n  }\n  calculateResourceTableElement(tBody, noOfDays, agendaDate) {\n    if (isNullOrUndefined(this.parent.resourceBase.lastResourceLevel)) {\n      const level = this.getDateSlots(this.renderDates, this.parent.activeViewOptions.workDays);\n      this.parent.resourceBase.generateResourceLevels(level);\n    }\n    const agendaLastDate = addDays(new Date(agendaDate.getTime()), noOfDays);\n    const days = this.parent.activeViewOptions.group.byDate || this.parent.currentView === 'MonthAgenda' ? noOfDays : 1;\n    const resColl = this.parent.resourceBase.resourceCollection;\n    const resData = this.parent.resourceBase.lastResourceLevel;\n    const initialDate = agendaDate;\n    for (let i = 0; i < days; i++) {\n      const lastLevelInfo = [];\n      const tempLastLevelInfo = [];\n      let tempIndex = 0;\n      let eventObj;\n      let dateObj;\n      const firstDate = addDays(initialDate, i);\n      const finalDate = this.parent.activeViewOptions.group.byDate || this.parent.currentView === 'MonthAgenda' ? addDays(firstDate, 1) : agendaLastDate;\n      const agendaCollection = this.parent.eventBase.filterEvents(firstDate, finalDate);\n      if (agendaCollection.length > 0 || !this.parent.hideEmptyAgendaDays || this.parent.currentView === 'MonthAgenda') {\n        for (let res = 0; res < resData.length; res++) {\n          noOfDays = !this.parent.activeViewOptions.group.byDate || this.parent.currentView === 'MonthAgenda' ? noOfDays : 1;\n          const data = [];\n          agendaDate = firstDate;\n          // eslint-disable-next-line max-len\n          const resDataCollection = this.parent.eventBase.filterEvents(agendaDate, agendaLastDate, agendaCollection, resData[res]);\n          if (resDataCollection.length > 0 || !this.parent.hideEmptyAgendaDays || this.parent.currentView === 'MonthAgenda') {\n            for (let r = 0; r < noOfDays; r++) {\n              // eslint-disable-next-line max-len\n              const resDayCollection = this.parent.eventBase.filterEvents(agendaDate, addDays(agendaDate, 1), resDataCollection, undefined);\n              if (resDayCollection.length > 0 || !this.parent.hideEmptyAgendaDays || this.parent.currentView === 'MonthAgenda') {\n                data.push(resDayCollection[0]);\n                eventObj = {\n                  rowSpan: 1,\n                  type: 'eventColumn',\n                  resource: resColl[resColl.length - 1],\n                  groupIndex: resData[res].groupIndex,\n                  groupOrder: resData[res].groupOrder,\n                  resourceData: resData[res].resourceData,\n                  eventData: resDayCollection,\n                  date: agendaDate\n                };\n                dateObj = {\n                  rowSpan: 1,\n                  type: 'dateColumn',\n                  resource: resColl[resColl.length - 1],\n                  groupOrder: resData[res].groupOrder,\n                  resourceData: resData[res].resourceData,\n                  date: agendaDate\n                };\n                if (!lastLevelInfo[tempIndex]) {\n                  lastLevelInfo[tempIndex] = [];\n                }\n                lastLevelInfo[tempIndex].push(eventObj);\n                lastLevelInfo[tempIndex].push(dateObj);\n                tempIndex++;\n              }\n              agendaDate = addDays(agendaDate, 1);\n              if (agendaDate.getTime() >= agendaLastDate.getTime() || this.parent.activeViewOptions.group.byDate || this.parent.currentView === 'MonthAgenda') {\n                lastLevelInfo[lastLevelInfo.length - 1][1].cssClass = AGENDA_DAY_BORDER_CLASS;\n                const tempObj = {\n                  rowSpan: data.length,\n                  type: 'resourceColumn',\n                  resource: resColl[resColl.length - 1],\n                  groupOrder: resData[res].groupOrder.slice(0, -1),\n                  resourceData: resData[res].resourceData,\n                  groupIndex: lastLevelInfo.length - data.length,\n                  className: [RESOURCE_NAME],\n                  date: agendaDate\n                };\n                lastLevelInfo[lastLevelInfo.length - data.length].push(tempObj);\n                tempLastLevelInfo.push(extend({}, tempObj, null, true));\n                break;\n              }\n            }\n          }\n        }\n        const topResources = resColl.slice(0, -1);\n        let tempGroupedData = [];\n        let totalRowSpan = 0;\n        for (let y = 0; y < topResources.length; y++) {\n          const data = topResources[topResources.length - (y + 1)].dataSource;\n          for (let x = 0; x < data.length; x++) {\n            let z = 0;\n            for (let u = 0; u < tempLastLevelInfo.length; u++) {\n              // eslint-disable-next-line max-len\n              if (tempLastLevelInfo[u].groupOrder[topResources.length - (y + 1)] === data[x][topResources[topResources.length - (y + 1)].idField]) {\n                totalRowSpan = totalRowSpan + tempLastLevelInfo[u].rowSpan;\n                tempGroupedData.push(extend({}, tempLastLevelInfo[u], null, true));\n              }\n              if (++z === tempLastLevelInfo.length && tempGroupedData.length > 0) {\n                tempGroupedData[0].rowSpan = totalRowSpan;\n                tempGroupedData[0].type = 'parentColumnLevel_' + (y + 1);\n                tempGroupedData[0].resource = topResources[topResources.length - (y + 1)];\n                tempGroupedData[0].resourceData = data[x];\n                tempGroupedData[0].date = agendaDate;\n                lastLevelInfo[tempGroupedData[0].groupIndex].push(tempGroupedData[0]);\n                tempGroupedData = [];\n                totalRowSpan = 0;\n              }\n            }\n          }\n        }\n        this.createResourceTableRow(lastLevelInfo, tBody);\n      }\n    }\n    const totalCollection = this.parent.eventBase.filterEvents(initialDate, agendaLastDate);\n    if (totalCollection.length === 0 && !this.parent.activeViewOptions.allowVirtualScrolling && this.parent.hideEmptyAgendaDays) {\n      this.renderEmptyContent(tBody, initialDate);\n    }\n  }\n  createResourceTableRow(tContent, tBody) {\n    const tr = createElement('tr', {\n      attrs: {\n        role: 'row'\n      }\n    });\n    let ntr;\n    const td = createElement('td', {\n      attrs: {\n        role: 'gridcell',\n        'aria-selected': 'false'\n      }\n    });\n    let tempData;\n    let rowSpan = 0;\n    let level;\n    if (this.parent.activeViewOptions.group.byDate || this.parent.currentView === 'MonthAgenda') {\n      let tContentCollection = [];\n      const parentCollection = this.parent.resourceBase.resourceCollection.slice(0, -1);\n      for (let w = 0; w < tContent.length; w++) {\n        tContentCollection = tContentCollection.concat(tContent[w]);\n      }\n      level = parentCollection.length > 0 ? 'parentColumnLevel_' + parentCollection.length : 'resourceColumn';\n      const rowSpanCollection = tContentCollection.filter(data => data.type === level);\n      for (let x = 0; x < rowSpanCollection.length; x++) {\n        rowSpan = rowSpan + rowSpanCollection[x].rowSpan;\n      }\n    }\n    for (let row = 0; row < tContent.length; row++) {\n      ntr = tr.cloneNode();\n      for (let col = tContent[row].length - 1; col >= 0; col--) {\n        const data = tContent[row][col];\n        let ntd = td.cloneNode();\n        if (data.type === 'dateColumn') {\n          if (this.parent.activeViewOptions.group.byDate || this.parent.currentView === 'MonthAgenda') {\n            tempData = tContent[row][col];\n            continue;\n          }\n          ntd.setAttribute('data-date', data.date.getTime().toString());\n          ntd.appendChild(this.createDateHeaderElement(data.date));\n          const className = [AGENDA_CELLS_CLASS, AGENDA_DATE_CLASS];\n          if (data.cssClass) {\n            className.push(data.cssClass);\n          }\n          addClass([ntd], className);\n          ntr.appendChild(ntd);\n        } else if (data.type === 'eventColumn') {\n          const elementType = data.eventData.length === 0 ? 'noEvents' : 'data';\n          ntd = this.createAgendaContentElement(elementType, data.eventData, ntd, data.groupOrder, data.groupIndex);\n          ntd.setAttribute('data-date', data.date.getTime().toString());\n          if (this.parent.activeViewOptions.group.byDate || this.parent.currentView === 'MonthAgenda') {\n            addClass([ntd], [AGENDA_CELLS_CLASS, AGENDA_DAY_PADDING_CLASS]);\n          }\n          ntr.appendChild(ntd);\n        } else {\n          ntd.setAttribute('rowspan', data.rowSpan.toString());\n          addClass([ntd], AGENDA_RESOURCE_CLASS);\n          this.setResourceHeaderContent(ntd, data, data.className[0]);\n          ntr.appendChild(ntd);\n        }\n      }\n      if (this.parent.activeViewOptions.group.byDate && row === 0 && this.parent.currentView !== 'MonthAgenda') {\n        const ntd = td.cloneNode();\n        ntd.setAttribute('data-date', tempData.date.getTime().toString());\n        ntd.setAttribute('rowspan', rowSpan.toString());\n        ntd.appendChild(this.createDateHeaderElement(tempData.date));\n        addClass([ntd], [AGENDA_CELLS_CLASS, AGENDA_DATE_CLASS, DATE_BORDER_CLASS]);\n        const daysCount = getDaysCount(this.parent.selectedDate.getTime(), tempData.date.getTime());\n        ntr.setAttribute('aria-rowindex', daysCount.toString());\n        if (this.parent.element.querySelector(`.e-agenda-view tr[aria-rowindex=\"${daysCount}\"]`)) {\n          break;\n        }\n        ntr.insertBefore(ntd, ntr.childNodes[0]);\n      }\n      tBody.appendChild(ntr);\n    }\n  }\n  createDateHeaderElement(date) {\n    let dateHeader;\n    if (this.parent.activeViewOptions.dateHeaderTemplate) {\n      dateHeader = createElement('div', {\n        className: AGENDA_HEADER_CLASS\n      });\n      const args = {\n        date: date,\n        type: 'dateHeader'\n      };\n      const scheduleId = this.parent.element.id + '_';\n      const viewName = this.parent.activeViewOptions.dateHeaderTemplateName;\n      const templateId = scheduleId + viewName + 'dateHeaderTemplate';\n      const dateTemplate = [].slice.call(this.parent.getDateHeaderTemplate()(args, this.parent, 'dateHeaderTemplate', templateId, false));\n      append(dateTemplate, dateHeader);\n    } else {\n      dateHeader = this.getMobileDateElement(date, AGENDA_HEADER_CLASS);\n    }\n    return dateHeader;\n  }\n  renderEmptyContent(tBody, agendaDate) {\n    const eTr = this.createTableRowElement(agendaDate, 'noEvents');\n    const eTd = eTr.children[0];\n    const noEvents = createElement('div', {\n      className: AGENDA_EMPTY_EVENT_CLASS,\n      innerHTML: this.parent.localeObj.getConstant('noEvents')\n    });\n    eTd.appendChild(noEvents);\n    tBody.appendChild(eTr);\n  }\n  createTableRowElement(date, type) {\n    const daysCount = getDaysCount(this.parent.selectedDate.getTime(), date.getTime());\n    const tr = createElement('tr', {\n      attrs: {\n        'role': 'row',\n        'aria-rowindex': daysCount.toString()\n      }\n    });\n    const td = createElement('td', {\n      attrs: {\n        'class': type === 'monthHeader' ? MONTH_HEADER_CLASS : AGENDA_CELLS_CLASS,\n        'role': 'gridcell',\n        'aria-selected': 'false',\n        'aria-colindex': daysCount.toString(),\n        'data-date': date.getTime().toString()\n      }\n    });\n    const dTd = td.cloneNode();\n    const aTd = td.cloneNode();\n    tr.appendChild(dTd);\n    if (type !== 'noEvents') {\n      tr.appendChild(aTd);\n    }\n    return tr;\n  }\n  destroy() {\n    super.destroy();\n  }\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * agenda view\n */\nclass Agenda extends AgendaBase {\n  constructor(parent) {\n    super(parent);\n    this.viewClass = 'e-agenda-view';\n    this.isInverseTableSelect = false;\n    this.agendaDates = {};\n    this.virtualScrollTop = 1;\n  }\n  getModuleName() {\n    return 'agenda';\n  }\n  renderLayout() {\n    this.agendaDates = {};\n    this.element = createElement('div', {\n      className: TABLE_WRAP_CLASS\n    });\n    addClass([this.element], this.viewClass);\n    this.element.appendChild(this.createTableLayout(OUTER_TABLE_CLASS));\n    this.element.querySelector('table').setAttribute('role', 'presentation');\n    this.parent.element.querySelector('.' + TABLE_CONTAINER_CLASS).appendChild(this.element);\n    const eTr = createElement('tr');\n    this.element.querySelector('tbody').appendChild(eTr);\n    const workTd = createElement('td');\n    eTr.appendChild(workTd);\n    const wrap = createElement('div', {\n      className: CONTENT_WRAP_CLASS\n    });\n    workTd.appendChild(wrap);\n    const tbl = this.createTableLayout(CONTENT_TABLE_CLASS);\n    wrap.appendChild(tbl);\n    const tBody = tbl.querySelector('tbody');\n    const agendaDate = resetTime(this.parent.selectedDate);\n    this.renderEmptyContent(tBody, agendaDate);\n    this.wireEvents();\n    if (this.parent.resourceBase) {\n      this.parent.resourceBase.generateResourceLevels([{\n        renderDates: this.parent.activeView.renderDates\n      }]);\n    }\n    if (this.parent.uiStateValues.isGroupAdaptive && !this.parent.element.querySelector('.' + RESOURCE_TOOLBAR_CONTAINER)) {\n      this.renderResourceMobileLayout();\n    }\n    this.parent.notify(contentReady, {});\n  }\n  eventLoad(args) {\n    this.dataSource = extend([], this.parent.eventsData, null, true);\n    for (const event of this.parent.eventsData) {\n      delete event.generatedDates;\n    }\n    let eventCollection = this.parent.activeViewOptions.allowVirtualScrolling ? args.processedData : this.parent.eventsProcessed;\n    if (this.parent.uiStateValues.isGroupAdaptive) {\n      const resource = this.parent.resourceBase.lastResourceLevel[this.parent.uiStateValues.groupIndex];\n      this.dataSource = this.parent.eventBase.filterEventsByResource(resource, this.dataSource);\n      eventCollection = this.parent.eventBase.filterEventsByResource(resource, eventCollection);\n    }\n    this.parent.eventsProcessed = this.processAgendaEvents(eventCollection);\n    const agendaDate = resetTime(this.parent.selectedDate);\n    const tBody = this.element.querySelector('.' + CONTENT_TABLE_CLASS + ' tbody');\n    removeChildren(tBody);\n    this.renderInitialContent(tBody, agendaDate);\n    this.wireEventActions();\n    const contentArea = closest(tBody, '.' + CONTENT_WRAP_CLASS);\n    contentArea.scrollTop = 1;\n    this.parent.notify(eventsLoaded, {});\n    if (!this.parent.activeViewOptions.allowVirtualScrolling) {\n      this.retainScrollPosition();\n    }\n  }\n  refreshEvent(refreshDate) {\n    let processedData = [];\n    const fields = this.parent.eventFields;\n    for (const data of this.dataSource) {\n      if (isNullOrUndefined(data[fields.recurrenceID]) && !isNullOrUndefined(data[fields.recurrenceRule]) && !isNullOrUndefined(data.generatedDates) && refreshDate >= data.generatedDates.end) {\n        processedData = processedData.concat(this.parent.eventBase.generateOccurrence(data, refreshDate));\n      }\n    }\n    this.parent.eventsProcessed = this.parent.eventsProcessed.concat(this.processAgendaEvents(processedData));\n  }\n  refreshHeader() {\n    const tBody = this.element.querySelector('.' + CONTENT_TABLE_CLASS + ' tbody');\n    if (this.parent.activeViewOptions.group.byDate) {\n      removeChildren(tBody);\n    } else {\n      remove(tBody.firstElementChild);\n    }\n    const agendaDate = resetTime(this.parent.selectedDate);\n    const emptyTBody = createElement('tbody');\n    const firstDate = new Date(agendaDate.getTime());\n    const lastDate = this.parent.activeViewOptions.allowVirtualScrolling && this.parent.hideEmptyAgendaDays ? this.getEndDateFromStartDate(firstDate) : addDays(firstDate, this.parent.agendaDaysCount);\n    this.renderContent(emptyTBody, firstDate, lastDate);\n    append([].slice.call(emptyTBody.childNodes), tBody);\n  }\n  renderInitialContent(tBody, agendaDate) {\n    const emptyTBody = createElement('tbody');\n    let firstDate = new Date(agendaDate.getTime());\n    let lastDate = this.parent.activeViewOptions.allowVirtualScrolling && this.parent.hideEmptyAgendaDays ? this.getEndDateFromStartDate(firstDate) : addDays(firstDate, this.parent.agendaDaysCount);\n    this.renderContent(emptyTBody, firstDate, lastDate);\n    append([].slice.call(emptyTBody.childNodes), tBody);\n    // Initial rendering, to load previous date events upto scroll bar enable\n    if (this.parent.activeViewOptions.allowVirtualScrolling && this.parent.hideEmptyAgendaDays && this.parent.eventsData.length > 0) {\n      const contentArea = this.getContentAreaElement();\n      const contentChild = contentArea.querySelector('.e-content-table');\n      while (contentArea.offsetWidth <= contentArea.clientWidth) {\n        if (this.parent.isAdaptive && contentChild.offsetHeight >= contentArea.clientHeight) {\n          break;\n        }\n        const emptyTBody = createElement('tbody');\n        lastDate = firstDate;\n        firstDate = addDays(lastDate, -this.parent.agendaDaysCount);\n        this.renderContent(emptyTBody, firstDate, lastDate);\n        prepend([].slice.call(emptyTBody.childNodes), tBody);\n        if (firstDate <= this.parent.minDate) {\n          break;\n        }\n      }\n    }\n    if (tBody.childNodes.length <= 0) {\n      this.renderEmptyContent(tBody, agendaDate);\n    }\n  }\n  renderContent(tBody, agendaDate, lastDate) {\n    const fieldMapping = this.parent.eventFields;\n    const firstDate = new Date(agendaDate.getTime());\n    const isObject = this.appointmentFiltering(firstDate, lastDate);\n    if (isObject.length > 0 && this.parent.activeViewOptions.allowVirtualScrolling && this.parent.hideEmptyAgendaDays) {\n      agendaDate = isObject[0][fieldMapping.startTime];\n      agendaDate = new Date(new Date(agendaDate.getTime()).setHours(0, 0, 0, 0));\n      this.updateHeaderText(isObject[0][fieldMapping.startTime]);\n    }\n    let endDate;\n    if (!this.parent.hideEmptyAgendaDays || this.parent.agendaDaysCount > 0 && isObject.length > 0) {\n      if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {\n        let date = agendaDate;\n        if (!this.parent.activeViewOptions.group.byDate) {\n          this.parent.activeViewOptions.allowVirtualScrolling = false;\n          date = firstDate;\n          if (this.parent.headerModule) {\n            this.parent.headerModule.updateDateRange(this.parent.activeView.getDateRangeText());\n            this.parent.headerModule.updateHeaderItems('remove');\n          }\n        }\n        this.calculateResourceTableElement(tBody, this.parent.agendaDaysCount, date);\n      } else {\n        for (let day = 0; day < this.parent.agendaDaysCount; day++) {\n          const filterData = this.appointmentFiltering(agendaDate);\n          const nTr = this.createTableRowElement(agendaDate, 'data');\n          if (this.element.querySelector('tr[aria-rowindex=\"' + parseInt(nTr.getAttribute('aria-rowindex'), 10) + '\"]')) {\n            agendaDate = addDays(agendaDate, 1);\n            continue;\n          }\n          const dTd = nTr.children[0];\n          const aTd = nTr.children[1];\n          if (filterData.length > 0 || !this.parent.hideEmptyAgendaDays && filterData.length === 0) {\n            const elementType = !this.parent.hideEmptyAgendaDays && filterData.length === 0 ? 'noEvents' : 'data';\n            dTd.appendChild(this.createDateHeaderElement(agendaDate));\n            nTr.appendChild(dTd);\n            const cTd = this.createAgendaContentElement(elementType, filterData, aTd);\n            nTr.appendChild(cTd);\n            if (cTd.querySelectorAll('li').length > 0) {\n              tBody.appendChild(nTr);\n            }\n          } else if (this.parent.activeViewOptions.allowVirtualScrolling) {\n            day--;\n          }\n          if (this.isCurrentDate(new Date(agendaDate.getTime()))) {\n            addClass(dTd.childNodes, AGENDA_CURRENT_DAY_CLASS);\n          }\n          agendaDate = addDays(agendaDate, 1);\n          if (agendaDate.getTime() > lastDate.getTime()) {\n            break;\n          }\n        }\n      }\n      endDate = new Date(agendaDate.getTime() - MS_PER_DAY);\n    }\n    this.agendaDates = {\n      start: firstDate,\n      end: endDate\n    };\n  }\n  agendaScrolling(event) {\n    if (this.parent.quickPopup) {\n      this.parent.quickPopup.quickPopupHide();\n    }\n    if (this.parent.activeViewOptions.allowVirtualScrolling) {\n      this.virtualScrolling(event);\n    }\n    if (!this.parent.activeViewOptions.allowVirtualScrolling) {\n      this.setPersistence();\n    }\n  }\n  virtualScrolling(event) {\n    const target = event.target;\n    const scrollTop = target.scrollTop;\n    const scrollHeight = target.scrollHeight;\n    const offsetHeight = target.clientHeight;\n    const totalHeight = scrollTop + offsetHeight;\n    const direction = this.virtualScrollTop < scrollTop ? 'next' : 'previous';\n    const tBody = target.querySelector('tbody');\n    const emptyTBody = createElement('tbody');\n    const topElement = this.getElementFromScrollerPosition(event);\n    const scrollDate = this.parent.getDateFromElement(topElement);\n    let filterDate;\n    let filterData;\n    if (scrollTop === 0) {\n      filterDate = this.getPreviousNextDate(addDays(scrollDate, -1), direction);\n      filterData = this.appointmentFiltering(filterDate.start, filterDate.end);\n      if (filterData.length > 0 || !this.parent.hideEmptyAgendaDays) {\n        this.renderContent(emptyTBody, filterDate.start, filterDate.end);\n        prepend([].slice.call(emptyTBody.childNodes), tBody);\n        this.wireEventActions();\n        for (let s = 0, element = tBody.children; s < element.length; s++) {\n          if (element[s].getAttribute('aria-rowindex') === topElement.getAttribute('aria-colindex')) {\n            const scrollToValue = element[s].offsetTop - this.element.querySelector('.e-agenda-item').offsetHeight;\n            target.scrollTop = scrollToValue;\n            break;\n          }\n        }\n        this.updateHeaderText(scrollDate);\n      }\n    } else if (totalHeight >= scrollHeight - 5) {\n      filterDate = this.getPreviousNextDate(addDays(scrollDate, 1), direction);\n      filterData = this.appointmentFiltering(filterDate.start, filterDate.end);\n      if (filterData.length > 0 || !this.parent.hideEmptyAgendaDays) {\n        this.renderContent(emptyTBody, filterDate.start, filterDate.end);\n        append([].slice.call(emptyTBody.childNodes), tBody);\n        this.wireEventActions();\n        this.updateHeaderText(scrollDate);\n      }\n    } else {\n      this.updateHeaderText(scrollDate);\n    }\n    this.virtualScrollTop = scrollTop;\n    const selectedElements = this.parent.eventBase.getSelectedAppointments();\n    if (selectedElements.length > 0) {\n      selectedElements[selectedElements.length - 1].focus();\n    }\n  }\n  getElementFromScrollerPosition(event) {\n    let filterElement;\n    const target = event.target;\n    const scrollTop = target.scrollTop;\n    const scrollHeight = target.scrollHeight;\n    const offsetHeight = target.clientHeight;\n    const totalHeight = scrollTop + offsetHeight;\n    const liCollection = [].slice.call(target.querySelectorAll('.e-agenda-item'));\n    let li;\n    let liDetails;\n    if (liCollection.length > 0) {\n      if (scrollTop === 0) {\n        li = liCollection[0];\n        filterElement = closest(li, '.' + AGENDA_CELLS_CLASS);\n      } else if (totalHeight === scrollHeight) {\n        li = liCollection[liCollection.length - 1];\n        filterElement = closest(li, '.' + AGENDA_CELLS_CLASS);\n      } else {\n        for (let a = 0, length = liCollection.length; a < length; a++) {\n          li = liCollection[a];\n          liDetails = li.getBoundingClientRect();\n          if (liDetails.top >= 0) {\n            filterElement = closest(li, '.' + AGENDA_CELLS_CLASS);\n            break;\n          }\n        }\n      }\n    }\n    return filterElement;\n  }\n  updateHeaderText(date) {\n    if (this.parent.showHeaderBar) {\n      this.parent.headerModule.updateDateRange(this.getDateRangeText(date));\n    }\n  }\n  getPreviousNextDate(date, type) {\n    let currentDate = new Date(date.getTime());\n    const firstDate = this.getStartDateFromEndDate(date);\n    const lastDate = this.getEndDateFromStartDate(date);\n    let daysCount = 0;\n    do {\n      const filterData = this.appointmentFiltering(currentDate);\n      if (filterData.length > 0 || !this.parent.hideEmptyAgendaDays) {\n        daysCount++;\n      }\n      currentDate = addDays(currentDate, type === 'next' ? 1 : -1);\n      if (currentDate < firstDate || currentDate > lastDate) {\n        break;\n      }\n    } while (daysCount !== this.parent.agendaDaysCount);\n    const endDate = addDays(currentDate, type === 'next' ? -1 : 1);\n    return type === 'next' ? {\n      start: date,\n      end: addDays(endDate, 1)\n    } : {\n      start: endDate,\n      end: addDays(date, 1)\n    };\n  }\n  appointmentFiltering(startDate, endDate) {\n    let dateStart;\n    let dateEnd;\n    if (!isNullOrUndefined(startDate) && isNullOrUndefined(endDate)) {\n      dateStart = resetTime(new Date(startDate.getTime()));\n      dateEnd = setTime(new Date(dateStart.getTime()), MS_PER_DAY);\n    } else {\n      dateStart = new Date(startDate.getTime());\n      dateEnd = new Date(endDate.getTime());\n    }\n    let filterData = this.parent.eventBase.filterEvents(dateStart, dateEnd);\n    if (filterData.length === 0) {\n      this.refreshEvent(startDate);\n      filterData = this.parent.eventBase.filterEvents(dateStart, dateEnd);\n    }\n    return filterData;\n  }\n  getStartDateFromEndDate(endDate) {\n    let filterDate;\n    const fields = this.parent.eventFields;\n    if (this.parent.eventsProcessed.length > 0) {\n      const firstDate = Math.min(...this.parent.eventsProcessed.map(a => a[fields.startTime].getTime()));\n      filterDate = this.parent.hideEmptyAgendaDays ? new Date(firstDate) : this.parent.minDate;\n    } else {\n      filterDate = this.parent.hideEmptyAgendaDays ? addMonths(endDate, -1) : this.parent.minDate;\n    }\n    return resetTime(filterDate);\n  }\n  getEndDateFromStartDate(startDate) {\n    let filterDate;\n    const fieldMapping = this.parent.eventFields;\n    if (this.parent.eventsProcessed.length > 0) {\n      const lastDate = Math.max(...this.parent.eventsProcessed.map(a => a[fieldMapping.endTime].getTime()));\n      filterDate = this.parent.hideEmptyAgendaDays ? new Date(lastDate) : this.parent.maxDate;\n    } else {\n      filterDate = this.parent.hideEmptyAgendaDays ? addMonths(startDate, 1) : this.parent.maxDate;\n    }\n    return resetTime(addDays(filterDate, 1));\n  }\n  getNextPreviousDate(type) {\n    const noOfDays = type === 'next' ? 1 : -1;\n    return addDays(this.parent.selectedDate, noOfDays);\n  }\n  startDate() {\n    return resetTime(this.parent.selectedDate);\n  }\n  endDate() {\n    if (this.parent.activeViewOptions.allowVirtualScrolling) {\n      return this.getEndDateFromStartDate(this.startDate());\n    } else {\n      return addDays(this.startDate(), this.parent.agendaDaysCount);\n    }\n  }\n  getDateRangeText(date) {\n    const formatDate = this.parent.activeViewOptions.dateFormat ? this.parent.activeViewOptions.dateFormat : 'MMMM y';\n    if (this.parent.activeViewOptions.allowVirtualScrolling || this.parent.isAdaptive) {\n      const currentDate = isNullOrUndefined(date) ? this.parent.selectedDate : date;\n      return capitalizeFirstWord(this.parent.globalize.formatDate(currentDate, {\n        format: formatDate,\n        calendar: this.parent.getCalendarMode()\n      }), 'multiple');\n    } else {\n      const startDate = this.parent.selectedDate;\n      const endDate = addDays(startDate, this.parent.agendaDaysCount - 1);\n      return this.formatDateRange(startDate, endDate);\n    }\n  }\n  dayNavigationClick(e) {\n    const element = closest(e.currentTarget, '.' + AGENDA_CELLS_CLASS);\n    const date = this.parent.getDateFromElement(element);\n    if (!isNullOrUndefined(date) && !this.parent.isAdaptive && this.parent.isMinMaxDate(date)) {\n      this.parent.setProperties({\n        selectedDate: date\n      }, true);\n      this.parent.changeView('Day', e);\n    }\n  }\n  wireEvents() {\n    EventHandler.add(this.element.querySelector('.' + CONTENT_WRAP_CLASS), scroll, this.agendaScrolling, this);\n  }\n  unWireEvents() {\n    EventHandler.remove(this.element.querySelector('.' + CONTENT_WRAP_CLASS), scroll, this.agendaScrolling);\n    const dateHeaderElement = [].slice.call(this.element.querySelectorAll('.e-m-date'));\n    for (const element of dateHeaderElement) {\n      EventHandler.remove(element, 'click', this.dayNavigationClick);\n    }\n  }\n  addEventListener() {\n    this.parent.on(scrollUiUpdate, this.onAgendaScrollUiUpdate, this);\n    this.parent.on(dataReady, this.eventLoad, this);\n  }\n  removeEventListener() {\n    if (this.parent) {\n      this.parent.off(scrollUiUpdate, this.onAgendaScrollUiUpdate);\n      this.parent.off(dataReady, this.eventLoad);\n    }\n  }\n  onAgendaScrollUiUpdate() {\n    const headerHeight = this.getHeaderBarHeight();\n    if (this.parent.headerModule) {\n      if (this.parent.activeViewOptions.allowVirtualScrolling) {\n        this.parent.headerModule.updateHeaderItems('add');\n      } else {\n        this.parent.headerModule.updateHeaderItems('remove');\n      }\n    }\n    const contentArea = this.element.querySelector('.' + CONTENT_WRAP_CLASS);\n    if (this.parent.height !== 'auto') {\n      contentArea.style.height = formatUnit(this.parent.element.offsetHeight - headerHeight);\n    }\n  }\n  destroy() {\n    if (!this.parent || this.parent && this.parent.isDestroyed) {\n      return;\n    }\n    if (this.element) {\n      this.unWireEvents();\n      if (this.parent.resourceBase) {\n        this.parent.resourceBase.destroy();\n      }\n      if (this.parent.headerModule && this.parent.activeViewOptions.allowVirtualScrolling) {\n        this.parent.headerModule.updateHeaderItems('remove');\n      }\n      super.destroy();\n    }\n  }\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * month agenda view\n */\nclass MonthAgenda extends Month {\n  constructor(parent) {\n    super(parent);\n    this.dayNameFormat = 'narrow';\n    this.viewClass = 'e-month-agenda-view';\n    this.monthAgendaDate = new Date('' + parent.selectedDate);\n  }\n  getModuleName() {\n    return 'monthAgenda';\n  }\n  renderAppointmentContainer() {\n    const contentArea = this.getContentAreaElement();\n    const wrapperContainer = createElement('div', {\n      className: WRAPPER_CONTAINER_CLASS\n    });\n    contentArea.appendChild(wrapperContainer);\n    const appWrap = createElement('div', {\n      className: APPOINTMENT_WRAP_CLASS\n    });\n    wrapperContainer.appendChild(appWrap);\n    this.appendAppContainer(appWrap);\n    this.setEventWrapperHeight();\n  }\n  getDayNameFormat() {\n    if (this.parent.isAdaptive) {\n      return 'narrow';\n    }\n    return 'abbreviated';\n  }\n  setEventWrapperHeight() {\n    let headerHeight = (this.parent.headerModule ? this.parent.headerModule.getHeaderElement().offsetHeight : 0) + 2;\n    const resourceWrapper = this.parent.element.querySelector('.' + RESOURCE_HEADER_TOOLBAR);\n    if (resourceWrapper) {\n      headerHeight += resourceWrapper.offsetHeight;\n    }\n    const contentArea = this.getContentAreaElement().firstElementChild;\n    const dateHeader = this.element.querySelector('.' + DATE_HEADER_WRAP_CLASS);\n    const availHeight = this.parent.element.offsetHeight - headerHeight - dateHeader.offsetHeight - contentArea.offsetHeight;\n    const wrapperContainer = this.element.querySelector('.' + WRAPPER_CONTAINER_CLASS);\n    const eventWrapper = this.element.querySelector('.' + APPOINTMENT_WRAP_CLASS);\n    if (this.parent.height !== 'auto') {\n      wrapperContainer.style.height = eventWrapper.style.height = formatUnit(availHeight);\n    }\n  }\n  onDataReady(args) {\n    this.setEventWrapperHeight();\n    this.clearElements();\n    let eventCollection = args.processedData;\n    if (this.parent.uiStateValues.isGroupAdaptive) {\n      const resource = this.parent.resourceBase.lastResourceLevel[this.parent.uiStateValues.groupIndex];\n      eventCollection = this.parent.eventBase.filterEventsByResource(resource, eventCollection);\n    }\n    this.agendaBase = this.getAgendaBase();\n    this.parent.eventsProcessed = this.agendaBase.processAgendaEvents(eventCollection);\n    let count = 0;\n    for (const date of this.renderDates) {\n      const filterData = this.appointmentFiltering(date);\n      const workCell = this.element.querySelectorAll('.' + WORK_CELLS_CLASS)[count];\n      if (filterData.length > 0) {\n        if (!workCell.querySelector('.' + APPOINTMENT_INDICATOR_CLASS)) {\n          workCell.appendChild(createElement('div', {\n            className: APPOINTMENT_INDICATOR_CLASS\n          }));\n        }\n        if (date.getTime() === resetTime(new Date(this.monthAgendaDate.getTime())).getTime()) {\n          this.onEventRender(filterData, date);\n        }\n      }\n      count++;\n    }\n    this.parent.notify(eventsLoaded, {});\n  }\n  onCellClick(event) {\n    if (this.parent.quickPopup) {\n      this.parent.quickPopup.quickPopupHide();\n    }\n    const filterData = this.appointmentFiltering(event.startTime);\n    this.onEventRender(filterData, event.startTime);\n    this.parent.notify(eventsLoaded, {});\n    this.monthAgendaDate = new Date('' + event.startTime);\n  }\n  onEventRender(events, date) {\n    this.agendaBase = this.getAgendaBase();\n    const appWrap = this.element.querySelector('.' + APPOINTMENT_WRAP_CLASS);\n    removeChildren(appWrap);\n    if (this.parent.activeViewOptions.group.resources.length === 0 || this.parent.uiStateValues.isGroupAdaptive) {\n      if (events.length > 0) {\n        const appContainer = createElement('div', {\n          className: APPOINTMENT_CONTAINER_CLASS\n        });\n        appWrap.appendChild(this.agendaBase.createAgendaContentElement('data', events, appContainer));\n      } else {\n        this.appendAppContainer(appWrap);\n      }\n    } else {\n      if (events.length > 0) {\n        const table = this.createTableLayout();\n        const tBody = table.querySelector('tbody');\n        this.agendaBase.calculateResourceTableElement(tBody, 1, date);\n        table.appendChild(tBody);\n        appWrap.appendChild(table);\n      } else {\n        this.appendAppContainer(appWrap);\n      }\n    }\n    this.agendaBase.wireEventActions();\n  }\n  appointmentFiltering(date) {\n    const dateStart = resetTime(new Date(date.getTime()));\n    const dateEnd = setTime(new Date(dateStart.getTime()), MS_PER_DAY);\n    return this.parent.eventBase.filterEvents(dateStart, dateEnd);\n  }\n  clearElements() {\n    const appointmentIndicators = [].slice.call(this.element.querySelectorAll('.' + APPOINTMENT_INDICATOR_CLASS));\n    for (const appointmentIndicator of appointmentIndicators) {\n      remove(appointmentIndicator);\n    }\n    this.appendAppContainer(this.element.querySelector('.' + APPOINTMENT_WRAP_CLASS));\n  }\n  appendAppContainer(appWrap) {\n    const app = createElement('div', {\n      className: APPOINTMENT_CONTAINER_CLASS\n    });\n    addClass([app], AGENDA_NO_EVENT_CLASS);\n    app.innerHTML = this.parent.localeObj.getConstant('noEvents');\n    removeChildren(appWrap);\n    appWrap.appendChild(app);\n  }\n  getNextPreviousDate(type) {\n    const selectedDate = this.parent.selectedDate;\n    const interval = type === 'next' ? this.parent.activeViewOptions.interval : -this.parent.activeViewOptions.interval;\n    const navigateDate = addMonths(this.parent.selectedDate, interval);\n    const month = type === 'next' ? 2 : 0;\n    const lastDate = new Date(selectedDate.getFullYear(), selectedDate.getMonth() + month, 0).getDate();\n    const date = lastDate >= this.monthAgendaDate.getDate() ? this.monthAgendaDate.getDate() : lastDate;\n    this.monthAgendaDate = new Date(navigateDate.getFullYear(), navigateDate.getMonth(), date);\n    return this.monthAgendaDate;\n  }\n  getAgendaBase() {\n    return this.agendaBase || new AgendaBase(this.parent);\n  }\n  destroy() {\n    if (this.agendaBase) {\n      this.agendaBase.destroy();\n      this.agendaBase = null;\n    }\n    super.destroy();\n  }\n}\n\n/**\n * timeline header rows\n */\nclass TimelineHeaderRow {\n  constructor(parent, renderDates) {\n    this.parent = parent;\n    this.renderDates = renderDates;\n  }\n  groupByYear(dates) {\n    const result = {};\n    for (const d of dates) {\n      const key = d.getFullYear();\n      result[key] = result[key] || [];\n      result[key].push(d);\n    }\n    return result;\n  }\n  groupByMonth(dates) {\n    const result = {};\n    for (const d of dates) {\n      const key = (d.getFullYear() - 1970) * 12 + d.getMonth();\n      result[key] = result[key] || [];\n      result[key].push(d);\n    }\n    return result;\n  }\n  groupByWeek(dates) {\n    const result = {};\n    for (const d of dates) {\n      const jsDate = +new Date(1970, 0, 1);\n      const tzOffsetDiff = d.getTimezoneOffset() - new Date(1970, 0, 1).getTimezoneOffset();\n      let key = Math.ceil(((+d - jsDate - tzOffsetDiff * 60 * 1000) / MS_PER_DAY + new Date(jsDate).getDay() + 1) / 7);\n      if (this.parent.firstDayOfWeek && this.parent.firstDayOfWeek > new Date(+d).getDay()) {\n        key = key - 1;\n      }\n      result[key] = result[key] || [];\n      result[key].push(d);\n    }\n    return result;\n  }\n  generateSlots(data, colspan, row, cls, type) {\n    const dateParser = (date, format) => this.parent.globalize.formatDate(date, {\n      format: format,\n      calendar: this.parent.getCalendarMode()\n    });\n    const tdDatas = [];\n    const keys = Object.keys(data);\n    for (let i = 0; i < keys.length; i++) {\n      const dates = data[keys[i]];\n      let htmlCol;\n      if (row.template) {\n        const args = {\n          date: dates[0],\n          type: type\n        };\n        const templateId = this.parent.element.id + '_headerRowTemplate';\n        htmlCol = [].slice.call(this.parent.templateParser(row.template)(args, this.parent, 'template', templateId, false));\n      } else {\n        let viewTemplate;\n        switch (row.option) {\n          case 'Year':\n            viewTemplate = `<span class=\"e-header-year\">${dateParser(dates[0], 'y')}</span>`;\n            break;\n          case 'Month':\n            viewTemplate = `<span class=\"e-header-month\">${capitalizeFirstWord(dateParser(dates[0], 'MMMM'), 'single')}</span>`;\n            break;\n          case 'Week':\n            viewTemplate = `<span class=\"e-header-week\">${this.parent.getWeekNumberContent(dates)}</span>`;\n        }\n        const headerWrapper = createElement('div', {\n          innerHTML: viewTemplate\n        });\n        htmlCol = [].slice.call(headerWrapper.childNodes);\n      }\n      tdDatas.push({\n        date: dates[0],\n        type: type,\n        className: [cls],\n        colSpan: dates.length * colspan,\n        template: htmlCol\n      });\n    }\n    return tdDatas;\n  }\n  generateColumnLevels(dateSlots, hourSlots) {\n    const levels = [];\n    const rows = this.parent.activeViewOptions.headerRows;\n    let lastLevelColspan = 1;\n    if (rows[rows.length - 1].option === 'Hour' && hourSlots.length > 0) {\n      lastLevelColspan = hourSlots.length / dateSlots.length;\n    }\n    let tdDatas = [];\n    let byYear;\n    let byMonth;\n    let byWeek;\n    for (const row of rows) {\n      switch (row.option) {\n        case 'Year':\n          byYear = this.groupByYear(this.renderDates);\n          tdDatas = this.generateSlots(byYear, lastLevelColspan, row, 'e-header-year-cell', 'yearHeader');\n          levels.push(tdDatas);\n          break;\n        case 'Month':\n          byMonth = this.groupByMonth(this.renderDates);\n          tdDatas = this.generateSlots(byMonth, lastLevelColspan, row, 'e-header-month-cell', 'monthHeader');\n          levels.push(tdDatas);\n          break;\n        case 'Week':\n          byWeek = this.groupByWeek(this.renderDates);\n          tdDatas = this.generateSlots(byWeek, lastLevelColspan, row, 'e-header-week-cell', 'weekHeader');\n          levels.push(tdDatas);\n          break;\n        case 'Date':\n          tdDatas = dateSlots;\n          tdDatas = tdDatas.map(value => {\n            value.colSpan = lastLevelColspan;\n            return value;\n          });\n          levels.push(tdDatas);\n          break;\n        case 'Hour':\n          if (hourSlots.length > 0) {\n            levels.push(hourSlots);\n          }\n          break;\n      }\n    }\n    return levels;\n  }\n}\n\n/**\n * timeline views\n */\nclass TimelineViews extends VerticalView {\n  constructor(parent) {\n    super(parent);\n    this.timelineAppointment = null;\n    this.baseCssClass = 'e-timeline-view';\n  }\n  getModuleName() {\n    return 'timelineViews';\n  }\n  getLeftPanelElement() {\n    return this.element.querySelector('.' + RESOURCE_COLUMN_WRAP_CLASS);\n  }\n  scrollTopPanel(target) {\n    super.scrollTopPanel(target);\n    this.scrollHeaderLabels(target);\n  }\n  scrollToWorkHour() {\n    const start = this.parent.getStartEndTime(this.parent.workHours.start);\n    const currDateTime = this.isWorkDay(this.parent.selectedDate) && this.parent.workHours.highlight && !isNullOrUndefined(start) ? new Date(+this.parent.selectedDate).setHours(start.getHours(), start.getMinutes(), 0, 0) : new Date(+this.parent.selectedDate).setHours(0, 0, 0, 0);\n    const queryString = '[data-date=\"' + new Date(currDateTime).getTime().toString() + '\"]';\n    const firstWorkHourCell = this.element.querySelector(queryString);\n    if (firstWorkHourCell) {\n      this.getContentAreaElement().scrollLeft = !this.parent.enableRtl ? firstWorkHourCell.offsetLeft : -(this.parent.getContentTable().offsetWidth - firstWorkHourCell.offsetLeft - firstWorkHourCell.offsetWidth);\n    }\n  }\n  scrollToHour(hour, scrollDate) {\n    let date;\n    let index;\n    if (scrollDate) {\n      index = this.parent.getIndexOfDate(this.renderDates, resetTime(scrollDate));\n      if (index >= 0) {\n        const timeString = hour.split(':');\n        if (timeString.length === 2) {\n          date = new Date(scrollDate.setHours(parseInt(timeString[0], 10), parseInt(timeString[1], 10), 0));\n        }\n      }\n    }\n    date = isNullOrUndefined(scrollDate) ? this.parent.getStartEndTime(hour) : date;\n    if (isNullOrUndefined(date)) {\n      return;\n    }\n    const scrollLeft = isNullOrUndefined(scrollDate) ? this.getLeftFromDateTime(null, date) : this.getLeftFromDateTime([index], date);\n    this.getScrollableElement().scrollLeft = !this.parent.enableRtl ? scrollLeft : -scrollLeft;\n  }\n  generateColumnLevels() {\n    let levels = [];\n    const dateSlots = this.getDateSlots(this.renderDates, this.parent.activeViewOptions.workDays);\n    levels.push(dateSlots);\n    if (this.parent.activeViewOptions.group.resources.length > 0) {\n      this.parent.resourceBase.generateResourceLevels(dateSlots, !this.parent.uiStateValues.isGroupAdaptive);\n    }\n    let hourSlots = [];\n    if (this.parent.activeViewOptions.timeScale.enable) {\n      hourSlots = this.generateTimeSlots(levels[levels.length - 1]);\n      levels.push(hourSlots);\n    }\n    if (this.parent.activeViewOptions.headerRows.length > 0) {\n      const renderGn = new TimelineHeaderRow(this.parent, this.renderDates);\n      levels = renderGn.generateColumnLevels(dateSlots, hourSlots);\n    }\n    return levels;\n  }\n  generateTimeSlots(dateSlots) {\n    const handler = r => {\n      r.type = r.first ? 'majorSlot' : 'minorSlot';\n      r.className = r.first ? [TIME_SLOT_CLASS] : [TIME_SLOT_CLASS, TIME_CELLS_CLASS];\n      r.workDays = this.parent.activeViewOptions.workDays;\n      return r;\n    };\n    const timeSlotData = this.getTimeSlotRows(handler);\n    const slots = [];\n    for (const data of dateSlots) {\n      data.colSpan = timeSlotData.length;\n      const tempTimeSlots = extend([], timeSlotData, null, true);\n      for (const slot of tempTimeSlots) {\n        const cellDate = resetTime(new Date('' + data.date));\n        slot.date = setTime(cellDate, getDateInMs(slot.date));\n        slots.push(slot);\n      }\n    }\n    return slots;\n  }\n  changeCurrentTimePosition() {\n    if (!this.parent || this.parent && this.parent.isDestroyed) {\n      return;\n    }\n    this.removeCurrentTimeIndicatorElements();\n    const currentDateIndex = this.getCurrentTimeIndicatorIndex();\n    const left = this.getLeftFromDateTime(currentDateIndex, this.parent.getCurrentTime());\n    const height = this.element.querySelector('.' + CONTENT_TABLE_CLASS).offsetHeight;\n    const headerWrap = this.element.querySelector('.' + DATE_HEADER_WRAP_CLASS);\n    const contentWrap = this.element.querySelector('.' + CONTENT_WRAP_CLASS);\n    contentWrap.appendChild(createElement('div', {\n      className: CURRENT_TIMELINE_CLASS,\n      styles: (this.parent.enableRtl ? 'right' : 'left') + ':' + formatUnit(left) + '; height:' + formatUnit(height)\n    }));\n    if (this.parent.virtualScrollModule) {\n      const timeIndicator = this.parent.element.querySelector('.' + CURRENT_TIMELINE_CLASS);\n      const element = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS + ' table');\n      setStyleAttribute(timeIndicator, {\n        transform: element.style.transform\n      });\n    }\n    const currentTimeEle = createElement('div', {\n      innerHTML: this.parent.getTimeString(this.parent.getCurrentTime()),\n      className: CURRENT_TIME_CLASS\n    });\n    headerWrap.appendChild(currentTimeEle);\n    currentTimeEle.style[this.parent.enableRtl ? 'right' : 'left'] = formatUnit(left - currentTimeEle.offsetWidth / 2);\n  }\n  getLeftFromDateTime(currentDateIndex, date) {\n    const startHour = this.getStartHour();\n    const endHour = this.getEndHour();\n    let diffInDates = 0;\n    let diffInMinutes = (date.getHours() - startHour.getHours()) * 60 + (date.getMinutes() - startHour.getMinutes());\n    if (!isNullOrUndefined(currentDateIndex)) {\n      const end = endHour.getHours() === 0 ? 24 : endHour.getHours();\n      if (currentDateIndex[0] !== 0) {\n        diffInDates = currentDateIndex[0] * ((end - startHour.getHours()) * 60) + (endHour.getMinutes() - startHour.getMinutes());\n      }\n      diffInMinutes = diffInDates + diffInMinutes;\n    }\n    return diffInMinutes * this.getWorkCellWidth() * this.parent.activeViewOptions.timeScale.slotCount / this.parent.activeViewOptions.timeScale.interval;\n  }\n  getWorkCellWidth() {\n    return this.element.querySelector('.e-work-cells').getBoundingClientRect().width;\n  }\n  renderHeader() {\n    const tr = createElement('tr');\n    if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {\n      this.parent.resourceBase.renderResourceHeaderIndent(tr);\n    }\n    const dateTd = createElement('td');\n    dateTd.appendChild(this.renderDatesHeader());\n    tr.appendChild(dateTd);\n    prepend([tr], this.element.querySelector('tbody'));\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  createAllDayRow(table, tdData) {}\n  getCurrentTimeIndicatorIndex() {\n    const currentDateIndex = [];\n    const index = this.parent.getIndexOfDate(this.renderDates, resetTime(this.parent.getCurrentTime()));\n    if (index >= 0) {\n      currentDateIndex.push(index);\n    }\n    return currentDateIndex;\n  }\n  renderContent() {\n    const tr = createElement('tr');\n    if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {\n      const resTd = createElement('td');\n      resTd.appendChild(this.parent.resourceBase.createResourceColumn());\n      tr.appendChild(resTd);\n    }\n    const workTd = createElement('td');\n    const wrap = this.renderContentArea();\n    wrap.appendChild(this.createEventTable(this.getRowCount()));\n    this.collapseRows(wrap);\n    workTd.appendChild(wrap);\n    tr.appendChild(workTd);\n    if (this.parent.virtualScrollModule) {\n      this.parent.virtualScrollModule.renderVirtualTrack(wrap);\n    }\n    this.element.querySelector('tbody').appendChild(tr);\n  }\n  getRowCount() {\n    if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {\n      return this.parent.resourceBase.renderedResources.length;\n    }\n    return 1;\n  }\n  getResourceTdData(i, tdData) {\n    const resLevel = this.parent.resourceBase.renderedResources[i];\n    const resSHr = resLevel.resourceData[resLevel.resource.startHourField] || this.parent.workHours.start;\n    const resEHr = resLevel.resourceData[resLevel.resource.endHourField] || this.parent.workHours.end;\n    tdData.startHour = this.parent.getStartEndTime(resSHr);\n    tdData.endHour = this.parent.getStartEndTime(resEHr);\n    tdData.workDays = resLevel.resourceData[resLevel.resource.workDaysField] || this.parent.workDays;\n    tdData.className = resLevel.className;\n    tdData.groupIndex = resLevel.groupIndex;\n    tdData.groupOrder = resLevel.groupOrder;\n    return tdData;\n  }\n  renderContentTable(table) {\n    const tBody = table.querySelector('tbody');\n    append(this.getContentRows(), tBody);\n  }\n  getContentRows() {\n    const rows = [];\n    const tr = createElement('tr', {\n      attrs: {\n        role: 'row'\n      }\n    });\n    const td = createElement('td', {\n      attrs: {\n        role: 'gridcell',\n        'aria-selected': 'false'\n      }\n    });\n    const trCount = this.getRowCount();\n    for (let i = 0; i < trCount; i++) {\n      const ntr = tr.cloneNode();\n      for (let tdData of this.colLevels[this.colLevels.length - 1]) {\n        if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {\n          tdData = this.getResourceTdData(i, tdData);\n        }\n        const ntd = this.createContentTd(tdData, tdData, td);\n        ntr.appendChild(ntd);\n      }\n      rows.push(ntr);\n    }\n    return rows;\n  }\n  getContentTdClass(r) {\n    return r.first || !this.parent.activeViewOptions.timeScale.enable ? [WORK_CELLS_CLASS] : [WORK_CELLS_CLASS, ALTERNATE_CELLS_CLASS];\n  }\n  renderEvents() {\n    this.timelineAppointment = new TimelineEvent(this.parent, this.parent.activeViewOptions.timeScale.enable ? 'hour' : 'day');\n    this.timelineAppointment.renderAppointments();\n    this.parent.notify(eventsLoaded, {});\n  }\n  destroy() {\n    if (!this.parent || this.parent && this.parent.isDestroyed) {\n      return;\n    }\n    if (this.timelineAppointment) {\n      this.timelineAppointment.destroy();\n      this.timelineAppointment = null;\n    }\n    super.destroy();\n  }\n}\n\n/**\n * timeline month view\n */\nclass TimelineMonth extends Month {\n  constructor(parent) {\n    super(parent);\n    this.viewClass = 'e-timeline-month-view';\n    this.isInverseTableSelect = true;\n    this.appointment = null;\n  }\n  getModuleName() {\n    return 'timelineMonth';\n  }\n  onDataReady() {\n    this.appointment = new TimelineEvent(this.parent, 'day');\n    this.appointment.renderAppointments();\n    this.parent.notify(eventsLoaded, {});\n  }\n  getLeftPanelElement() {\n    return this.element.querySelector('.' + RESOURCE_COLUMN_WRAP_CLASS);\n  }\n  scrollTopPanel(target) {\n    super.scrollTopPanel(target);\n    this.scrollHeaderLabels(target);\n  }\n  setContentHeight(content, leftPanelElement, height) {\n    if (leftPanelElement) {\n      leftPanelElement.style.height = formatUnit(height - this.getScrollXIndent(content));\n    }\n    content.style.height = formatUnit(height);\n  }\n  getDateSlots(renderDates, workDays) {\n    const dateSlots = [];\n    for (const col of renderDates) {\n      const classList$$1 = [HEADER_CELLS_CLASS];\n      if (this.isCurrentDate(col)) {\n        classList$$1.push(CURRENT_DAY_CLASS);\n      }\n      dateSlots.push({\n        date: col,\n        type: 'dateHeader',\n        className: classList$$1,\n        colSpan: 1,\n        workDays: workDays\n      });\n    }\n    return dateSlots;\n  }\n  renderLeftIndent(tr) {\n    if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {\n      this.parent.resourceBase.renderResourceHeaderIndent(tr);\n    }\n  }\n  renderContent() {\n    const contentTr = createElement('tr');\n    if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {\n      const resTd = createElement('td');\n      resTd.appendChild(this.parent.resourceBase.createResourceColumn());\n      contentTr.appendChild(resTd);\n    }\n    const contentTd = createElement('td');\n    this.element.querySelector('tbody').appendChild(contentTr);\n    const wrap = createElement('div', {\n      className: CONTENT_WRAP_CLASS\n    });\n    wrap.appendChild(this.renderContentArea());\n    wrap.appendChild(this.createEventTable(this.getRowCount()));\n    this.collapseRows(wrap);\n    EventHandler.add(wrap, 'scroll', this.onContentScroll, this);\n    contentTd.appendChild(wrap);\n    if (this.parent.virtualScrollModule) {\n      this.parent.virtualScrollModule.renderVirtualTrack(wrap);\n    }\n    contentTr.appendChild(contentTd);\n  }\n  getRowCount() {\n    if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {\n      return this.parent.resourceBase.renderedResources.length;\n    }\n    return 1;\n  }\n  getContentSlots() {\n    const slotDatas = [];\n    for (let row = 0; row < this.getRowCount(); row++) {\n      for (const data of this.colLevels[this.colLevels.length - 1]) {\n        data.className = [WORK_CELLS_CLASS];\n        if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {\n          const resLevel = this.parent.resourceBase.renderedResources[row];\n          data.workDays = resLevel.resourceData[resLevel.resource.workDaysField] || this.parent.workDays;\n          data.className = data.className.concat(resLevel.className);\n          data.groupIndex = resLevel.groupIndex;\n          data.groupOrder = resLevel.groupOrder;\n        }\n        const slotData = {\n          date: new Date(+data.date),\n          colSpan: data.colSpan,\n          groupIndex: data.groupIndex,\n          workDays: data.workDays,\n          type: 'monthCells',\n          className: data.className\n        };\n        if (!slotDatas[row]) {\n          slotDatas[row] = [];\n        }\n        slotDatas[row].push(slotData);\n      }\n    }\n    return slotDatas;\n  }\n  updateClassList(data) {\n    if (!this.parent.isMinMaxDate(data.date)) {\n      data.className.push(DISABLE_DATES);\n    }\n  }\n  unWireEvents() {\n    EventHandler.remove(this.getContentAreaElement(), 'scroll', this.onContentScroll);\n  }\n  getMonthStart(currentDate) {\n    const monthStart = this.parent.calendarUtil.firstDateOfMonth(resetTime(currentDate));\n    return new Date(monthStart.getFullYear(), monthStart.getMonth(), monthStart.getDate());\n  }\n  getMonthEnd(currentDate) {\n    const monthStart = this.parent.calendarUtil.firstDateOfMonth(resetTime(currentDate));\n    return this.parent.calendarUtil.lastDateOfMonth(addMonths(new Date(+monthStart), this.parent.activeViewOptions.interval - 1));\n  }\n  generateColumnLevels() {\n    let colLevels = [];\n    const level = this.getDateSlots(this.renderDates, this.parent.activeViewOptions.workDays);\n    colLevels.push(level);\n    if (this.parent.activeViewOptions.group.resources.length > 0) {\n      this.parent.resourceBase.generateResourceLevels(level, !this.parent.uiStateValues.isGroupAdaptive);\n    }\n    const hourSlots = [];\n    if (this.parent.activeViewOptions.headerRows.length > 0) {\n      const renderGn = new TimelineHeaderRow(this.parent, this.renderDates);\n      colLevels = renderGn.generateColumnLevels(level, hourSlots);\n    }\n    this.colLevels = colLevels;\n    return colLevels;\n  }\n  destroy() {\n    if (!this.parent || this.parent && this.parent.isDestroyed) {\n      return;\n    }\n    if (this.element) {\n      const contentScrollableEle = this.element.querySelector('.' + CONTENT_WRAP_CLASS);\n      if (contentScrollableEle) {\n        EventHandler.remove(contentScrollableEle, 'scroll', this.onContentScroll);\n      }\n    }\n    if (this.appointment) {\n      this.appointment.destroy();\n      this.appointment = null;\n    }\n    super.destroy();\n  }\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * timeline year view\n */\nclass TimelineYear extends Year {\n  constructor(parent) {\n    super(parent);\n    this.viewClass = 'e-timeline-year-view';\n    this.isInverseTableSelect = true;\n  }\n  getModuleName() {\n    return 'timelineYear';\n  }\n  renderHeader(headerWrapper) {\n    const tr = createElement('tr');\n    headerWrapper.appendChild(tr);\n    if (this.parent.activeViewOptions.orientation === 'Vertical' && this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {\n      this.parent.resourceBase.renderResourceHeaderIndent(tr);\n    } else {\n      const leftHeaderCells = createElement('td', {\n        className: LEFT_INDENT_CLASS\n      });\n      tr.appendChild(leftHeaderCells);\n      leftHeaderCells.appendChild(this.renderResourceHeader(LEFT_INDENT_WRAP_CLASS));\n    }\n    const isHorizontal = this.parent.activeViewOptions.orientation === 'Horizontal';\n    const isGroup = this.parent.activeViewOptions.group.resources.length > 0;\n    this.isInverseTableSelect = isHorizontal && !isGroup ? false : true;\n    const td = createElement('td');\n    tr.appendChild(td);\n    const container = createElement('div', {\n      className: DATE_HEADER_CONTAINER_CLASS\n    });\n    td.appendChild(container);\n    if (this.parent.activeViewOptions.orientation === 'Horizontal' && this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {\n      container.appendChild(this.renderResourceHeader(DATE_HEADER_WRAP_CLASS));\n      this.columnCount = this.colLevels.slice(-1)[0].length;\n    } else {\n      const wrapper = createElement('div', {\n        className: DATE_HEADER_WRAP_CLASS\n      });\n      container.appendChild(wrapper);\n      const table = this.createTableLayout();\n      wrapper.appendChild(table);\n      table.appendChild(this.createTableColGroup(this.columnCount));\n      const innerTr = createElement('tr');\n      table.querySelector('tbody').appendChild(innerTr);\n      const months = this.getMonths();\n      const dayHeaderDates = this.getMonthDates(new Date(this.parent.selectedDate.getFullYear(), months[0], 1));\n      for (let column = 0; column < this.columnCount; column++) {\n        const date = new Date(this.parent.selectedDate.getFullYear(), months[column], 1);\n        const innerTd = createElement('td', {\n          className: HEADER_CELLS_CLASS\n        });\n        if (this.parent.activeViewOptions.orientation === 'Horizontal') {\n          if (this.parent.dayHeaderTemplate) {\n            append(this.renderDayMonthHeaderTemplate(dayHeaderDates[column], column, 'dayHeaderTemplate'), innerTd);\n          } else {\n            innerTd.innerHTML = `<span>${this.parent.getDayNames('abbreviated')[column % 7]}</span>`;\n          }\n        } else {\n          if (this.parent.monthHeaderTemplate) {\n            append(this.renderDayMonthHeaderTemplate(date, months[column], 'monthHeaderTemplate'), innerTd);\n          } else {\n            innerTd.innerHTML = `<span>${this.getMonthName(date)}</span>`;\n          }\n          innerTd.setAttribute('data-date', date.getTime().toString());\n        }\n        innerTr.appendChild(innerTd);\n        this.parent.trigger(renderCell, {\n          elementType: 'headerCells',\n          element: innerTd\n        });\n      }\n    }\n  }\n  renderResourceHeader(className) {\n    const wrap = createElement('div', {\n      className: className\n    });\n    const tbl = this.createTableLayout();\n    wrap.appendChild(tbl);\n    const trEle = createElement('tr');\n    if (this.parent.activeViewOptions.group.resources.length > 0) {\n      this.colLevels = this.generateColumnLevels();\n    } else {\n      const colData = [{\n        className: [HEADER_CELLS_CLASS],\n        type: 'headerCell'\n      }];\n      this.colLevels = [colData];\n    }\n    for (const col of this.colLevels) {\n      const ntr = trEle.cloneNode();\n      const count = className === DATE_HEADER_WRAP_CLASS ? col : [col[0]];\n      for (const c of count) {\n        const tdEle = createElement('td');\n        if (c.className) {\n          addClass([tdEle], c.className);\n        }\n        if (className === DATE_HEADER_WRAP_CLASS) {\n          if (c.template) {\n            append(c.template, tdEle);\n          }\n          if (c.colSpan) {\n            tdEle.setAttribute('colspan', c.colSpan.toString());\n          }\n          if (c.groupIndex > -1) {\n            tdEle.setAttribute('data-group-index', c.groupIndex.toString());\n          }\n          this.setResourceHeaderContent(tdEle, c);\n        }\n        if (className === LEFT_INDENT_WRAP_CLASS) {\n          this.parent.renderHeaderIndentTemplate(c, tdEle);\n        }\n        const args = {\n          elementType: c.type,\n          element: tdEle,\n          date: c.date,\n          groupIndex: c.groupIndex\n        };\n        this.parent.trigger(renderCell, args);\n        ntr.appendChild(tdEle);\n      }\n      tbl.querySelector('tbody').appendChild(ntr);\n    }\n    if (className === DATE_HEADER_WRAP_CLASS) {\n      tbl.appendChild(this.createTableColGroup(this.colLevels.slice(-1)[0].length));\n    }\n    return wrap;\n  }\n  renderContent(contentWrapper) {\n    const tr = createElement('tr');\n    contentWrapper.appendChild(tr);\n    const firstTd = createElement('td');\n    const lastTd = createElement('td');\n    const tdCollection = [];\n    let monthTBody;\n    if (this.parent.activeViewOptions.orientation === 'Vertical' && this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {\n      tdCollection.push(firstTd);\n      firstTd.appendChild(this.parent.resourceBase.createResourceColumn());\n      this.rowCount = this.parent.resourceBase.lastResourceLevel.length;\n    } else {\n      tdCollection.push(firstTd);\n      const monthWrapper = createElement('div', {\n        className: MONTH_HEADER_WRAPPER\n      });\n      firstTd.appendChild(monthWrapper);\n      monthWrapper.appendChild(this.createTableLayout());\n      monthTBody = monthWrapper.querySelector('tbody');\n    }\n    tdCollection.push(lastTd);\n    append(tdCollection, tr);\n    const content = createElement('div', {\n      className: CONTENT_WRAP_CLASS\n    });\n    lastTd.appendChild(content);\n    const contentTable = this.createTableLayout(CONTENT_TABLE_CLASS);\n    content.appendChild(contentTable);\n    const eventWrapper = createElement('div', {\n      className: EVENT_TABLE_CLASS\n    });\n    content.appendChild(eventWrapper);\n    const contentTBody = contentTable.querySelector('tbody');\n    if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {\n      if (this.parent.rowAutoHeight) {\n        const addClassTable = [contentTable];\n        const monthHeader = this.parent.element.querySelector('.' + MONTH_HEADER_WRAPPER + ' .' + SCHEDULE_TABLE_CLASS);\n        if (monthHeader) {\n          addClassTable.push(monthHeader);\n        }\n        addClass(addClassTable, AUTO_HEIGHT);\n      }\n      const colCount = this.parent.activeViewOptions.orientation === 'Horizontal' ? this.colLevels.slice(-1)[0].length : this.columnCount;\n      contentTable.appendChild(this.createTableColGroup(colCount));\n      this.renderResourceContent(eventWrapper, monthTBody, contentTBody);\n    } else {\n      contentTable.appendChild(this.createTableColGroup(this.columnCount));\n      this.renderDefaultContent(eventWrapper, monthTBody, contentTBody);\n    }\n  }\n  renderDefaultContent(wrapper, monthBody, contentBody) {\n    const months = this.getMonths();\n    const dayHeaderDates = this.getMonthDates(new Date(this.parent.selectedDate.getFullYear(), months[0], 1));\n    for (let month = 0; month < this.rowCount; month++) {\n      wrapper.appendChild(createElement('div', {\n        className: APPOINTMENT_CONTAINER_CLASS\n      }));\n      let monthDate = new Date(this.parent.selectedDate.getFullYear(), months[month], 1);\n      let monthStart = this.parent.calendarUtil.getMonthStartDate(new Date(monthDate.getTime()));\n      let monthEnd = this.parent.calendarUtil.getMonthEndDate(new Date(monthDate.getTime()));\n      const tr = createElement('tr', {\n        attrs: {\n          'role': 'row'\n        }\n      });\n      const monthTr = tr.cloneNode();\n      monthBody.appendChild(monthTr);\n      const contentTr = tr.cloneNode();\n      contentBody.appendChild(contentTr);\n      const monthTd = createElement('td', {\n        className: MONTH_HEADER_CLASS,\n        attrs: {\n          'role': 'gridcell'\n        }\n      });\n      if (this.parent.activeViewOptions.orientation === 'Horizontal') {\n        if (this.parent.monthHeaderTemplate) {\n          append(this.renderDayMonthHeaderTemplate(monthStart, month, 'monthHeaderTemplate'), monthTd);\n        } else {\n          monthTd.innerHTML = `<span>${this.getMonthName(monthDate)}</span>`;\n        }\n        monthTd.setAttribute('data-date', monthDate.getTime().toString());\n      } else {\n        if (this.parent.dayHeaderTemplate) {\n          append(this.renderDayMonthHeaderTemplate(dayHeaderDates[month], month, 'dayHeaderTemplate'), monthTd);\n        } else {\n          monthTd.innerHTML = `<span>${this.parent.getDayNames('abbreviated')[month % 7]}</span>`;\n        }\n      }\n      monthTr.appendChild(monthTd);\n      this.parent.trigger(renderCell, {\n        elementType: 'leftHeaderCells',\n        element: monthTd\n      });\n      let date = new Date(monthStart.getTime());\n      for (let column = 0; column < this.columnCount; column++) {\n        let isDateAvail;\n        if (this.parent.activeViewOptions.orientation === 'Vertical') {\n          monthDate = new Date(this.parent.selectedDate.getFullYear(), months[column], 1);\n          monthStart = this.parent.calendarUtil.getMonthStartDate(new Date(monthDate.getTime()));\n          monthEnd = this.parent.calendarUtil.getMonthEndDate(new Date(monthDate.getTime()));\n          const dayDate = month - monthStart.getDay() + 1;\n          date = new Date(this.parent.selectedDate.getFullYear(), months[column], dayDate);\n          isDateAvail = dayDate > 0 && date.getTime() < monthEnd.getTime();\n        } else {\n          isDateAvail = column >= monthStart.getDay() && date.getTime() < monthEnd.getTime();\n        }\n        const td = createElement('td', {\n          className: WORK_CELLS_CLASS,\n          attrs: {\n            'role': 'gridcell',\n            'aria-selected': 'false'\n          }\n        });\n        contentTr.appendChild(td);\n        const dateHeader = createElement('div', {\n          className: DATE_HEADER_CLASS + ' ' + NAVIGATE_CLASS,\n          innerHTML: isDateAvail ? this.parent.globalize.formatDate(date, {\n            skeleton: 'd',\n            calendar: this.parent.getCalendarMode()\n          }) : ''\n        });\n        const skeleton = 'full';\n        const announcementText = this.parent.globalize.formatDate(date, {\n          skeleton: skeleton,\n          calendar: this.parent.getCalendarMode()\n        });\n        dateHeader.setAttribute('aria-label', announcementText);\n        if (isDateAvail) {\n          const tds = [td];\n          const classList$$1 = [];\n          if (this.parent.activeViewOptions.workDays.indexOf(date.getDay()) > -1) {\n            classList$$1.push(WORKDAY_CLASS);\n          }\n          if (this.isCurrentDate(date)) {\n            classList$$1.push(CURRENT_DAY_CLASS);\n            if (this.parent.activeViewOptions.orientation === 'Horizontal') {\n              tds.push(this.element.querySelector('.' + HEADER_CELLS_CLASS + `:nth-child(${column + 1})`));\n            } else {\n              tds.push(this.element.querySelectorAll('.' + MONTH_HEADER_CLASS).item(month));\n            }\n          }\n          if (classList$$1.length > 0) {\n            addClass(tds, classList$$1);\n          }\n        } else {\n          addClass([td], OTHERMONTH_CLASS);\n        }\n        td.appendChild(dateHeader);\n        if (isDateAvail) {\n          td.setAttribute('data-date', date.getTime().toString());\n          this.wireEvents(td, 'cell');\n        }\n        this.renderCellTemplate({\n          date: date,\n          type: 'workCells'\n        }, td);\n        this.parent.trigger(renderCell, {\n          elementType: 'workCells',\n          element: td,\n          date: date\n        });\n        if (isDateAvail) {\n          if (this.parent.activeViewOptions.orientation === 'Horizontal') {\n            date = addDays(new Date(date.getTime()), 1);\n          }\n        }\n      }\n    }\n  }\n  renderResourceContent(wrapper, monthBody, contentBody) {\n    const months = this.getMonths();\n    for (let row = 0; row < this.rowCount; row++) {\n      wrapper.appendChild(createElement('div', {\n        className: APPOINTMENT_CONTAINER_CLASS\n      }));\n      const tr = createElement('tr', {\n        attrs: {\n          'role': 'row'\n        }\n      });\n      contentBody.appendChild(tr);\n      let resData;\n      if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {\n        resData = this.parent.resourceBase.lastResourceLevel[row];\n      }\n      let monthDate = new Date(this.parent.selectedDate.getFullYear(), months[row], 1);\n      let date = this.parent.calendarUtil.getMonthStartDate(new Date(monthDate.getTime()));\n      if (this.parent.activeViewOptions.orientation === 'Horizontal') {\n        const monthTr = tr.cloneNode();\n        monthBody.appendChild(monthTr);\n        const monthTd = createElement('td', {\n          className: MONTH_HEADER_CLASS,\n          attrs: {\n            'role': 'gridcell',\n            'data-date': date.getTime().toString()\n          }\n        });\n        if (this.parent.monthHeaderTemplate) {\n          append(this.renderDayMonthHeaderTemplate(monthDate, row, 'monthHeaderTemplate'), monthTd);\n        } else {\n          monthTd.innerHTML = `<span>${this.getMonthName(monthDate)}</span>`;\n        }\n        monthTr.appendChild(monthTd);\n      }\n      for (let month = 0; month < this.columnCount; month++) {\n        let classList$$1 = [];\n        let groupIndex = row;\n        if (this.parent.activeViewOptions.orientation === 'Vertical') {\n          classList$$1 = classList$$1.concat(resData.className);\n          if (classList$$1.indexOf(RESOURCE_PARENT_CLASS) > -1) {\n            classList$$1.push(RESOURCE_GROUP_CELLS_CLASS);\n          } else {\n            classList$$1.push(WORKDAY_CLASS);\n          }\n          monthDate = new Date(this.parent.selectedDate.getFullYear(), months[month], 1);\n          date = this.parent.calendarUtil.getMonthStartDate(new Date(monthDate.getTime()));\n        } else {\n          groupIndex = this.colLevels.slice(-1)[0][month].groupIndex;\n          classList$$1.push(WORKDAY_CLASS);\n        }\n        const td = createElement('td', {\n          className: WORK_CELLS_CLASS,\n          attrs: {\n            'role': 'gridcell',\n            'aria-selected': 'false',\n            'data-date': date.getTime().toString()\n          }\n        });\n        addClass([td], classList$$1);\n        td.setAttribute('data-group-index', groupIndex.toString());\n        this.renderCellTemplate({\n          date: date,\n          type: 'resourceGroupCells',\n          groupIndex: groupIndex\n        }, td);\n        this.wireEvents(td, 'cell');\n        tr.appendChild(td);\n        this.parent.trigger(renderCell, {\n          elementType: 'resourceGroupCells',\n          element: td,\n          date: date\n        });\n      }\n    }\n    if (this.parent.activeViewOptions.orientation === 'Vertical') {\n      this.collapseRows(this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS));\n    }\n  }\n  renderDayMonthHeaderTemplate(date, column, type) {\n    const args = {\n      date: date,\n      type: type === 'dayHeaderTemplate' ? 'dayHeader' : 'monthHeader'\n    };\n    const dayId = `schedule_${this.parent.activeViewOptions.dayHeaderTemplateName}dayHeaderTemplate`;\n    const monthId = `schedule_${this.parent.activeViewOptions.dayHeaderTemplateName}monthHeaderTemplate`;\n    if (type === 'dayHeaderTemplate') {\n      args.day = this.parent.getDayNames('wide')[column % 7];\n      return [].slice.call(this.parent.getDayHeaderTemplate()(args, this.parent, 'dayHeaderTemplate', dayId, false));\n    } else {\n      return [].slice.call(this.parent.getMonthHeaderTemplate()(args, this.parent, 'monthHeaderTemplate', monthId, false));\n    }\n  }\n  renderCellTemplate(data, td) {\n    if (!this.parent.activeViewOptions.cellTemplate || td.classList.contains(OTHERMONTH_CLASS)) {\n      return;\n    }\n    const args = {\n      date: data.date,\n      type: data.type\n    };\n    if (data.groupIndex) {\n      args.groupIndex = data.groupIndex;\n    }\n    const scheduleId = this.parent.element.id + '_';\n    const viewName = this.parent.activeViewOptions.cellTemplateName;\n    const templateId = scheduleId + viewName + 'cellTemplate';\n    const cellTemplate = [].slice.call(this.parent.getCellTemplate()(args, this.parent, 'cellTemplate', templateId, false));\n    append(cellTemplate, td);\n  }\n  scrollToDate(scrollDate) {\n    if (this.parent.activeViewOptions.group.resources.length === 0) {\n      const date = +new Date(resetTime(scrollDate));\n      const element = this.element.querySelector('[data-date=\"' + date + '\"]');\n      if (element) {\n        this.getScrollableElement().scrollLeft = element.offsetLeft;\n        this.getScrollableElement().scrollTop = element.offsetTop;\n      }\n    }\n  }\n  getScrollableElement() {\n    if (this.parent.isAdaptive && !this.isTimelineView()) {\n      return this.element.querySelector('.' + SCROLL_CONTAINER_CLASS);\n    } else {\n      return this.getContentAreaElement();\n    }\n  }\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * ICalendar Export Module\n */\nclass ICalendarExport {\n  constructor(parent) {\n    this.parent = parent;\n  }\n  initializeCalendarExport(fileName, customData) {\n    let eventsData = customData ? customData : extend([], this.parent.eventsData, null, true);\n    eventsData = this.parent.eventBase.sortByTime(eventsData);\n    const SEPARATOR = navigator.appVersion.indexOf('Win') !== -1 ? '\\r\\n' : '\\n';\n    const iCalendarEvents = [];\n    const filterCollection = [];\n    const timeZone = this.parent.timezone || this.parent.tzModule.getLocalTimezoneName();\n    const fields = this.parent.eventFields;\n    eventsData.forEach(eventObj => {\n      let uId = this.parent.eventBase.generateGuid();\n      const editedExDate = [];\n      if (eventObj[fields.recurrenceID]) {\n        const filter = this.filterEvents(filterCollection, fields.id, eventObj[fields.recurrenceID]);\n        uId = filter[0].UID;\n      }\n      if (!eventObj[fields.recurrenceID] && eventObj[fields.recurrenceRule] && eventObj[fields.recurrenceException]) {\n        const exDate = eventObj[fields.recurrenceException].split(',');\n        const editedObj = this.filterEvents(eventsData, fields.recurrenceID, eventObj[fields.id]);\n        editedObj.forEach(edited => {\n          editedExDate.push(getRecurrenceStringFromDate(edited[fields.startTime]));\n        });\n        const exceptionDateList = exDate.filter(value => editedExDate.indexOf(value) === -1);\n        eventObj[fields.recurrenceException] = exceptionDateList.length > 0 ? exceptionDateList.join(',') + ',' : '';\n      }\n      const startZone = eventObj[fields.startTimezone] || timeZone;\n      const endZone = eventObj[fields.endTimezone] || timeZone;\n      const readonly = eventObj[fields.isReadonly] ? eventObj[fields.isReadonly] : false;\n      const calendarEvent = ['BEGIN:VEVENT', 'LOCATION:' + (eventObj[fields.location] || ''), 'SUMMARY:' + (eventObj[fields.subject] || ''), 'UID:' + uId, 'DESCRIPTION:' + (eventObj[fields.description] || ''), 'ISREADONLY:' + readonly, 'END:VEVENT'];\n      if (eventObj[fields.isAllDay]) {\n        calendarEvent.splice(4, 0, 'DTEND;VALUE=DATE:' + this.convertDateToString(eventObj[fields.endTime], true));\n        calendarEvent.splice(4, 0, 'DTSTART;VALUE=DATE:' + this.convertDateToString(eventObj[fields.startTime], true));\n      } else if (!eventObj[fields.isAllDay] && !eventObj[fields.recurrenceRule]) {\n        calendarEvent.splice(4, 0, 'DTEND:' + this.convertDateToString(eventObj[fields.endTime]));\n        calendarEvent.splice(4, 0, 'DTSTART:' + this.convertDateToString(eventObj[fields.startTime]));\n      } else {\n        calendarEvent.splice(4, 0, 'DTEND;TZID=\"' + endZone + '\":' + this.convertDateToString(eventObj[fields.endTime]));\n        calendarEvent.splice(4, 0, 'DTSTART;TZID=\"' + startZone + '\":' + this.convertDateToString(eventObj[fields.startTime]));\n      }\n      if (eventObj[fields.recurrenceRule]) {\n        calendarEvent.splice(4, 0, 'RRULE:' + eventObj[fields.recurrenceRule]);\n      }\n      if (eventObj[fields.recurrenceException]) {\n        const exDate = eventObj[fields.recurrenceException].split(',');\n        for (let i = 0; i < exDate.length - 1; i++) {\n          calendarEvent.splice(5, 0, 'EXDATE:' + this.convertDateToString(getDateFromRecurrenceDateString(exDate[i]), eventObj[fields.isAllDay]));\n        }\n      }\n      if (eventObj[fields.recurrenceID]) {\n        calendarEvent.splice(4, 0, 'RECURRENCE-ID;TZID=\"' + startZone + '\":' + this.convertDateToString(eventObj[fields.startTime], eventObj[fields.isAllDay]));\n      }\n      const customFields = this.customFieldFilter(eventObj, fields);\n      if (customFields.length > 0) {\n        customFields.forEach(customField => calendarEvent.splice(4, 0, customField + ':' + (eventObj[customField] || '')));\n      }\n      const app = extend({}, eventObj);\n      app.UID = uId;\n      filterCollection.push(app);\n      iCalendarEvents.push(calendarEvent.join(SEPARATOR));\n    });\n    const iCalendar = ['BEGIN:VCALENDAR', 'PRODID:-//Syncfusion Inc//Scheduler//EN', 'VERSION:2.0', 'CALSCALE:GREGORIAN', 'METHOD:PUBLISH', 'X-WR-CALNAME:' + (fileName || 'Calendar'), 'X-WR-TIMEZONE:' + timeZone].join(SEPARATOR);\n    const icsString = iCalendar + SEPARATOR + iCalendarEvents.join(SEPARATOR) + SEPARATOR + 'END:VCALENDAR';\n    this.download(icsString, fileName);\n  }\n  customFieldFilter(eventObj, fields) {\n    const defaultFields = Object.keys(fields).map(key => fields[key]);\n    const eventFields = Object.keys(eventObj);\n    return eventFields.filter(value => defaultFields.indexOf(value) === -1 && value !== 'Guid');\n  }\n  convertDateToString(eventDate, allDay) {\n    const year = ('0000' + eventDate.getFullYear().toString()).slice(-4);\n    const month = ('00' + (eventDate.getMonth() + 1).toString()).slice(-2);\n    const date = ('00' + eventDate.getDate().toString()).slice(-2);\n    const hours = ('00' + eventDate.getHours().toString()).slice(-2);\n    const minutes = ('00' + eventDate.getMinutes().toString()).slice(-2);\n    const seconds = ('00' + eventDate.getSeconds().toString()).slice(-2);\n    const timeString = allDay ? year + month + date : year + month + date + 'T' + hours + minutes + seconds;\n    return timeString;\n  }\n  download(icsString, fileName) {\n    const buffer = new Blob([icsString], {\n      type: 'data:text/calendar;charset=utf8'\n    });\n    fileName = (fileName || 'Calendar') + '.ics';\n    if (navigator.msSaveBlob) {\n      navigator.msSaveBlob(buffer, fileName);\n    } else {\n      const downloadLink = document.createElementNS('http://www.w3.org/1999/xhtml', 'a');\n      downloadLink.download = fileName;\n      downloadLink.href = URL.createObjectURL(buffer);\n      const event = document.createEvent('MouseEvent');\n      event.initEvent('click', true, true);\n      downloadLink.dispatchEvent(event);\n      setTimeout(() => {\n        URL.revokeObjectURL(downloadLink.href);\n        downloadLink.href = undefined;\n      });\n    }\n  }\n  filterEvents(data, field, value) {\n    return data.filter(e => e[field] === value);\n  }\n  getModuleName() {\n    return 'iCalendarExport';\n  }\n  destroy() {\n    if (!this.parent || this.parent && this.parent.isDestroyed) {\n      return;\n    }\n    this.parent = null;\n  }\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * ICalendar Import Module\n */\nclass ICalendarImport {\n  constructor(parent) {\n    this.allDay = false;\n    this.parent = parent;\n  }\n  initializeCalendarImport(fileContent) {\n    if (fileContent && fileContent instanceof Blob) {\n      const fileReader = new FileReader();\n      fileReader.onload = () => {\n        const iCalString = fileReader.result;\n        this.iCalendarParser(iCalString);\n      };\n      fileReader.readAsText(fileContent, 'UTF-8');\n    } else if (fileContent && typeof fileContent === 'string') {\n      this.iCalendarParser(fileContent);\n    }\n  }\n  iCalendarParser(iCalString) {\n    const fields = this.parent.eventFields;\n    const events = [];\n    const uId = 'UID';\n    const calArray = iCalString.replace(new RegExp('\\\\r', 'g'), '').split('\\n');\n    let isEvent = false;\n    let curEvent;\n    // eslint-disable-next-line prefer-const\n    let id = this.parent.eventBase.getEventMaxID();\n    let count = 0;\n    calArray.forEach(element => {\n      let index;\n      let type;\n      let value;\n      if (!isEvent && element === 'BEGIN:VEVENT') {\n        isEvent = true;\n        curEvent = {};\n      }\n      if (isEvent && element === 'END:VEVENT') {\n        isEvent = false;\n        events.push(curEvent);\n        curEvent = null;\n      }\n      if (isEvent) {\n        index = element.indexOf(':');\n        type = element.substr(0, index).replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n        value = element.substr(index + 1, element.length - (index + 1)).replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n        if (element.indexOf('SUMMARY') !== -1) {\n          type = 'SUMMARY';\n        }\n        if (element.indexOf('DTSTART') !== -1) {\n          curEvent[fields.startTime] = this.dateParsing(element);\n          curEvent[fields.isAllDay] = this.allDay;\n          this.allDay = false;\n        } else if (element.indexOf('DTEND') !== -1) {\n          curEvent[fields.endTime] = this.dateParsing(element);\n        } else if (element.indexOf('EXDATE') !== -1) {\n          value = getRecurrenceStringFromDate(this.dateParsing(element));\n          curEvent[fields.recurrenceException] = isNullOrUndefined(curEvent[fields.recurrenceException]) ? value : curEvent[fields.recurrenceException] + ',' + value;\n        } else if (element.indexOf('RECURRENCE-ID') !== -1) {\n          value = getRecurrenceStringFromDate(this.dateParsing(element));\n          curEvent[fields.recurrenceException] = value;\n          curEvent[fields.recurrenceID] = value;\n        } else {\n          switch (type) {\n            case 'BEGIN':\n              break;\n            case 'UID':\n              curEvent[uId] = value;\n              curEvent[fields.id] = typeof id === 'string' ? id + count.toString() : id + count;\n              count++;\n              break;\n            case 'SUMMARY':\n              curEvent[fields.subject] = value;\n              break;\n            case 'LOCATION':\n              curEvent[fields.location] = value;\n              break;\n            case 'DESCRIPTION':\n              curEvent[fields.description] = value;\n              break;\n            case 'ISREADONLY':\n              curEvent[fields.isReadonly] = value.indexOf('true') > -1;\n              break;\n            case 'RRULE':\n              curEvent[fields.recurrenceRule] = value;\n              break;\n            default:\n              if (this.parent.resourceCollection.length > 0) {\n                const resData = this.parent.resourceCollection.filter(data => data.field === type);\n                curEvent[type] = resData.length > 0 && typeof resData[0].dataSource[0][resData[0].idField] == 'number' ? parseInt(value, 10) : value;\n              } else {\n                curEvent[type] = value;\n              }\n          }\n        }\n      }\n    });\n    const app = extend([], events, null, true);\n    this.parent.addEvent(this.processOccurrence(app));\n  }\n  processOccurrence(app) {\n    const appoint = [];\n    const uId = 'UID';\n    const fields = this.parent.eventFields;\n    app.forEach(eventObj => {\n      let parentObj;\n      let id;\n      // eslint-disable-next-line no-prototype-builtins\n      if (!eventObj.hasOwnProperty(fields.recurrenceID)) {\n        parentObj = eventObj;\n        id = eventObj[fields.id];\n      }\n      const data = app.filter(data => data.UID === eventObj[uId]);\n      if (data.length > 1 && isNullOrUndefined(eventObj[fields.recurrenceID])) {\n        for (let i = 0; i < data.length; i++) {\n          // eslint-disable-next-line no-prototype-builtins\n          if (data[i].hasOwnProperty(fields.recurrenceID)) {\n            const exdate = data[i][fields.recurrenceID];\n            data[i][fields.recurrenceID] = id;\n            data[i][fields.recurrenceException] = null;\n            parentObj[fields.recurrenceException] = isNullOrUndefined(parentObj[fields.recurrenceException]) ? exdate : parentObj[fields.recurrenceException] + ',' + exdate;\n            appoint.push(data[i]);\n          }\n        }\n        appoint.push(parentObj);\n        // eslint-disable-next-line no-prototype-builtins\n      } else if (!eventObj.hasOwnProperty(fields.recurrenceID)) {\n        appoint.push(eventObj);\n      }\n    });\n    return appoint;\n  }\n  getDateString(value) {\n    value = value || '';\n    // eslint-disable-next-line no-useless-escape\n    return value.replace(/\\\\\\,/g, ',').replace(/\\\\\\;/g, ';').replace(/\\\\[nN]/g, '\\n').replace(/\\\\\\\\/g, '\\\\');\n  }\n  dateParsing(element) {\n    const expression = /([^':;]+)((?:;(?:[^':;]+)(?:=(?:(?:'[^']*')|(?:[^':;]+))))*):(.*)/;\n    const split = element.match(expression).slice(1);\n    const value = split[split.length - 1];\n    let newDate = new Date(this.getDateString(value));\n    if (element && (element.indexOf('VALUE=DATE') > -1 || element.indexOf('RECURRENCE-ID;TZID') > -1)) {\n      const data = /^(\\d{4})(\\d{2})(\\d{2})$/.exec(value);\n      if (data !== null) {\n        newDate = new Date(parseInt(data[1], 10), parseInt(data[2], 10) - 1, parseInt(data[3], 10));\n      }\n      if (element.indexOf('DTSTART') > -1) {\n        this.allDay = true;\n      }\n    }\n    const data = /^(\\d{4})(\\d{2})(\\d{2})T(\\d{2})(\\d{2})(\\d{2})(Z)?$/.exec(value);\n    if (data !== null) {\n      if (data[7] === 'Z') {\n        newDate = new Date(Date.UTC(parseInt(data[1], 10), parseInt(data[2], 10) - 1, parseInt(data[3], 10), parseInt(data[4], 10), parseInt(data[5], 10), parseInt(data[6], 10)));\n      } else {\n        newDate = new Date(parseInt(data[1], 10), parseInt(data[2], 10) - 1, parseInt(data[3], 10), parseInt(data[4], 10), parseInt(data[5], 10), parseInt(data[6], 10));\n      }\n    }\n    return newDate;\n  }\n  getModuleName() {\n    return 'iCalendarImport';\n  }\n  destroy() {\n    if (!this.parent || this.parent && this.parent.isDestroyed) {\n      return;\n    }\n  }\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Excel Export Module\n */\nclass ExcelExport {\n  constructor(parent) {\n    this.parent = parent;\n  }\n  initializeExcelExport(excelExportOptions = {}) {\n    const exportColumns = this.getExportColumns(excelExportOptions);\n    const exportName = excelExportOptions.fileName || 'Schedule';\n    const exportType = excelExportOptions.exportType || 'xlsx';\n    const isIncludeOccurrences = excelExportOptions.includeOccurrences || false;\n    let eventCollection;\n    if (excelExportOptions.customData) {\n      eventCollection = !isIncludeOccurrences ? excelExportOptions.customData : this.parent.eventBase.getProcessedEvents(excelExportOptions.customData);\n    } else {\n      eventCollection = !isIncludeOccurrences ? this.parent.eventsData : this.parent.eventsProcessed;\n    }\n    this.processWorkbook(exportColumns, exportName, exportType, eventCollection);\n  }\n  processWorkbook(fields, name, type, eventCollection) {\n    const columns = [];\n    const rows = [];\n    const columnHeader = [];\n    fields.forEach((field, i) => {\n      columns.push({\n        index: i + 1,\n        width: field.name === 'Id' ? 50 : 150\n      });\n    });\n    const style = {\n      fontSize: 12,\n      borders: {\n        color: '#E0E0E0'\n      },\n      bold: true\n    };\n    fields.forEach((field, i) => {\n      columnHeader.push({\n        index: i + 1,\n        value: field.text,\n        style: style\n      });\n    });\n    rows.push({\n      index: 1,\n      cells: columnHeader\n    });\n    eventCollection.forEach((event, i) => {\n      const columnData = [];\n      fields.forEach((field, n) => {\n        let columnRule = {\n          index: n + 1,\n          value: event[field.name] || ''\n        };\n        if (field.name === this.parent.eventFields.startTime || field.name === this.parent.eventFields.endTime) {\n          const styleRule = {\n            fontSize: 12,\n            numberFormat: 'm/d/yyyy h:mm AM/PM'\n          };\n          columnRule = extend({}, columnRule, {\n            style: styleRule\n          }, true);\n        }\n        columnData.push(columnRule);\n      });\n      rows.push({\n        index: i + 2,\n        cells: columnData\n      });\n    });\n    const workSheet = [{\n      columns: columns,\n      rows: rows\n    }];\n    const book = new Workbook({\n      worksheets: workSheet\n    }, type, this.parent.locale);\n    book.save(name + '.' + type);\n  }\n  getExportColumns(exportOptions) {\n    const exportColumns = exportOptions.fieldsInfo || [];\n    if (exportColumns.length === 0) {\n      const fields = exportOptions.fields || Object.keys(this.parent.eventFields).map(field => this.parent.eventFields[field]);\n      fields.forEach(field => {\n        exportColumns.push({\n          name: field,\n          text: field\n        });\n      });\n    }\n    return exportColumns;\n  }\n  getModuleName() {\n    return 'excelExport';\n  }\n  destroy() {\n    this.parent = null;\n  }\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Print Module\n */\nclass Print {\n  constructor(parent) {\n    this.parent = parent;\n  }\n  print(printOptions) {\n    if (isNullOrUndefined(printOptions)) {\n      this.printScheduler();\n    } else {\n      this.printSchedulerWithModel(printOptions);\n    }\n  }\n  printScheduler() {\n    const clone = this.parent.element.cloneNode(true);\n    clone.id = this.parent.element.id + '_print';\n    document.body.appendChild(clone);\n    const className = this.parent.currentView === 'MonthAgenda' ? '.e-appointment-wrap' : '.e-content-wrap';\n    const scrollableEle = this.parent.element.querySelector(className);\n    const links = [].slice.call(document.getElementsByTagName('head')[0].querySelectorAll('link, style'));\n    let reference = '';\n    for (const link of links) {\n      reference += link.outerHTML;\n    }\n    const div = createElement('div');\n    clone.style.width = this.parent.element.offsetWidth + 'px';\n    const elementWidth = Math.round(parseInt(clone.style.width, 10) / 100) * 100;\n    div.appendChild(clone);\n    const printWindow = window.open('', 'print', 'height=550,width=' + elementWidth + ',tabbar=no');\n    printWindow.document.write('<!DOCTYPE html><html><head>' + reference + '</head><body>' + div.innerHTML + '<script>(function() { window.ready = true; })();</script></body></html>');\n    printWindow.document.close();\n    printWindow.focus();\n    setTimeout(() => {\n      if (printWindow.ready && scrollableEle) {\n        // eslint-disable-next-line no-self-assign\n        scrollableEle.scrollLeft = scrollableEle.scrollLeft;\n        // eslint-disable-next-line no-self-assign\n        scrollableEle.scrollTop = scrollableEle.scrollTop;\n        const headerTimeCellsScroll = printWindow.document.querySelector('.e-date-header-wrap');\n        if (headerTimeCellsScroll) {\n          headerTimeCellsScroll.scrollLeft = scrollableEle.scrollLeft;\n        }\n        const timeCellsScroll = printWindow.document.querySelector('.e-time-cells-wrap');\n        if (timeCellsScroll) {\n          timeCellsScroll.scrollTop = scrollableEle.scrollTop;\n        }\n        printWindow.print();\n        printWindow.close();\n      }\n    }, 500);\n  }\n  printSchedulerWithModel(printOptions) {\n    const element = createElement('div', {\n      id: this.parent.element.id + '_print',\n      className: 'e-print-schedule'\n    });\n    document.body.appendChild(element);\n    Schedule.Inject(Day, Week, WorkWeek, Month, Agenda, MonthAgenda, TimelineViews, TimelineMonth, Year, TimelineYear);\n    this.printInstance = new Schedule(this.getPrintScheduleModel(printOptions));\n    this.printInstance.isPrinting = true;\n    this.printInstance.appendTo(element);\n    this.printInstance.on(print$1, this.contentReady, this);\n    this.printWindow = window.open('', 'print', 'height=' + window.outerHeight + ',width=' + window.outerWidth + ',tabbar=no');\n    this.printWindow.moveTo(0, 0);\n    this.printWindow.resizeTo(screen.availWidth, screen.availHeight);\n  }\n  getPrintScheduleModel(printOptions) {\n    const printModel = {};\n    const scheduleProps = ['agendaDaysCount', 'calendarMode', 'cssClass', 'currentView', 'dateFormat', 'enableRtl', 'endHour', 'eventSettings', 'firstDayOfWeek', 'firstMonthOfYear', 'group', 'height', 'locale', 'maxDate', 'minDate', 'readonly', 'resources', 'rowAutoHeight', 'selectedDate', 'showHeaderBar', 'showTimeIndicator', 'showWeekNumber', 'showWeekend', 'startHour', 'timeFormat', 'timeScale', 'timezone', 'views', 'width', 'workDays', 'workHours'];\n    let eventSettings;\n    let group;\n    for (const key of scheduleProps) {\n      switch (key) {\n        case 'eventSettings':\n          eventSettings = Object.assign({}, this.parent.eventSettings.properties);\n          eventSettings.dataSource = this.parent.eventsData;\n          eventSettings.template = null;\n          printModel.eventSettings = eventSettings;\n          break;\n        case 'group':\n          group = isNullOrUndefined(printOptions.group) ? this.parent.group : printOptions.group;\n          group.headerTooltipTemplate = null;\n          printModel.group = group;\n          break;\n        default:\n          printModel[key] = isNullOrUndefined(printOptions[key]) ? this.parent[key] : printOptions[key];\n          break;\n      }\n    }\n    return printModel;\n  }\n  contentReady() {\n    this.printWindow = print(this.printInstance.element, this.printWindow);\n    this.printWindow.onbeforeunload = () => {\n      this.printInstance.off(print$1, this.contentReady);\n      this.printInstance.element.remove();\n      this.printInstance.destroy();\n      this.printInstance = null;\n      this.printWindow = null;\n    };\n  }\n  getModuleName() {\n    return 'print';\n  }\n  destroy() {\n    this.parent = null;\n  }\n}\n\n/**\n * Exporting modules\n */\n\n/**\n * Schedule component exported items\n */\n\n/**\n * Recurrence-Editor component exported items\n */\n\n/**\n * Calendar util exported items\n */\n\n/**\n * Export Schedule components\n */\n\nexport { Schedule, cellClick, cellDoubleClick, moreEventsClick, select, hover, actionBegin, actionComplete, actionFailure, navigating, renderCell, eventClick, eventRendered, dataBinding, dataBound, popupOpen, popupClose, dragStart, drag, dragStop, resizeStart, resizing, resizeStop, inlineClick, initialLoad, initialEnd, print$1 as print, dataReady, eventsLoaded, contentReady, scroll, virtualScroll, scrollUiUpdate, uiUpdate, documentClick, cellMouseDown, WEEK_LENGTH, DEFAULT_WEEKS, MS_PER_DAY, MS_PER_MINUTE, getElementHeightFromClass, getTranslateY, getWeekFirstDate, getWeekLastDate, firstDateOfMonth, lastDateOfMonth, getWeekNumber, getWeekMiddleDate, setTime, resetTime, getDateInMs, getDateCount, addDays, addMonths, addYears, getStartEndHours, getMaxDays, getDaysCount, getDateFromString, getScrollBarWidth, findIndexInData, getOuterHeight, removeChildren, isDaylightSavingTime, getUniversalTime, isMobile, isIPadDevice, capitalizeFirstWord, Resize, DragAndDrop, HeaderRenderer, ViewBase, Day, Week, WorkWeek, Month, Year, Agenda, MonthAgenda, TimelineViews, TimelineMonth, TimelineYear, Timezone, timezoneData, ICalendarExport, ICalendarImport, ExcelExport, Print, RecurrenceEditor, generateSummary, generate, getDateFromRecurrenceDateString, extractObjectFromRule, getCalendarUtil, getRecurrenceStringFromDate, Gregorian, Islamic };\n//# sourceMappingURL=ej2-schedule.es2015.js.map","map":null,"metadata":{},"sourceType":"module"}